(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
    /*  A entry point for the browser bundle version. This gets compiled by:
            
            browserify --debug ./ccxt.browser.js > ./dist/ccxt.browser.js
     */
    
    window.ccxt = require ('./ccxt')
    },{"./ccxt":2}],2:[function(require,module,exports){
    "use strict";
    
    /*
    
    MIT License
    
    Copyright (c) 2017 Igor Kroitor
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    
    */
    
    //-----------------------------------------------------------------------------
    
    const Exchange  = require ('./js/base/Exchange')
        , Precise   = require ('./js/base/Precise')
        , functions = require ('./js/base/functions')
        , errors    = require ('./js/base/errors')
    
    //-----------------------------------------------------------------------------
    // this is updated by vss.js when building
    
    const version = '1.56.45'
    
    Exchange.ccxtVersion = version
    
    //-----------------------------------------------------------------------------
    
    const exchanges = {
        'aax':                     require ('./js/aax.js'),
        'aofex':                   require ('./js/aofex.js'),
        'ascendex':                require ('./js/ascendex.js'),
        'bequant':                 require ('./js/bequant.js'),
        'bibox':                   require ('./js/bibox.js'),
        'bigone':                  require ('./js/bigone.js'),
        'binance':                 require ('./js/binance.js'),
        'binancecoinm':            require ('./js/binancecoinm.js'),
        'binanceus':               require ('./js/binanceus.js'),
        'binanceusdm':             require ('./js/binanceusdm.js'),
        'bit2c':                   require ('./js/bit2c.js'),
        'bitbank':                 require ('./js/bitbank.js'),
        'bitbay':                  require ('./js/bitbay.js'),
        'bitbns':                  require ('./js/bitbns.js'),
        'bitcoincom':              require ('./js/bitcoincom.js'),
        'bitfinex':                require ('./js/bitfinex.js'),
        'bitfinex2':               require ('./js/bitfinex2.js'),
        'bitflyer':                require ('./js/bitflyer.js'),
        'bitforex':                require ('./js/bitforex.js'),
        'bitget':                  require ('./js/bitget.js'),
        'bithumb':                 require ('./js/bithumb.js'),
        'bitmart':                 require ('./js/bitmart.js'),
        'bitmex':                  require ('./js/bitmex.js'),
        'bitpanda':                require ('./js/bitpanda.js'),
        'bitso':                   require ('./js/bitso.js'),
        'bitstamp':                require ('./js/bitstamp.js'),
        'bitstamp1':               require ('./js/bitstamp1.js'),
        'bittrex':                 require ('./js/bittrex.js'),
        'bitvavo':                 require ('./js/bitvavo.js'),
        'bitz':                    require ('./js/bitz.js'),
        'bl3p':                    require ('./js/bl3p.js'),
        'btcalpha':                require ('./js/btcalpha.js'),
        'btcbox':                  require ('./js/btcbox.js'),
        'btcmarkets':              require ('./js/btcmarkets.js'),
        'btctradeua':              require ('./js/btctradeua.js'),
        'btcturk':                 require ('./js/btcturk.js'),
        'buda':                    require ('./js/buda.js'),
        'bw':                      require ('./js/bw.js'),
        'bybit':                   require ('./js/bybit.js'),
        'cdax':                    require ('./js/cdax.js'),
        'cex':                     require ('./js/cex.js'),
        'coinbase':                require ('./js/coinbase.js'),
        'coinbaseprime':           require ('./js/coinbaseprime.js'),
        'coinbasepro':             require ('./js/coinbasepro.js'),
        'coincheck':               require ('./js/coincheck.js'),
        'coinegg':                 require ('./js/coinegg.js'),
        'coinex':                  require ('./js/coinex.js'),
        'coinfalcon':              require ('./js/coinfalcon.js'),
        'coinfloor':               require ('./js/coinfloor.js'),
        'coinmarketcap':           require ('./js/coinmarketcap.js'),
        'coinmate':                require ('./js/coinmate.js'),
        'coinone':                 require ('./js/coinone.js'),
        'coinspot':                require ('./js/coinspot.js'),
        'crex24':                  require ('./js/crex24.js'),
        'currencycom':             require ('./js/currencycom.js'),
        'delta':                   require ('./js/delta.js'),
        'deribit':                 require ('./js/deribit.js'),
        'digifinex':               require ('./js/digifinex.js'),
        'eqonex':                  require ('./js/eqonex.js'),
        'equos':                   require ('./js/equos.js'),
        'exmo':                    require ('./js/exmo.js'),
        'exx':                     require ('./js/exx.js'),
        'flowbtc':                 require ('./js/flowbtc.js'),
        'ftx':                     require ('./js/ftx.js'),
        'gateio':                  require ('./js/gateio.js'),
        'gemini':                  require ('./js/gemini.js'),
        'hbtc':                    require ('./js/hbtc.js'),
        'hitbtc':                  require ('./js/hitbtc.js'),
        'hollaex':                 require ('./js/hollaex.js'),
        'huobi':                   require ('./js/huobi.js'),
        'huobijp':                 require ('./js/huobijp.js'),
        'huobipro':                require ('./js/huobipro.js'),
        'idex':                    require ('./js/idex.js'),
        'independentreserve':      require ('./js/independentreserve.js'),
        'indodax':                 require ('./js/indodax.js'),
        'itbit':                   require ('./js/itbit.js'),
        'kraken':                  require ('./js/kraken.js'),
        'kucoin':                  require ('./js/kucoin.js'),
        'kuna':                    require ('./js/kuna.js'),
        'latoken':                 require ('./js/latoken.js'),
        'lbank':                   require ('./js/lbank.js'),
        'liquid':                  require ('./js/liquid.js'),
        'luno':                    require ('./js/luno.js'),
        'lykke':                   require ('./js/lykke.js'),
        'mercado':                 require ('./js/mercado.js'),
        'mixcoins':                require ('./js/mixcoins.js'),
        'ndax':                    require ('./js/ndax.js'),
        'novadax':                 require ('./js/novadax.js'),
        'oceanex':                 require ('./js/oceanex.js'),
        'okcoin':                  require ('./js/okcoin.js'),
        'okex':                    require ('./js/okex.js'),
        'okex3':                   require ('./js/okex3.js'),
        'okex5':                   require ('./js/okex5.js'),
        'paymium':                 require ('./js/paymium.js'),
        'phemex':                  require ('./js/phemex.js'),
        'poloniex':                require ('./js/poloniex.js'),
        'probit':                  require ('./js/probit.js'),
        'qtrade':                  require ('./js/qtrade.js'),
        'ripio':                   require ('./js/ripio.js'),
        'stex':                    require ('./js/stex.js'),
        'therock':                 require ('./js/therock.js'),
        'tidebit':                 require ('./js/tidebit.js'),
        'tidex':                   require ('./js/tidex.js'),
        'timex':                   require ('./js/timex.js'),
        'upbit':                   require ('./js/upbit.js'),
        'vcc':                     require ('./js/vcc.js'),
        'wavesexchange':           require ('./js/wavesexchange.js'),
        'whitebit':                require ('./js/whitebit.js'),
        'xena':                    require ('./js/xena.js'),
        'yobit':                   require ('./js/yobit.js'),
        'zaif':                    require ('./js/zaif.js'),
        'zb':                      require ('./js/zb.js'),    
    }
    
    //-----------------------------------------------------------------------------
    
    module.exports = Object.assign ({ version, Exchange, Precise, 'exchanges': Object.keys (exchanges) }, exchanges, functions, errors)
    
    //-----------------------------------------------------------------------------
    
    },{"./js/aax.js":3,"./js/aofex.js":4,"./js/ascendex.js":5,"./js/base/Exchange":6,"./js/base/Precise":7,"./js/base/errors":9,"./js/base/functions":10,"./js/bequant.js":21,"./js/bibox.js":22,"./js/bigone.js":23,"./js/binance.js":24,"./js/binancecoinm.js":25,"./js/binanceus.js":26,"./js/binanceusdm.js":27,"./js/bit2c.js":28,"./js/bitbank.js":29,"./js/bitbay.js":30,"./js/bitbns.js":31,"./js/bitcoincom.js":32,"./js/bitfinex.js":33,"./js/bitfinex2.js":34,"./js/bitflyer.js":35,"./js/bitforex.js":36,"./js/bitget.js":37,"./js/bithumb.js":38,"./js/bitmart.js":39,"./js/bitmex.js":40,"./js/bitpanda.js":41,"./js/bitso.js":42,"./js/bitstamp.js":43,"./js/bitstamp1.js":44,"./js/bittrex.js":45,"./js/bitvavo.js":46,"./js/bitz.js":47,"./js/bl3p.js":48,"./js/btcalpha.js":49,"./js/btcbox.js":50,"./js/btcmarkets.js":51,"./js/btctradeua.js":52,"./js/btcturk.js":53,"./js/buda.js":54,"./js/bw.js":55,"./js/bybit.js":56,"./js/cdax.js":57,"./js/cex.js":58,"./js/coinbase.js":59,"./js/coinbaseprime.js":60,"./js/coinbasepro.js":61,"./js/coincheck.js":62,"./js/coinegg.js":63,"./js/coinex.js":64,"./js/coinfalcon.js":65,"./js/coinfloor.js":66,"./js/coinmarketcap.js":67,"./js/coinmate.js":68,"./js/coinone.js":69,"./js/coinspot.js":70,"./js/crex24.js":71,"./js/currencycom.js":72,"./js/delta.js":73,"./js/deribit.js":74,"./js/digifinex.js":75,"./js/eqonex.js":76,"./js/equos.js":77,"./js/exmo.js":78,"./js/exx.js":79,"./js/flowbtc.js":80,"./js/ftx.js":81,"./js/gateio.js":82,"./js/gemini.js":83,"./js/hbtc.js":84,"./js/hitbtc.js":85,"./js/hollaex.js":86,"./js/huobi.js":87,"./js/huobijp.js":88,"./js/huobipro.js":89,"./js/idex.js":90,"./js/independentreserve.js":91,"./js/indodax.js":92,"./js/itbit.js":93,"./js/kraken.js":94,"./js/kucoin.js":95,"./js/kuna.js":96,"./js/latoken.js":97,"./js/lbank.js":98,"./js/liquid.js":99,"./js/luno.js":100,"./js/lykke.js":101,"./js/mercado.js":102,"./js/mixcoins.js":103,"./js/ndax.js":104,"./js/novadax.js":105,"./js/oceanex.js":106,"./js/okcoin.js":107,"./js/okex.js":108,"./js/okex3.js":109,"./js/okex5.js":110,"./js/paymium.js":111,"./js/phemex.js":112,"./js/poloniex.js":113,"./js/probit.js":114,"./js/qtrade.js":115,"./js/ripio.js":116,"./js/stex.js":157,"./js/therock.js":158,"./js/tidebit.js":159,"./js/tidex.js":160,"./js/timex.js":161,"./js/upbit.js":162,"./js/vcc.js":163,"./js/wavesexchange.js":164,"./js/whitebit.js":165,"./js/xena.js":166,"./js/yobit.js":167,"./js/zaif.js":168,"./js/zb.js":169}],3:[function(require,module,exports){
    'use strict';
    
    // ----------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ArgumentsRequired, AuthenticationError, ExchangeError, ExchangeNotAvailable, OrderNotFound, InvalidOrder, CancelPending, RateLimitExceeded, InsufficientFunds, BadRequest, BadSymbol, PermissionDenied } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    // ----------------------------------------------------------------------------
    
    module.exports = class aax extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'aax',
                'name': 'AAX',
                'countries': [ 'MT' ], // Malta
                'enableRateLimit': true,
                'rateLimit': 500,
                'version': 'v2',
                'hostname': 'aaxpro.com', // aax.com
                'certified': true,
                'pro': true,
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchCanceledOrders': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchStatus': true,
                    'fetchTicker': 'emulated',
                    'fetchTickers': true,
                    'fetchTrades': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '2h': '2h',
                    '4h': '4h',
                    '12h': '12h',
                    '1d': '1d',
                    '3d': '3d',
                    '1w': '1w',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/104140087-a27f2580-53c0-11eb-87c1-5d9e81208fe9.jpg',
                    'test': {
                        'v1': 'https://api.testnet.{hostname}/marketdata/v1',
                        'public': 'https://api.testnet.{hostname}',
                        'private': 'https://api.testnet.{hostname}',
                    },
                    'api': {
                        'v1': 'https://api.{hostname}/marketdata/v1',
                        'public': 'https://api.{hostname}',
                        'private': 'https://api.{hostname}',
                    },
                    'www': 'https://www.aaxpro.com', // string website URL
                    'doc': 'https://www.aaxpro.com/apidoc/index.html',
                    'fees': 'https://www.aaxpro.com/en-US/fees/',
                    'referral': 'https://www.aaxpro.com/invite/sign-up?inviteCode=JXGm5Fy7R2MB',
                },
                'api': {
                    'v1': {
                        'get': [
                            'getHistMarketData', // Get OHLC k line of specific market
                        ],
                    },
                    'public': {
                        // these endpoints are not documented
                        // 'get': [
                        //     'order_book', // Get the order book of specified market
                        //     'order_book/{market}',
                        //     'trades', // Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
                        //     'trades/{market}',
                        //     'tickers', // Get ticker of all markets
                        //     'tickers/{market}', // Get ticker of specific market
                        // ],
                        'get': [
                            'currencies',
                            'announcement/maintenance', // System Maintenance Notice
                            'instruments', // Retrieve all trading pairs information
                            'market/orderbook', // Order Book
                            'futures/position/openInterest', // Open Interest
                            'market/tickers', // Get the Last 24h Market Summary
                            'market/candles', // Get Current Candlestick
                            'market/history/candles', // Get Current Candlestick
                            'market/trades', // Get the Most Recent Trades
                            'market/markPrice', // Get Current Mark Price
                            'futures/funding/predictedFunding/{symbol}', // Get Predicted Funding Rate
                            'futures/funding/prevFundingRate/{symbol}', // Get Last Funding Rate
                            'market/candles/index', // Get Current Index Candlestick
                        ],
                    },
                    'private': {
                        'get': [
                            'user/info', // Retrieve user information
                            'account/balances', // Get Account Balances
                            'account/deposit/address', // undocumented
                            'spot/trades', // Retrieve trades details for a spot order
                            'spot/openOrders', // Retrieve spot open orders
                            'spot/orders', // Retrieve historical spot orders
                            'futures/position', // Get positions for all contracts
                            'futures/position/closed', // Get closed positions
                            'futures/trades', // Retrieve trade details for a futures order
                            'futures/openOrders', // Retrieve futures open orders
                            'futures/orders', // Retrieve historical futures orders
                            'futures/funding/predictedFundingFee/{symbol}', // Get predicted funding fee
                        ],
                        'post': [
                            'account/transfer', // Asset Transfer
                            'spot/orders', // Create a new spot order
                            'spot/orders/cancelAllOnTimeout', // Automatically cancel all your spot orders after a specified timeout.
                            'futures/orders', // Create a new futures order
                            'futures/orders/cancelAllOnTimeout', // Automatically cancel all your futures orders after a specified timeout.
                            'futures/position/sltp', // Set take profit and stop loss orders for an opening position
                            'futures/position/close', // Close position
                            'futures/position/leverage', // Update leverage for position
                            'futures/position/margin', // Modify Isolated Position Margin
                        ],
                        'put': [
                            'spot/orders', // Amend spot order
                            'futures/orders', // Amend the quantity of an open futures order
                        ],
                        'delete': [
                            'spot/orders/cancel/{orderID}', // Cancel a spot order
                            'spot/orders/cancel/all', // Batch cancel spot orders
                            'futures/orders/cancel/{orderID}', // Cancel a futures order
                            'futures/orders/cancel/all', // Batch cancel futures orders
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': this.parseNumber ('0.0006'),
                        'taker': this.parseNumber ('0.001'),
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': true,
                        'withdraw': {}, // There is only 1% fee on withdrawals to your bank account.
                    },
                },
                'commonCurrencies': {
                    'XBT': 'XBT',
                },
                'exceptions': {
                    'exact': {
                        '2002': InsufficientFunds,
                        '2003': OrderNotFound,
                        '10003': BadRequest, // Parameter validation error
                        '10006': AuthenticationError, // Session expired, please relogin
                        '10007': AuthenticationError, // Invalid authentication key or token
                        '11007': AuthenticationError, // Invalid key format
                        '20001': InsufficientFunds, // Insufficient balance. Please deposit to trade.
                        '20009': InvalidOrder, // Order amount must be positive
                        '30000': OrderNotFound, // {"code":30000,"data":null,"message":"The order does not exist","ts":1610259732263}
                        '30001': InvalidOrder, // The order is being submitted, please try again later
                        '30004': InvalidOrder, // Minimum quantity is {0}
                        '30005': InvalidOrder, // Quantity maximum precision is {0} decimal places
                        '30006': InvalidOrder, // Price maximum precision is {0} decimal places
                        '30007': InvalidOrder, // Minimum price is {0}
                        '30008': InvalidOrder, // Stop price maximum precision is {0} decimal places
                        '30009': InvalidOrder, // Stop Price cannot be less than {0}
                        '30010': InvalidOrder, // Market price cannot be empty
                        '30011': CancelPending, // The order is being cancelled, please wait.
                        '30012': BadRequest, // Unknown currency
                        '30013': BadSymbol, // Unknown symbol
                        '30014': OrderNotFound, // Futures order cannot be found
                        '30015': InvalidOrder, // This is not an open order and cannot modified
                        '30016': ExchangeError, // No position found
                        '30017': InvalidOrder, // The current close position is 0. It is recommended that you cancel the current order closing order.
                        '30018': InvalidOrder, // Order price cannot be greater than {0}
                        '30019': InvalidOrder, // Order quantity cannot be greater than {0}
                        '30020': InvalidOrder, // Order price must be a multiple of {0}
                        '30021': InvalidOrder, // Margin adjustement must be greater than 0
                        '30022': InvalidOrder, // New quantity must be greater than filled quantity
                        '30023': InvalidOrder, // Order failed, please try again
                        '30024': InvalidOrder, // TimeInForce error, only GTC or IOC are allowed
                        '30025': InvalidOrder, // TimeInForce error, only GTC is allowed
                        '30026': InvalidOrder, // Quantity is not a multiple of {0}
                        '30027': InvalidOrder, // Close position failed, it is recommended that you cancel the current order and then close the position.
                        '30028': BadSymbol, // Symbol cannot be traded at this time
                        '30029': InvalidOrder, // Modified quantity or price cannot be empty
                        '30030': InvalidOrder, // Price cannot be specified for market orders
                        '30031': InvalidOrder, // Liquidation orders cannot be modified
                        '30032': InvalidOrder, // Leverage cannot be greater than {0}
                        '30033': InvalidOrder, // Leverage cannot be smaller than {0}
                        '30034': RateLimitExceeded, // The max number of open orders is {0}. To place a new order, please cancel a previous one
                        '30035': RateLimitExceeded, // The max number of {0} open orders is {1}. To place a new order, please cancel a previous one
                        '30036': ExchangeNotAvailable, // Liquidation is in progress, please try again later
                        '30037': InvalidOrder, // Once stop limit order triggered, stop price cannot be amended
                        '30038': ExchangeError, // The total value of your orders has exceeded the current risk limit. Please adjust the risk limit
                        '30039': InsufficientFunds, // Your risk limit has now been changed to {0}, your maximum leverage less than 1, please readjust accordingly
                        '30040': InvalidOrder, // Order status has changed, please try again later
                        '30041': InvalidOrder, // Liquidation orders cannot be cancelled
                        '30042': InvalidOrder, // Order cannot be placed as you will be breaching you max limit value of {1} BTC for {0}
                        '30043': InvalidOrder, // The risk limit cannot be less than 0
                        '30044': BadRequest, // Timeout cannot be greater than 60 minutes
                        '30045': InvalidOrder, // Side is not valid, it should be BUY or SELL
                        '30046': InvalidOrder, // Order type is not valid, it should be MARKET or LIMIT or STOP-LIMIT or STOP
                        '30047': InvalidOrder, // The order is closed. Can't cancel
                        '30048': InvalidOrder, // Market orders cannot be modified
                        '30049': InvalidOrder, // The order is being modified, please wait
                        '30050': InvalidOrder, // Maximum 10 orders
                        '40004': BadRequest, // Requested resource doesn't exist
                        '40009': RateLimitExceeded, // Too many requests
                        '40102': AuthenticationError, // {"code":40102,"message":"Unauthorized(invalid key)"}
                        '40103': AuthenticationError, // {"code":40103,"message":"Unauthorized(invalid sign)"}
                        '40303': PermissionDenied, // {"code":40303,"message":"Forbidden(invalid scopes)"}
                        '41001': BadRequest, // Incorrect HTTP request
                        '41002': BadRequest, // Unsupported HTTP request method
                        '42001': ExchangeNotAvailable, // Duplicated data entry, please check and try again
                        '50001': ExchangeError, // Server side exception, please try again later
                        '50002': ExchangeError, // Server is busy, please try again later
                    },
                    'broad': {},
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    'defaultType': 'spot', // 'spot', 'future'
                    'types': {
                        'spot': 'SPTP',
                        'future': 'FUTP',
                        'otc': 'F2CP',
                        'saving': 'VLTP',
                    },
                    'accounts': {
                        'SPTP': 'spot',
                        'FUTP': 'future',
                        'F2CP': 'otc',
                        'VLTP': 'saving',
                    },
                },
            });
        }
    
        async fetchStatus (params = {}) {
            const response = await this.publicGetAnnouncementMaintenance (params);
            //
            //     {
            //         "code": 1,
            //         "data": {
            //             "startTime":"2020-06-25T02:15:00.000Z",
            //             "endTime":"2020-06-25T02:45:00.000Z"，
            //             "description":"Spot Trading :UTC Jun 25, 2020 02:15 to 02:45 (HKT Jun 25 10:15 to 10:45),Futures Trading: UTC Jun 25, 2020 02:15 to 02:45 (HKT Jun 25 10:15 to 10:45).We apologize for any inconvenience caused. Thank you for your patience and understanding.Should you have any enquiries, please do not hesitate our live chat support or via email at cs@aax.com."
            //         },
            //         "message":"success",
            //         "ts":1593043237000
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const timestamp = this.milliseconds ();
            const startTime = this.parse8601 (this.safeString (data, 'startTime'));
            const endTime = this.parse8601 (this.safeString (data, 'endTime'));
            const update = {
                'updated': this.safeInteger (response, 'ts', timestamp),
            };
            if (endTime !== undefined) {
                const startTimeIsOk = (startTime === undefined) ? true : (timestamp < startTime);
                const isOk = (timestamp > endTime) || startTimeIsOk;
                update['eta'] = endTime;
                update['status'] = isOk ? 'ok' : 'maintenance';
            }
            this.status = this.extend (this.status, update);
            return this.status;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetInstruments (params);
            //
            //     {
            //         "code":1,
            //         "message":"success",
            //         "ts":1610159448962,
            //         "data":[
            //             {
            //                 "tickSize":"0.01",
            //                 "lotSize":"1",
            //                 "base":"BTC",
            //                 "quote":"USDT",
            //                 "minQuantity":"1.0000000000",
            //                 "maxQuantity":"30000",
            //                 "minPrice":"0.0100000000",
            //                 "maxPrice":"999999.0000000000",
            //                 "status":"readOnly",
            //                 "symbol":"BTCUSDTFP",
            //                 "code":"FP",
            //                 "takerFee":"0.00040",
            //                 "makerFee":"0.00020",
            //                 "multiplier":"0.001000000000",
            //                 "mmRate":"0.00500",
            //                 "imRate":"0.01000",
            //                 "type":"futures",
            //                 "settleType":"Vanilla",
            //                 "settleCurrency":"USDT"
            //             },
            //             {
            //                 "tickSize":"0.5",
            //                 "lotSize":"10",
            //                 "base":"BTC",
            //                 "quote":"USD",
            //                 "minQuantity":"10.0000000000",
            //                 "maxQuantity":"300000",
            //                 "minPrice":"0.5000000000",
            //                 "maxPrice":"999999.0000000000",
            //                 "status":"readOnly",
            //                 "symbol":"BTCUSDFP",
            //                 "code":"FP",
            //                 "takerFee":"0.00040",
            //                 "makerFee":"0.00020",
            //                 "multiplier":"1.000000000000",
            //                 "mmRate":"0.00500",
            //                 "imRate":"0.01000",
            //                 "type":"futures",
            //                 "settleType":"Inverse",
            //                 "settleCurrency":"BTC"
            //             },
            //             {
            //                 "tickSize":"0.0001",
            //                 "lotSize":"0.01",
            //                 "base":"AAB",
            //                 "quote":"USDT",
            //                 "minQuantity":"5.0000000000",
            //                 "maxQuantity":"50000.0000000000",
            //                 "minPrice":"0.0001000000",
            //                 "maxPrice":"999999.0000000000",
            //                 "status":"readOnly",
            //                 "symbol":"AABUSDT",
            //                 "code":null,
            //                 "takerFee":"0.00100",
            //                 "makerFee":"0.00100",
            //                 "multiplier":"1.000000000000",
            //                 "mmRate":"0.02500",
            //                 "imRate":"0.05000",
            //                 "type":"spot",
            //                 "settleType":null,
            //                 "settleCurrency":null
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data');
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const market = data[i];
                const id = this.safeString (market, 'symbol');
                const baseId = this.safeString (market, 'base');
                const quoteId = this.safeString (market, 'quote');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const status = this.safeString (market, 'status');
                const active = (status === 'enable');
                const taker = this.safeNumber (market, 'takerFee');
                const maker = this.safeNumber (market, 'makerFee');
                const type = this.safeString (market, 'type');
                let inverse = undefined;
                let linear = undefined;
                let quanto = undefined;
                const spot = (type === 'spot');
                const futures = (type === 'futures');
                const settleType = this.safeStringLower (market, 'settleType');
                if (settleType !== undefined) {
                    inverse = (settleType === 'inverse');
                    linear = (settleType === 'vanilla');
                    quanto = (settleType === 'quanto');
                }
                let symbol = id;
                if (type === 'spot') {
                    symbol = base + '/' + quote;
                }
                const precision = {
                    'amount': this.safeNumber (market, 'lotSize'),
                    'price': this.safeNumber (market, 'tickSize'),
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'type': type,
                    'spot': spot,
                    'futures': futures,
                    'inverse': inverse,
                    'linear': linear,
                    'quanto': quanto,
                    'precision': precision,
                    'info': market,
                    'active': active,
                    'taker': taker,
                    'maker': maker,
                    'percentage': false,
                    'tierBased': true,
                    'limits': {
                        'amount': {
                            'min': this.safeString (market, 'minQuantity'),
                            'max': this.safeString (market, 'maxQuantity'),
                        },
                        'price': {
                            'min': this.safeString (market, 'minPrice'),
                            'max': this.safeString (market, 'maxPrice'),
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     {
            //         "code":1,
            //         "data":[
            //             {
            //                 "chain":"BTC",
            //                 "displayName":"Bitcoin",
            //                 "withdrawFee":"0.0004",
            //                 "withdrawMin":"0.001",
            //                 "otcFee":"0",
            //                 "enableOTC":true,
            //                 "visible":true,
            //                 "enableTransfer":true,
            //                 "transferMin":"0.00001",
            //                 "depositMin":"0.0005",
            //                 "enableWithdraw":true,
            //                 "enableDeposit":true,
            //                 "addrWithMemo":false,
            //                 "withdrawPrecision":"0.00000001",
            //                 "currency":"BTC",
            //                 "network":"BTC", // ETH, ERC20, TRX, TRC20, OMNI, LTC, XRP, XLM, ...
            //                 "minConfirm":"2"
            //             },
            //         ],
            //         "message":"success",
            //         "ts":1624330530697
            //     }
            //
            const result = {};
            const data = this.safeValue (response, 'data', []);
            for (let i = 0; i < data.length; i++) {
                const currency = data[i];
                const id = this.safeString (currency, 'chain');
                const name = this.safeString (currency, 'displayName');
                const code = this.safeCurrencyCode (id);
                const precision = this.safeNumber (currency, 'withdrawPrecision');
                const enableWithdraw = this.safeValue (currency, 'enableWithdraw');
                const enableDeposit = this.safeValue (currency, 'enableDeposit');
                const fee = this.safeNumber (currency, 'withdrawFee');
                const visible = this.safeValue (currency, 'visible');
                const active = (enableWithdraw && enableDeposit && visible);
                const network = this.safeString (currency, 'network');
                result[code] = {
                    'id': id,
                    'name': name,
                    'code': code,
                    'precision': precision,
                    'info': currency,
                    'active': active,
                    'fee': fee,
                    'network': network,
                    'limits': {
                        'deposit': {
                            'min': this.safeNumber (currency, 'depositMin'),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'withdrawMin'),
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         "t":1610162685342, // timestamp
            //         "a":"0.00000000", // trading volume in USD in the last 24 hours, futures only
            //         "c":"435.20000000", // close
            //         "d":"4.22953489", // change
            //         "h":"455.04000000", // high
            //         "l":"412.78000000", // low
            //         "o":"417.54000000", // open
            //         "s":"BCHUSDTFP", // market id
            //         "v":"2031068.00000000", // trading volume in quote currency of last 24 hours
            //     }
            //
            const timestamp = this.safeInteger (ticker, 't');
            const marketId = this.safeString (ticker, 's');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber (ticker, 'c');
            const open = this.safeNumber (ticker, 'o');
            const quoteVolume = this.safeNumber (ticker, 'v');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': undefined,
                'high': this.safeNumber (ticker, 'h'),
                'low': this.safeNumber (ticker, 'l'),
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetMarketTickers (params);
            //
            //     {
            //         "e":"tickers",
            //         "t":1610162685342,
            //         "tickers":[
            //             {
            //                 "a":"0.00000000",
            //                 "c":"435.20000000",
            //                 "d":"4.22953489",
            //                 "h":"455.04000000",
            //                 "l":"412.78000000",
            //                 "o":"417.54000000",
            //                 "s":"BCHUSDTFP",
            //                 "v":"2031068.00000000",
            //             },
            //         ],
            //     }
            //
            const tickers = this.safeValue (response, 'tickers', []);
            const result = [];
            const timestamp = this.safeInteger (response, 't');
            for (let i = 0; i < tickers.length; i++) {
                const ticker = this.parseTicker (this.extend (tickers[i], { 't': timestamp }));
                result.push (ticker);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (limit === undefined) {
                limit = 20;
            } else {
                if ((limit !== 20) && (limit !== 50)) {
                    throw new BadRequest (this.id + ' fetchOrderBook() limit argument must be undefined, 20 or 50');
                }
            }
            const request = {
                'symbol': market['id'],
                'level': limit, // required
            };
            //
            const response = await this.publicGetMarketOrderbook (this.extend (request, params));
            //
            //     {
            //         "asks":[
            //             ["10823.00000000","0.004000"],
            //             ["10823.10000000","0.100000"],
            //             ["10823.20000000","0.010000"]
            //         ],
            //         "bids":[
            //             ["10821.20000000","0.002000"],
            //             ["10821.10000000","0.005000"],
            //             ["10820.40000000","0.013000"]
            //         ],
            //         "e":"BTCUSDT@book_50",
            //         "t":1561543614756
            //     }
            //
            const timestamp = this.safeInteger (response, 't'); // need unix type
            return this.parseOrderBook (response, symbol, timestamp);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     {
            //         "p":"9395.50000000",
            //         "q":"50.000000",
            //         "t":1592563996718
            //     }
            //
            // private fetchMyTrades
            //
            //     {
            //         "avgPrice":"1199.8",
            //         "base":"ETH",
            //         "clOrdID":null,
            //         "commission":"0.00002",
            //         "createTime":"2021-01-11T02:47:51.512Z",
            //         "cumQty":"0.02",
            //         "filledOrderID":"1eUD4F5rwK",
            //         "filledPrice":"1199.8",
            //         "filledQty":"0.02",
            //         "leavesQty":"0",
            //         "oCreateTime":"2021-01-11T02:47:51.377Z",
            //         "orderID":"1eUD4EHfdU",
            //         "orderQty":"0.02",
            //         "orderStatus":3,
            //         "orderType":1,
            //         "price":"1198.25",
            //         "quote":"USDT",
            //         "rejectCode":null,
            //         "rejectReason":null,
            //         "side":1,
            //         "stopPrice":"0",
            //         "symbol":"ETHUSDT",
            //         "taker":true,
            //         "tradeID":"E04WTIgfmULU",
            //         "transactTime":"2021-01-11T02:47:51.389Z",
            //         "updateTime":null,
            //         "userID":"1362494"
            //     }
            //
            let timestamp = this.safeInteger (trade, 't');
            if (timestamp === undefined) {
                timestamp = this.parse8601 (this.safeString (trade, 'createTime'));
            }
            const id = this.safeString2 (trade, 'tid', 'tradeID');
            let symbol = undefined;
            const marketId = this.safeString (trade, 'symbol');
            market = this.safeMarket (marketId, market);
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            let priceString = this.safeString2 (trade, 'p', 'filledPrice');
            const amountString = this.safeString2 (trade, 'q', 'filledQty');
            const orderId = this.safeString (trade, 'orderID');
            const isTaker = this.safeValue (trade, 'taker');
            let takerOrMaker = undefined;
            if (isTaker !== undefined) {
                takerOrMaker = isTaker ? 'taker' : 'maker';
            }
            let side = this.safeString (trade, 'side');
            if (side === '1') {
                side = 'buy';
            } else if (side === '2') {
                side = 'sell';
            }
            if (side === undefined) {
                side = (priceString[0] === '-') ? 'sell' : 'buy';
            }
            priceString = Precise.stringAbs (priceString);
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const orderType = this.parseOrderType (this.safeString (trade, 'orderType'));
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'commission');
            if (feeCost !== undefined) {
                let feeCurrency = undefined;
                if (market !== undefined) {
                    if (side === 'buy') {
                        feeCurrency = market['base'];
                    } else if (side === 'sell') {
                        feeCurrency = market['quote'];
                    }
                }
                fee = {
                    'currency': feeCurrency,
                    'cost': feeCost,
                };
            }
            return {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': orderType,
                'side': side,
                'order': orderId,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            limit = (limit === undefined) ? 2000 : limit;
            limit = Math.min (limit, 2000);
            const request = {
                'symbol': market['id'],
                'limit': limit,
            };
            const response = await this.publicGetMarketTrades (request);
            //
            //     {
            //         "e":"BTCUSDFP@trades",
            //         "trades": [
            //             {"p":"9395.50000000","q":"50.000000","t":1592563996718},
            //             {"p":"9395.50000000","q":"50.000000","t":1592563993577},
            //         ],
            //     }
            //
            const trades = this.safeValue (response, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         0.042398, // 0 open
            //         0.042684, // 1 high
            //         0.042366, // 2 low
            //         0.042386, // 3 close
            //         0.93734243, // 4 volume
            //         1611514800, // 5 timestamp
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 5),
                this.safeNumber (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1h', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                // 'limit': limit, // if set counts from now into the past
                'symbol': market['id'],
                'timeFrame': this.timeframes[timeframe],
            };
            limit = (limit === undefined) ? 500 : limit;
            const duration = this.parseTimeframe (timeframe);
            if (since === undefined) {
                const end = this.seconds ();
                request['start'] = end - duration * limit;
                request['end'] = end;
            } else {
                const start = parseInt (since / 1000);
                request['start'] = start;
                request['end'] = this.sum (start, duration * limit);
            }
            const response = await this.publicGetMarketHistoryCandles (this.extend (request, params));
            //
            //     {
            //         "data":[
            //             [0.042398,0.042684,0.042366,0.042386,0.93734243,1611514800],
            //             [0.042386,0.042602,0.042234,0.042373,1.01925239,1611518400],
            //             [0.042373,0.042558,0.042362,0.042389,0.93801705,1611522000],
            //         ],
            //         "success":true,
            //         "t":1611875157
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString2 (this.options, 'fetchBalance', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const types = this.safeValue (this.options, 'types', {});
            const purseType = this.safeString (types, type, type);
            const request = {
                'purseType': purseType,
            };
            params = this.omit (params, 'type');
            const response = await this.privateGetAccountBalances (this.extend (request, params));
            //
            //     {
            //         "code":1,
            //         "data":[
            //             {
            //                 "purseType":"FUTP",
            //                 "currency":"BTC",
            //                 "available":"0.41000000",
            //                 "unavailable":"0.00000000"
            //             },
            //             {
            //                 "purseType":"FUTP",
            //                 "currency":"USDT",
            //                 "available":"0.21000000",
            //                 "unvaliable":"0.00000000"
            //             }
            //         ]
            //         "message":"success",
            //         "ts":1573530401020
            //     }
            //
            const data = this.safeValue (response, 'data');
            const timestamp = this.safeInteger (response, 'ts');
            const result = {
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
            };
            for (let i = 0; i < data.length; i++) {
                const balance = data[i];
                const balanceType = this.safeString (balance, 'purseType');
                if (balanceType === purseType) {
                    const currencyId = this.safeString (balance, 'currency');
                    const code = this.safeCurrencyCode (currencyId);
                    const account = this.account ();
                    account['free'] = this.safeString (balance, 'available');
                    account['used'] = this.safeString (balance, 'unavailable');
                    result[code] = account;
                }
            }
            return this.parseBalance (result);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            let orderType = type.toUpperCase ();
            const orderSide = side.toUpperCase ();
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                // 'orderType': orderType, // MARKET, LIMIT, STOP, STOP-LIMIT
                'symbol': market['id'],
                'orderQty': this.amountToPrecision (symbol, amount),
                'side': orderSide,
                // 'stopPrice': this.priceToPrecision (symbol, stopPrice),
                // 'clOrdID': clientOrderId, // up to 20 chars, lowercase and uppercase letters only
                // 'timeInForce': 'GTC', // GTC, IOC, FOK, default is GTC
                // 'execInst': 'Post-Only', // the only value supported by the exchange, futures-only
            };
            const timeInForce = this.safeString (params, 'timeInForce');
            if (timeInForce !== undefined) {
                request['timeInForce'] = timeInForce;
                params = this.omit (params, 'timeInForce');
            }
            const clientOrderId = this.safeString2 (params, 'clOrdID', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['clOrdID'] = clientOrderId;
                params = this.omit (params, [ 'clOrdID', 'clientOrderId' ]);
            }
            const stopPrice = this.safeNumber (params, 'stopPrice');
            if (stopPrice === undefined) {
                if ((orderType === 'STOP-LIMIT') || (orderType === 'STOP')) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a stopPrice parameter for ' + orderType + ' orders');
                }
            } else {
                if (orderType === 'LIMIT') {
                    orderType = 'STOP-LIMIT';
                } else if (orderType === 'MARKET') {
                    orderType = 'STOP';
                }
                request['stopPrice'] = this.priceToPrecision (symbol, stopPrice);
                params = this.omit (params, 'stopPrice');
            }
            if (orderType === 'LIMIT' || orderType === 'STOP-LIMIT') {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            request['orderType'] = orderType;
            let method = undefined;
            if (market['spot']) {
                method = 'privatePostSpotOrders';
            } else if (market['futures']) {
                method = 'privatePostFuturesOrders';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "symbol":"ETHUSDT",
            //             "orderType":2,
            //             "avgPrice":"0",
            //             "execInst":null,
            //             "orderStatus":0,
            //             "userID":"1362494",
            //             "quote":"USDT",
            //             "rejectReason":null,
            //             "rejectCode":null,
            //             "price":"1500",
            //             "orderQty":"1",
            //             "commission":"0",
            //             "id":"268323430253735936",
            //             "timeInForce":1,
            //             "isTriggered":false,
            //             "side":2,
            //             "orderID":"1eO51MDSpQ",
            //             "leavesQty":"0",
            //             "cumQty":"0",
            //             "updateTime":null,
            //             "lastQty":"0",
            //             "clOrdID":null,
            //             "stopPrice":null,
            //             "createTime":null,
            //             "transactTime":null,
            //             "base":"ETH",
            //             "lastPrice":"0"
            //         },
            //         "message":"success",
            //         "ts":1610245290980
            //     }
            //
            // futures
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "liqType":0,
            //             "symbol":"ETHUSDTFP",
            //             "orderType":2,
            //             "leverage":"1",
            //             "marketPrice":"1318.3150000000",
            //             "code":"FP",
            //             "avgPrice":"0",
            //             "execInst":null,
            //             "orderStatus":0,
            //             "userID":"1362494",
            //             "quote":"USDT",
            //             "rejectReason":null,
            //             "rejectCode":null,
            //             "price":"500",
            //             "orderQty":"1",
            //             "commission":"0",
            //             "id":"268346885133053953",
            //             "timeInForce":1,
            //             "isTriggered":false,
            //             "side":1,
            //             "orderID":"1eOuPUAAkq",
            //             "leavesQty":"1",
            //             "cumQty":"0",
            //             "updateTime":null,
            //             "lastQty":null,
            //             "clOrdID":null,
            //             "stopPrice":null,
            //             "createTime":null,
            //             "transactTime":null,
            //             "settleType":"VANILLA",
            //             "base":"ETH",
            //             "lastPrice":"0"
            //         },
            //         "message":"success",
            //         "ts":1610250883059
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data, market);
        }
    
        async editOrder (id, symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'orderID': id,
                // 'orderQty': this.amountToPrecision (symbol, amount),
                // 'price': this.priceToPrecision (symbol, price),
                // 'stopPrice': this.priceToPrecision (symbol, stopPrice),
            };
            const stopPrice = this.safeNumber (params, 'stopPrice');
            if (stopPrice !== undefined) {
                request['stopPrice'] = this.priceToPrecision (symbol, stopPrice);
                params = this.omit (params, 'stopPrice');
            }
            if (price !== undefined) {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            if (amount !== undefined) {
                request['orderQty'] = this.amountToPrecision (symbol, amount);
            }
            let method = undefined;
            if (market['spot']) {
                method = 'privatePutSpotOrders';
            } else if (market['futures']) {
                method = 'privatePutFuturesOrders';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "symbol":"ETHUSDT",
            //             "orderType":2,
            //             "avgPrice":"0",
            //             "execInst":null,
            //             "orderStatus":0,
            //             "userID":"1362494",
            //             "quote":"USDT",
            //             "rejectReason":null,
            //             "rejectCode":null,
            //             "price":"1500",
            //             "orderQty":"1",
            //             "commission":"0",
            //             "id":"268323430253735936",
            //             "timeInForce":1,
            //             "isTriggered":false,
            //             "side":2,
            //             "orderID":"1eO51MDSpQ",
            //             "leavesQty":"0",
            //             "cumQty":"0",
            //             "updateTime":null,
            //             "lastQty":"0",
            //             "clOrdID":null,
            //             "stopPrice":null,
            //             "createTime":null,
            //             "transactTime":null,
            //             "base":"ETH",
            //             "lastPrice":"0"
            //         },
            //         "message":"success",
            //         "ts":1610245290980
            //     }
            //
            // futures
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "liqType":0,
            //             "symbol":"ETHUSDTFP",
            //             "orderType":2,
            //             "leverage":"1",
            //             "marketPrice":"1318.3150000000",
            //             "code":"FP",
            //             "avgPrice":"0",
            //             "execInst":null,
            //             "orderStatus":0,
            //             "userID":"1362494",
            //             "quote":"USDT",
            //             "rejectReason":null,
            //             "rejectCode":null,
            //             "price":"500",
            //             "orderQty":"1",
            //             "commission":"0",
            //             "id":"268346885133053953",
            //             "timeInForce":1,
            //             "isTriggered":false,
            //             "side":1,
            //             "orderID":"1eOuPUAAkq",
            //             "leavesQty":"1",
            //             "cumQty":"0",
            //             "updateTime":null,
            //             "lastQty":null,
            //             "clOrdID":null,
            //             "stopPrice":null,
            //             "createTime":null,
            //             "transactTime":null,
            //             "settleType":"VANILLA",
            //             "base":"ETH",
            //             "lastPrice":"0"
            //         },
            //         "message":"success",
            //         "ts":1610250883059
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderID': id,
            };
            let method = undefined;
            const defaultType = this.safeString2 (this.options, 'cancelOrder', 'defaultType', 'spot');
            let type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                type = market['type'];
            }
            if (type === 'spot') {
                method = 'privateDeleteSpotOrdersCancelOrderID';
            } else if (type === 'futures') {
                method = 'privateDeleteFuturesOrdersCancelOrderID';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "avgPrice":"0",
            //             "base":"BTC",
            //             "clOrdID":"aax",
            //             "commission":"0",
            //             "createTime":"2019-11-12T03:46:41Z",
            //             "cumQty":"0",
            //             "id":"114330021504606208",
            //             "isTriggered":false,
            //             "lastPrice":"0",
            //             "lastQty":"0",
            //             "leavesQty":"0",
            //             "orderID":"wJ4L366KB",
            //             "orderQty":"0.05",
            //             "orderStatus":1,
            //             "orderType":2,
            //             "price":"8000",
            //             "quote":"USDT",
            //             "rejectCode":0,
            //             "rejectReason":null,
            //             "side":1,
            //             "stopPrice":"0",
            //             "symbol":"BTCUSDT",
            //             "transactTime":null,
            //             "updateTime":"2019-11-12T03:46:41Z",
            //             "timeInForce":1,
            //             "userID":"216214"
            //         },
            //         "message":"success",
            //         "ts":1573530402029
            //     }
            //
            // futures
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "avgPrice":"0",
            //             "base":"BTC",
            //             "clOrdID":"aax_futures",
            //             "code":"FP",
            //             "commission":"0",
            //             "createTime":"2019-11-12T06:48:58Z",
            //             "cumQty":"0",
            //             "id":"114375893764395008",
            //             "isTriggered":false,
            //             "lastPrice":"0",
            //             "lastQty":null,
            //             "leavesQty":"300",
            //             "leverage":"1",
            //             "liqType":0,
            //             "marketPrice":"8760.75",
            //             "orderID":"wJTewQc81",
            //             "orderQty":"300",
            //             "orderStatus":1,
            //             "orderType":2,
            //             "price":"8000",
            //             "quote":"USD",
            //             "rejectCode":0,
            //             "rejectReason":null,
            //             "settleType":"INVERSE",
            //             "side":1,
            //             "stopPrice":"0",
            //             "symbol":"BTCUSDFP",
            //             "transactTime":"2019-11-12T06:48:58Z",
            //             "updateTime":"2019-11-12T06:48:58Z",
            //             "timeInForce":1,
            //             "execInst": "",
            //             "userID":"216214"
            //         },
            //         "message":"success",
            //         "ts":1573541642970
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data, market);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelAllOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            if (market['spot']) {
                method = 'privateDeleteSpotOrdersCancelAll';
            } else if (market['futures']) {
                method = 'privateDeleteFuturesOrdersCancelAll';
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "code":1,
            //         "data":[
            //             "vBC9rXsEE",
            //             "vBCc46OI0"
            //             ],
            //         "message":"success",
            //         "ts":1572597435470
            //     }
            //
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString2 (this.options, 'fetchOrder', 'defaultType', 'spot');
            params['type'] = this.safeString (params, 'type', defaultType);
            const request = {};
            const clientOrderId = this.safeString2 (params, 'clOrdID', 'clientOrderId');
            if (clientOrderId === undefined) {
                request['orderID'] = id;
            } else {
                request['clOrdID'] = clientOrderId;
                params = this.omit (params, [ 'clOrdID', 'clientOrderId' ]);
            }
            const orders = await this.fetchOrders (symbol, undefined, undefined, this.extend (request, params));
            const order = this.safeValue (orders, 0);
            if (order === undefined) {
                if (clientOrderId === undefined) {
                    throw new OrderNotFound (this.id + ' fetchOrder() could not find order id ' + id);
                } else {
                    throw new OrderNotFound (this.id + ' fetchOrder() could not find order clientOrderID ' + clientOrderId);
                }
            }
            return order;
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'pageNum': '1',
                // 'pageSize': '10',
                // 'symbol': market['id'],
                // 'orderID': id,
                // 'side': 'undefined', // BUY, SELL
                // 'clOrdID': clientOrderId,
            };
            const defaultType = this.safeString2 (this.options, 'fetchOpenOrders', 'defaultType', 'spot');
            let type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                type = market['type'];
            }
            const clientOrderId = this.safeString2 (params, 'clOrdID', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['clOrdID'] = clientOrderId;
                params = this.omit (params, [ 'clOrdID', 'clientOrderId' ]);
            }
            let method = undefined;
            if (type === 'spot') {
                method = 'privateGetSpotOpenOrders';
            } else if (type === 'futures') {
                method = 'privateGetFuturesOpenOrders';
            }
            if (limit !== undefined) {
                request['pageSize'] = limit; // default 10
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "total":19,
            //             "pageSize":10,
            //             "list":[
            //                 {
            //                     "orderType":2,
            //                     "symbol":"BTCUSDT",
            //                     "avgPrice":"0",
            //                     "orderStatus":0,
            //                     "userID":"7225",
            //                     "quote":"USDT",
            //                     "rejectReason":null,
            //                     "rejectCode":null,
            //                     "price":"0",
            //                     "orderQty":"0.002",
            //                     "commission":"0",
            //                     "id":"110419975166304256",
            //                     "isTriggered":null,
            //                     "side":1,
            //                     "orderID":"vBGlDcLwk",
            //                     "cumQty":"0",
            //                     "leavesQty":"0",
            //                     "updateTime":null,
            //                     "clOrdID":"0001",
            //                     "lastQty":"0",
            //                     "stopPrice":"0",
            //                     "createTime":"2019-11-01T08:49:33Z",
            //                     "transactTime":null,
            //                     "timeInForce":1,
            //                     "base":"BTC",
            //                     "lastPrice":"0"
            //                 }
            //             ],
            //             "pageNum":1
            //         },
            //         "message":"success",
            //         "ts":1572598173682
            //     }
            //
            // futures
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "list":[
            //                 {
            //                     "avgPrice":"8768.99999999484997",
            //                     "base":"BTC",
            //                     "clOrdID":null,
            //                     "code":"FP",
            //                     "commission":"0.00000913",
            //                     "createTime":"2019-11-12T07:05:52.000Z,
            //                     "cumQty":"100",
            //                     "id":"114380149603028993",
            //                     "isTriggered":false,
            //                     "lastPrice":"8769",
            //                     "lastQty":"100",
            //                     "leavesQty":"0",
            //                     "leverage":"1",
            //                     "liqType":1,
            //                     "marketPrice":"8769.75",
            //                     "orderID":"wJXURIFBT",
            //                     "orderQty":"100",
            //                     "orderStatus":3,
            //                     "orderType":1,
            //                     "price":"8769.75",
            //                     "quote":"USD",
            //                     "rejectCode":0,
            //                     "rejectReason":null,
            //                     "settleType":"INVERSE",
            //                     "side":2,
            //                     "stopPrice":"0",
            //                     "symbol":"BTCUSDFP",
            //                     "transactTime":"2019-11-12T07:05:52.000Z,
            //                     "updateTime":"2019-11-12T07:05:52.000Z,
            //                     "timeInForce":1,
            //                     "execInst": "",
            //                     "userID":"216214"
            //                 },
            //             ],
            //             "pageNum":1,
            //             "pageSize":10,
            //             "total":21
            //         },
            //         "message":"success",
            //         "ts":1573546960172
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const orders = this.safeValue (data, 'list', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'orderStatus': '2', // 1 new, 2 filled, 3 canceled
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchCanceledOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'orderStatus': '3', // 1 new, 2 filled, 3 canceled
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'pageNum': '1',
                // 'pageSize': '10',
                // 'symbol': market['id'],
                // 'orderID': id,
                // 'base': market['baseId'],
                // 'quote': market['quoteId'],
                // 'orderStatus': undefined, // 1 new, 2 filled, 3 canceled
                // 'startDate': this.ymd (since),
                // 'endDate': this.ymd (this.milliseconds()),
                // 'orderType': undefined, // MARKET, LIMIT, STOP, STOP-LIMIT
                // 'side': 'undefined', // BUY, SELL
                // 'clOrdID': clientOrderId,
            };
            let method = undefined;
            const defaultType = this.safeString2 (this.options, 'fetchOrders', 'defaultType', 'spot');
            let type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                type = market['type'];
            }
            if (type === 'spot') {
                method = 'privateGetSpotOrders';
            } else if (type === 'futures') {
                method = 'privateGetFuturesOrders';
            }
            const clientOrderId = this.safeString2 (params, 'clOrdID', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['clOrdID'] = clientOrderId;
                params = this.omit (params, [ 'clOrdID', 'clientOrderId' ]);
            }
            if (limit !== undefined) {
                request['pageSize'] = limit; // default 10
            }
            if (since !== undefined) {
                request['startDate'] = this.ymd (since);
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "total":19,
            //             "pageSize":10,
            //             "list":[
            //                 {
            //                     "orderType":2,
            //                     "symbol":"BTCUSDT",
            //                     "avgPrice":"0",
            //                     "orderStatus":0,
            //                     "userID":"7225",
            //                     "quote":"USDT",
            //                     "rejectReason":null,
            //                     "rejectCode":null,
            //                     "price":"0",
            //                     "orderQty":"0.002",
            //                     "commission":"0",
            //                     "id":"110419975166304256",
            //                     "isTriggered":null,
            //                     "side":1,
            //                     "orderID":"vBGlDcLwk",
            //                     "cumQty":"0",
            //                     "leavesQty":"0",
            //                     "updateTime":null,
            //                     "clOrdID":"0001",
            //                     "lastQty":"0",
            //                     "stopPrice":"0",
            //                     "createTime":"2019-11-01T08:49:33Z",
            //                     "transactTime":null,
            //                     "timeInForce":1,
            //                     "base":"BTC",
            //                     "lastPrice":"0"
            //                 }
            //             ],
            //             "pageNum":1
            //         },
            //         "message":"success",
            //         "ts":1572598173682
            //     }
            //
            // futures
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "list":[
            //                 {
            //                     "avgPrice":"8768.99999999484997",
            //                     "base":"BTC",
            //                     "clOrdID":null,
            //                     "code":"FP",
            //                     "commission":"0.00000913",
            //                     "createTime":"2019-11-12T07:05:52.000Z,
            //                     "cumQty":"100",
            //                     "id":"114380149603028993",
            //                     "isTriggered":false,
            //                     "lastPrice":"8769",
            //                     "lastQty":"100",
            //                     "leavesQty":"0",
            //                     "leverage":"1",
            //                     "liqType":1,
            //                     "marketPrice":"8769.75",
            //                     "orderID":"wJXURIFBT",
            //                     "orderQty":"100",
            //                     "orderStatus":3,
            //                     "orderType":1,
            //                     "price":"8769.75",
            //                     "quote":"USD",
            //                     "rejectCode":0,
            //                     "rejectReason":null,
            //                     "settleType":"INVERSE",
            //                     "side":2,
            //                     "stopPrice":"0",
            //                     "symbol":"BTCUSDFP",
            //                     "transactTime":"2019-11-12T07:05:52.000Z,
            //                     "updateTime":"2019-11-12T07:05:52.000Z,
            //                     "timeInForce":1,
            //                     "execInst": "",
            //                     "userID":"216214"
            //                 },
            //             ],
            //             "pageNum":1,
            //             "pageSize":10,
            //             "total":21
            //         },
            //         "message":"success",
            //         "ts":1573546960172
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const orders = this.safeValue (data, 'list', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '0': 'open', // pending new
                '1': 'open', // new
                '2': 'open', // partially-filled
                '3': 'closed', // filled
                '4': 'canceled', // cancel-reject
                '5': 'canceled', // canceled
                '6': 'rejected', // rejected
                '10': 'expired', // expired
                '11': 'rejected', // business-reject
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrderType (status) {
            const statuses = {
                '1': 'market',
                '2': 'limit',
                '3': 'stop',
                '4': 'stop-limit',
                '7': 'stop-loss',
                '8': 'take-profit',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTimeInForce (timeInForce) {
            const timeInForces = {
                '1': 'GTC',
                '3': 'IOC',
                '4': 'FOK',
            };
            return this.safeString (timeInForces, timeInForce, timeInForce);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "avgPrice":"8768.99999999484997",
            //         "base":"BTC",
            //         "clOrdID":null,
            //         "code":"FP", // futures only
            //         "commission":"0.00000913",
            //         "createTime":"2019-11-12T07:05:52.000Z,
            //         "cumQty":"100",
            //         "id":"114380149603028993", // futures only
            //         "isTriggered":false,
            //         "lastPrice":"8769",
            //         "lastQty":"100",
            //         "leavesQty":"0",
            //         "leverage":"1", // futures only
            //         "liqType":1, // futures only
            //         "marketPrice":"8769.75", // futures only
            //         "orderID":"wJXURIFBT",
            //         "orderQty":"100",
            //         "orderStatus":3,
            //         "orderType":1,
            //         "price":"8769.75",
            //         "quote":"USD",
            //         "rejectCode":0,
            //         "rejectReason":null,
            //         "settleType":"INVERSE", // futures only
            //         "side":2,
            //         "stopPrice":"0",
            //         "symbol":"BTCUSDFP",
            //         "transactTime":"2019-11-12T07:05:52.000Z,
            //         "updateTime":"2019-11-12T07:05:52.000Z,
            //         "timeInForce":1,
            //         "execInst": "",
            //         "userID":"216214"
            //     }
            //
            // sometimes the timestamp is returned in milliseconds
            let timestamp = this.safeValue (order, 'createTime');
            if (typeof timestamp === 'string') {
                timestamp = this.parse8601 (timestamp);
            }
            const status = this.parseOrderStatus (this.safeString (order, 'orderStatus'));
            const type = this.parseOrderType (this.safeString (order, 'orderType'));
            let side = this.safeString (order, 'side');
            if (side === '1') {
                side = 'buy';
            } else if (side === '2') {
                side = 'sell';
            }
            const id = this.safeString (order, 'orderID');
            const clientOrderId = this.safeString (order, 'clOrdID');
            const marketId = this.safeString (order, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = market['symbol'];
            const price = this.safeNumber (order, 'price');
            const stopPrice = this.safeNumber (order, 'stopPrice');
            const timeInForce = this.parseTimeInForce (this.safeString (order, 'timeInForce'));
            const execInst = this.safeString (order, 'execInst');
            const postOnly = (execInst === 'Post-Only');
            const average = this.safeNumber (order, 'avgPrice');
            const amount = this.safeNumber (order, 'orderQty');
            const filled = this.safeNumber (order, 'cumQty');
            let remaining = this.safeNumber (order, 'leavesQty');
            if ((filled === 0) && (remaining === 0)) {
                remaining = undefined;
            }
            let lastTradeTimestamp = this.safeValue (order, 'transactTime');
            if (typeof lastTradeTimestamp === 'string') {
                lastTradeTimestamp = this.parse8601 (lastTradeTimestamp);
            }
            let fee = undefined;
            const feeCost = this.safeNumber (order, 'commission');
            if (feeCost !== undefined) {
                let feeCurrency = undefined;
                if (market !== undefined) {
                    if (side === 'buy') {
                        feeCurrency = market['base'];
                    } else if (side === 'sell') {
                        feeCurrency = market['quote'];
                    }
                }
                fee = {
                    'currency': feeCurrency,
                    'cost': feeCost,
                };
            }
            return this.safeOrder ({
                'id': id,
                'info': order,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'average': average,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'cost': undefined,
                'trades': undefined,
                'fee': fee,
            });
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'pageNum': '1',
                // 'pageSize': '10',
                // 'symbol': market['id'],
                // 'orderID': id,
                // 'base': market['baseId'],
                // 'quote': market['quoteId'],
                // 'startDate': this.ymd (since),
                // 'endDate': this.ymd (this.milliseconds()),
                // 'orderType': undefined, // MARKET, LIMIT, STOP, STOP-LIMIT
                // 'side': 'undefined', // BUY, SELL
            };
            let method = undefined;
            const defaultType = this.safeString2 (this.options, 'fetchMyTrades', 'defaultType', 'spot');
            let type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                type = market['type'];
            }
            if (type === 'spot') {
                method = 'privateGetSpotTrades';
            } else if (type === 'futures') {
                method = 'privateGetFuturesTrades';
            }
            if (limit !== undefined) {
                request['pageSize'] = limit; // default 10
            }
            if (since !== undefined) {
                request['startDate'] = this.ymd (since);
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "list":[
            //                 {
            //                     "avgPrice":"1199.8",
            //                     "base":"ETH",
            //                     "clOrdID":null,
            //                     "commission":"0.00002",
            //                     "createTime":"2021-01-11T02:47:51.512Z",
            //                     "cumQty":"0.02",
            //                     "filledOrderID":"1eUD4F5rwK",
            //                     "filledPrice":"1199.8",
            //                     "filledQty":"0.02",
            //                     "leavesQty":"0",
            //                     "oCreateTime":"2021-01-11T02:47:51.377Z",
            //                     "orderID":"1eUD4EHfdU",
            //                     "orderQty":"0.02",
            //                     "orderStatus":3,
            //                     "orderType":1,
            //                     "price":"1198.25",
            //                     "quote":"USDT",
            //                     "rejectCode":null,
            //                     "rejectReason":null,
            //                     "side":1,
            //                     "stopPrice":"0",
            //                     "symbol":"ETHUSDT",
            //                     "taker":true,
            //                     "tradeID":"E04WTIgfmULU",
            //                     "transactTime":"2021-01-11T02:47:51.389Z",
            //                     "updateTime":null,
            //                     "userID":"1362494"
            //                 }
            //             ],
            //             "pageNum":1,
            //             "pageSize":10,
            //             "total":1
            //         },
            //         "message":"success",
            //         "ts":1610333278042
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const trades = this.safeValue (data, 'list', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                // 'network': undefined, // 'ERC20
            };
            const response = await this.privateGetAccountDepositAddress (this.extend (request, params));
            //
            //     {
            //         "code":1,
            //         "data":{
            //             "address":"0x080c5c667381404cca9be0be9a04b2e47691ff86",
            //             "tag":null,
            //             "currency":"USDT",
            //             "network":"ERC20"
            //         },
            //         "message":"success",
            //         "ts":1610270465132
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseDepositAddress (data, currency);
        }
    
        parseDepositAddress (depositAddress, currency = undefined) {
            //
            //     {
            //         "address":"0x080c5c667381404cca9be0be9a04b2e47691ff86",
            //         "tag":null,
            //         "currency":"USDT",
            //         "network":"ERC20"
            //     }
            //
            const address = this.safeString (depositAddress, 'address');
            const tag = this.safeString (depositAddress, 'tag');
            const currencyId = this.safeString (depositAddress, 'currency');
            const code = this.safeCurrencyCode (currencyId);
            return {
                'info': depositAddress,
                'code': code,
                'address': address,
                'tag': tag,
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'v1') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                url = '/' + this.version + url;
                if (api === 'public') {
                    if (Object.keys (query).length) {
                        url += '?' + this.urlencode (query);
                    }
                } else if (api === 'private') {
                    this.checkRequiredCredentials ();
                    const nonce = this.nonce ().toString ();
                    headers = {
                        'X-ACCESS-KEY': this.apiKey,
                        'X-ACCESS-NONCE': nonce,
                    };
                    let auth = nonce + ':' + method;
                    if (method === 'GET') {
                        if (Object.keys (query).length) {
                            url += '?' + this.urlencode (query);
                        }
                        auth += url;
                    } else {
                        headers['Content-Type'] = 'application/json';
                        body = this.json (query);
                        auth += url + body;
                    }
                    const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                    headers['X-ACCESS-SIGN'] = signature;
                }
            }
            url = this.implodeHostname (this.urls['api'][api]) + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     {"code":40102,"message":"Unauthorized(invalid key)"}
            //
            const errorCode = this.safeString (response, 'code');
            if ((errorCode !== undefined) && (errorCode !== '1')) {
                const feedback = this.id + ' ' + this.json (response);
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], body, feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],4:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ArgumentsRequired, ExchangeError, BadSymbol, InvalidOrder, PermissionDenied, InvalidAddress, AuthenticationError, InvalidNonce, BadRequest, InsufficientFunds, OrderNotFound } = require ('./base/errors');
    const { TRUNCATE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class aofex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'aofex',
                'name': 'AOFEX',
                'countries': [ 'GB' ],
                'rateLimit': 1000,
                'hostname': 'openapi.aofex.com',
                'has': {
                    'fetchMarkets': true,
                    'fetchCurrencies': false,
                    'fetchOrderBook': true,
                    'fetchTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchOHLCV': true,
                    'fetchBalance': true,
                    'createOrder': true,
                    'cancelOrder': true,
                    'cancelAllOrders': true,
                    'fetchOpenOrders': true,
                    'fetchClosedOrders': true,
                    'fetchClosedOrder': true,
                    'fetchOrderTrades': true,
                    'fetchTradingFee': true,
                },
                'timeframes': {
                    '1m': '1min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '1hour',
                    '6h': '6hour',
                    '12h': '12hour',
                    '1d': '1day',
                    '1w': '1week',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/77670271-056d1080-6f97-11ea-9ac2-4268e9ed0c1f.jpg',
                    'api': {
                        'public': 'https://{hostname}/openApi',
                        'private': 'https://{hostname}/openApi',
                    },
                    'www': 'https://aofex.com',
                    'doc': 'https://aofex.zendesk.com/hc/en-us/sections/360005576574-API',
                    'fees': 'https://aofex.zendesk.com/hc/en-us/articles/360025814934-Fees-on-AOFEX',
                    'referral': 'https://aofex.com/#/register?key=9763840',
                },
                'api': {
                    'public': {
                        'get': [
                            'market/symbols',
                            'market/trade',
                            'market/depth',
                            'market/kline',
                            'market/precision',
                            'market/24kline',
                            'market/gears_depth',
                            'market/detail',
                        ],
                    },
                    'private': {
                        'get': [
                            'entrust/currentList',
                            'entrust/historyList',
                            'entrust/rate',
                            'wallet/list',
                            'entrust/detail',
                        ],
                        'post': [
                            'entrust/add',
                            'entrust/cancel',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': 0.0019,
                        'taker': 0.002,
                    },
                },
                'exceptions': {
                    'exact': {
                        '20001': ExchangeError, // request failure
                        '20401': PermissionDenied, // no permission
                        '20500': ExchangeError, // system error
                        '20501': BadSymbol, // base symbol error
                        '20502': ExchangeError, // base currency error
                        '20503': ExchangeError, // base date error
                        '20504': InsufficientFunds, // account frozen balance insufficient error
                        '20505': BadRequest, // bad argument
                        '20506': AuthenticationError, // api signature not valid
                        '20507': ExchangeError, // gateway internal error
                        '20508': InvalidAddress, // ad ethereum addresss
                        '20509': InsufficientFunds, // order accountbalance error
                        '20510': InvalidOrder, // order limitorder price error
                        '20511': InvalidOrder, // order limitorder amount error
                        '20512': InvalidOrder, // order orderprice precision error
                        '20513': InvalidOrder, // order orderamount precision error
                        '20514': InvalidOrder, // order marketorder amount error
                        '20515': InvalidOrder, // order queryorder invalid
                        '20516': InvalidOrder, // order orderstate error
                        '20517': InvalidOrder, // order datelimit error
                        '50518': InvalidOrder, // order update error
                        '20519': InvalidNonce, // the nonce has been used
                        '20520': InvalidNonce, // nonce expires, please verify server time
                        '20521': BadRequest, // incomplete header parameters
                        '20522': ExchangeError, // not getting the current user
                        '20523': AuthenticationError, // please authenticate
                        '20524': PermissionDenied, // btc account lockout
                        '20525': AuthenticationError, // get API Key error
                        '20526': PermissionDenied, // no query permission
                        '20527': PermissionDenied, // no deal permission
                        '20528': PermissionDenied, // no withdrawal permission
                        '20529': AuthenticationError, // API Key expired
                        '20530': PermissionDenied, // no permission
                    },
                    'broad': {
                    },
                },
                'options': {
                    'fetchBalance': {
                        'show_all': '0', // '1' to show zero balances
                    },
                },
                'commonCurrencies': {
                    'CPC': 'Consensus Planet Coin',
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            let markets = await this.publicGetMarketSymbols (params);
            //
            //     {
            //         errno: 0,
            //         errmsg: 'success',
            //         result: [
            //             {
            //                 id: 2,
            //                 symbol: 'BTC-USDT',
            //                 base_currency: 'BTC',
            //                 quote_currency: 'USDT',
            //                 min_size: 0.00008,
            //                 max_size: 1300,
            //                 min_price: 1000,
            //                 max_price: 110000,
            //                 maker_fee: 1,
            //                 taker_fee: 1,
            //                 isHot: null,
            //                 isNew: null,
            //                 crown: null
            //             },
            //         ]
            //     }
            //
            let precisions = await this.publicGetMarketPrecision ();
            //
            //     {
            //         errno: 0,
            //         errmsg: 'success',
            //         result: {
            //             'MANA-USDT': {
            //                 amount: '2',
            //                 minQuantity: '32',
            //                 maxQuantity: '46000000',
            //                 price: '4',
            //                 minPrice: '0.003',
            //                 maxPrice: '0.35'
            //             },
            //         }
            //     }
            //
            precisions = this.safeValue (precisions, 'result', {});
            markets = this.safeValue (markets, 'result', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'symbol');
                const baseId = this.safeString (market, 'base_currency');
                const quoteId = this.safeString (market, 'quote_currency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const numericId = this.safeInteger (market, 'id');
                const precision = this.safeValue (precisions, id, {});
                const makerFeeString = this.safeString (market, 'maker_fee');
                const takerFeeString = this.safeString (market, 'taker_fee');
                const makerFee = this.parseNumber (Precise.stringDiv (makerFeeString, '1000'));
                const takerFee = this.parseNumber (Precise.stringDiv (takerFeeString, '1000'));
                result.push ({
                    'id': id,
                    'numericId': numericId,
                    'symbol': symbol,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'base': base,
                    'quote': quote,
                    'active': undefined,
                    'maker': makerFee,
                    'taker': takerFee,
                    'precision': {
                        'amount': this.safeInteger (precision, 'amount'),
                        'price': this.safeInteger (precision, 'price'),
                    },
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'min_size'),
                            'max': this.safeNumber (market, 'max_size'),
                        },
                        'price': {
                            'min': this.safeNumber (market, 'min_price'),
                            'max': this.safeNumber (market, 'max_price'),
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'info': market,
                });
            }
            return result;
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         id:  1584950100,
            //         amount: "329.196",
            //         count:  81,
            //         open: "0.021155",
            //         close: "0.021158",
            //         low: "0.021144",
            //         high: "0.021161",
            //         vol: "6.963557767"
            //     }
            //
            return [
                this.safeTimestamp (ohlcv, 'id'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'amount'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (limit === undefined) {
                limit = 150; // default 150, max 2000
            }
            const request = {
                'symbol': market['id'],
                'period': this.timeframes[timeframe],
                'size': limit, // default 150, max 2000
            };
            const response = await this.publicGetMarketKline (this.extend (request, params));
            //
            //     {
            //         errno: 0,
            //         errmsg: "success",
            //         result: {
            //             ts:  1584950139003,
            //             symbol: "ETH-BTC",
            //             period: "1min",
            //             data: [
            //                 {
            //                     id:  1584950100,
            //                     amount: "329.196",
            //                     count:  81,
            //                     open: "0.021155",
            //                     close: "0.021158",
            //                     low: "0.021144",
            //                     high: "0.021161",
            //                     vol: "6.963557767"
            //                 },
            //                 {
            //                     id:  1584950040,
            //                     amount: "513.265",
            //                     count:  151,
            //                     open: "0.021165",
            //                     close: "0.021155",
            //                     low: "0.021151",
            //                     high: "0.02118",
            //                     vol: "10.862806573"
            //                 },
            //             ]
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseOHLCVs (data, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const options = this.safeValue (this.options, 'fetchBalance', {});
            const showAll = this.safeValue (options, 'show_all', '0');
            const request = {
                // 'currency': 'BTC',
                'show_all': showAll, // required to show zero balances
            };
            const response = await this.privateGetWalletList (this.extend (request, params));
            //
            //     {
            //         "errno": 0,
            //         "errmsg": "success",
            //         "result": [
            //             { "available": "0", "frozen": "0", "currency": "BTC" }
            //         ]
            //     }
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const balances = this.safeValue (response, 'result', []);
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'frozen');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchTradingFee (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.privateGetEntrustRate (this.extend (request, params));
            //
            //     {
            //         "errno":0,
            //         "errmsg":"success",
            //         "result": {
            //             "toFee":"0.002","fromFee":"0.002"
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return {
                'info': response,
                'symbol': symbol,
                'maker': this.safeNumber (result, 'fromFee'),
                'taker': this.safeNumber (result, 'toFee'),
            };
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            const response = await this.publicGetMarketDepth (this.extend (request, params));
            //
            //     {
            //         errno: 0,
            //         errmsg: "success",
            //         result: {
            //             buyType: 1,
            //             sellType: 1,
            //             ts: 1584950701050,
            //             symbol: "ETH-BTC",
            //             asks: [
            //                 ["0.021227", "0.182"],
            //                 ["0.021249", "0.035"],
            //                 ["0.021253", "0.058"],
            //             ],
            //             bids: [
            //                 ["0.021207", "0.039"],
            //                 ["0.021203", "0.051"],
            //                 ["0.02117", "2.326"],
            //             ]
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const timestamp = this.safeInteger (result, 'ts');
            return this.parseOrderBook (result, symbol, timestamp);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker
            //
            //     {
            //         id: 1584890087,
            //         amount: '150032.919',
            //         count: 134538,
            //         open: '0.021394',
            //         close: '0.021177',
            //         low: '0.021053',
            //         high: '0.021595',
            //         vol: '3201.72451442'
            //     }
            //
            const timestamp = this.safeTimestamp (ticker, 'id');
            const open = this.safeNumber (ticker, 'open');
            const last = this.safeNumber (ticker, 'close');
            const baseVolume = this.safeNumber (ticker, 'amount');
            const quoteVolume = this.safeNumber (ticker, 'vol');
            return this.safeTicker ({
                'symbol': undefined,
                'timestamp': timestamp,
                'datetime': undefined,
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbols !== undefined) {
                const ids = this.marketIds (symbols);
                request['symbol'] = ids.join (',');
            }
            const response = await this.publicGetMarket24kline (this.extend (request, params));
            //
            //     {
            //         errno: 0,
            //         errmsg: "success",
            //         result: [
            //             {
            //                 symbol: "HB-AQ",
            //                 data: {
            //                     id:  1584893403,
            //                     amount: "4753751.243400354852648809",
            //                     count:  4724,
            //                     open: "6.3497",
            //                     close: "6.3318",
            //                     low: "6.011",
            //                     high: "6.5",
            //                     vol: "29538384.7873528796542891343493"
            //                 }
            //             },
            //         ]
            //     }
            //
            const tickers = this.safeValue (response, 'result', []);
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const marketId = this.safeString (tickers[i], 'symbol');
                const market = this.safeMarket (marketId, undefined, '-');
                const symbol = market['symbol'];
                const data = this.safeValue (tickers[i], 'data', {});
                result[symbol] = this.parseTicker (data, market);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetMarketDetail (this.extend (request, params));
            //
            //     {
            //         errno: 0,
            //         errmsg: 'success',
            //         result: {
            //             id: 1584890087,
            //             amount: '150032.919',
            //             count: 134538,
            //             open: '0.021394',
            //             close: '0.021177',
            //             low: '0.021053',
            //             high: '0.021595',
            //             vol: '3201.72451442'
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseTicker (result, market);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         id: 1584948803298490,
            //         amount: "2.737",
            //         price: "0.021209",
            //         direction: "sell",
            //         ts: 1584948803
            //     }
            //
            // fetchOrder trades
            //
            //     {
            //         "id":null,
            //         "ctime":"2020-03-23 20:07:17",
            //         "price":"123.9",
            //         "number":"0.010688626311541565",
            //         "total_price":"1.324320799999999903",
            //         "fee":"0.000021377252623083"
            //     }
            //
            const id = this.safeString (trade, 'id');
            const ctime = this.parse8601 (this.safeString (trade, 'ctime'));
            const timestamp = this.safeTimestamp (trade, 'ts', ctime) - 28800000; // 8 hours, adjust to UTC;
            let symbol = undefined;
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const side = this.safeString (trade, 'direction');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString2 (trade, 'amount', 'number');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            let cost = this.safeNumber (trade, 'total_price');
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            const feeCost = this.safeNumber (trade, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                let feeCurrencyCode = undefined;
                if (market !== undefined) {
                    if (side === 'buy') {
                        feeCurrencyCode = market['base'];
                    } else if (side === 'sell') {
                        feeCurrencyCode = market['quote'];
                    }
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': undefined,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetMarketTrade (this.extend (request, params));
            //
            //     {
            //         errno: 0,
            //         errmsg: "success",
            //         result: {
            //             symbol: "ETH-BTC",
            //             ts: 1584948805439,
            //             data: [
            //                 {
            //                     id: 1584948803300883,
            //                     amount: "0.583",
            //                     price: "0.021209",
            //                     direction: "buy",
            //                     ts: 1584948803
            //                 },
            //                 {
            //                     id: 1584948803298490,
            //                     amount: "2.737",
            //                     price: "0.021209",
            //                     direction: "sell",
            //                     ts: 1584948803
            //                 },
            //             ]
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '1': 'open',
                '2': 'open', // partially filled
                '3': 'closed',
                '4': 'canceled', // canceling
                '5': 'canceled', // partially canceled
                '6': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     { order_sn: 'BM7442641584965237751ZMAKJ5' }
            //
            // fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "order_sn": "BL74426415849672087836G48N1",
            //         "symbol": "ETH-USDT",
            //         "ctime": "2020-03-23 20:40:08",
            //         "type": 2,
            //         "side": "buy",
            //         "price": "90", // undefined for market orders
            //         "number": "0.1",
            //         "total_price": "9.0", // 0 for market orders
            //         "deal_number": null,
            //         "deal_price": null,
            //         "status": 1,
            //     }
            //
            // fetchOrder
            //
            //     {
            //         order_sn: 'BM7442641584965237751ZMAKJ5',
            //         symbol: 'ETH-USDT',
            //         ctime: '2020-03-23 20:07:17',
            //         type: 1,
            //         side: 'buy',
            //         price: '0',
            //         number: '10',
            //         total_price: '0',
            //         deal_number: '0.080718626311541565',
            //         deal_price: '123.890000000000000000',
            //         status: 3,
            //         // the trades field is injected by fetchOrder
            //         trades: [
            //             {
            //                 id: null,
            //                 ctime: '2020-03-23 20:07:17',
            //                 price: '123.9',
            //                 number: '0.010688626311541565',
            //                 total_price: '1.324320799999999903',
            //                 fee: '0.000021377252623083'
            //             }
            //         ]
            //     }
            //
            const id = this.safeString (order, 'order_sn');
            const orderStatus = this.safeString (order, 'status');
            const status = this.parseOrderStatus (orderStatus);
            const marketId = this.safeString (order, 'symbol');
            market = this.safeMarket (marketId, market, '-');
            let timestamp = this.parse8601 (this.safeString (order, 'ctime'));
            if (timestamp !== undefined) {
                timestamp -= 28800000; // 8 hours, adjust to UTC
            }
            const orderType = this.safeString (order, 'type');
            const type = (orderType === '2') ? 'limit' : 'market';
            const side = this.safeString (order, 'side');
            // const amount = this.safeNumber (order, 'number');
            // const price = this.safeNumber (order, 'price');
            let cost = undefined;
            let price = undefined;
            let amount = undefined;
            let average = undefined;
            const number = this.safeNumber (order, 'number');
            const totalPrice = this.safeNumber (order, 'total_price');
            if (type === 'limit') {
                amount = number;
                price = this.safeNumber (order, 'price');
            } else {
                average = this.safeNumber (order, 'deal_price');
                if (side === 'buy') {
                    amount = this.safeNumber (order, 'deal_number');
                } else {
                    amount = number;
                }
            }
            // all orders except new orders and canceled orders
            const rawTrades = this.safeValue (order, 'trades', []);
            for (let i = 0; i < rawTrades.length; i++) {
                rawTrades[i]['direction'] = side;
            }
            const trades = this.parseTrades (rawTrades, market, undefined, undefined, {
                'symbol': market['symbol'],
                'order': id,
                'type': type,
            });
            if (type === 'limit') {
                cost = totalPrice;
            } else if (side === 'buy') {
                cost = number;
            }
            let filled = undefined;
            if ((type === 'limit') && (orderStatus === '3')) {
                filled = amount;
            }
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': market['symbol'],
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'average': average,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'trades': trades,
                'fee': undefined,
            });
        }
    
        async fetchClosedOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_sn': id,
            };
            const response = await this.privateGetEntrustDetail (this.extend (request, params));
            //
            //     {
            //         "errno": 0,
            //         "errmsg": "success",
            //         "result": {
            //             "trades": [
            //                 {
            //                     "id":null,
            //                     "ctime":"2020-03-23 20:07:17",
            //                     "price":"123.9",
            //                     "number":"0.010688626311541565",
            //                     "total_price":"1.324320799999999903",
            //                     "fee":"0.000021377252623083"
            //                 },
            //             ],
            //             "entrust":{
            //                 "order_sn":"BM7442641584965237751ZMAKJ5",
            //                 "symbol":"ETH-USDT",
            //                 "ctime":"2020-03-23 20:07:17",
            //                 "type":1,
            //                 "side":"buy",
            //                 "price":"0",
            //                 "number":"10",
            //                 "total_price":"0",
            //                 "deal_number":"0.080718626311541565",
            //                 "deal_price":"123.890000000000000000",
            //                 "status":3
            //             }
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const trades = this.safeValue (result, 'trades', []);
            const order = this.safeValue (result, 'entrust', {});
            order['trades'] = trades;
            return this.parseOrder (order);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const response = await this.fetchClosedOrder (id, symbol, params);
            return this.safeValue (response, 'trades', []);
        }
    
        async fetchOrdersWithMethod (method, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'from': 'BM7442641584965237751ZMAKJ5', // query start order_sn
                'direct': 'prev', // next
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 20, max 100
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "errno": 0,
            //         "errmsg": "success",
            //         "result": [
            //             {
            //                 "order_sn": "BL74426415849672087836G48N1",
            //                 "symbol": "ETH-USDT",
            //                 "ctime": "2020-03-23 20:40:08",
            //                 "type": 2,
            //                 "side": "buy",
            //                 "price": "90",
            //                 "number": "0.1",
            //                 "total_price": "9.0",
            //                 "deal_number": null,
            //                 "deal_price": null,
            //                 "status": 1,
            //             }
            //         ]
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOrders (result, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersWithMethod ('privateGetEntrustCurrentList', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersWithMethod ('privateGetEntrustHistoryList', symbol, since, limit, params);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderType = side + '-' + type;
            const request = {
                'symbol': market['id'],
                'type': orderType,
            };
            if (type === 'limit') {
                request['amount'] = this.amountToPrecision (symbol, amount);
                request['price'] = this.priceToPrecision (symbol, price);
            } else if (type === 'market') {
                // for market buy it requires the amount of quote currency to spend
                if (side === 'buy') {
                    const createMarketBuyOrderRequiresPrice = this.safeValue (this.options, 'createMarketBuyOrderRequiresPrice', true);
                    let cost = amount;
                    if (createMarketBuyOrderRequiresPrice) {
                        if (price !== undefined) {
                            cost = amount * price;
                        } else {
                            throw new InvalidOrder (this.id + " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument");
                        }
                    }
                    const precision = market['precision']['price'];
                    request['amount'] = this.decimalToPrecision (cost, TRUNCATE, precision, this.precisionMode);
                } else {
                    request['amount'] = this.amountToPrecision (symbol, amount);
                }
            }
            const response = await this.privatePostEntrustAdd (this.extend (request, params));
            //
            //     {
            //         errno: 0,
            //         errmsg: 'success',
            //         result: { order_sn: 'BM7442641584965237751ZMAKJ5' }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const order = this.parseOrder (result, market);
            const timestamp = this.milliseconds ();
            return this.extend (order, {
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'amount': amount,
                'price': price,
                'type': type,
                'side': side,
            });
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_ids': id,
            };
            const response = await this.privatePostEntrustCancel (this.extend (request, params));
            //
            //     {
            //         "errno": 0,
            //         "errmsg": "success",
            //         "result": {
            //             "success": [ "avl12121", "bl3123123" ],
            //             "failed": [ "sd24564", "sdf6564564" ]
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const success = this.safeValue (result, 'success', []);
            if (!this.inArray (id, success)) {
                throw new OrderNotFound (this.id + ' order id ' + id + ' not found in successfully canceled orders: ' + this.json (response));
            }
            const timestamp = undefined;
            return {
                'info': response,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': 'canceled',
                'symbol': symbol,
                'type': undefined,
                'side': undefined,
                'price': undefined,
                'cost': undefined,
                'average': undefined,
                'amount': undefined,
                'filled': undefined,
                'remaining': undefined,
                'trades': undefined,
                'fee': undefined,
                'clientOrderId': undefined,
            };
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelAllOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.privatePostEntrustCancel (this.extend (request, params));
            //
            //     {
            //         "errno": 0,
            //         "errmsg": "success",
            //         "result": {
            //             "success": [ "avl12121", "bl3123123" ],
            //             "failed": [ "sd24564", "sdf6564564" ]
            //         }
            //     }
            //
            return response;
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.implodeHostname (this.urls['api'][api]) + '/' + path;
            let keys = Object.keys (params);
            const keysLength = keys.length;
            if (api === 'public') {
                if (keysLength > 0) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                const nonce = this.nonce ().toString ();
                const uuid = this.uuid ();
                const randomString = uuid.slice (0, 5);
                const nonceString = nonce + '_' + randomString;
                const auth = {};
                auth[this.apiKey] = this.apiKey;
                auth[this.secret] = this.secret;
                auth[nonceString] = nonceString;
                for (let i = 0; i < keysLength; i++) {
                    const key = keys[i];
                    auth[key] = key + '=' + params[key];
                }
                const keysorted = this.keysort (auth);
                let stringToSign = '';
                keys = Object.keys (keysorted);
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    stringToSign += keysorted[key];
                }
                const signature = this.hash (this.encode (stringToSign), 'sha1');
                headers = {
                    'Nonce': nonceString,
                    'Token': this.apiKey,
                    'Signature': signature,
                };
                if (method === 'POST') {
                    headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    if (keysLength > 0) {
                        body = this.urlencode (params);
                    }
                } else {
                    if (keysLength > 0) {
                        url += '?' + this.urlencode (params);
                    }
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            //
            //     {"errno":20501,"errmsg":"base symbol error"}
            //
            const error = this.safeString (response, 'errno');
            if ((error !== undefined) && (error !== '0')) {
                const message = this.safeString (response, 'errmsg');
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], error, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],5:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ArgumentsRequired, AuthenticationError, ExchangeError, InsufficientFunds, InvalidOrder, BadSymbol, PermissionDenied, BadRequest } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class ascendex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'ascendex',
                'name': 'AscendEX',
                'countries': [ 'SG' ], // Singapore
                'rateLimit': 500,
                'certified': true,
                // new metainfo interface
                'has': {
                    'CORS': false,
                    'fetchMarkets': true,
                    'fetchCurrencies': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchOHLCV': true,
                    'fetchTrades': true,
                    'fetchAccounts': true,
                    'fetchBalance': true,
                    'createOrder': true,
                    'cancelOrder': true,
                    'cancelAllOrders': true,
                    'fetchDepositAddress': true,
                    'fetchTransactions': true,
                    'fetchDeposits': true,
                    'fetchWithdrawals': true,
                    'fetchOrder': true,
                    'fetchOrders': true,
                    'fetchOpenOrders': true,
                    'fetchClosedOrders': true,
                },
                'timeframes': {
                    '1m': '1',
                    '5m': '5',
                    '15m': '15',
                    '30m': '30',
                    '1h': '60',
                    '2h': '120',
                    '4h': '240',
                    '6h': '360',
                    '12h': '720',
                    '1d': '1d',
                    '1w': '1w',
                    '1M': '1m',
                },
                'version': 'v1',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/112027508-47984600-8b48-11eb-9e17-d26459cc36c6.jpg',
                    'api': 'https://ascendex.com',
                    'test': 'https://bitmax-test.io',
                    'www': 'https://ascendex.com',
                    'doc': [
                        'https://bitmax-exchange.github.io/bitmax-pro-api/#bitmax-pro-api-documentation',
                    ],
                    'fees': 'https://ascendex.com/en/feerate/transactionfee-traderate',
                    'referral': {
                        'url': 'https://ascendex.com/en-us/register?inviteCode=EL6BXBQM',
                        'discount': 0.25,
                    },
                },
                'api': {
                    'public': {
                        'get': [
                            'assets',
                            'products',
                            'ticker',
                            'barhist/info',
                            'barhist',
                            'depth',
                            'trades',
                            'cash/assets', // not documented
                            'cash/products', // not documented
                            'margin/assets', // not documented
                            'margin/products', // not documented
                            'futures/collateral',
                            'futures/contracts',
                            'futures/ref-px',
                            'futures/market-data',
                            'futures/funding-rates',
                        ],
                    },
                    'accountCategory': {
                        'get': [
                            'balance',
                            'order/open',
                            'order/status',
                            'order/hist/current',
                            'risk',
                        ],
                        'post': [
                            'order',
                            'order/batch',
                        ],
                        'delete': [
                            'order',
                            'order/all',
                            'order/batch',
                        ],
                    },
                    'accountGroup': {
                        'get': [
                            'cash/balance',
                            'margin/balance',
                            'margin/risk',
                            'transfer',
                            'futures/collateral-balance',
                            'futures/position',
                            'futures/risk',
                            'futures/funding-payments',
                            'order/hist',
                        ],
                        'post': [
                            'futures/transfer/deposit',
                            'futures/transfer/withdraw',
                        ],
                    },
                    'private': {
                        'get': [
                            'info',
                            'wallet/transactions',
                            'wallet/deposit/address', // not documented
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'tierBased': true,
                        'percentage': true,
                        'taker': this.parseNumber ('0.002'),
                        'maker': this.parseNumber ('0.002'),
                    },
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    'account-category': 'cash', // 'cash'/'margin'/'futures'
                    'account-group': undefined,
                    'fetchClosedOrders': {
                        'method': 'accountGroupGetOrderHist', // 'accountGroupGetAccountCategoryOrderHistCurrent'
                    },
                },
                'exceptions': {
                    'exact': {
                        // not documented
                        '1900': BadRequest, // {"code":1900,"message":"Invalid Http Request Input"}
                        '2100': AuthenticationError, // {"code":2100,"message":"ApiKeyFailure"}
                        '5002': BadSymbol, // {"code":5002,"message":"Invalid Symbol"}
                        '6001': BadSymbol, // {"code":6001,"message":"Trading is disabled on symbol."}
                        '6010': InsufficientFunds, // {'code': 6010, 'message': 'Not enough balance.'}
                        '60060': InvalidOrder, // { 'code': 60060, 'message': 'The order is already filled or canceled.' }
                        '600503': InvalidOrder, // {"code":600503,"message":"Notional is too small."}
                        // documented
                        '100001': BadRequest, // INVALID_HTTP_INPUT Http request is invalid
                        '100002': BadRequest, // DATA_NOT_AVAILABLE Some required data is missing
                        '100003': BadRequest, // KEY_CONFLICT The same key exists already
                        '100004': BadRequest, // INVALID_REQUEST_DATA The HTTP request contains invalid field or argument
                        '100005': BadRequest, // INVALID_WS_REQUEST_DATA Websocket request contains invalid field or argument
                        '100006': BadRequest, // INVALID_ARGUMENT The arugment is invalid
                        '100007': BadRequest, // ENCRYPTION_ERROR Something wrong with data encryption
                        '100008': BadSymbol, // SYMBOL_ERROR Symbol does not exist or not valid for the request
                        '100009': AuthenticationError, // AUTHORIZATION_NEEDED Authorization is require for the API access or request
                        '100010': BadRequest, // INVALID_OPERATION The action is invalid or not allowed for the account
                        '100011': BadRequest, // INVALID_TIMESTAMP Not a valid timestamp
                        '100012': BadRequest, // INVALID_STR_FORMAT String format does not
                        '100013': BadRequest, // INVALID_NUM_FORMAT Invalid number input
                        '100101': ExchangeError, // UNKNOWN_ERROR Some unknown error
                        '150001': BadRequest, // INVALID_JSON_FORMAT Require a valid json object
                        '200001': AuthenticationError, // AUTHENTICATION_FAILED Authorization failed
                        '200002': ExchangeError, // TOO_MANY_ATTEMPTS Tried and failed too many times
                        '200003': ExchangeError, // ACCOUNT_NOT_FOUND Account not exist
                        '200004': ExchangeError, // ACCOUNT_NOT_SETUP Account not setup properly
                        '200005': ExchangeError, // ACCOUNT_ALREADY_EXIST Account already exist
                        '200006': ExchangeError, // ACCOUNT_ERROR Some error related with error
                        '200007': ExchangeError, // CODE_NOT_FOUND
                        '200008': ExchangeError, // CODE_EXPIRED Code expired
                        '200009': ExchangeError, // CODE_MISMATCH Code does not match
                        '200010': AuthenticationError, // PASSWORD_ERROR Wrong assword
                        '200011': ExchangeError, // CODE_GEN_FAILED Do not generate required code promptly
                        '200012': ExchangeError, // FAKE_COKE_VERIFY
                        '200013': ExchangeError, // SECURITY_ALERT Provide security alert message
                        '200014': PermissionDenied, // RESTRICTED_ACCOUNT Account is restricted for certain activity, such as trading, or withdraw.
                        '200015': PermissionDenied, // PERMISSION_DENIED No enough permission for the operation
                        '300001': InvalidOrder, // INVALID_PRICE Order price is invalid
                        '300002': InvalidOrder, // INVALID_QTY Order size is invalid
                        '300003': InvalidOrder, // INVALID_SIDE Order side is invalid
                        '300004': InvalidOrder, // INVALID_NOTIONAL Notional is too small or too large
                        '300005': InvalidOrder, // INVALID_TYPE Order typs is invalid
                        '300006': InvalidOrder, // INVALID_ORDER_ID Order id is invalid
                        '300007': InvalidOrder, // INVALID_TIME_IN_FORCE Time In Force in order request is invalid
                        '300008': InvalidOrder, // INVALID_ORDER_PARAMETER Some order parameter is invalid
                        '300009': InvalidOrder, // TRADING_VIOLATION Trading violation on account or asset
                        '300011': InsufficientFunds, // INVALID_BALANCE No enough account or asset balance for the trading
                        '300012': BadSymbol, // INVALID_PRODUCT Not a valid product supported by exchange
                        '300013': InvalidOrder, // INVALID_BATCH_ORDER Some or all orders are invalid in batch order request
                        '300020': InvalidOrder, // TRADING_RESTRICTED There is some trading restriction on account or asset
                        '300021': InvalidOrder, // TRADING_DISABLED Trading is disabled on account or asset
                        '300031': InvalidOrder, // NO_MARKET_PRICE No market price for market type order trading
                        '310001': InsufficientFunds, // INVALID_MARGIN_BALANCE No enough margin balance
                        '310002': InvalidOrder, // INVALID_MARGIN_ACCOUNT Not a valid account for margin trading
                        '310003': InvalidOrder, // MARGIN_TOO_RISKY Leverage is too high
                        '310004': BadSymbol, // INVALID_MARGIN_ASSET This asset does not support margin trading
                        '310005': InvalidOrder, // INVALID_REFERENCE_PRICE There is no valid reference price
                        '510001': ExchangeError, // SERVER_ERROR Something wrong with server.
                        '900001': ExchangeError, // HUMAN_CHALLENGE Human change do not pass
                    },
                    'broad': {},
                },
                'commonCurrencies': {
                    'BOND': 'BONDED',
                    'BTCBEAR': 'BEAR',
                    'BTCBULL': 'BULL',
                    'BYN': 'Beyond Finance',
                },
            });
        }
    
        getAccount (params = {}) {
            // get current or provided bitmax sub-account
            const account = this.safeValue (params, 'account', this.options['account']);
            return account.toLowerCase ().capitalize ();
        }
    
        async fetchCurrencies (params = {}) {
            const assets = await this.publicGetAssets (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "assetCode" : "LTCBULL",
            //                 "assetName" : "3X Long LTC Token",
            //                 "precisionScale" : 9,
            //                 "nativeScale" : 4,
            //                 "withdrawalFee" : "0.2",
            //                 "minWithdrawalAmt" : "1.0",
            //                 "status" : "Normal"
            //             },
            //         ]
            //     }
            //
            const margin = await this.publicGetMarginAssets (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "assetCode":"BTT",
            //                 "borrowAssetCode":"BTT-B",
            //                 "interestAssetCode":"BTT-I",
            //                 "nativeScale":0,
            //                 "numConfirmations":1,
            //                 "withdrawFee":"100.0",
            //                 "minWithdrawalAmt":"1000.0",
            //                 "statusCode":"Normal",
            //                 "statusMessage":"",
            //                 "interestRate":"0.001"
            //             }
            //         ]
            //     }
            //
            const cash = await this.publicGetCashAssets (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "assetCode":"LTCBULL",
            //                 "nativeScale":4,
            //                 "numConfirmations":20,
            //                 "withdrawFee":"0.2",
            //                 "minWithdrawalAmt":"1.0",
            //                 "statusCode":"Normal",
            //                 "statusMessage":""
            //             }
            //         ]
            //     }
            //
            const assetsData = this.safeValue (assets, 'data', []);
            const marginData = this.safeValue (margin, 'data', []);
            const cashData = this.safeValue (cash, 'data', []);
            const assetsById = this.indexBy (assetsData, 'assetCode');
            const marginById = this.indexBy (marginData, 'assetCode');
            const cashById = this.indexBy (cashData, 'assetCode');
            const dataById = this.deepExtend (assetsById, marginById, cashById);
            const ids = Object.keys (dataById);
            const result = {};
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const currency = dataById[id];
                const code = this.safeCurrencyCode (id);
                const precision = this.safeString2 (currency, 'precisionScale', 'nativeScale');
                const minAmount = this.parsePrecision (precision);
                // why would the exchange API have different names for the same field
                const fee = this.safeNumber2 (currency, 'withdrawFee', 'withdrawalFee');
                const status = this.safeString2 (currency, 'status', 'statusCode');
                const active = (status === 'Normal');
                const margin = ('borrowAssetCode' in currency);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'type': undefined,
                    'margin': margin,
                    'name': this.safeString (currency, 'assetName'),
                    'active': active,
                    'fee': fee,
                    'precision': parseInt (precision),
                    'limits': {
                        'amount': {
                            'min': this.parseNumber (minAmount),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'minWithdrawalAmt'),
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const products = await this.publicGetProducts (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"LBA/BTC",
            //                 "baseAsset":"LBA",
            //                 "quoteAsset":"BTC",
            //                 "status":"Normal",
            //                 "minNotional":"0.000625",
            //                 "maxNotional":"6.25",
            //                 "marginTradable":false,
            //                 "commissionType":"Quote",
            //                 "commissionReserveRate":"0.001",
            //                 "tickSize":"0.000000001",
            //                 "lotSize":"1"
            //             },
            //         ]
            //     }
            //
            const cash = await this.publicGetCashProducts (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"QTUM/BTC",
            //                 "domain":"BTC",
            //                 "tradingStartTime":1569506400000,
            //                 "collapseDecimals":"0.0001,0.000001,0.00000001",
            //                 "minQty":"0.000000001",
            //                 "maxQty":"1000000000",
            //                 "minNotional":"0.000625",
            //                 "maxNotional":"12.5",
            //                 "statusCode":"Normal",
            //                 "statusMessage":"",
            //                 "tickSize":"0.00000001",
            //                 "useTick":false,
            //                 "lotSize":"0.1",
            //                 "useLot":false,
            //                 "commissionType":"Quote",
            //                 "commissionReserveRate":"0.001",
            //                 "qtyScale":1,
            //                 "priceScale":8,
            //                 "notionalScale":4
            //             }
            //         ]
            //     }
            //
            const futures = await this.publicGetFuturesContracts (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"BTC-PERP",
            //                 "tradingStartTime":1579701600000,
            //                 "collapseDecimals":"1,0.1,0.01",
            //                 "minQty":"0.000000001",
            //                 "maxQty":"1000000000",
            //                 "minNotional":"5",
            //                 "maxNotional":"1000000",
            //                 "statusCode":"Normal",
            //                 "statusMessage":"",
            //                 "tickSize":"0.25",
            //                 "lotSize":"0.0001",
            //                 "priceScale":2,
            //                 "qtyScale":4,
            //                 "notionalScale":2
            //             }
            //         ]
            //     }
            //
            const productsData = this.safeValue (products, 'data', []);
            const productsById = this.indexBy (productsData, 'symbol');
            const cashData = this.safeValue (cash, 'data', []);
            const futuresData = this.safeValue (futures, 'data', []);
            const cashAndFuturesData = this.arrayConcat (cashData, futuresData);
            const cashAndFuturesById = this.indexBy (cashAndFuturesData, 'symbol');
            const dataById = this.deepExtend (productsById, cashAndFuturesById);
            const ids = Object.keys (dataById);
            const result = [];
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const market = dataById[id];
                const baseId = this.safeString (market, 'baseAsset');
                const quoteId = this.safeString (market, 'quoteAsset');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const precision = {
                    'amount': this.safeNumber (market, 'lotSize'),
                    'price': this.safeNumber (market, 'tickSize'),
                };
                const status = this.safeString (market, 'status');
                const active = (status === 'Normal');
                const type = ('useLot' in market) ? 'spot' : 'future';
                const spot = (type === 'spot');
                const future = (type === 'future');
                const margin = this.safeValue (market, 'marginTradable', false);
                let symbol = id;
                if (!future) {
                    symbol = base + '/' + quote;
                }
                const fee = this.safeNumber (market, 'commissionReserveRate');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                    'type': type,
                    'spot': spot,
                    'margin': margin,
                    'future': future,
                    'active': active,
                    'precision': precision,
                    'taker': fee,
                    'maker': fee,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'minQty'),
                            'max': this.safeNumber (market, 'maxQty'),
                        },
                        'price': {
                            'min': this.safeNumber (market, 'tickSize'),
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.safeNumber (market, 'minNotional'),
                            'max': this.safeNumber (market, 'maxNotional'),
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchAccounts (params = {}) {
            let accountGroup = this.safeString (this.options, 'account-group');
            let response = undefined;
            if (accountGroup === undefined) {
                response = await this.privateGetInfo (params);
                //
                //     {
                //         "code":0,
                //         "data":{
                //             "email":"igor.kroitor@gmail.com",
                //             "accountGroup":8,
                //             "viewPermission":true,
                //             "tradePermission":true,
                //             "transferPermission":true,
                //             "cashAccount":["cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda"],
                //             "marginAccount":["martXoh1v1N3EMQC5FDtSj5VHso8aI2Z"],
                //             "futuresAccount":["futc9r7UmFJAyBY2rE3beA2JFxav2XFF"],
                //             "userUID":"U6491137460"
                //         }
                //     }
                //
                const data = this.safeValue (response, 'data', {});
                accountGroup = this.safeString (data, 'accountGroup');
                this.options['account-group'] = accountGroup;
            }
            return [
                {
                    'id': accountGroup,
                    'type': undefined,
                    'currency': undefined,
                    'info': response,
                },
            ];
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const defaultAccountCategory = this.safeString (this.options, 'account-category', 'cash');
            const options = this.safeValue (this.options, 'fetchBalance', {});
            let accountCategory = this.safeString (options, 'account-category', defaultAccountCategory);
            accountCategory = this.safeString (params, 'account-category', accountCategory);
            params = this.omit (params, 'account-category');
            const account = this.safeValue (this.accounts, 0, {});
            const accountGroup = this.safeString (account, 'id');
            const request = {
                'account-group': accountGroup,
            };
            let method = 'accountCategoryGetBalance';
            if (accountCategory === 'futures') {
                method = 'accountGroupGetFuturesCollateralBalance';
            } else {
                request['account-category'] = accountCategory;
            }
            const response = await this[method] (this.extend (request, params));
            //
            // cash
            //
            //     {
            //         'code': 0,
            //         'data': [
            //             {
            //                 'asset': 'BCHSV',
            //                 'totalBalance': '64.298000048',
            //                 'availableBalance': '64.298000048',
            //             },
            //         ]
            //     }
            //
            // margin
            //
            //     {
            //         'code': 0,
            //         'data': [
            //             {
            //                 'asset': 'BCHSV',
            //                 'totalBalance': '64.298000048',
            //                 'availableBalance': '64.298000048',
            //                 'borrowed': '0',
            //                 'interest': '0',
            //             },
            //         ]
            //     }
            //
            // futures
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {"asset":"BTC","totalBalance":"0","availableBalance":"0","maxTransferrable":"0","priceInUSDT":"9456.59"},
            //             {"asset":"ETH","totalBalance":"0","availableBalance":"0","maxTransferrable":"0","priceInUSDT":"235.95"},
            //             {"asset":"USDT","totalBalance":"0","availableBalance":"0","maxTransferrable":"0","priceInUSDT":"1"},
            //             {"asset":"USDC","totalBalance":"0","availableBalance":"0","maxTransferrable":"0","priceInUSDT":"1.00035"},
            //             {"asset":"PAX","totalBalance":"0","availableBalance":"0","maxTransferrable":"0","priceInUSDT":"1.00045"},
            //             {"asset":"USDTR","totalBalance":"0","availableBalance":"0","maxTransferrable":"0","priceInUSDT":"1"}
            //         ]
            //     }
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const balances = this.safeValue (response, 'data', []);
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const code = this.safeCurrencyCode (this.safeString (balance, 'asset'));
                const account = this.account ();
                account['free'] = this.safeString (balance, 'availableBalance');
                account['total'] = this.safeString (balance, 'totalBalance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetDepth (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "m":"depth-snapshot",
            //             "symbol":"BTC-PERP",
            //             "data":{
            //                 "ts":1590223998202,
            //                 "seqnum":115444921,
            //                 "asks":[
            //                     ["9207.5","18.2383"],
            //                     ["9207.75","18.8235"],
            //                     ["9208","10.7873"],
            //                 ],
            //                 "bids":[
            //                     ["9207.25","0.4009"],
            //                     ["9207","0.003"],
            //                     ["9206.5","0.003"],
            //                 ]
            //             }
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const orderbook = this.safeValue (data, 'data', {});
            const timestamp = this.safeInteger (orderbook, 'ts');
            const result = this.parseOrderBook (orderbook, symbol, timestamp);
            result['nonce'] = this.safeInteger (orderbook, 'seqnum');
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         "symbol":"QTUM/BTC",
            //         "open":"0.00016537",
            //         "close":"0.00019077",
            //         "high":"0.000192",
            //         "low":"0.00016537",
            //         "volume":"846.6",
            //         "ask":["0.00018698","26.2"],
            //         "bid":["0.00018408","503.7"],
            //         "type":"spot"
            //     }
            //
            const timestamp = undefined;
            const marketId = this.safeString (ticker, 'symbol');
            const type = this.safeString (ticker, 'type');
            const delimiter = (type === 'spot') ? '/' : undefined;
            const symbol = this.safeSymbol (marketId, market, delimiter);
            const close = this.safeNumber (ticker, 'close');
            const bid = this.safeValue (ticker, 'bid', []);
            const ask = this.safeValue (ticker, 'ask', []);
            const open = this.safeNumber (ticker, 'open');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': undefined,
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (bid, 0),
                'bidVolume': this.safeNumber (bid, 1),
                'ask': this.safeNumber (ask, 0),
                'askVolume': this.safeNumber (ask, 1),
                'vwap': undefined,
                'open': open,
                'close': close,
                'last': close,
                'previousClose': undefined, // previous day close
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "symbol":"BTC-PERP", // or "BTC/USDT"
            //             "open":"9073",
            //             "close":"9185.75",
            //             "high":"9185.75",
            //             "low":"9185.75",
            //             "volume":"576.8334",
            //             "ask":["9185.75","15.5863"],
            //             "bid":["9185.5","0.003"],
            //             "type":"derivatives", // or "spot"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseTicker (data, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbols !== undefined) {
                const marketIds = this.marketIds (symbols);
                request['symbol'] = marketIds.join (',');
            }
            const response = await this.publicGetTicker (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "symbol":"QTUM/BTC",
            //                 "open":"0.00016537",
            //                 "close":"0.00019077",
            //                 "high":"0.000192",
            //                 "low":"0.00016537",
            //                 "volume":"846.6",
            //                 "ask":["0.00018698","26.2"],
            //                 "bid":["0.00018408","503.7"],
            //                 "type":"spot"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTickers (data, symbols);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "m":"bar",
            //         "s":"BTC/USDT",
            //         "data":{
            //             "i":"1",
            //             "ts":1590228000000,
            //             "o":"9139.59",
            //             "c":"9131.94",
            //             "h":"9139.99",
            //             "l":"9121.71",
            //             "v":"25.20648"
            //         }
            //     }
            //
            const data = this.safeValue (ohlcv, 'data', {});
            return [
                this.safeInteger (data, 'ts'),
                this.safeNumber (data, 'o'),
                this.safeNumber (data, 'h'),
                this.safeNumber (data, 'l'),
                this.safeNumber (data, 'c'),
                this.safeNumber (data, 'v'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'interval': this.timeframes[timeframe],
            };
            // if since and limit are not specified
            // the exchange will return just 1 last candle by default
            const duration = this.parseTimeframe (timeframe);
            const options = this.safeValue (this.options, 'fetchOHLCV', {});
            const defaultLimit = this.safeInteger (options, 'limit', 500);
            if (since !== undefined) {
                request['from'] = since;
                if (limit === undefined) {
                    limit = defaultLimit;
                } else {
                    limit = Math.min (limit, defaultLimit);
                }
                request['to'] = this.sum (since, limit * duration * 1000, 1);
            } else if (limit !== undefined) {
                request['n'] = limit; // max 500
            }
            const response = await this.publicGetBarhist (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "m":"bar",
            //                 "s":"BTC/USDT",
            //                 "data":{
            //                     "i":"1",
            //                     "ts":1590228000000,
            //                     "o":"9139.59",
            //                     "c":"9131.94",
            //                     "h":"9139.99",
            //                     "l":"9121.71",
            //                     "v":"25.20648"
            //                 }
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     {
            //         "p":"9128.5", // price
            //         "q":"0.0030", // quantity
            //         "ts":1590229002385, // timestamp
            //         "bm":false, // if true, the buyer is the market maker, we only use this field to "define the side" of a public trade
            //         "seqnum":180143985289898554
            //     }
            //
            const timestamp = this.safeInteger (trade, 'ts');
            const priceString = this.safeString2 (trade, 'price', 'p');
            const amountString = this.safeString (trade, 'q');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const buyerIsMaker = this.safeValue (trade, 'bm', false);
            const makerOrTaker = buyerIsMaker ? 'maker' : 'taker';
            const side = buyerIsMaker ? 'buy' : 'sell';
            let symbol = undefined;
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': undefined,
                'order': undefined,
                'type': undefined,
                'takerOrMaker': makerOrTaker,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['n'] = limit; // max 100
            }
            const response = await this.publicGetTrades (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "m":"trades",
            //             "symbol":"BTC-PERP",
            //             "data":[
            //                 {"p":"9128.5","q":"0.0030","ts":1590229002385,"bm":false,"seqnum":180143985289898554},
            //                 {"p":"9129","q":"0.0030","ts":1590229002642,"bm":false,"seqnum":180143985289898587},
            //                 {"p":"9129.5","q":"0.0030","ts":1590229021306,"bm":false,"seqnum":180143985289899043}
            //             ]
            //         }
            //     }
            //
            const records = this.safeValue (response, 'data', []);
            const trades = this.safeValue (records, 'data', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'PendingNew': 'open',
                'New': 'open',
                'PartiallyFilled': 'open',
                'Filled': 'closed',
                'Canceled': 'canceled',
                'Rejected': 'rejected',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "id": "16e607e2b83a8bXHbAwwoqDo55c166fa",
            //         "orderId": "16e85b4d9b9a8bXHbAwwoqDoc3d66830",
            //         "orderType": "Market",
            //         "symbol": "BTC/USDT",
            //         "timestamp": 1573576916201
            //     }
            //
            // fetchOrder, fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "symbol":       "BTC/USDT",
            //         "price":        "8131.22",
            //         "orderQty":     "0.00082",
            //         "orderType":    "Market",
            //         "avgPx":        "7392.02",
            //         "cumFee":       "0.005152238",
            //         "cumFilledQty": "0.00082",
            //         "errorCode":    "",
            //         "feeAsset":     "USDT",
            //         "lastExecTime": 1575953151764,
            //         "orderId":      "a16eee20b6750866943712zWEDdAjt3",
            //         "seqNum":       2623469,
            //         "side":         "Buy",
            //         "status":       "Filled",
            //         "stopPrice":    "",
            //         "execInst":     "NULL_VAL"
            //     }
            //
            //     {
            //         "ac": "FUTURES",
            //         "accountId": "testabcdefg",
            //         "avgPx": "0",
            //         "cumFee": "0",
            //         "cumQty": "0",
            //         "errorCode": "NULL_VAL",
            //         "execInst": "NULL_VAL",
            //         "feeAsset": "USDT",
            //         "lastExecTime": 1584072844085,
            //         "orderId": "r170d21956dd5450276356bbtcpKa74",
            //         "orderQty": "1.1499",
            //         "orderType": "Limit",
            //         "price": "4000",
            //         "sendingTime": 1584072841033,
            //         "seqNum": 24105338,
            //         "side": "Buy",
            //         "status": "Canceled",
            //         "stopPrice": "",
            //         "symbol": "BTC-PERP"
            //     },
            //
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '/');
            const timestamp = this.safeInteger2 (order, 'timestamp', 'sendingTime');
            const lastTradeTimestamp = this.safeInteger (order, 'lastExecTime');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'orderQty');
            const average = this.safeNumber (order, 'avgPx');
            const filled = this.safeNumber2 (order, 'cumFilledQty', 'cumQty');
            const id = this.safeString (order, 'orderId');
            let clientOrderId = this.safeString (order, 'id');
            if (clientOrderId !== undefined) {
                if (clientOrderId.length < 1) {
                    clientOrderId = undefined;
                }
            }
            const type = this.safeStringLower (order, 'orderType');
            const side = this.safeStringLower (order, 'side');
            const feeCost = this.safeNumber (order, 'cumFee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (order, 'feeAsset');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            const stopPrice = this.safeNumber (order, 'stopPrice');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const market = this.market (symbol);
            const defaultAccountCategory = this.safeString (this.options, 'account-category', 'cash');
            const options = this.safeValue (this.options, 'createOrder', {});
            let accountCategory = this.safeString (options, 'account-category', defaultAccountCategory);
            accountCategory = this.safeString (params, 'account-category', accountCategory);
            params = this.omit (params, 'account-category');
            const account = this.safeValue (this.accounts, 0, {});
            const accountGroup = this.safeValue (account, 'id');
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'id');
            const request = {
                'account-group': accountGroup,
                'account-category': accountCategory,
                'symbol': market['id'],
                'time': this.milliseconds (),
                'orderQty': this.amountToPrecision (symbol, amount),
                'orderType': type, // "limit", "market", "stop_market", "stop_limit"
                'side': side, // "buy" or "sell"
                // 'orderPrice': this.priceToPrecision (symbol, price),
                // 'stopPrice': this.priceToPrecision (symbol, stopPrice), // required for stop orders
                // 'postOnly': 'false', // 'false', 'true'
                // 'timeInForce': 'GTC', // GTC, IOC, FOK
                // 'respInst': 'ACK', // ACK, 'ACCEPT, DONE
            };
            if (clientOrderId !== undefined) {
                request['id'] = clientOrderId;
                params = this.omit (params, [ 'clientOrderId', 'id' ]);
            }
            if ((type === 'limit') || (type === 'stop_limit')) {
                request['orderPrice'] = this.priceToPrecision (symbol, price);
            }
            if ((type === 'stop_limit') || (type === 'stop_market')) {
                const stopPrice = this.safeNumber (params, 'stopPrice');
                if (stopPrice === undefined) {
                    throw new InvalidOrder (this.id + ' createOrder() requires a stopPrice parameter for ' + type + ' orders');
                } else {
                    request['stopPrice'] = this.priceToPrecision (symbol, stopPrice);
                    params = this.omit (params, 'stopPrice');
                }
            }
            const response = await this.accountCategoryPostOrder (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "ac": "MARGIN",
            //             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //             "action": "place-order",
            //             "info": {
            //                 "id": "16e607e2b83a8bXHbAwwoqDo55c166fa",
            //                 "orderId": "16e85b4d9b9a8bXHbAwwoqDoc3d66830",
            //                 "orderType": "Market",
            //                 "symbol": "BTC/USDT",
            //                 "timestamp": 1573576916201
            //             },
            //             "status": "Ack"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const info = this.safeValue (data, 'info', {});
            return this.parseOrder (info, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const defaultAccountCategory = this.safeString (this.options, 'account-category', 'cash');
            const options = this.safeValue (this.options, 'fetchOrder', {});
            let accountCategory = this.safeString (options, 'account-category', defaultAccountCategory);
            accountCategory = this.safeString (params, 'account-category', accountCategory);
            params = this.omit (params, 'account-category');
            const account = this.safeValue (this.accounts, 0, {});
            const accountGroup = this.safeValue (account, 'id');
            const request = {
                'account-group': accountGroup,
                'account-category': accountCategory,
                'orderId': id,
            };
            const response = await this.accountCategoryGetOrderStatus (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "accountCategory": "CASH",
            //         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //         "data": [
            //             {
            //                 "symbol":       "BTC/USDT",
            //                 "price":        "8131.22",
            //                 "orderQty":     "0.00082",
            //                 "orderType":    "Market",
            //                 "avgPx":        "7392.02",
            //                 "cumFee":       "0.005152238",
            //                 "cumFilledQty": "0.00082",
            //                 "errorCode":    "",
            //                 "feeAsset":     "USDT",
            //                 "lastExecTime": 1575953151764,
            //                 "orderId":      "a16eee20b6750866943712zWEDdAjt3",
            //                 "seqNum":       2623469,
            //                 "side":         "Buy",
            //                 "status":       "Filled",
            //                 "stopPrice":    "",
            //                 "execInst":     "NULL_VAL"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const defaultAccountCategory = this.safeString (this.options, 'account-category', 'cash');
            const options = this.safeValue (this.options, 'fetchOpenOrders', {});
            let accountCategory = this.safeString (options, 'account-category', defaultAccountCategory);
            accountCategory = this.safeString (params, 'account-category', accountCategory);
            params = this.omit (params, 'account-category');
            const account = this.safeValue (this.accounts, 0, {});
            const accountGroup = this.safeValue (account, 'id');
            const request = {
                'account-group': accountGroup,
                'account-category': accountCategory,
            };
            const response = await this.accountCategoryGetOrderOpen (this.extend (request, params));
            //
            //     {
            //         "ac": "CASH",
            //         "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //         "code": 0,
            //         "data": [
            //             {
            //                 "avgPx": "0",         // Average filled price of the order
            //                 "cumFee": "0",       // cumulative fee paid for this order
            //                 "cumFilledQty": "0", // cumulative filled quantity
            //                 "errorCode": "",     // error code; could be empty
            //                 "feeAsset": "USDT",  // fee asset
            //                 "lastExecTime": 1576019723550, //  The last execution time of the order
            //                 "orderId": "s16ef21882ea0866943712034f36d83", // server provided orderId
            //                 "orderQty": "0.0083",  // order quantity
            //                 "orderType": "Limit",  // order type
            //                 "price": "7105",       // order price
            //                 "seqNum": 8193258,     // sequence number
            //                 "side": "Buy",         // order side
            //                 "status": "New",       // order status on matching engine
            //                 "stopPrice": "",       // only available for stop market and stop limit orders; otherwise empty
            //                 "symbol": "BTC/USDT",
            //                 "execInst": "NULL_VAL" // execution instruction
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            if (accountCategory === 'futures') {
                return this.parseOrders (data, market, since, limit);
            }
            // a workaround for https://github.com/ccxt/ccxt/issues/7187
            const orders = [];
            for (let i = 0; i < data.length; i++) {
                const order = this.parseOrder (data[i], market);
                orders.push (order);
            }
            return this.filterBySymbolSinceLimit (orders, symbol, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const defaultAccountCategory = this.safeString (this.options, 'account-category');
            const options = this.safeValue (this.options, 'fetchClosedOrders', {});
            let accountCategory = this.safeString (options, 'account-category', defaultAccountCategory);
            accountCategory = this.safeString (params, 'account-category', accountCategory);
            params = this.omit (params, 'account-category');
            const account = this.safeValue (this.accounts, 0, {});
            const accountGroup = this.safeValue (account, 'id');
            const request = {
                'account-group': accountGroup,
                // 'category': accountCategory,
                // 'symbol': market['id'],
                // 'orderType': 'market', // optional, string
                // 'side': 'buy', // or 'sell', optional, case insensitive.
                // 'status': 'Filled', // "Filled", "Canceled", or "Rejected"
                // 'startTime': exchange.milliseconds (),
                // 'endTime': exchange.milliseconds (),
                // 'page': 1,
                // 'pageSize': 100,
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const method = this.safeValue (options, 'method', 'accountGroupGetOrderHist');
            if (method === 'accountGroupGetOrderHist') {
                if (accountCategory !== undefined) {
                    request['category'] = accountCategory;
                }
            } else {
                request['account-category'] = accountCategory;
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            const response = await this[method] (this.extend (request, params));
            //
            // accountCategoryGetOrderHistCurrent
            //
            //     {
            //         "code":0,
            //         "accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda",
            //         "ac":"CASH",
            //         "data":[
            //             {
            //                 "seqNum":15561826728,
            //                 "orderId":"a17294d305c0U6491137460bethu7kw9",
            //                 "symbol":"ETH/USDT",
            //                 "orderType":"Limit",
            //                 "lastExecTime":1591635618200,
            //                 "price":"200",
            //                 "orderQty":"0.1",
            //                 "side":"Buy",
            //                 "status":"Canceled",
            //                 "avgPx":"0",
            //                 "cumFilledQty":"0",
            //                 "stopPrice":"",
            //                 "errorCode":"",
            //                 "cumFee":"0",
            //                 "feeAsset":"USDT",
            //                 "execInst":"NULL_VAL"
            //             }
            //         ]
            //     }
            //
            // accountGroupGetOrderHist
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "data": [
            //                 {
            //                     "ac": "FUTURES",
            //                     "accountId": "testabcdefg",
            //                     "avgPx": "0",
            //                     "cumFee": "0",
            //                     "cumQty": "0",
            //                     "errorCode": "NULL_VAL",
            //                     "execInst": "NULL_VAL",
            //                     "feeAsset": "USDT",
            //                     "lastExecTime": 1584072844085,
            //                     "orderId": "r170d21956dd5450276356bbtcpKa74",
            //                     "orderQty": "1.1499",
            //                     "orderType": "Limit",
            //                     "price": "4000",
            //                     "sendingTime": 1584072841033,
            //                     "seqNum": 24105338,
            //                     "side": "Buy",
            //                     "status": "Canceled",
            //                     "stopPrice": "",
            //                     "symbol": "BTC-PERP"
            //                 },
            //             ],
            //             "hasNext": False,
            //             "limit": 500,
            //             "page": 1,
            //             "pageSize": 20
            //         }
            //     }
            //
            let data = this.safeValue (response, 'data');
            const isArray = Array.isArray (data);
            if (!isArray) {
                data = this.safeValue (data, 'data', []);
            }
            return this.parseOrders (data, market, since, limit);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            await this.loadAccounts ();
            const market = this.market (symbol);
            const defaultAccountCategory = this.safeString (this.options, 'account-category', 'cash');
            const options = this.safeValue (this.options, 'cancelOrder', {});
            let accountCategory = this.safeString (options, 'account-category', defaultAccountCategory);
            accountCategory = this.safeString (params, 'account-category', accountCategory);
            params = this.omit (params, 'account-category');
            const account = this.safeValue (this.accounts, 0, {});
            const accountGroup = this.safeValue (account, 'id');
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'id');
            const request = {
                'account-group': accountGroup,
                'account-category': accountCategory,
                'symbol': market['id'],
                'time': this.milliseconds (),
                'id': 'foobar',
            };
            if (clientOrderId === undefined) {
                request['orderId'] = id;
            } else {
                request['id'] = clientOrderId;
                params = this.omit (params, [ 'clientOrderId', 'id' ]);
            }
            const response = await this.accountCategoryDeleteOrder (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //             "ac": "CASH",
            //             "action": "cancel-order",
            //             "status": "Ack",
            //             "info": {
            //                 "id":        "wv8QGquoeamhssvQBeHOHGQCGlcBjj23",
            //                 "orderId":   "16e6198afb4s8bXHbAwwoqDo2ebc19dc",
            //                 "orderType": "", // could be empty
            //                 "symbol":    "ETH/USDT",
            //                 "timestamp":  1573594877822
            //             }
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const info = this.safeValue (data, 'info', {});
            return this.parseOrder (info, market);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const defaultAccountCategory = this.safeString (this.options, 'account-category', 'cash');
            const options = this.safeValue (this.options, 'cancelAllOrders', {});
            let accountCategory = this.safeString (options, 'account-category', defaultAccountCategory);
            accountCategory = this.safeString (params, 'account-category', accountCategory);
            params = this.omit (params, 'account-category');
            const account = this.safeValue (this.accounts, 0, {});
            const accountGroup = this.safeValue (account, 'id');
            const request = {
                'account-group': accountGroup,
                'account-category': accountCategory,
                'time': this.milliseconds (),
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const response = await this.accountCategoryDeleteOrderAll (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "ac": "CASH",
            //             "accountId": "cshQtyfq8XLAA9kcf19h8bXHbAwwoqDo",
            //             "action": "cancel-all",
            //             "info": {
            //                 "id":  "2bmYvi7lyTrneMzpcJcf2D7Pe9V1P9wy",
            //                 "orderId": "",
            //                 "orderType": "NULL_VAL",
            //                 "symbol": "",
            //                 "timestamp": 1574118495462
            //             },
            //             "status": "Ack"
            //         }
            //     }
            //
            return response;
        }
    
        parseDepositAddress (depositAddress, currency = undefined) {
            //
            //     {
            //         address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
            //         destTag: "",
            //         tagType: "",
            //         tagId: "",
            //         chainName: "ERC20",
            //         numConfirmations: 20,
            //         withdrawalFee: 1,
            //         nativeScale: 4,
            //         tips: []
            //     }
            //
            const address = this.safeString (depositAddress, 'address');
            const tagId = this.safeString (depositAddress, 'tagId');
            const tag = this.safeString (depositAddress, tagId);
            this.checkAddress (address);
            const code = (currency === undefined) ? undefined : currency['code'];
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': depositAddress,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const chainName = this.safeString (params, 'chainName');
            params = this.omit (params, 'chainName');
            const request = {
                'asset': currency['id'],
            };
            const response = await this.privateGetWalletDepositAddress (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "asset":"USDT",
            //             "assetName":"Tether",
            //             "address":[
            //                 {
            //                     "address":"1N22odLHXnLPCjC8kwBJPTayarr9RtPod6",
            //                     "destTag":"",
            //                     "tagType":"",
            //                     "tagId":"",
            //                     "chainName":"Omni",
            //                     "numConfirmations":3,
            //                     "withdrawalFee":4.7,
            //                     "nativeScale":4,
            //                     "tips":[]
            //                 },
            //                 {
            //                     "address":"0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
            //                     "destTag":"",
            //                     "tagType":"",
            //                     "tagId":"",
            //                     "chainName":"ERC20",
            //                     "numConfirmations":20,
            //                     "withdrawalFee":1.0,
            //                     "nativeScale":4,
            //                     "tips":[]
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const addresses = this.safeValue (data, 'address', []);
            const numAddresses = addresses.length;
            let address = undefined;
            if (numAddresses > 1) {
                const addressesByChainName = this.indexBy (addresses, 'chainName');
                if (chainName === undefined) {
                    const chainNames = Object.keys (addressesByChainName);
                    const chains = chainNames.join (', ');
                    throw new ArgumentsRequired (this.id + ' fetchDepositAddress returned more than one address, a chainName parameter is required, one of ' + chains);
                }
                address = this.safeValue (addressesByChainName, chainName, {});
            } else {
                // first address
                address = this.safeValue (addresses, 0, {});
            }
            const result = this.parseDepositAddress (address, currency);
            return this.extend (result, {
                'info': response,
            });
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'txType': 'deposit',
            };
            return await this.fetchTransactions (code, since, limit, this.extend (request, params));
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'txType': 'withdrawal',
            };
            return await this.fetchTransactions (code, since, limit, this.extend (request, params));
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'asset': currency['id'],
                // 'page': 1,
                // 'pageSize': 20,
                // 'startTs': this.milliseconds (),
                // 'endTs': this.milliseconds (),
                // 'txType': undefned, // deposit, withdrawal
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['asset'] = currency['id'];
            }
            if (since !== undefined) {
                request['startTs'] = since;
            }
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            const response = await this.privateGetWalletTransactions (this.extend (request, params));
            //
            //     {
            //         code: 0,
            //         data: {
            //             data: [
            //                 {
            //                     requestId: "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
            //                     time: 1591606166000,
            //                     asset: "USDT",
            //                     transactionType: "deposit",
            //                     amount: "25",
            //                     commission: "0",
            //                     networkTransactionId: "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
            //                     status: "pending",
            //                     numConfirmed: 8,
            //                     numConfirmations: 20,
            //                     destAddress: { address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722" }
            //                 }
            //             ],
            //             page: 1,
            //             pageSize: 20,
            //             hasNext: false
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const transactions = this.safeValue (data, 'data', []);
            return this.parseTransactions (transactions, currency, since, limit);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'reviewing': 'pending',
                'pending': 'pending',
                'confirmed': 'ok',
                'rejected': 'rejected',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            //     {
            //         requestId: "wuzd1Ojsqtz4bCA3UXwtUnnJDmU8PiyB",
            //         time: 1591606166000,
            //         asset: "USDT",
            //         transactionType: "deposit",
            //         amount: "25",
            //         commission: "0",
            //         networkTransactionId: "0xbc4eabdce92f14dbcc01d799a5f8ca1f02f4a3a804b6350ea202be4d3c738fce",
            //         status: "pending",
            //         numConfirmed: 8,
            //         numConfirmations: 20,
            //         destAddress: {
            //             address: "0xe7c70b4e73b6b450ee46c3b5c0f5fb127ca55722",
            //             destTag: "..." // for currencies that have it
            //         }
            //     }
            //
            const id = this.safeString (transaction, 'requestId');
            const amount = this.safeNumber (transaction, 'amount');
            const destAddress = this.safeValue (transaction, 'destAddress', {});
            const address = this.safeString (destAddress, 'address');
            const tag = this.safeString (destAddress, 'destTag');
            const txid = this.safeString (transaction, 'networkTransactionId');
            const type = this.safeString (transaction, 'transactionType');
            const timestamp = this.safeInteger (transaction, 'time');
            const currencyId = this.safeString (transaction, 'asset');
            const code = this.safeCurrencyCode (currencyId, currency);
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const feeCost = this.safeNumber (transaction, 'commission');
            return {
                'info': transaction,
                'id': id,
                'currency': code,
                'amount': amount,
                'address': address,
                'addressTo': address,
                'addressFrom': undefined,
                'tag': tag,
                'tagTo': tag,
                'tagFrom': undefined,
                'status': status,
                'type': type,
                'updated': undefined,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': {
                    'currency': code,
                    'cost': feeCost,
                },
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = '';
            let query = params;
            const accountCategory = (api === 'accountCategory');
            if (accountCategory || (api === 'accountGroup')) {
                url += this.implodeParams ('/{account-group}', params);
                query = this.omit (params, 'account-group');
            }
            const request = this.implodeParams (path, query);
            url += '/api/pro/' + this.version;
            if (accountCategory) {
                url += this.implodeParams ('/{account-category}', query);
                query = this.omit (query, 'account-category');
            }
            url += '/' + request;
            query = this.omit (query, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const timestamp = this.milliseconds ().toString ();
                const payload = timestamp + '+' + request;
                const hmac = this.hmac (this.encode (payload), this.encode (this.secret), 'sha256', 'base64');
                headers = {
                    'x-auth-key': this.apiKey,
                    'x-auth-timestamp': timestamp,
                    'x-auth-signature': hmac,
                };
                if (method === 'GET') {
                    if (Object.keys (query).length) {
                        url += '?' + this.urlencode (query);
                    }
                } else {
                    headers['Content-Type'] = 'application/json';
                    body = this.json (query);
                }
            }
            url = this.urls['api'] + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     {'code': 6010, 'message': 'Not enough balance.'}
            //     {'code': 60060, 'message': 'The order is already filled or canceled.'}
            //     {"code":2100,"message":"ApiKeyFailure"}
            //     {"code":300001,"message":"Price is too low from market price.","reason":"INVALID_PRICE","accountId":"cshrHKLZCjlZ2ejqkmvIHHtPmLYqdnda","ac":"CASH","action":"place-order","status":"Err","info":{"symbol":"BTC/USDT"}}
            //
            const code = this.safeString (response, 'code');
            const message = this.safeString (response, 'message');
            const error = (code !== undefined) && (code !== '0');
            if (error || (message !== undefined)) {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],6:[function(require,module,exports){
    "use strict";
    
    // ----------------------------------------------------------------------------
    
    const functions = require ('./functions')
    
    const {
        isNode
        , keys
        , values
        , deepExtend
        , extend
        , clone
        , flatten
        , unique
        , indexBy
        , sortBy
        , groupBy
        , aggregate
        , uuid
        , unCamelCase
        , precisionFromString
        , throttle
        , capitalize
        , now
        , timeout
        , TimedOut
        , buildOHLCVC
        , decimalToPrecision
        , defaultFetch
    } = functions
    
    const { // eslint-disable-line object-curly-newline
        ExchangeError
        , BadSymbol
        , InvalidAddress
        , NotSupported
        , AuthenticationError
        , DDoSProtection
        , RequestTimeout
        , ExchangeNotAvailable
        , RateLimitExceeded } = require ('./errors')
    
    const { TRUNCATE, ROUND, DECIMAL_PLACES, NO_PADDING } = functions.precisionConstants
    
    const BN = require ('../static_dependencies/BN/bn')
    const Precise = require ('./Precise')
    
    // ----------------------------------------------------------------------------
    
    module.exports = class Exchange {
    
        describe () {
            return {
                'id': undefined,
                'name': undefined,
                'countries': undefined,
                'enableRateLimit': true,
                'rateLimit': 2000, // milliseconds = seconds * 1000
                'certified': false, // if certified by the CCXT dev team
                'pro': false, // if it is integrated with CCXT Pro for WebSocket support
                'alias': false, // whether this exchange is an alias to another exchange
                'has': {
                    'loadMarkets': true,
                    'cancelAllOrders': false,
                    'cancelOrder': true,
                    'cancelOrders': false,
                    'CORS': false,
                    'createDepositAddress': false,
                    'createLimitOrder': true,
                    'createMarketOrder': true,
                    'createOrder': true,
                    'deposit': false,
                    'editOrder': 'emulated',
                    'fetchBalance': true,
                    'fetchBidsAsks': false,
                    'fetchClosedOrders': false,
                    'fetchCurrencies': false,
                    'fetchDepositAddress': false,
                    'fetchDeposits': false,
                    'fetchFundingFees': false,
                    'fetchL2OrderBook': true,
                    'fetchLedger': false,
                    'fetchMarkets': true,
                    'fetchMyTrades': false,
                    'fetchOHLCV': 'emulated',
                    'fetchOpenOrders': false,
                    'fetchOrder': false,
                    'fetchOrderBook': true,
                    'fetchOrderBooks': false,
                    'fetchOrders': false,
                    'fetchOrderTrades': false,
                    'fetchStatus': 'emulated',
                    'fetchTicker': true,
                    'fetchTickers': false,
                    'fetchTime': false,
                    'fetchTrades': true,
                    'fetchTradingFee': false,
                    'fetchTradingFees': false,
                    'fetchTradingLimits': false,
                    'fetchTransactions': false,
                    'fetchWithdrawals': false,
                    'privateAPI': true,
                    'publicAPI': true,
                    'signIn': false,
                    'withdraw': false,
                },
                'urls': {
                    'logo': undefined,
                    'api': undefined,
                    'www': undefined,
                    'doc': undefined,
                    'fees': undefined,
                },
                'api': undefined,
                'requiredCredentials': {
                    'apiKey':     true,
                    'secret':     true,
                    'uid':        false,
                    'login':      false,
                    'password':   false,
                    'twofa':      false, // 2-factor authentication (one-time password key)
                    'privateKey': false, // a "0x"-prefixed hexstring private key for a wallet
                    'walletAddress': false, // the wallet address "0x"-prefixed hexstring
                    'token':      false, // reserved for HTTP auth in some cases
                },
                'markets': undefined, // to be filled manually or by fetchMarkets
                'currencies': {}, // to be filled manually or by fetchMarkets
                'timeframes': undefined, // redefine if the exchange has.fetchOHLCV
                'fees': {
                    'trading': {
                        'tierBased': undefined,
                        'percentage': undefined,
                        'taker': undefined,
                        'maker': undefined,
                    },
                    'funding': {
                        'tierBased': undefined,
                        'percentage': undefined,
                        'withdraw': {},
                        'deposit': {},
                    },
                },
                'status': {
                    'status': 'ok',
                    'updated': undefined,
                    'eta': undefined,
                    'url': undefined,
                },
                'exceptions': undefined,
                'httpExceptions': {
                    '422': ExchangeError,
                    '418': DDoSProtection,
                    '429': RateLimitExceeded,
                    '404': ExchangeNotAvailable,
                    '409': ExchangeNotAvailable,
                    '410': ExchangeNotAvailable,
                    '500': ExchangeNotAvailable,
                    '501': ExchangeNotAvailable,
                    '502': ExchangeNotAvailable,
                    '520': ExchangeNotAvailable,
                    '521': ExchangeNotAvailable,
                    '522': ExchangeNotAvailable,
                    '525': ExchangeNotAvailable,
                    '526': ExchangeNotAvailable,
                    '400': ExchangeNotAvailable,
                    '403': ExchangeNotAvailable,
                    '405': ExchangeNotAvailable,
                    '503': ExchangeNotAvailable,
                    '530': ExchangeNotAvailable,
                    '408': RequestTimeout,
                    '504': RequestTimeout,
                    '401': AuthenticationError,
                    '511': AuthenticationError,
                },
                // some exchanges report only 'free' on `fetchBlance` call (i.e. report no 'used' funds)
                // in this case ccxt will try to infer 'used' funds from open order cache, which might be stale
                // still, some exchanges report number of open orders together with balance
                // if you set the following flag to 'true' ccxt will leave 'used' funds undefined in case of discrepancy
                'dontGetUsedBalanceFromStaleCache': false,
                'commonCurrencies': { // gets extended/overwritten in subclasses
                    'XBT': 'BTC',
                    'BCC': 'BCH',
                    'DRK': 'DASH',
                    'BCHABC': 'BCH',
                    'BCHSV': 'BSV',
                },
                'precisionMode': DECIMAL_PLACES,
                'paddingMode': NO_PADDING,
                'limits': {
                    'amount': { 'min': undefined, 'max': undefined },
                    'price': { 'min': undefined, 'max': undefined },
                    'cost': { 'min': undefined, 'max': undefined },
                },
            } // return
        } // describe ()
    
        constructor (userConfig = {}) {
            Object.assign (this, functions)
            // if (isNode) {
            //     this.nodeVersion = process.version.match (/\d+\.\d+\.\d+/)[0]
            //     this.userAgent = {
            //         'User-Agent': 'ccxt/' + Exchange.ccxtVersion +
            //             ' (+https://github.com/ccxt/ccxt)' +
            //             ' Node.js/' + this.nodeVersion + ' (JavaScript)'
            //     }
            // }
    
            this.options = {} // exchange-specific options, if any
    
            // fetch implementation options (JS only)
            this.fetchOptions = {
                // keepalive: true, // does not work in Chrome, https://github.com/ccxt/ccxt/issues/6368
            }
    
            this.userAgents = {
                'chrome': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36',
                'chrome39': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36',
            }
    
            this.headers = {}
    
            // prepended to URL, like https://proxy.com/https://exchange.com/api...
            this.proxy = ''
            this.origin = '*' // CORS origin
    
            this.minFundingAddressLength = 1 // used in checkAddress
            this.substituteCommonCurrencyCodes = true  // reserved
            this.quoteJsonNumbers = true // treat numbers in json as quoted precise strings
            this.number = Number // or String (a pointer to a function)
    
            // whether fees should be summed by currency code
            this.reduceFees = true
    
            // do not delete this line, it is needed for users to be able to define their own fetchImplementation
            this.fetchImplementation = defaultFetch
    
            this.timeout       = 10000 // milliseconds
            this.verbose       = false
            this.debug         = false
            this.userAgent     = undefined
            this.twofa         = undefined // two-factor authentication (2FA)
    
            this.apiKey        = undefined
            this.secret        = undefined
            this.uid           = undefined
            this.login         = undefined
            this.password      = undefined
            this.privateKey    = undefined // a "0x"-prefixed hexstring private key for a wallet
            this.walletAddress = undefined // a wallet address "0x"-prefixed hexstring
            this.token         = undefined // reserved for HTTP auth in some cases
    
            this.balance      = {}
            this.orderbooks   = {}
            this.tickers      = {}
            this.orders       = undefined
            this.trades       = {}
            this.transactions = {}
            this.ohlcvs       = {}
            this.myTrades     = undefined
            this.positions    = {}
    
            this.requiresWeb3 = false
            this.requiresEddsa = false
            this.precision = {}
    
            this.enableLastJsonResponse = true
            this.enableLastHttpResponse = true
            this.enableLastResponseHeaders = true
            this.last_http_response    = undefined
            this.last_json_response    = undefined
            this.last_response_headers = undefined
    
            const unCamelCaseProperties = (obj = this) => {
                if (obj !== null) {
                    const ownPropertyNames = Object.getOwnPropertyNames (obj)
                    for (let i = 0; i < ownPropertyNames.length; i++) {
                        const k = ownPropertyNames[i]
                        this[unCamelCase (k)] = this[k]
                    }
                    unCamelCaseProperties (Object.getPrototypeOf (obj))
                }
            }
            unCamelCaseProperties ()
    
            // merge to this
            const configEntries = Object.entries (this.describe ()).concat (Object.entries (userConfig))
            for (let i = 0; i < configEntries.length; i++) {
                const [property, value] = configEntries[i]
                if (value && Object.getPrototypeOf (value) === Object.prototype) {
                    this[property] = deepExtend (this[property], value)
                } else {
                    this[property] = value
                }
            }
    
            const agentOptions = {
                'keepAlive': true,
            }
    
            if (!this.httpAgent && defaultFetch.http && isNode) {
                this.httpAgent = new defaultFetch.http.Agent (agentOptions)
            }
    
            if (!this.httpsAgent && defaultFetch.https && isNode) {
                this.httpsAgent = new defaultFetch.https.Agent (agentOptions)
            }
    
            // generate old metainfo interface
            const hasKeys = Object.keys (this.has)
            for (let i = 0; i < hasKeys.length; i++) {
                const k = hasKeys[i]
                this['has' + capitalize (k)] = !!this.has[k] // converts 'emulated' to true
            }
    
            if (this.api) {
                this.defineRestApi (this.api, 'request')
            }
    
            this.initRestRateLimiter ()
    
            if (this.markets) {
                this.setMarkets (this.markets)
            }
        }
    
        defaults () {
            return { /* override me */ }
        }
    
        nonce () {
            return this.seconds ()
        }
    
        encodeURIComponent (...args) {
            return encodeURIComponent (...args)
        }
    
        checkRequiredVersion (requiredVersion, error = true) {
            let result = true
            const [ major1, minor1, patch1 ] = requiredVersion.split ('.')
                , [ major2, minor2, patch2 ] = Exchange.ccxtVersion.split ('.')
                , intMajor1 = parseInt (major1)
                , intMinor1 = parseInt (minor1)
                , intPatch1 = parseInt (patch1)
                , intMajor2 = parseInt (major2)
                , intMinor2 = parseInt (minor2)
                , intPatch2 = parseInt (patch2)
            if (intMajor1 > intMajor2) {
                result = false
            }
            if (intMajor1 === intMajor2) {
                if (intMinor1 > intMinor2) {
                    result = false
                } else if (intMinor1 === intMinor2 && intPatch1 > intPatch2) {
                    result = false
                }
            }
            if (!result) {
                if (error) {
                    throw new NotSupported ('Your current version of CCXT is ' + Exchange.ccxtVersion + ', a newer version ' + requiredVersion + ' is required, please, upgrade your version of CCXT')
                } else {
                    return error
                }
            }
            return result
        }
    
        checkRequiredCredentials (error = true) {
            const keys = Object.keys (this.requiredCredentials)
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i]
                if (this.requiredCredentials[key] && !this[key]) {
                    if (error) {
                        throw new AuthenticationError (this.id + ' requires `' + key + '` credential')
                    } else {
                        return error
                    }
                }
            }
            return true
        }
    
        checkAddress (address) {
    
            if (address === undefined) {
                throw new InvalidAddress (this.id + ' address is undefined')
            }
    
            // check the address is not the same letter like 'aaaaa' nor too short nor has a space
            if ((unique (address).length === 1) || address.length < this.minFundingAddressLength || address.includes (' ')) {
                throw new InvalidAddress (this.id + ' address is invalid or has less than ' + this.minFundingAddressLength.toString () + ' characters: "' + this.json (address) + '"')
            }
    
            return address
        }
    
        initRestRateLimiter () {
    
            if (this.rateLimit === undefined) {
                throw new Error (this.id + '.rateLimit property is not configured')
            }
    
            this.tokenBucket = this.extend ({
                delay:       0.001,
                capacity:    1,
                cost: 1,
                maxCapacity: 1000,
                refillRate: (this.rateLimit > 0) ? 1 / this.rateLimit : Number.MAX_VALUE
            }, this.tokenBucket)
    
            this.throttle = throttle (this.tokenBucket)
    
            this.executeRestRequest = (url, method = 'GET', headers = undefined, body = undefined) => {
    
                // fetchImplementation cannot be called on this. in browsers:
                // TypeError Failed to execute 'fetch' on 'Window': Illegal invocation
                const fetchImplementation = this.fetchImplementation
    
                const params = { method, headers, body, timeout: this.timeout }
    
                if (this.agent) {
                    params['agent'] = this.agent
                } else if (this.httpAgent && url.indexOf ('http://') === 0) {
                    params['agent'] = this.httpAgent
                } else if (this.httpsAgent && url.indexOf ('https://') === 0) {
                    params['agent'] = this.httpsAgent
                }
    
                const promise =
                    fetchImplementation (url, this.extend (params, this.fetchOptions))
                        .catch ((e) => {
                            if (isNode) {
                                throw new ExchangeNotAvailable ([ this.id, method, url, e.type, e.message ].join (' '))
                            }
                            throw e // rethrow all unknown errors
                        })
                        .then ((response) => this.handleRestResponse (response, url, method, headers, body))
    
                return timeout (this.timeout, promise).catch ((e) => {
                    if (e instanceof TimedOut) {
                        throw new RequestTimeout (this.id + ' ' + method + ' ' + url + ' request timed out (' + this.timeout + ' ms)')
                    }
                    throw e
                })
            }
        }
    
        setSandboxMode (enabled) {
            if (!!enabled) { // eslint-disable-line no-extra-boolean-cast
                if ('test' in this.urls) {
                    if (typeof this.urls['api'] === 'string') {
                        this.urls['apiBackup'] = this.urls['api']
                        this.urls['api'] = this.urls['test']
                    } else {
                        this.urls['apiBackup'] = clone (this.urls['api'])
                        this.urls['api'] = clone (this.urls['test'])
                    }
                } else {
                    throw new NotSupported (this.id + ' does not have a sandbox URL')
                }
            } else if ('apiBackup' in this.urls) {
                if (typeof this.urls['api'] === 'string') {
                    this.urls['api'] = this.urls['apiBackup']
                } else {
                    this.urls['api'] = clone (this.urls['apiBackup'])
                }
            }
        }
    
        defineRestApiEndpoint (methodName, uppercaseMethod, lowercaseMethod, camelcaseMethod, path, paths, config = {}) {
            const splitPath = path.split (/[^a-zA-Z0-9]/)
            const camelcaseSuffix  = splitPath.map (this.capitalize).join ('')
            const underscoreSuffix = splitPath.map ((x) => x.trim ().toLowerCase ()).filter ((x) => x.length > 0).join ('_')
            const camelcasePrefix = [ paths[0] ].concat (paths.slice (1).map (this.capitalize)).join ('')
            const underscorePrefix = [ paths[0] ].concat (paths.slice (1).map ((x) => x.trim ()).filter ((x) => x.length > 0)).join ('_')
            const camelcase  = camelcasePrefix + camelcaseMethod + this.capitalize (camelcaseSuffix)
            const underscore = underscorePrefix + '_' + lowercaseMethod + '_' + underscoreSuffix
            const typeArgument = (paths.length > 1) ? paths : paths[0]
            // handle call costs here
            const partial = async (params = {}, context = {}) => this[methodName] (path, typeArgument, uppercaseMethod, params, undefined, undefined, config, context)
            // const partial = async (params) => this[methodName] (path, typeArgument, uppercaseMethod, params || {})
            this[camelcase]  = partial
            this[underscore] = partial
        }
    
        defineRestApi (api, methodName, paths = []) {
            const keys = Object.keys (api)
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i]
                const value = api[key]
                const uppercaseMethod = key.toUpperCase ()
                const lowercaseMethod = key.toLowerCase ()
                const camelcaseMethod = this.capitalize (lowercaseMethod)
                if (Array.isArray (value)) {
                    for (let k = 0; k < value.length; k++) {
                        const path = value[k].trim ()
                        this.defineRestApiEndpoint (methodName, uppercaseMethod, lowercaseMethod, camelcaseMethod, path, paths)
                    }
                } else if (key.match (/^(?:get|post|put|delete|options|head)$/i)) {
                    const endpoints = Object.keys (value);
                    for (let j = 0; j < endpoints.length; j++) {
                        const endpoint = endpoints[j]
                        const path = endpoint.trim ()
                        const config = value[endpoint]
                        if (typeof config === 'object') {
                            this.defineRestApiEndpoint (methodName, uppercaseMethod, lowercaseMethod, camelcaseMethod, path, paths, config)
                        } else if (typeof config === 'number') {
                            this.defineRestApiEndpoint (methodName, uppercaseMethod, lowercaseMethod, camelcaseMethod, path, paths, { cost: config })
                        } else {
                            throw new NotSupported (this.id + ' defineRestApi() API format not supported, API leafs must strings, objects or numbers');
                        }
                    }
                } else {
                    this.defineRestApi (value, methodName, paths.concat ([ key ]))
                }
            }
        }
    
        log (... args) {
            console.log (... args)
        }
    
        setHeaders (headers) {
            return headers;
        }
    
        fetch (url, method = 'GET', headers = undefined, body = undefined) {
    
            if (isNode && this.userAgent) {
                if (typeof this.userAgent === 'string') {
                    headers = extend ({ 'User-Agent': this.userAgent }, headers)
                } else if ((typeof this.userAgent === 'object') && ('User-Agent' in this.userAgent)) {
                    headers = extend (this.userAgent, headers)
                }
            }
    
            if (typeof this.proxy === 'function') {
    
                url = this.proxy (url)
                if (isNode) {
                    headers = extend ({ 'Origin': this.origin }, headers)
                }
    
            } else if (typeof this.proxy === 'string') {
    
                if (this.proxy.length && isNode) {
                    headers = extend ({ 'Origin': this.origin }, headers)
                }
    
                url = this.proxy + url
            }
    
            headers = extend (this.headers, headers)
            headers = this.setHeaders (headers)
    
            if (this.verbose) {
                this.log ("fetch:\n", this.id, method, url, "\nRequest:\n", headers, "\n", body, "\n")
            }
    
            return this.executeRestRequest (url, method, headers, body)
        }
    
        // eslint-disable-next-line no-unused-vars
        calculateRateLimiterCost (api, method, path, params, config = {}, context = {}) {
            return this.safeValue (config, 'cost', 1);
        }
    
        async fetch2 (path, type = 'public', method = 'GET', params = {}, headers = undefined, body = undefined, config = {}, context = {}) {
            if (this.enableRateLimit) {
                const cost = this.calculateRateLimiterCost (type, method, path, params, config, context)
                await this.throttle (cost)
            }
            const request = this.sign (path, type, method, params, headers, body)
            return this.fetch (request.url, request.method, request.headers, request.body)
        }
    
        request (path, type = 'public', method = 'GET', params = {}, headers = undefined, body = undefined, config = {}, context = {}) {
            return this.fetch2 (path, type, method, params, headers, body, config, context)
        }
    
        parseJson (jsonString) {
            try {
                if (this.isJsonEncodedObject (jsonString)) {
                    return JSON.parse (this.onJsonResponse (jsonString))
                }
            } catch (e) {
                // SyntaxError
                return undefined
            }
        }
    
        throwExactlyMatchedException (exact, string, message) {
            if (string in exact) {
                throw new exact[string] (message)
            }
        }
    
        throwBroadlyMatchedException (broad, string, message) {
            const broadKey = this.findBroadlyMatchedKey (broad, string)
            if (broadKey !== undefined) {
                throw new broad[broadKey] (message)
            }
        }
    
        // a helper for matching error strings exactly vs broadly
        findBroadlyMatchedKey (broad, string) {
            const keys = Object.keys (broad)
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i]
                if (string.indexOf (key) >= 0) {
                    return key
                }
            }
            return undefined
        }
    
        handleErrors (statusCode, statusText, url, method, responseHeaders, responseBody, response, requestHeaders, requestBody) {
            // override me
        }
    
        handleHttpStatusCode (code, reason, url, method, body) {
            const codeAsString = code.toString ()
            if (codeAsString in this.httpExceptions) {
                const ErrorClass = this.httpExceptions[codeAsString]
                throw new ErrorClass ([ this.id, method, url, code, reason, body ].join (' '))
            }
        }
    
        getResponseHeaders (response) {
            const result = {}
            response.headers.forEach ((value, key) => {
                key = key.split ('-').map ((word) => capitalize (word)).join ('-')
                result[key] = value
            })
            return result
        }
    
        handleRestResponse (response, url, method = 'GET', requestHeaders = undefined, requestBody = undefined) {
    
            return response.text ().then ((responseBody) => {
                const responseHeaders = this.getResponseHeaders (response)
                const bodyText = this.onRestResponse (response.status, response.statusText, url, method, responseHeaders, responseBody, requestHeaders, requestBody);
                const json = this.parseJson (bodyText)
                if (this.enableLastResponseHeaders) {
                    this.last_response_headers = responseHeaders
                }
                if (this.enableLastHttpResponse) {
                    this.last_http_response = responseBody
                }
                if (this.enableLastJsonResponse) {
                    this.last_json_response = json
                }
                if (this.verbose) {
                    this.log ("handleRestResponse:\n", this.id, method, url, response.status, response.statusText, "\nResponse:\n", responseHeaders, "\n", responseBody, "\n")
                }
                this.handleErrors (response.status, response.statusText, url, method, responseHeaders, responseBody, json, requestHeaders, requestBody)
                this.handleHttpStatusCode (response.status, response.statusText, url, method, responseBody)
                return json || responseBody
            })
        }
    
        onRestResponse (statusCode, statusText, url, method, responseHeaders, responseBody, requestHeaders, requestBody) {
            return responseBody.trim ()
        }
    
        onJsonResponse (responseBody) {
            return this.quoteJsonNumbers ? responseBody.replace (/":([+.0-9eE-]+)([,}])/g, '":"$1"$2') : responseBody;
        }
    
        setMarkets (markets, currencies = undefined) {
            const values = Object.values (markets).map ((market) => deepExtend ({
                'limits': this.limits,
                'precision': this.precision,
            }, this.fees['trading'], market))
            this.markets = indexBy (values, 'symbol')
            this.markets_by_id = indexBy (markets, 'id')
            this.symbols = Object.keys (this.markets).sort ()
            this.ids = Object.keys (this.markets_by_id).sort ()
            if (currencies) {
                this.currencies = deepExtend (currencies, this.currencies)
            } else {
                let baseCurrencies =
                    values.filter ((market) => 'base' in market)
                        .map ((market) => ({
                            id: market.baseId || market.base,
                            numericId: (market.baseNumericId !== undefined) ? market.baseNumericId : undefined,
                            code: market.base,
                            precision: market.precision ? (market.precision.base || market.precision.amount) : 8,
                        }))
                let quoteCurrencies =
                    values.filter ((market) => 'quote' in market)
                        .map ((market) => ({
                            id: market.quoteId || market.quote,
                            numericId: (market.quoteNumericId !== undefined) ? market.quoteNumericId : undefined,
                            code: market.quote,
                            precision: market.precision ? (market.precision.quote || market.precision.price) : 8,
                        }))
                baseCurrencies = sortBy (baseCurrencies, 'code')
                quoteCurrencies = sortBy (quoteCurrencies, 'code')
                this.baseCurrencies = indexBy (baseCurrencies, 'code')
                this.quoteCurrencies = indexBy (quoteCurrencies, 'code')
                const allCurrencies = baseCurrencies.concat (quoteCurrencies)
                const groupedCurrencies = groupBy (allCurrencies, 'code')
                const currencies = Object.keys (groupedCurrencies).map ((code) =>
                    groupedCurrencies[code].reduce ((previous, current) => // eslint-disable-line implicit-arrow-linebreak
                        ((previous.precision > current.precision) ? previous : current), groupedCurrencies[code][0])) // eslint-disable-line implicit-arrow-linebreak
                const sortedCurrencies = sortBy (flatten (currencies), 'code')
                this.currencies = deepExtend (indexBy (sortedCurrencies, 'code'), this.currencies)
            }
            this.currencies_by_id = indexBy (this.currencies, 'id')
            this.codes = Object.keys (this.currencies).sort ()
            return this.markets
        }
    
        async loadMarketsHelper (reload = false, params = {}) {
            if (!reload && this.markets) {
                if (!this.markets_by_id) {
                    return this.setMarkets (this.markets)
                }
                return this.markets
            }
            let currencies = undefined
            if (this.has.fetchCurrencies) {
                currencies = await this.fetchCurrencies ()
            }
            const markets = await this.fetchMarkets (params)
            return this.setMarkets (markets, currencies)
        }
    
        // is async (returns a promise)
        loadMarkets (reload = false, params = {}) {
            if ((reload && !this.reloadingMarkets) || !this.marketsLoading) {
                this.reloadingMarkets = true
                this.marketsLoading = this.loadMarketsHelper (reload, params).then ((resolved) => {
                    this.reloadingMarkets = false
                    return resolved
                }, (error) => {
                    this.reloadingMarkets = false
                    throw error
                })
            }
            return this.marketsLoading
        }
    
        async loadAccounts (reload = false, params = {}) {
            if (reload) {
                this.accounts = await this.fetchAccounts (params)
            } else {
                if (this.accounts) {
                    return this.accounts
                } else {
                    this.accounts = await this.fetchAccounts (params)
                }
            }
            this.accountsById = this.indexBy (this.accounts, 'id')
            return this.accounts
        }
    
        fetchBidsAsks (symbols = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchBidsAsks not supported yet')
        }
    
        async fetchOHLCVC (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            if (!this.has['fetchTrades']) {
                throw new NotSupported (this.id + ' fetchOHLCV() not supported yet')
            }
            await this.loadMarkets ()
            const trades = await this.fetchTrades (symbol, since, limit, params)
            const ohlcvc = buildOHLCVC (trades, timeframe, since, limit)
            return ohlcvc
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            if (!this.has['fetchTrades']) {
                throw new NotSupported (this.id + ' fetchOHLCV() not supported yet')
            }
            await this.loadMarkets ()
            const trades = await this.fetchTrades (symbol, since, limit, params)
            const ohlcvc = buildOHLCVC (trades, timeframe, since, limit)
            return ohlcvc.map ((c) => c.slice (0, -1))
        }
    
        parseTradingViewOHLCV (ohlcvs, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
            const result = this.convertTradingViewToOHLCV (ohlcvs)
            return this.parseOHLCVs (result, market, timeframe, since, limit)
        }
    
        convertTradingViewToOHLCV (ohlcvs, t = 't', o = 'o', h = 'h', l = 'l', c = 'c', v = 'v', ms = false) {
            const result = [];
            for (let i = 0; i < ohlcvs[t].length; i++) {
                result.push ([
                    ms ? ohlcvs[t][i] : (ohlcvs[t][i] * 1000),
                    ohlcvs[o][i],
                    ohlcvs[h][i],
                    ohlcvs[l][i],
                    ohlcvs[c][i],
                    ohlcvs[v][i],
                ])
            }
            return result
        }
    
        convertOHLCVToTradingView (ohlcvs, t = 't', o = 'o', h = 'h', l = 'l', c = 'c', v = 'v', ms = false) {
            const result = {}
            result[t] = []
            result[o] = []
            result[h] = []
            result[l] = []
            result[c] = []
            result[v] = []
            for (let i = 0; i < ohlcvs.length; i++) {
                result[t].push (ms ? ohlcvs[i][0] : parseInt (ohlcvs[i][0] / 1000))
                result[o].push (ohlcvs[i][1])
                result[h].push (ohlcvs[i][2])
                result[l].push (ohlcvs[i][3])
                result[c].push (ohlcvs[i][4])
                result[v].push (ohlcvs[i][5])
            }
            return result
        }
    
        async fetchTicker (symbol, params = {}) {
            if (this.has['fetchTickers']) {
                const tickers = await this.fetchTickers ([ symbol ], params);
                const ticker = this.safeValue (tickers, symbol);
                if (ticker === undefined) {
                    throw new InvalidAddress (this.id + ' fetchTickers could not find a ticker for ' + symbol);
                } else {
                    return ticker;
                }
            } else {
                throw new NotSupported (this.id + ' fetchTicker not supported yet');
            }
        }
    
        fetchTickers (symbols = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchTickers not supported yet')
        }
    
        fetchOrder (id, symbol = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchOrder not supported yet');
        }
    
        fetchUnifiedOrder (order, params = {}) {
            return this.fetchOrder (this.safeValue (order, 'id'), this.safeValue (order, 'symbol'), params);
        }
    
        createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            throw new NotSupported (this.id + ' createOrder not supported yet');
        }
    
        cancelOrder (id, symbol = undefined, params = {}) {
            throw new NotSupported (this.id + ' cancelOrder not supported yet');
        }
    
        cancelUnifiedOrder (order, params = {}) {
            return this.cancelOrder (this.safeValue (order, 'id'), this.safeValue (order, 'symbol'), params);
        }
    
        fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchOrders not supported yet');
        }
    
        fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchOpenOrders not supported yet');
        }
    
        fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchClosedOrders not supported yet');
        }
    
        fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchMyTrades not supported yet');
        }
    
        fetchTransactions (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchTransactions not supported yet');
        }
    
        fetchDeposits (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchDeposits not supported yet');
        }
    
        fetchWithdrawals (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchWithdrawals not supported yet');
        }
    
        async fetchDepositAddress (code, params = {}) {
            if (this.has['fetchDepositAddresses']) {
                const depositAddresses = await this.fetchDepositAddresses ([ code ], params);
                const depositAddress = this.safeValue (depositAddresses, code);
                if (depositAddress === undefined) {
                    throw new InvalidAddress (this.id + ' fetchDepositAddress could not find a deposit address for ' + code + ', make sure you have created a corresponding deposit address in your wallet on the exchange website');
                } else {
                    return depositAddress;
                }
            } else {
                throw new NotSupported (this.id + ' fetchDepositAddress not supported yet');
            }
        }
    
        fetchCurrencies (params = {}) {
            // markets are returned as a list
            // currencies are returned as a dict
            // this is for historical reasons
            // and may be changed for consistency later
            return new Promise ((resolve, reject) => resolve (this.currencies));
        }
    
        fetchMarkets (params = {}) {
            // markets are returned as a list
            // currencies are returned as a dict
            // this is for historical reasons
            // and may be changed for consistency later
            return new Promise ((resolve, reject) => resolve (Object.values (this.markets)))
        }
    
        async fetchOrderStatus (id, symbol = undefined, params = {}) {
            const order = await this.fetchOrder (id, symbol, params);
            return order['status'];
        }
    
        account () {
            return {
                'free': undefined,
                'used': undefined,
                'total': undefined,
            }
        }
    
        commonCurrencyCode (currency) {
            if (!this.substituteCommonCurrencyCodes) {
                return currency
            }
            return this.safeString (this.commonCurrencies, currency, currency)
        }
    
        currency (code) {
    
            if (this.currencies === undefined) {
                throw new ExchangeError (this.id + ' currencies not loaded')
            }
    
            if ((typeof code === 'string') && (code in this.currencies)) {
                return this.currencies[code]
            }
    
            throw new ExchangeError (this.id + ' does not have currency code ' + code)
        }
    
        market (symbol) {
    
            if (this.markets === undefined) {
                throw new ExchangeError (this.id + ' markets not loaded')
            }
    
            if (typeof symbol === 'string') {
                if (symbol in this.markets) {
                    return this.markets[symbol]
                } else if (symbol in this.markets_by_id) {
                    return this.markets_by_id[symbol]
                }
            }
    
            throw new BadSymbol (this.id + ' does not have market symbol ' + symbol)
        }
    
        marketId (symbol) {
            const market = this.market (symbol)
            return (market !== undefined ? market['id'] : symbol)
        }
    
        marketIds (symbols) {
            return symbols.map ((symbol) => this.marketId (symbol))
        }
    
        symbol (symbol) {
            return this.market (symbol).symbol || symbol
        }
    
        implodeHostname (url) {
            return this.implodeParams (url, { 'hostname': this.hostname })
        }
    
        parseBidAsk (bidask, priceKey = 0, amountKey = 1) {
            const price = this.safeNumber (bidask, priceKey)
            const amount = this.safeNumber (bidask, amountKey)
            return [ price, amount ]
        }
    
        parseBidsAsks (bidasks, priceKey = 0, amountKey = 1) {
            return Object.values (bidasks || []).map ((bidask) => this.parseBidAsk (bidask, priceKey, amountKey))
        }
    
        async fetchL2OrderBook (symbol, limit = undefined, params = {}) {
            const orderbook = await this.fetchOrderBook (symbol, limit, params)
            return extend (orderbook, {
                'bids': sortBy (aggregate (orderbook.bids), 0, true),
                'asks': sortBy (aggregate (orderbook.asks), 0),
            })
        }
    
        parseOrderBook (orderbook, symbol, timestamp = undefined, bidsKey = 'bids', asksKey = 'asks', priceKey = 0, amountKey = 1) {
            return {
                'symbol': symbol,
                'bids': sortBy ((bidsKey in orderbook) ? this.parseBidsAsks (orderbook[bidsKey], priceKey, amountKey) : [], 0, true),
                'asks': sortBy ((asksKey in orderbook) ? this.parseBidsAsks (orderbook[asksKey], priceKey, amountKey) : [], 0),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'nonce': undefined,
            }
        }
    
        parseBalance (balance, legacy = false) {
    
            const codes = Object.keys (this.omit (balance, [ 'info', 'timestamp', 'datetime', 'free', 'used', 'total' ]));
    
            balance['free'] = {}
            balance['used'] = {}
            balance['total'] = {}
    
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i]
                if (balance[code].total === undefined) {
                    if (balance[code].free !== undefined && balance[code].used !== undefined) {
                        if (legacy) {
                            balance[code].total = this.sum (balance[code].free, balance[code].used)
                        } else {
                            balance[code].total = Precise.stringAdd (balance[code].free, balance[code].used)
                        }
                    }
                }
                if (balance[code].free === undefined) {
                    if (balance[code].total !== undefined && balance[code].used !== undefined) {
                        if (legacy) {
                            balance[code].free = this.sum (balance[code].total, -balance[code].used)
                        } else {
                            balance[code].free = Precise.stringSub (balance[code].total, balance[code].used)
                        }
                    }
                }
                if (balance[code].used === undefined) {
                    if (balance[code].total !== undefined && balance[code].free !== undefined) {
                        if (legacy) {
                            balance[code].used = this.sum (balance[code].total, -balance[code].free)
                        } else {
                            balance[code].used = Precise.stringSub (balance[code].total, balance[code].free)
                        }
                    }
                }
                balance[code].free = this.parseNumber (balance[code].free)
                balance[code].used = this.parseNumber (balance[code].used)
                balance[code].total = this.parseNumber (balance[code].total)
                balance.free[code] = balance[code].free
                balance.used[code] = balance[code].used
                balance.total[code] = balance[code].total
            }
    
            return balance
        }
    
        async fetchBalance (params = {}) {
            throw new NotSupported (this.id + ' fetchBalance not supported yet')
        }
    
        async fetchPartialBalance (part, params = {}) {
            const balance = await this.fetchBalance (params)
            return balance[part]
        }
    
        fetchFreeBalance (params = {}) {
            return this.fetchPartialBalance ('free', params)
        }
    
        fetchUsedBalance (params = {}) {
            return this.fetchPartialBalance ('used', params)
        }
    
        fetchTotalBalance (params = {}) {
            return this.fetchPartialBalance ('total', params)
        }
    
        async fetchStatus (params = {}) {
            if (this.has['fetchTime']) {
                const time = await this.fetchTime (params)
                this.status = this.extend (this.status, {
                    'updated': time,
                })
            }
            return this.status
        }
    
        async fetchTradingFees (params = {}) {
            throw new NotSupported (this.id + ' fetchTradingFees not supported yet')
        }
    
        async fetchTradingFee (symbol, params = {}) {
            if (!this.has['fetchTradingFees']) {
                throw new NotSupported (this.id + ' fetchTradingFee not supported yet')
            }
            return await this.fetchTradingFees (params)
        }
    
        async loadTradingLimits (symbols = undefined, reload = false, params = {}) {
            if (this.has['fetchTradingLimits']) {
                if (reload || !('limitsLoaded' in this.options)) {
                    const response = await this.fetchTradingLimits (symbols);
                    for (let i = 0; i < symbols.length; i++) {
                        const symbol = symbols[i];
                        this.markets[symbol] = this.deepExtend (this.markets[symbol], response[symbol]);
                    }
                    this.options['limitsLoaded'] = this.milliseconds ();
                }
            }
            return this.markets;
        }
    
        filterBySinceLimit (array, since = undefined, limit = undefined, key = 'timestamp', tail = false) {
            const sinceIsDefined = (since !== undefined && since !== null)
            if (sinceIsDefined) {
                array = array.filter ((entry) => entry[key] >= since)
            }
            if (limit !== undefined && limit !== null) {
                array = tail ? array.slice (-limit) : array.slice (0, limit)
            }
            return array
        }
    
        filterByValueSinceLimit (array, field, value = undefined, since = undefined, limit = undefined, key = 'timestamp', tail = false) {
    
            const valueIsDefined = value !== undefined && value !== null
            const sinceIsDefined = since !== undefined && since !== null
    
            // single-pass filter for both symbol and since
            if (valueIsDefined || sinceIsDefined) {
                array = array.filter ((entry) =>
                    ((valueIsDefined ? (entry[field] === value) : true) &&
                     (sinceIsDefined ? (entry[key] >= since) : true)))
            }
    
            if (limit !== undefined && limit !== null) {
                array = tail ? array.slice (-limit) : array.slice (0, limit)
            }
    
            return array
        }
    
        filterBySymbolSinceLimit (array, symbol = undefined, since = undefined, limit = undefined, tail = false) {
            return this.filterByValueSinceLimit (array, 'symbol', symbol, since, limit, 'timestamp', tail)
        }
    
        filterByCurrencySinceLimit (array, code = undefined, since = undefined, limit = undefined, tail = false) {
            return this.filterByValueSinceLimit (array, 'currency', code, since, limit, 'timestamp', tail)
        }
    
        filterByArray (objects, key, values = undefined, indexed = true) {
    
            objects = Object.values (objects)
    
            // return all of them if no values were passed
            if (values === undefined || values === null) {
                return indexed ? indexBy (objects, key) : objects
            }
    
            const result = []
            for (let i = 0; i < objects.length; i++) {
                if (values.includes (objects[i][key])) {
                    result.push (objects[i])
                }
            }
    
            return indexed ? indexBy (result, key) : result
        }
    
        safeTicker (ticker, market = undefined) {
            let symbol = this.safeValue (ticker, 'symbol');
            if (symbol === undefined) {
                symbol = this.safeSymbol (undefined, market);
            }
            const timestamp = this.safeInteger (ticker, 'timestamp');
            const baseVolume = this.safeValue (ticker, 'baseVolume');
            const quoteVolume = this.safeValue (ticker, 'quoteVolume');
            let vwap = this.safeValue (ticker, 'vwap');
            if (vwap === undefined) {
                vwap = this.vwap (baseVolume, quoteVolume);
            }
            let open = this.safeValue (ticker, 'open');
            let close = this.safeValue (ticker, 'close');
            let last = this.safeValue (ticker, 'last');
            let change = this.safeValue (ticker, 'change');
            let percentage = this.safeValue (ticker, 'percentage');
            let average = this.safeValue (ticker, 'average');
            if ((last !== undefined) && (close === undefined)) {
                close = last;
            } else if ((last === undefined) && (close !== undefined)) {
                last = close;
            }
            if ((last !== undefined) && (open !== undefined)) {
                if (change === undefined) {
                    change = last - open;
                }
                if (average === undefined) {
                    average = this.sum (last, open) / 2;
                }
            }
            if ((percentage === undefined) && (change !== undefined) && (open !== undefined) && (open > 0)) {
                percentage = change / open * 100;
            }
            if ((change === undefined) && (percentage !== undefined) && (last !== undefined)) {
                change = percentage / 100 * last;
            }
            if ((open === undefined) && (last !== undefined) && (change !== undefined)) {
                open = last - change;
            }
            ticker['symbol'] = symbol;
            ticker['timestamp'] = timestamp;
            ticker['datetime'] = this.iso8601 (timestamp);
            ticker['open'] = open;
            ticker['close'] = close;
            ticker['last'] = last;
            ticker['vwap'] = vwap;
            ticker['change'] = change;
            ticker['percentage'] = percentage;
            ticker['average'] = average;
            return ticker;
        }
    
        parseTickers (tickers, symbols = undefined, params = {}) {
            const result = [];
            const values = Object.values (tickers || []);
            for (let i = 0; i < values.length; i++) {
                result.push (this.extend (this.parseTicker (values[i]), params));
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        parseDepositAddresses (addresses, codes = undefined) {
            let result = [];
            for (let i = 0; i < addresses.length; i++) {
                const address = this.parseDepositAddress (addresses[i]);
                result.push (address);
            }
            if (codes) {
                result = this.filterByArray (result, 'currency', codes);
            }
            return this.indexBy (result, 'currency');
        }
    
        parseTrades (trades, market = undefined, since = undefined, limit = undefined, params = {}) {
            let result = Object.values (trades || []).map ((trade) => this.extend (this.parseTrade (trade, market), params))
            result = sortBy (result, 'timestamp')
            const symbol = (market !== undefined) ? market['symbol'] : undefined
            const tail = since === undefined
            return this.filterBySymbolSinceLimit (result, symbol, since, limit, tail)
        }
    
        parseTransactions (transactions, currency = undefined, since = undefined, limit = undefined, params = {}) {
            let result = Object.values (transactions || []).map ((transaction) => this.extend (this.parseTransaction (transaction, currency), params))
            result = this.sortBy (result, 'timestamp');
            const code = (currency !== undefined) ? currency['code'] : undefined;
            const tail = since === undefined;
            return this.filterByCurrencySinceLimit (result, code, since, limit, tail);
        }
    
        parseTransfers (transfers, currency = undefined, since = undefined, limit = undefined, params = {}) {
            let result = Object.values (transfers || []).map ((transfer) => this.extend (this.parseTransfer (transfer, currency), params))
            result = this.sortBy (result, 'timestamp');
            const code = (currency !== undefined) ? currency['code'] : undefined;
            const tail = since === undefined;
            return this.filterByCurrencySinceLimit (result, code, since, limit, tail);
        }
    
        parseLedger (data, currency = undefined, since = undefined, limit = undefined, params = {}) {
            let result = [];
            const array = Object.values (data || []);
            for (let i = 0; i < array.length; i++) {
                const itemOrItems = this.parseLedgerEntry (array[i], currency);
                if (Array.isArray (itemOrItems)) {
                    for (let j = 0; j < itemOrItems.length; j++) {
                        result.push (this.extend (itemOrItems[j], params));
                    }
                } else {
                    result.push (this.extend (itemOrItems, params));
                }
            }
            result = this.sortBy (result, 'timestamp');
            const code = (currency !== undefined) ? currency['code'] : undefined;
            const tail = since === undefined;
            return this.filterByCurrencySinceLimit (result, code, since, limit, tail);
        }
    
        parseOrders (orders, market = undefined, since = undefined, limit = undefined, params = {}) {
            //
            // the value of orders is either a dict or a list
            //
            // dict
            //
            //     {
            //         'id1': { ... },
            //         'id2': { ... },
            //         'id3': { ... },
            //         ...
            //     }
            //
            // list
            //
            //     [
            //         { 'id': 'id1', ... },
            //         { 'id': 'id2', ... },
            //         { 'id': 'id3', ... },
            //         ...
            //     ]
            //
            let result = Array.isArray (orders) ?
                Object.values (orders).map ((order) => this.extend (this.parseOrder (order, market), params)) :
                Object.entries (orders).map (([ id, order ]) => this.extend (this.parseOrder (this.extend ({ 'id': id }, order), market), params))
            result = sortBy (result, 'timestamp')
            const symbol = (market !== undefined) ? market['symbol'] : undefined
            const tail = since === undefined
            return this.filterBySymbolSinceLimit (result, symbol, since, limit, tail)
        }
    
        safeCurrency (currencyId, currency = undefined) {
            if ((currencyId === undefined) && (currency !== undefined)) {
                return currency
            }
            if ((this.currencies_by_id !== undefined) && (currencyId in this.currencies_by_id)) {
                return this.currencies_by_id[currencyId]
            }
            return {
                'id': currencyId,
                'code': (currencyId === undefined) ? currencyId : this.commonCurrencyCode (currencyId.toUpperCase ()),
            }
        }
    
        safeCurrencyCode (currencyId, currency = undefined) {
            currency = this.safeCurrency (currencyId, currency)
            return currency['code']
        }
    
        safeMarket (marketId, market = undefined, delimiter = undefined) {
            if (marketId !== undefined) {
                if (this.markets_by_id !== undefined && marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId]
                } else if (delimiter !== undefined) {
                    const [ baseId, quoteId ] = marketId.split (delimiter)
                    const base = this.safeCurrencyCode (baseId)
                    const quote = this.safeCurrencyCode (quoteId)
                    const symbol = base + '/' + quote
                    return {
                        'id': marketId,
                        'symbol': symbol,
                        'base': base,
                        'quote': quote,
                        'baseId': baseId,
                        'quoteId': quoteId,
                    }
                }
            }
            if (market !== undefined) {
                return market
            }
            return {
                'id': marketId,
                'symbol': marketId,
                'base': undefined,
                'quote': undefined,
                'baseId': undefined,
                'quoteId': undefined,
            }
        }
    
        safeSymbol (marketId, market = undefined, delimiter = undefined) {
            market = this.safeMarket (marketId, market, delimiter)
            return market['symbol'];
        }
    
        filterBySymbol (array, symbol = undefined) {
            return ((symbol !== undefined) ? array.filter ((entry) => entry.symbol === symbol) : array)
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            return Array.isArray (ohlcv) ? ohlcv.slice (0, 6) : ohlcv
        }
    
        parseOHLCVs (ohlcvs, market = undefined, timeframe = '1m', since = undefined, limit = undefined) {
            // this code is commented out temporarily to catch for exchange-specific errors
            // if (!this.isArray (ohlcvs)) {
            //     throw new ExchangeError (this.id + ' parseOHLCVs expected an array in the ohlcvs argument, but got ' + typeof ohlcvs);
            // }
            const parsed = ohlcvs.map ((ohlcv) => this.parseOHLCV (ohlcv, market))
            const sorted = this.sortBy (parsed, 0)
            const tail = since === undefined
            return this.filterBySinceLimit (sorted, since, limit, 0, tail)
        }
    
        editLimitBuyOrder (id, symbol, ...args) {
            return this.editLimitOrder (id, symbol, 'buy', ...args)
        }
    
        editLimitSellOrder (id, symbol, ...args) {
            return this.editLimitOrder (id, symbol, 'sell', ...args)
        }
    
        editLimitOrder (id, symbol, ...args) {
            return this.editOrder (id, symbol, 'limit', ...args)
        }
    
        async editOrder (id, symbol, ...args) {
            if (!this.enableRateLimit) {
                throw new ExchangeError (this.id + ' editOrder() requires enableRateLimit = true')
            }
            await this.cancelOrder (id, symbol);
            return this.createOrder (symbol, ...args)
        }
    
        createLimitOrder (symbol, side, amount, price, params = {}) {
            return this.createOrder (symbol, 'limit', side, amount, price, params)
        }
    
        createMarketOrder (symbol, side, amount, price, params = {}) {
            return this.createOrder (symbol, 'market', side, amount, price, params)
        }
    
        createLimitBuyOrder (symbol, amount, price, params = {}) {
            return this.createOrder  (symbol, 'limit', 'buy', amount, price, params)
        }
    
        createLimitSellOrder (symbol, amount, price, params = {}) {
            return this.createOrder (symbol, 'limit', 'sell', amount, price, params)
        }
    
        createMarketBuyOrder (symbol, amount, params = {}) {
            return this.createOrder (symbol, 'market', 'buy', amount, undefined, params)
        }
    
        createMarketSellOrder (symbol, amount, params = {}) {
            return this.createOrder (symbol, 'market', 'sell', amount, undefined, params)
        }
    
        costToPrecision (symbol, cost) {
            const market = this.market (symbol)
            return decimalToPrecision (cost, TRUNCATE, market.precision.price, this.precisionMode, this.paddingMode)
        }
    
        priceToPrecision (symbol, price) {
            const market = this.market (symbol)
            return decimalToPrecision (price, ROUND, market.precision.price, this.precisionMode, this.paddingMode)
        }
    
        amountToPrecision (symbol, amount) {
            const market = this.market (symbol)
            return decimalToPrecision (amount, TRUNCATE, market.precision.amount, this.precisionMode, this.paddingMode)
        }
    
        feeToPrecision (symbol, fee) {
            const market = this.market (symbol)
            return decimalToPrecision (fee, ROUND, market.precision.price, this.precisionMode, this.paddingMode)
        }
    
        currencyToPrecision (currency, fee) {
            return decimalToPrecision (fee, ROUND, this.currencies[currency]['precision'], this.precisionMode, this.paddingMode);
        }
    
        calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
            const market = this.markets[symbol];
            const feeSide = this.safeString (market, 'feeSide', 'quote');
            let key = 'quote';
            let cost = undefined;
            if (feeSide === 'quote') {
                // the fee is always in quote currency
                cost = amount * price;
            } else if (feeSide === 'base') {
                // the fee is always in base currency
                cost = amount;
            } else if (feeSide === 'get') {
                // the fee is always in the currency you get
                cost = amount;
                if (side === 'sell') {
                    cost *= price;
                } else {
                    key = 'base';
                }
            } else if (feeSide === 'give') {
                // the fee is always in the currency you give
                cost = amount;
                if (side === 'buy') {
                    cost *= price;
                } else {
                    key = 'base';
                }
            }
            const rate = market[takerOrMaker];
            if (cost !== undefined) {
                cost *= rate;
            }
            return {
                'type': takerOrMaker,
                'currency': market[key],
                'rate': rate,
                'cost': cost,
            };
        }
    
        checkRequiredDependencies () {
            return
        }
    
        remove0xPrefix (hexData) {
            if (hexData.slice (0, 2) === '0x') {
                return hexData.slice (2)
            } else {
                return hexData
            }
        }
    
        hashMessage (message) {
            // takes a hex encoded message
            const binaryMessage = this.base16ToBinary (this.remove0xPrefix (message))
            const prefix = this.stringToBinary ('\x19Ethereum Signed Message:\n' + binaryMessage.sigBytes)
            return '0x' + this.hash (this.binaryConcat (prefix, binaryMessage), 'keccak', 'hex')
        }
    
        signHash (hash, privateKey) {
            const signature = this.ecdsa (hash.slice (-64), privateKey.slice (-64), 'secp256k1', undefined)
            return {
                'r': '0x' + signature['r'],
                's': '0x' + signature['s'],
                'v': 27 + signature['v'],
            }
        }
    
        signMessage (message, privateKey) {
            return this.signHash (this.hashMessage (message), privateKey.slice (-64))
        }
    
        signMessageString (message, privateKey) {
            // still takes the input as a hex string
            // same as above but returns a string instead of an object
            const signature = this.signMessage (message, privateKey)
            return signature['r'] + this.remove0xPrefix (signature['s']) + this.binaryToBase16 (this.numberToBE (signature['v']))
        }
    
        oath () {
            if (typeof this.twofa !== 'undefined') {
                return this.totp (this.twofa)
            } else {
                throw new ExchangeError (this.id + ' this.twofa has not been set')
            }
        }
    
        reduceFeesByCurrency (fees) {
            const reduced = {};
            for (let i = 0; i < fees.length; i++) {
                const fee = fees[i];
                const feeCurrencyCode = this.safeValue (fee, 'currency');
                if (feeCurrencyCode !== undefined) {
                    if (feeCurrencyCode in reduced) {
                        reduced[feeCurrencyCode]['cost'] = this.sum (reduced[feeCurrencyCode]['cost'], fee['cost']);
                    } else {
                        reduced[feeCurrencyCode] = {
                            'cost': fee['cost'],
                            'currency': feeCurrencyCode,
                        };
                    }
                }
            }
            return Object.values (reduced);
        }
    
        safeOrder (order) {
            // Cost
            // Remaining
            // Average
            // Price
            // Amount
            // Filled
            //
            // first we try to calculate the order fields from the trades
            let amount = this.safeValue (order, 'amount');
            let remaining = this.safeValue (order, 'remaining');
            let filled = this.safeValue (order, 'filled');
            let cost = this.safeValue (order, 'cost');
            let average = this.safeValue (order, 'average');
            let price = this.safeValue (order, 'price');
            let lastTradeTimeTimestamp = this.safeInteger (order, 'lastTradeTimestamp');
            const parseFilled = (filled === undefined);
            const parseCost = (cost === undefined);
            const parseLastTradeTimeTimestamp = (lastTradeTimeTimestamp === undefined);
            const parseFee = this.safeValue (order, 'fee') === undefined;
            const parseFees = this.safeValue (order, 'fees') === undefined;
            const shouldParseFees = parseFee || parseFees;
            const fees = this.safeValue (order, 'fees', []);
            if (parseFilled || parseCost || shouldParseFees) {
                const trades = this.safeValue (order, 'trades');
                if (Array.isArray (trades)) {
                    if (parseFilled) {
                        filled = 0;
                    }
                    if (parseCost) {
                        cost = 0;
                    }
                    for (let i = 0; i < trades.length; i++) {
                        const trade = trades[i];
                        const tradeAmount = this.safeValue (trade, 'amount');
                        if (parseFilled && (tradeAmount !== undefined)) {
                            filled = this.sum (filled, tradeAmount);
                        }
                        const tradeCost = this.safeValue (trade, 'cost');
                        if (parseCost && (tradeCost !== undefined)) {
                            cost = this.sum (cost, tradeCost);
                        }
                        const tradeTimestamp = this.safeValue (trade, 'timestamp');
                        if (parseLastTradeTimeTimestamp && (tradeTimestamp !== undefined)) {
                            if (lastTradeTimeTimestamp === undefined) {
                                lastTradeTimeTimestamp = tradeTimestamp;
                            } else {
                                lastTradeTimeTimestamp = Math.max (lastTradeTimeTimestamp, tradeTimestamp);
                            }
                        }
                        if (shouldParseFees) {
                            const tradeFees = this.safeValue (trade, 'fees');
                            if (tradeFees !== undefined) {
                                for (let j = 0; j < tradeFees.length; j++) {
                                    const tradeFee = tradeFees[j];
                                    fees.push (this.extend ({}, tradeFee));
                                }
                            } else {
                                const tradeFee = this.safeValue (trade, 'fee');
                                if (tradeFee !== undefined) {
                                    fees.push (this.extend ({}, tradeFee));
                                }
                            }
                        }
                    }
                }
            }
            if (shouldParseFees) {
                const reducedFees = this.reduceFees ? this.reduceFeesByCurrency (fees) : fees;
                const reducedLength = reducedFees.length;
                if (!parseFee && (reducedLength === 0)) {
                    reducedFees.push (order['fee']);
                }
                if (parseFees) {
                    order['fees'] = reducedFees;
                }
                if (parseFee && (reducedLength === 1)) {
                    order['fee'] = reducedFees[0];
                }
            }
            if (amount === undefined) {
                // ensure amount = filled + remaining
                if (filled !== undefined && remaining !== undefined) {
                    amount = this.sum (filled, remaining);
                } else if (this.safeString (order, 'status') === 'closed') {
                    amount = filled;
                }
            }
            if (filled === undefined) {
                if (amount !== undefined && remaining !== undefined) {
                    filled = Math.max (this.sum (amount, -remaining), 0);
                }
            }
            if (remaining === undefined) {
                if (amount !== undefined && filled !== undefined) {
                    remaining = Math.max (this.sum (amount, -filled), 0);
                }
            }
            // ensure that the average field is calculated correctly
            if (average === undefined) {
                if ((filled !== undefined) && (cost !== undefined) && (filled > 0)) {
                    average = cost / filled;
                }
            }
            // also ensure the cost field is calculated correctly
            const costPriceExists = (average !== undefined) || (price !== undefined);
            if (parseCost && (filled !== undefined) && costPriceExists) {
                cost = (average === undefined) ? (price * filled) : (average * filled);
            }
            // support for market orders
            const orderType = this.safeValue (order, 'type');
            const emptyPrice = (price === undefined) || (price === 0.0);
            if (emptyPrice && (orderType === 'market')) {
                price = average;
            }
            return this.extend (order, {
                'lastTradeTimestamp': lastTradeTimeTimestamp,
                'price': price,
                'amount': amount,
                'cost': cost,
                'average': average,
                'filled': filled,
                'remaining': remaining,
            });
        }
    
        parseNumber (value, d = undefined) {
            if (value === undefined) {
                return d
            } else {
                try {
                    return this.number (value)
                } catch (e) {
                    return d
                }
            }
        }
    
        safeNumber (object, key, d = undefined) {
            const value = this.safeString (object, key)
            return this.parseNumber (value, d)
        }
    
        safeNumber2 (object, key1, key2, d = undefined) {
            const value = this.safeString2 (object, key1, key2)
            return this.parseNumber (value, d)
        }
    
        parsePrecision (precision) {
            if (precision === undefined) {
                return undefined
            }
            return '1e' + Precise.stringNeg (precision)
        }
    }
    
    },{"../static_dependencies/BN/bn":117,"./Precise":7,"./errors":9,"./functions":10}],7:[function(require,module,exports){
    'use strict'
    
    const zero = BigInt (0)
    const minusOne = BigInt (-1)
    const base = BigInt (10)
    
    class Precise {
        constructor (number, decimals = undefined) {
            if (decimals === undefined) {
                let modifier = 0
                number = number.toLowerCase ()
                if (number.indexOf ('e') > -1) {
                    [ number, modifier ] = number.split ('e')
                    modifier = parseInt (modifier)
                }
                const decimalIndex = number.indexOf ('.')
                this.decimals = (decimalIndex > -1) ? number.length - decimalIndex - 1 : 0
                const integerString = number.replace ('.', '')
                this.integer = BigInt (integerString)
                this.decimals = this.decimals - modifier
            } else {
                this.integer = number
                this.decimals = decimals
            }
        }
    
        mul (other) {
            // other must be another instance of Precise
            const integerResult = this.integer * other.integer
            return new Precise (integerResult, this.decimals + other.decimals)
        }
    
        div (other, precision = 18) {
            const distance = precision - this.decimals + other.decimals
            let numerator
            if (distance === 0) {
                numerator = this.integer
            } else if (distance < 0) {
                const exponent = base ** BigInt (-distance)
                numerator = this.integer / exponent
            } else {
                const exponent = base ** BigInt (distance)
                numerator = this.integer * exponent
            }
            const result = numerator / other.integer
            return new Precise (result, precision)
        }
    
        add (other) {
            if (this.decimals === other.decimals) {
                const integerResult = this.integer + other.integer
                return new Precise (integerResult, this.decimals)
            } else {
                const [ smaller, bigger ] =
                    (this.decimals > other.decimals) ? [ other, this ] : [ this, other ]
                const exponent = bigger.decimals - smaller.decimals
                const normalised = smaller.integer * (base ** BigInt (exponent))
                const result = normalised + bigger.integer
                return new Precise (result, bigger.decimals)
            }
        }
    
        mod (other) {
            const rationizerNumerator = Math.max (-this.decimals + other.decimals, 0)
            const numerator = this.integer * (base ** BigInt (rationizerNumerator))
            const rationizerDenominator = Math.max (-other.decimals + this.decimals, 0)
            const denominator = other.integer * (base ** BigInt (rationizerDenominator))
            const result = numerator % denominator
            return new Precise (result, rationizerDenominator + other.decimals)
        }
    
        sub (other) {
            const negative = new Precise (-other.integer, other.decimals)
            return this.add (negative)
        }
    
        abs () {
            return new Precise (this.integer < 0 ? this.integer * minusOne : this.integer, this.decimals)
        }
    
        neg () {
            return new Precise (-this.integer, this.decimals)
        }
    
        min (other) {
            return this.lt (other) ? this : other
        }
    
        max (other) {
            return this.gt (other) ? this : other
        }
    
        gt (other) {
            const sum = this.sub (other)
            return sum.integer > 0
        }
    
        ge (other) {
            const sum = this.sub (other)
            return sum.integer >= 0
        }
    
        lt (other) {
            return other.gt (this)
        }
    
        le (other) {
            return other.ge (this)
        }
    
        reduce () {
            const string = this.integer.toString ()
            const start = string.length - 1
            if (start === 0) {
                if (string === '0') {
                    this.decimals = 0
                }
                return this
            }
            let i
            for (i = start; i >= 0; i--) {
                if (string.charAt (i) !== '0') {
                    break
                }
            }
            const difference = start - i
            if (difference === 0) {
                return this
            }
            this.decimals -= difference
            this.integer = BigInt (string.slice (0, i + 1))
        }
    
        equals (other) {
            this.reduce ()
            other.reduce ()
            return (this.decimals === other.decimals) && (this.integer === other.integer)
        }
    
        toString () {
            this.reduce ()
            let sign
            let abs
            if (this.integer < 0) {
                sign = '-'
                abs = -this.integer
            } else {
                sign = ''
                abs = this.integer
            }
            const integerArray = Array.from (abs.toString (this.base).padStart (this.decimals, '0'))
            const index = integerArray.length - this.decimals
            let item
            if (index === 0) {
                // if we are adding to the front
                item = '0.'
            } else if (this.decimals < 0) {
                item = '0'.repeat (-this.decimals)
            } else if (this.decimals === 0) {
                item = ''
            } else {
                item = '.'
            }
            integerArray.splice (index, 0, item)
            return sign + integerArray.join ('')
        }
    
        static stringMul (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).mul (new Precise (string2)).toString ()
        }
    
        static stringDiv (string1, string2, precision = 18) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).div (new Precise (string2), precision).toString ()
        }
    
        static stringAdd (string1, string2) {
            if ((string1 === undefined) && (string2 === undefined)) {
                return undefined
            }
            if (string1 === undefined) {
                return string2
            } else if (string2 === undefined) {
                return string1
            }
            return (new Precise (string1)).add (new Precise (string2)).toString ()
        }
    
        static stringSub (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).sub (new Precise (string2)).toString ()
        }
    
        static stringAbs (string) {
            if (string === undefined) {
                return undefined
            }
            return (new Precise (string)).abs ().toString ()
        }
    
        static stringNeg (string) {
            if (string === undefined) {
                return undefined
            }
            return (new Precise (string)).neg ().toString ()
        }
    
        static stringMod (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).mod (new Precise (string2)).toString ()
        }
    
        static stringEquals (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).equals (new Precise (string2))
        }
    
        static stringMin (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).min (new Precise (string2)).toString ()
        }
    
        static stringMax (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).max (new Precise (string2)).toString ()
        }
    
        static stringGt (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).gt (new Precise (string2))
        }
    
        static stringGe (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).ge (new Precise (string2))
        }
    
        static stringLt (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).lt (new Precise (string2))
        }
    
        static stringLe (string1, string2) {
            if ((string1 === undefined) || (string2 === undefined)) {
                return undefined
            }
            return (new Precise (string1)).le (new Precise (string2))
        }
    }
    
    module.exports = Precise;
    
    },{}],8:[function(require,module,exports){
    'use strict';
    
    const errorHierarchy = {
        'BaseError': {
            'ExchangeError': {
                'AuthenticationError': {
                    'PermissionDenied': {},
                    'AccountSuspended': {},
                },
                'ArgumentsRequired': {},
                'BadRequest': {
                    'BadSymbol': {},
                },
                'BadResponse': {
                    'NullResponse': {},
                },
                'InsufficientFunds': {},
                'InvalidAddress': {
                    'AddressPending': {},
                },
                'InvalidOrder': {
                    'OrderNotFound': {},
                    'OrderNotCached': {},
                    'CancelPending': {},
                    'OrderImmediatelyFillable': {},
                    'OrderNotFillable': {},
                    'DuplicateOrderId': {},
                },
                'NotSupported': {},
            },
            'NetworkError': {
                'DDoSProtection': {
                    'RateLimitExceeded': {},
                },
                'ExchangeNotAvailable': {
                    'OnMaintenance': {},
                },
                'InvalidNonce': {},
                'RequestTimeout': {},
            },
        },
    };
    
    module.exports = errorHierarchy;
    
    },{}],9:[function(require,module,exports){
    'use strict';
    
    const errorHierarchy = require ('./errorHierarchy.js')
    
    /*  ------------------------------------------------------------------------ */
    
    function subclass (BaseClass, classes, namespace = {}) {
    
        for (const [className, subclasses] of Object.entries (classes)) {
    
            const Class = Object.assign (namespace, {
    
            /*  By creating a named property, we trick compiler to assign our class constructor function a name.
                Otherwise, all our error constructors would be shown as [Function: Error] in the debugger! And
                the super-useful `e.constructor.name` magic wouldn't work — we then would have no chance to
                obtain a error type string from an error instance programmatically!                               */
    
                [className]: class extends BaseClass {
    
                    constructor (message) {
    
                        super (message)
    
                    /*  A workaround to make `instanceof` work on custom Error classes in transpiled ES5.
                        See my blog post for the explanation of this hack:
    
                        https://medium.com/@xpl/javascript-deriving-from-error-properly-8d2f8f315801        */
    
                        this.constructor = Class
                        this.__proto__   = Class.prototype
                        this.name        = className
                        this.message     = message
    
                        // https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-extending-built-ins-like-error-array-and-map-work
    
                        Object.setPrototypeOf (this, Class.prototype)
                    }
                }
    
            })[className]
    
            subclass (Class, subclasses, namespace)
        }
    
        return namespace
    }
    
    /*  ------------------------------------------------------------------------ */
    
    module.exports = subclass (
        // Root class
        Error,
        // Derived class hierarchy
        errorHierarchy
    )
    
    },{"./errorHierarchy.js":8}],10:[function(require,module,exports){
    'use strict';
    
    /*  ------------------------------------------------------------------------ */
    
    const { unCamelCase } = require ('./functions/string')
    
    const unCamelCasePropertyNames = x => {
        for (const k in x) x[unCamelCase (k)] = x[k] // camel_case_method = camelCaseMethod
        return x
    }
    
    /*  ------------------------------------------------------------------------ */
    
    module.exports = unCamelCasePropertyNames (Object.assign ({}
    
        , require ('./functions/platform')
        , require ('./functions/generic')
        , require ('./functions/string')
        , require ('./functions/type')
        , require ('./functions/number')
        , require ('./functions/encode')
        , require ('./functions/crypto')
        , require ('./functions/time')
        , require ('./functions/throttle')
        , require ('./functions/misc')
    ))
    
    /*  ------------------------------------------------------------------------ */
    
    },{"./functions/crypto":11,"./functions/encode":12,"./functions/generic":13,"./functions/misc":14,"./functions/number":15,"./functions/platform":16,"./functions/string":17,"./functions/throttle":18,"./functions/time":19,"./functions/type":20}],11:[function(require,module,exports){
    'use strict'
    
    /*  ------------------------------------------------------------------------ */
    
    const CryptoJS = require ('../../static_dependencies/crypto-js/crypto-js')
    const { capitalize } = require ('./string')
    const { stringToBase64, urlencodeBase64 } = require ('./encode')
    const NodeRSA = require ('./../../static_dependencies/node-rsa/NodeRSA')
    const { binaryToBase58, byteArrayToWordArray } = require ('./encode')
    const elliptic = require ('./../../static_dependencies/elliptic/lib/elliptic')
    const EC = elliptic.ec
    const EDDSA = elliptic.eddsa
    const { ArgumentsRequired } = require ('./../errors')
    const BN = require ('../../static_dependencies/BN/bn.js')
    
    /*  ------------------------------------------------------------------------ */
    
    const hash = (request, hash = 'md5', digest = 'hex') => {
        const options = {}
        if (hash === 'keccak') {
            hash = 'SHA3'
            options['outputLength'] = 256
        }
        const result = CryptoJS[hash.toUpperCase ()] (request, options)
        return (digest === 'binary') ? result : result.toString (CryptoJS.enc[capitalize (digest)])
    }
    
    /*  .............................................   */
    
    const hmac = (request, secret, hash = 'sha256', digest = 'hex') => {
        const result = CryptoJS['Hmac' + hash.toUpperCase ()] (request, secret)
        if (digest) {
            const encoding = (digest === 'binary') ? 'Latin1' : capitalize (digest)
            return result.toString (CryptoJS.enc[capitalize (encoding)])
        }
        return result
    }
    
    /*  .............................................   */
    
    function rsa (request, secret, alg = 'RS256') {
        const algos = {
            'RS256': 'pkcs1-sha256',
            'RS512': 'pkcs1-sha512',
        }
        if (!(alg in algos)) {
            throw new ExchangeError (alg + ' is not a supported rsa signing algorithm.')
        }
        const algorithm = algos[alg]
        let key = new NodeRSA (secret, {
            'environment': 'browser',
            'signingScheme': algorithm,
        })
        return key.sign (request, 'base64', 'binary')
    }
    
    
    /**
     * @return {string}
     */
    function jwt (request, secret, alg = 'HS256') {
        const algos = {
            'HS256': 'sha256',
            'HS384': 'sha384',
            'HS512': 'sha512',
        };
        const encodedHeader = urlencodeBase64 (stringToBase64 (JSON.stringify ({ 'alg': alg, 'typ': 'JWT' })))
        const encodedData = urlencodeBase64 (stringToBase64 (JSON.stringify (request)))
        const token = [ encodedHeader, encodedData ].join ('.')
        const algoType = alg.slice (0, 2);
        const algorithm = algos[alg]
        let signature = undefined
        if (algoType === 'HS') {
            signature = urlencodeBase64 (hmac (token, secret, algorithm, 'base64'))
        } else if (algoType === 'RS') {
            signature = urlencodeBase64 (rsa (token, secret, alg))
        }
        return [ token, signature ].join ('.')
    }
    
    function ecdsa (request, secret, algorithm = 'p256', hashFunction = undefined, fixedLength = false) {
        let digest = request
        if (hashFunction !== undefined) {
            digest = hash (request, hashFunction, 'hex')
        }
        const curve = new EC (algorithm)
        let signature = curve.sign (digest, secret, 'hex',  { 'canonical': true })
        let counter = new BN ('0')
        const minimum_size = new BN ('1').shln (8 * 31).sub (new BN ('1'))
        while (fixedLength && (signature.r.gt (curve.nh) || signature.r.lte (minimum_size) || signature.s.lte (minimum_size))) {
            signature = curve.sign (digest, secret, 'hex',  { 'canonical': true, 'extraEntropy': counter.toArray ('le', 32)})
            counter = counter.add (new BN ('1'))
        }
        return {
            'r': signature.r.toString (16).padStart (64, '0'),
            's': signature.s.toString (16).padStart (64, '0'),
            'v': signature.recoveryParam,
        }
    }
    
    
    function eddsa (request, secret, algorithm = 'ed25519') {
        // used for waves.exchange (that's why the output is base58)
        const curve = new EDDSA (algorithm)
        const signature = curve.signModified (request, secret)
        return binaryToBase58 (byteArrayToWordArray (signature.toBytes ()))
    }
    
    /*  ------------------------------------------------------------------------ */
    
    const totp = (secret) => {
    
        const dec2hex = s => ((s < 15.5 ? '0' : '') + Math.round (s).toString (16))
            , hex2dec = s => parseInt (s, 16)
            , leftpad = (s, p) => (p + s).slice (-p.length) // both s and p are short strings
    
        const base32tohex = (base32) => {
            let base32chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
            let bits = ''
            let hex = ''
            for (let i = 0; i < base32.length; i++) {
                let val = base32chars.indexOf (base32.charAt (i).toUpperCase ())
                bits += leftpad (val.toString (2), '00000')
            }
            for (let i = 0; i + 4 <= bits.length; i += 4) {
                let chunk = bits.substr (i, 4)
                hex = hex + parseInt (chunk, 2).toString (16)
            }
            return hex
        }
    
        const getOTP = (secret) => {
            secret = secret.replace (' ', '') // support 2fa-secrets with spaces like "4TDV WOGO" → "4TDVWOGO"
            let epoch = Math.round (new Date ().getTime () / 1000.0)
            let time = leftpad (dec2hex (Math.floor (epoch / 30)), '0000000000000000')
            let hmacRes = hmac (CryptoJS.enc.Hex.parse (time), CryptoJS.enc.Hex.parse (base32tohex (secret)), 'sha1', 'hex')
            let offset = hex2dec (hmacRes.substring (hmacRes.length - 1))
            let otp = (hex2dec (hmacRes.substr (offset * 2, 8)) & hex2dec ('7fffffff')) + ''
            otp = (otp).substr (otp.length - 6, 6)
            return otp
        }
    
        return getOTP (secret)
    }
    
    /*  ------------------------------------------------------------------------ */
    
    module.exports = {
        hash,
        hmac,
        jwt,
        totp,
        rsa,
        ecdsa,
        eddsa,
    }
    
    /*  ------------------------------------------------------------------------ */
    
    },{"../../static_dependencies/BN/bn.js":117,"../../static_dependencies/crypto-js/crypto-js":118,"./../../static_dependencies/elliptic/lib/elliptic":119,"./../../static_dependencies/node-rsa/NodeRSA":137,"./../errors":9,"./encode":12,"./string":17}],12:[function(require,module,exports){
    "use strict";
    
    /*  ------------------------------------------------------------------------ */
    
    const CryptoJS = require ('../../static_dependencies/crypto-js/crypto-js')
    const qs       = require ('../../static_dependencies/qs/index')
    const BN = require ('../../static_dependencies/BN/bn')
    
    
    /*  ------------------------------------------------------------------------ */
    
    // global vars for base58 encoding
    const base58Alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    let base58Decoder = null
    let base58Encoder = null
    
    /*  ------------------------------------------------------------------------ */
    
    module.exports =
    
        { json:   (data, params = undefined) => JSON.stringify (data)
    
        , isJsonEncodedObject: object => (
            (typeof object === 'string') &&
            (object.length >= 2) &&
            ((object[0] === '{') || (object[0] === '['))
        )
    
        , stringToBinary: string => CryptoJS.enc.Latin1.parse (string)
        , stringToBase64: string => CryptoJS.enc.Latin1.parse (string).toString (CryptoJS.enc.Base64)
        , base64ToBinary: string => CryptoJS.enc.Base64.parse (string)
        , base64ToString: string => CryptoJS.enc.Base64.parse (string).toString (CryptoJS.enc.Utf8)
        , binaryToBase64: binary => binary.toString (CryptoJS.enc.Base64)
        , base16ToBinary: string => CryptoJS.enc.Hex.parse (string)
        , binaryToBase16: binary => binary.toString (CryptoJS.enc.Hex)
        , binaryConcat: (...args) => args.reduce ((a, b) => a.concat (b))
        , binaryConcatArray: (arr) => arr.reduce ((a, b) => a.concat (b))
    
        , urlencode: object => qs.stringify (object)
        , urlencodeWithArrayRepeat: object => qs.stringify (object, { arrayFormat: 'repeat' })
        , rawencode: object => qs.stringify (object, { encode: false })
        , encode: x => x
        , decode: x => x
    
        // Url-safe-base64 without equals signs, with + replaced by - and slashes replaced by underscores
    
        , urlencodeBase64: base64string => base64string.replace (/[=]+$/, '')
                                                       .replace (/\+/g, '-')
                                                       .replace (/\//g, '_')
    
        , numberToLE: (n, padding) => {
            const hexArray = new BN (n).toArray ('le', padding)
            return byteArrayToWordArray (hexArray)
        }
    
        , numberToBE: (n, padding) => {
            const hexArray = new BN (n).toArray ('be', padding)
            return byteArrayToWordArray (hexArray)
        }
    
        , base58ToBinary: (string) => {
            if (!base58Decoder) {
                base58Decoder = {}
                base58Encoder = {}
                for (let i = 0; i < 58; i++) {
                    const c = base58Alphabet[i]
                    const bigNum = new BN (i)
                    base58Decoder[c] = bigNum
                    base58Encoder[bigNum] = c
                }
            }
            let result = new BN (0)
            const base = new BN (58)
            for (let i = 0; i < string.length; i++) {
                const character = string[i]
                result.imul (base)
                result.iadd (base58Decoder[character])
            }
            return byteArrayToWordArray (result.toArray ('be'))
        }
    
        , binaryToBase58: (wordArray) => {
            if (!base58Encoder) {
                base58Decoder = {}
                base58Encoder = {}
                for (let i = 0; i < 58; i++) {
                    const c = base58Alphabet[i]
                    const bigNum = new BN (i)
                    base58Decoder[c] = bigNum
                    base58Encoder[bigNum] = c
                }
            }
            const base = new BN (58)
            // hex is only compatible encoding between cryptojs and BN
            const hexString = wordArray.toString (CryptoJS.enc.Hex)
            let result = new BN (hexString, 16)
            let string = []
            while (!result.isZero ()) {
                const { div, mod } = result.divmod (base)
                result = div
                string.push (base58Encoder[mod])
            }
            return string.reverse ().join ('')
        }
    }
    
    function byteArrayToWordArray (ba) {
        const wa = []
        for (let i = 0; i < ba.length; i++) {
            wa[(i / 4) | 0] |= ba[i] << (24 - 8 * i)
        }
        return CryptoJS.lib.WordArray.create (wa, ba.length)
    }
    
    module.exports['byteArrayToWordArray'] = byteArrayToWordArray
    
    /*  ------------------------------------------------------------------------ */
    
    },{"../../static_dependencies/BN/bn":117,"../../static_dependencies/crypto-js/crypto-js":118,"../../static_dependencies/qs/index":153}],13:[function(require,module,exports){
    "use strict";
    
    // ----------------------------------------------------------------------------
    
    const { isObject, isNumber, isDictionary, isArray } = require ('./type')
    
    // ----------------------------------------------------------------------------
    
    const keys = Object.keys
        , values = (x) => ((!isArray (x)) ? Object.values (x) : x) // don't copy arrays if they're already arrays
        , index = (x) => new Set (values (x))
        , extend = (...args) => Object.assign ({}, ...args) // NB: side-effect free
        , clone = (x) => (isArray (x) ? Array.from (x) : extend (x)) // clone arrays or objects
    
    // ----------------------------------------------------------------------------
    
    module.exports = {
        keys
        , values
        , extend
        , clone
        , index
        , ordered: (x) => x // a stub to keep assoc keys in order (in JS it does nothing, it's mostly for Python)
        , unique: (x) => Array.from (index (x))
        , arrayConcat: (a, b) => a.concat (b)
    
        // ------------------------------------------------------------------------
    
        , inArray (needle, haystack) {
    
            return haystack.includes (needle)
        }
    
        , toArray (object) {
    
            return Object.values (object)
        }
    
        , isEmpty (object) {
            if (!object) {
                return true
            }
            return (Array.isArray (object) ? object : Object.keys (object)).length < 1;
        }
    
        // ------------------------------------------------------------------------
    
        , keysort (x, out = {}) {
    
            for (const k of keys (x).sort ())
                out[k] = x[k]
    
            return out
        }
    
        // ------------------------------------------------------------------------
    
        /*
            Accepts a map/array of objects and a key name to be used as an index:
            array = [
                { someKey: 'value1', anotherKey: 'anotherValue1' },
                { someKey: 'value2', anotherKey: 'anotherValue2' },
                { someKey: 'value3', anotherKey: 'anotherValue3' },
            ]
            key = 'someKey'
    
            Returns a map:
            {
                value1: { someKey: 'value1', anotherKey: 'anotherValue1' },
                value2: { someKey: 'value2', anotherKey: 'anotherValue2' },
                value3: { someKey: 'value3', anotherKey: 'anotherValue3' },
            }
        */
    
        , indexBy (x, k, out = {}) {
    
            for (const v of values (x)) {
                if (k in v) {
                    out[v[k]] = v
                }
            }
    
            return out
        }
    
        // ------------------------------------------------------------------------
    
        /*
            Accepts a map/array of objects and a key name to be used as a grouping parameter:
            array = [
                { someKey: 'value1', anotherKey: 'anotherValue1' },
                { someKey: 'value1', anotherKey: 'anotherValue2' },
                { someKey: 'value3', anotherKey: 'anotherValue3' },
            ]
            key = 'someKey'
    
            Returns a map:
            {
                value1: [
                    { someKey: 'value1', anotherKey: 'anotherValue1' },
                    { someKey: 'value1', anotherKey: 'anotherValue2' },
                ]
                value3: [
                    { someKey: 'value3', anotherKey: 'anotherValue3' }
                ],
            }
        */
    
        , groupBy (x, k, out = {}) {
    
            for (const v of values (x)) {
                if (k in v) {
                    const p = v[k]
                    out[p] = out[p] || []
                    out[p].push (v)
                }
            }
            return out
        }
    
        // ------------------------------------------------------------------------
    
        /*
            Accepts a map/array of objects, a key name and a key value to be used as a filter:
            array = [
                { someKey: 'value1', anotherKey: 'anotherValue1' },
                { someKey: 'value2', anotherKey: 'anotherValue2' },
                { someKey: 'value3', anotherKey: 'anotherValue3' },
            ]
            key = 'someKey'
            value = 'value1'
    
            Returns an array:
            [
                value1: { someKey: 'value1', anotherKey: 'anotherValue1' },
            ]
        */
    
        , filterBy (x, k, value = undefined, out = []) {
    
            for (const v of values (x)) {
                if (v[k] === value) {
                    out.push (v)
                }
            }
    
            return out
        }
    
        // ------------------------------------------------------------------------
        // NB: MUTATES ARRAY!
    
        , sortBy: (array, key, descending = false, direction  = descending ? -1 : 1) => array.sort ((a, b) => {
            if (a[key] < b[key]) {
                return -direction
            } else if (a[key] > b[key]) {
                return direction
            } else {
                return 0
            }
        })
    
        // ------------------------------------------------------------------------
    
        , flatten: function flatten (x, out = []) {
    
            for (const v of x) {
                if (isArray (v)) {
                    flatten (v, out)
                } else {
                    out.push (v)
                }
            }
    
            return out
        }
    
        // ------------------------------------------------------------------------
    
        , pluck: (x, k) => values (x).filter ((v) => k in v).map ((v) => v[k])
    
        // ------------------------------------------------------------------------
    
        , omit (x, ...args) {
    
            if (!Array.isArray (x)) {
    
                const out = clone (x)
    
                for (const k of args) {
                    if (isArray (k)) { // omit (x, ['a', 'b'])
                        for (const kk of k) {
                            delete out[kk]
                        }
                    } else {
                        delete out[k] // omit (x, 'a', 'b')
                    }
                }
    
                return out
            }
    
            return x
        }
    
        // ------------------------------------------------------------------------
    
        , sum (...xs) {
    
            const ns = xs.filter (isNumber) // leave only numbers
    
            return (ns.length > 0) ? ns.reduce ((a, b) => a + b, 0) : undefined
        }
    
        // ------------------------------------------------------------------------
    
        , deepExtend: function deepExtend (...xs) {
            let out = undefined
            for (const x of xs) {
                if (isDictionary (x)) {
                    if (!isDictionary (out)) {
                        out = {}
                    }
                    for (const k in x) {
                        out[k] = deepExtend (out[k], x[k])
                    }
                } else {
                    out = x
                }
            }
            return out
        }
    
    // ----------------------------------------------------------------------------
    
    }
    
    },{"./type":20}],14:[function(require,module,exports){
    'use strict';
    
    const { ROUND_UP, ROUND_DOWN } = require ('./number')
    const { NotSupported } = require ('../errors')
    
    //-------------------------------------------------------------------------
    // converts timeframe to seconds
    const parseTimeframe = (timeframe) => {
    
        const amount = timeframe.slice (0, -1)
        const unit = timeframe.slice (-1)
        let scale = undefined;
    
        if (unit === 'y') {
            scale = 60 * 60 * 24 * 365
        } else if (unit === 'M') {
            scale = 60 * 60 * 24 * 30
        } else if (unit === 'w') {
            scale = 60 * 60 * 24 * 7
        } else if (unit === 'd') {
            scale = 60 * 60 * 24
        } else if (unit === 'h') {
            scale = 60 * 60
        } else if (unit === 'm') {
            scale = 60
        } else if (unit === 's') {
            scale = 1
        } else {
            throw new NotSupported ('timeframe unit ' + unit + ' is not supported')
        }
    
        return amount * scale
    }
    
    const roundTimeframe = (timeframe, timestamp, direction = ROUND_DOWN) => {
        const ms = parseTimeframe (timeframe) * 1000
        // Get offset based on timeframe in milliseconds
        const offset = timestamp % ms
        return timestamp - offset + ((direction === ROUND_UP) ? ms : 0);
    }
    
    // given a sorted arrays of trades (recent last) and a timeframe builds an array of OHLCV candles
    const buildOHLCVC = (trades, timeframe = '1m', since = -Infinity, limit = Infinity) => {
        const ms = parseTimeframe (timeframe) * 1000;
        const ohlcvs = [];
        const [ timestamp, /* open */, high, low, close, volume, count ] = [ 0, 1, 2, 3, 4, 5, 6 ];
        const oldest = Math.min (trades.length - 1, limit);
    
        for (let i = 0; i <= oldest; i++) {
            const trade = trades[i];
            if (trade.timestamp < since) {
                continue;
            }
            const openingTime = Math.floor (trade.timestamp / ms) * ms; // shift to the edge of m/h/d (but not M)
            const candle = ohlcvs.length - 1;
    
            if (candle === -1 || openingTime >= ohlcvs[candle][timestamp] + ms) {
                // moved to a new timeframe -> create a new candle from opening trade
                ohlcvs.push ([
                    openingTime,  // timestamp
                    trade.price,  // O
                    trade.price,  // H
                    trade.price,  // L
                    trade.price,  // C
                    trade.amount, // V
                    1,            // count
                ]);
            } else {
                // still processing the same timeframe -> update opening trade
                ohlcvs[candle][high] = Math.max (ohlcvs[candle][high], trade.price);
                ohlcvs[candle][low] = Math.min (ohlcvs[candle][low], trade.price);
                ohlcvs[candle][close] = trade.price;
                ohlcvs[candle][volume] += trade.amount;
                ohlcvs[candle][count]++;
            } // if
        } // for
        return ohlcvs;
    }
    
    const extractParams = (string) => {
        const re = /{([\w-]+)}/g
        const matches = []
        let match = re.exec (string)
        while (match) {
            matches.push (match[1])
            match = re.exec (string)
        }
        return matches
    }
    
    const implodeParams = (string, params) => {
        if (!Array.isArray (params)) {
            const keys = Object.keys (params)
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i]
                if (!Array.isArray (params[key])) {
                    string = string.replace ('{' + key + '}', params[key])
                }
            }
        }
        return string
    }
    
    function vwap (baseVolume, quoteVolume) {
        return ((baseVolume !== undefined) && (quoteVolume !== undefined) && (baseVolume > 0)) ? (quoteVolume / baseVolume) : undefined
    }
    
    /*  ------------------------------------------------------------------------ */
    
    module.exports = {
    
        aggregate (bidasks) {
    
            const result = {}
    
            for (let i = 0; i < bidasks.length; i++) {
                const [ price, volume ] = bidasks[i];
                if (volume > 0) {
                    result[price] = (result[price] || 0) + volume
                }
            }
    
            return Object.keys (result).map ((price) => [parseFloat (price), parseFloat (result[price])])
        },
    
        parseTimeframe,
        roundTimeframe,
        buildOHLCVC,
        ROUND_UP,
        ROUND_DOWN,
    
        implodeParams,
        extractParams,
    
        vwap,
    }
    
    /*  ------------------------------------------------------------------------ */
    
    },{"../errors":9,"./number":15}],15:[function(require,module,exports){
    'use strict'
    
    /*  ------------------------------------------------------------------------
    
        NB: initially, I used objects for options passing:
    
                decimalToPrecision ('123.456', { digits: 2, round: true, afterPoint: true })
    
        ...but it turns out it's hard to port that across different languages and it is also
           probably has a performance penalty -- while it's a performance critical code! So
           I switched to using named constants instead, as it is actually more readable and
           succinct, and surely doesn't come with any inherent performance downside:
    
                decimalToPrecision ('123.456', ROUND, 2, DECIMAL_PLACES)                     */
    
    const ROUND      = 0                // rounding mode
        , TRUNCATE   = 1
        , ROUND_UP   = 2
        , ROUND_DOWN = 3
    
    const DECIMAL_PLACES     = 0        // digits counting mode
        , SIGNIFICANT_DIGITS = 1
        , TICK_SIZE = 2
    
    const NO_PADDING    = 0             // zero-padding mode
        , PAD_WITH_ZERO = 1
    
    const precisionConstants = {
        ROUND,
        TRUNCATE,
        ROUND_UP,
        ROUND_DOWN,
        DECIMAL_PLACES,
        SIGNIFICANT_DIGITS,
        TICK_SIZE,
        NO_PADDING,
        PAD_WITH_ZERO,
    }
    
    /*  ------------------------------------------------------------------------ */
    
    // See https://stackoverflow.com/questions/1685680/how-to-avoid-scientific-notation-for-large-numbers-in-javascript for discussion
    
    function numberToString (x) { // avoids scientific notation for too large and too small numbers
    
        if (typeof x === 'string') return x
    
        const s = x.toString ()
        if (Math.abs (x) < 1.0) {
            const n_e = s.split ('e-')
            const n = n_e[0].replace ('.', '')
            const e = parseInt (n_e[1])
            const neg = (s[0] === '-')
            if (e) {
                x = (neg ? '-' : '') + '0.' + (new Array (e)).join ('0') + n.substring (neg)
                return x
            }
        } else {
            const parts = s.split ('e')
            if (parts[1]) {
                let e = parseInt (parts[1])
                const m = parts[0].split ('.')
                let part = ''
                if (m[1]) {
                    e -= m[1].length
                    part = m[1]
                }
                return m[0] + part + (new Array (e + 1)).join ('0')
            }
        }
        return s
    }
    
    //-----------------------------------------------------------------------------
    // expects non-scientific notation
    
    const truncate_regExpCache = []
        , truncate_to_string = (num, precision = 0) => {
            num = numberToString (num)
            if (precision > 0) {
                const re = truncate_regExpCache[precision] || (truncate_regExpCache[precision] = new RegExp ("([-]*\\d+\\.\\d{" + precision + "})(\\d)"))
                const [ , result] = num.toString ().match (re) || [null, num]
                return result.toString ()
            }
            return parseInt (num).toString ()
        }
        , truncate = (num, precision = 0) => parseFloat (truncate_to_string (num, precision))
    
    function precisionFromString (string) {
        const split = string.replace (/0+$/g, '').split ('.')
        return (split.length > 1) ? (split[1].length) : 0
    }
    
    /*  ------------------------------------------------------------------------ */
    
    const decimalToPrecision = (x, roundingMode
                                 , numPrecisionDigits
                                 , countingMode       = DECIMAL_PLACES
                                 , paddingMode        = NO_PADDING) => {
    
        if (countingMode === TICK_SIZE) {
            if (numPrecisionDigits <= 0) {
                throw new Error ('TICK_SIZE cant be used with negative or zero numPrecisionDigits')
            }
        }
    
        if (numPrecisionDigits < 0) {
            const toNearest = Math.pow (10, -numPrecisionDigits)
            if (roundingMode === ROUND) {
                return (toNearest * decimalToPrecision (x / toNearest, roundingMode, 0, countingMode, paddingMode)).toString ()
            }
            if (roundingMode === TRUNCATE) {
                return (x - (x % toNearest)).toString ()
            }
        }
    
    /*  handle tick size */
        if (countingMode === TICK_SIZE) {
            const precisionDigitsString = decimalToPrecision (numPrecisionDigits, ROUND, 22, DECIMAL_PLACES, NO_PADDING)
            const newNumPrecisionDigits = precisionFromString (precisionDigitsString)
            let missing = x % numPrecisionDigits
            // See: https://github.com/ccxt/ccxt/pull/6486
            missing = Number (decimalToPrecision (missing, ROUND, 8, DECIMAL_PLACES, NO_PADDING));
            const fpError = decimalToPrecision (missing / numPrecisionDigits, ROUND, Math.max (newNumPrecisionDigits, 8), DECIMAL_PLACES, NO_PADDING)
            if (precisionFromString (fpError) !== 0) {
                if (roundingMode === ROUND) {
                    if (x > 0) {
                        if (missing >= numPrecisionDigits / 2) {
                            x = x - missing + numPrecisionDigits
                        } else {
                            x = x - missing
                        }
                    } else {
                        if (missing >= numPrecisionDigits / 2) {
                            x = Number (x) - missing
                        } else {
                            x = Number (x) - missing - numPrecisionDigits
                        }
                    }
                } else if (roundingMode === TRUNCATE) {
                    x = x - missing
                }
            }
            return decimalToPrecision (x, ROUND, newNumPrecisionDigits, DECIMAL_PLACES, paddingMode);
        }
    
    /*  Convert to a string (if needed), skip leading minus sign (if any)   */
    
        const str          = numberToString (x)
            , isNegative   = str[0] === '-'
            , strStart     = isNegative ? 1 : 0
            , strEnd       = str.length
    
    /*  Find the dot position in the source buffer   */
    
        for (var strDot = 0; strDot < strEnd; strDot++)
            if (str[strDot] === '.')
                break
    
        const hasDot = strDot < str.length
    
    /*  Char code constants         */
    
        const MINUS =  45
            , DOT   =  46
            , ZERO  =  48
            , ONE   = (ZERO + 1)
            , FIVE  = (ZERO + 5)
            , NINE  = (ZERO + 9)
    
    /*  For -123.4567 the `chars` array will hold 01234567 (leading zero is reserved for rounding cases when 099 → 100)    */
    
        const chars    = new Uint8Array ((strEnd - strStart) + (hasDot ? 0 : 1))
              chars[0] = ZERO
    
    /*  Validate & copy digits, determine certain locations in the resulting buffer  */
    
        let afterDot    = chars.length
          , digitsStart = -1                // significant digits
          , digitsEnd   = -1
    
        for (var i = 1, j = strStart; j < strEnd; j++, i++) {
    
            const c = str.charCodeAt (j)
    
            if (c === DOT) {
                afterDot = i--
    
            } else if ((c < ZERO) || (c > NINE)) {
                throw new Error (`${str}: invalid number (contains an illegal character '${str[i - 1]}')`)
    
            } else {
                chars[i] = c
                if ((c !== ZERO) && (digitsStart < 0)) digitsStart = i
            }
        }
    
        if (digitsStart < 0) digitsStart = 1
    
    /*  Determine the range to cut  */
    
        let precisionStart = (countingMode === DECIMAL_PLACES) ? afterDot      // 0.(0)001234567
                                                               : digitsStart   // 0.00(1)234567
          , precisionEnd = precisionStart +
                           numPrecisionDigits
    
    /*  Reset the last significant digit index, as it will change during the rounding/truncation.   */
    
        digitsEnd = -1
    
    /*  Perform rounding/truncation per digit, from digitsEnd to digitsStart, by using the following
        algorithm (rounding 999 → 1000, as an example):
    
            step  =          i=3      i=2      i=1      i=0
    
            chars =         0999     0999     0900     1000
            memo  =         ---0     --1-     -1--     0---                     */
    
        let allZeros = true;
        let signNeeded = isNegative;
    
        for (let i = chars.length - 1, memo = 0; i >= 0; i--) {
    
            let c = chars[i]
    
            if (i !== 0) {
                c += memo
    
                if (i >= (precisionStart + numPrecisionDigits)) {
    
                    const ceil = (roundingMode === ROUND) &&
                                 (c >= FIVE) &&
                                !((c === FIVE) && memo) // prevents rounding of 1.45 to 2
    
                    c = ceil ? (NINE + 1) : ZERO
                }
                if (c > NINE) { c = ZERO; memo = 1; }
                else memo = 0
    
            } else if (memo) c = ONE // leading extra digit (0900 → 1000)
    
            chars[i] = c
    
            if (c !== ZERO) {
                allZeros    = false
                digitsStart = i
                digitsEnd   = (digitsEnd < 0) ? (i + 1) : digitsEnd
            }
        }
    
    /*  Update the precision range, as `digitsStart` may have changed... & the need for a negative sign if it is only 0    */
    
        if (countingMode === SIGNIFICANT_DIGITS) {
            precisionStart = digitsStart
            precisionEnd   = precisionStart + numPrecisionDigits
        }
    
        if (allZeros) {
            signNeeded = false
        }
    
    /*  Determine the input character range     */
    
        const readStart     = ((digitsStart >= afterDot) || allZeros) ? (afterDot - 1) : digitsStart // 0.000(1)234  ----> (0).0001234
            , readEnd       = (digitsEnd    < afterDot) ? (afterDot    ) : digitsEnd   // 12(3)000     ----> 123000( )
    
    /*  Compute various sub-ranges       */
    
        const nSign         =          (signNeeded ? 1 : 0)                // (-)123.456
            , nBeforeDot    =          (nSign + (afterDot - readStart))    // (-123).456
            , nAfterDot     = Math.max (readEnd - afterDot, 0)             // -123.(456)
            , actualLength  =          (readEnd - readStart)               // -(123.456)
            , desiredLength =          (paddingMode === NO_PADDING)
                                           ? (actualLength)                // -(123.456)
                                           : (precisionEnd - readStart)    // -(123.456    )
    
            , pad           = Math.max (desiredLength - actualLength, 0)   //  -123.456(    )
            , padStart      =          (nBeforeDot + 1 + nAfterDot)        //  -123.456( )
            , padEnd        =          (padStart + pad)                    //  -123.456     ( )
            , isInteger     =          (nAfterDot + pad) === 0             //  -123
    
    /*  Fill the output buffer with characters    */
    
        const out = new Uint8Array (nBeforeDot + (isInteger ? 0 : 1) + nAfterDot + pad)
        // ------------------------------------------------------------------------------------------ // ---------------------
        if  (signNeeded)                                                  out[0]          = MINUS     // -     minus sign
        for (i = nSign, j = readStart;          i < nBeforeDot; i++, j++) out[i]          = chars[j]  // 123   before dot
        if  (!isInteger)                                                  out[nBeforeDot] = DOT       // .     dot
        for (i = nBeforeDot + 1, j = afterDot;  i < padStart;   i++, j++) out[i]          = chars[j]  // 456   after dot
        for (i = padStart;                      i < padEnd;     i++)      out[i]          = ZERO      // 000   padding
    
    /*  Build a string from the output buffer     */
    
        return String.fromCharCode (...out)
    }
    
    function omitZero (stringNumber) {
        if (stringNumber === undefined) {
            return undefined
        }
        if (parseFloat (stringNumber) === 0) {
            return undefined
        }
        return stringNumber
    }
    
    /*  ------------------------------------------------------------------------ */
    
    module.exports = {
        numberToString,
        precisionFromString,
        decimalToPrecision,
        truncate_to_string,
        truncate,
        omitZero,
        precisionConstants,
        ROUND,
        TRUNCATE,
        ROUND_UP,
        ROUND_DOWN,
        DECIMAL_PLACES,
        SIGNIFICANT_DIGITS,
        TICK_SIZE,
        NO_PADDING,
        PAD_WITH_ZERO,
    }
    
    /*  ------------------------------------------------------------------------ */
    
    },{}],16:[function(require,module,exports){
    (function (process){
    "use strict";
    
    // ----------------------------------------------------------------------------
    // There's been a lot of messing with this code...
    // The problem is to satisfy the following requirements:
    // - properly detect isNode == true on server side and isNode == false in the browser (on client side)
    // - make sure create-react-app, react-starter-kit and other react frameworks work
    // - make sure it does not break the browserified version (when linked into a html from a cdn)
    // - make sure it does not break the webpacking and babel-transpiled scripts
    // - make sure it works in Electron
    // - make sure it works with Angular.js
    // - make sure it does not break other possible usage scenarios
    
    const isBrowser = typeof window !== 'undefined'
    
    const isElectron = typeof process !== 'undefined' &&
                       typeof process.versions !== 'undefined' &&
                       typeof process.versions.electron !== 'undefined'
    
    const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && (self instanceof WorkerGlobalScope)
    
    const isWindows = typeof process !== 'undefined' && process.platform === "win32"
    
    const isNode = !(isBrowser || isWebWorker)
    
    const defaultFetch = typeof (fetch) === "undefined" ? require ('../../static_dependencies/fetch-ponyfill/fetch-node') ().fetch : fetch
    
    // ----------------------------------------------------------------------------
    
    module.exports = {
    
        isBrowser,
        isElectron,
        isWebWorker,
        isNode,
        isWindows,
        defaultFetch,
    }
    }).call(this,require('_process'))
    },{"../../static_dependencies/fetch-ponyfill/fetch-node":135,"_process":197}],17:[function(require,module,exports){
    "use strict";
    
    // ----------------------------------------------------------------------------
    
    const uuid = a => a ? (a ^ Math.random () * 16 >> a / 4).toString (16) : ([1e7]+-1e3+-4e3+-8e3+-1e11).replace (/[018]/g, uuid)
    const uuid16 = a => a ? (a ^ Math.random () * 16 >> a / 4).toString (16) : ([1e5]+1e2+4e2+8e3).replace (/[018]/g, uuid16)
    const uuid22 = a => a ? (a ^ Math.random () * 16 >> a / 4).toString (16) : ([1e7]+1e3+4e3+8e5).replace (/[018]/g, uuid22)
    
    
    // ----------------------------------------------------------------------------
    
    module.exports = {
    
        uuid
        , uuid16
        , uuid22
        // hasFetchOHLCV → has_fetch_ohlcv; parseHTTPResponse → parse_http_response
        , unCamelCase: s => s.match (/^[A-Z0-9_]+$/) ? s : (s.replace (/[a-z0-9][A-Z]/g, x => x[0] + '_' + x[1]).replace(/[A-Z0-9][A-Z0-9][a-z]/g, x => x[0] + '_' + x[1] + x[2]).toLowerCase ())
        , capitalize: s => s.length ? (s.charAt (0).toUpperCase () + s.slice (1)) : s
        , strip: s => s.replace(/^\s+|\s+$/g, '')
    }
    
    },{}],18:[function(require,module,exports){
    "use strict";
    
    /*  ------------------------------------------------------------------------ */
    
    const { now } = require ('./time')
    
    /*  ------------------------------------------------------------------------ */
    
    class Throttle {
        constructor (config) {
            this.config = {
                refillRate: 1.0,
                delay: 0.001,
                capacity: 1.0,
                maxCapacity: 1000,
                tokens: 0,
                cost: 1.0,
            }
            Object.assign (this.config, config)
            this.queue = []
            this.running = false
        }
    
        async loop () {
            let lastTimestamp = now ()
            while (this.running) {
                const { resolver, cost } = this.queue[0]
                if (this.config['tokens'] >= 0) {
                    this.config['tokens'] -= cost
                    resolver ()
                    this.queue.shift ()
                    // contextswitch
                    await Promise.resolve ()
                    if (this.queue.length === 0) {
                        this.running = false
                    }
                } else {
                    await new Promise (x => setTimeout (x, this.config['delay'] * 1000));
                    const current = now ()
                    const elapsed = current - lastTimestamp
                    lastTimestamp = current
                    this.config['tokens'] = Math.min (this.config['tokens'] + (this.config['refillRate'] * elapsed), this.config['capacity'])
                }
            }
        }
    }
    
    function throttle (config) {
        function inner (cost = undefined) {
            let resolver
            const promise = new Promise ((resolve, reject) => {
                resolver = resolve
            })
            if (this.queue.length > this.config['maxCapacity']) {
                throw new Error ('throttle queue is over maxCapacity')
            }
            cost = (cost === undefined) ? this.config['cost'] : cost
            this.queue.push ({
                resolver,
                cost,
            })
            if (!this.running) {
                this.running = true
                this.loop ()
            }
            return promise
        }
        const instance = new Throttle (config)
        const bound = inner.bind (instance)
        // useful for inspecting the tokenBucket
        bound.config = instance.config
        return bound
    }
    
    module.exports = {
        throttle,
    }
    
    // ----------------------------------------
    
    },{"./time":19}],19:[function(require,module,exports){
    'use strict';
    
    /*  ------------------------------------------------------------------------ */
    
    const now = Date.now // TODO: figure out how to utilize performance.now () properly – it's not as easy as it does not return a unix timestamp...
    const microseconds = () => now () * 1000 // TODO: utilize performance.now for that purpose
    const milliseconds = now
    const seconds      = () => Math.floor (now () / 1000)
    const uuidv1 = () => {
        const biasSeconds = 12219292800  // seconds from 15th Oct 1572 to Jan 1st 1970
        const bias = biasSeconds * 10000000  // in hundreds of nanoseconds
        const time = microseconds () * 10 + bias
        const timeHex = time.toString (16)
        const arranged = timeHex.slice (7, 15) + timeHex.slice (3, 7) + '1' + timeHex.slice (0, 3)
        // these should be random, but we're not making more than 10 requests per microsecond so who cares
        const clockId = '9696' // a 14 bit number
        const macAddress = 'ff'.repeat (6)
        return arranged + clockId + macAddress
    }
    
    /*  ------------------------------------------------------------------------ */
    
    const setTimeout_original = setTimeout
    const setTimeout_safe = (done, ms, setTimeout = setTimeout_original /* overrideable for mocking purposes */, targetTime = now () + ms) => {
    
    /*  The built-in setTimeout function can fire its callback earlier than specified, so we
        need to ensure that it does not happen: sleep recursively until `targetTime` is reached...   */
    
        let clearInnerTimeout = () => {}
        let active = true
    
        const id = setTimeout (() => {
            active = true
            const rest = targetTime - now ()
            if (rest > 0) {
                clearInnerTimeout = setTimeout_safe (done, rest, setTimeout, targetTime) // try sleep more
            } else {
                done ()
            }
        }, ms)
    
        return function clear () {
            if (active) {
                active = false // dunno if IDs are unique on various platforms, so it's better to rely on this flag to exclude the possible cancellation of the wrong timer (if called after completion)
                clearTimeout (id)
            }
            clearInnerTimeout ()
        }
    }
    
    /*  ------------------------------------------------------------------------ */
    
    class TimedOut extends Error {
    
        constructor () {
            const message = 'timed out'
            super (message)
            this.constructor = TimedOut
            this.__proto__   = TimedOut.prototype
            this.message     = message
        }
    }
    
    /*  ------------------------------------------------------------------------ */
    
    const iso8601 = (timestamp) => {
        let _timestampNumber = undefined;
        if (typeof timestamp === 'number') {
            _timestampNumber = Math.floor (timestamp);
        } else {
            _timestampNumber = parseInt (timestamp, 10);
        }
    
        // undefined, null and lots of nasty non-numeric values yield NaN
        if (Number.isNaN (_timestampNumber) || _timestampNumber < 0) {
            return undefined;
        }
    
        // last line of defence
        try {
            return new Date (_timestampNumber).toISOString ();
        } catch (e) {
            return undefined;
        }
    }
    
    const parse8601 = (x) => {
        if (typeof x !== 'string' || !x) {
            return undefined;
        }
    
        if (x.match (/^[0-9]+$/)) {
            // a valid number in a string, not a date.
            return undefined;
        }
    
        if (x.indexOf ('-') < 0 || x.indexOf (':') < 0) { // no date can be without a dash and a colon
            return undefined;
        }
    
        // last line of defence
        try {
            const candidate = Date.parse (((x.indexOf ('+') >= 0) || (x.slice (-1) === 'Z')) ? x : (x + 'Z').replace (/\s(\d\d):/, 'T$1:'));
            if (Number.isNaN (candidate)) {
                return undefined;
            }
            return candidate;
        } catch (e) {
            return undefined;
        }
    }
    
    const parseDate = (x) => {
        if (typeof x !== 'string' || !x) {
            return undefined;
        }
    
        if (x.indexOf ('GMT') >= 0) {
            try {
                return Date.parse (x);
            } catch (e) {
                return undefined;
            }
        }
    
        return parse8601 (x);
    }
    
    const rfc2616 = (timestamp = undefined) => {
        return new Date (timestamp).toUTCString ();
    }
    
    const mdy = (timestamp, infix = '-') => {
        infix = infix || ''
        const date = new Date (timestamp)
        const Y = date.getUTCFullYear ().toString ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        m = m < 10 ? ('0' + m) : m.toString ()
        d = d < 10 ? ('0' + d) : d.toString ()
        return m + infix + d + infix + Y
    }
    
    const ymd = (timestamp, infix = '-') => {
        infix = infix || ''
        const date = new Date (timestamp)
        const Y = date.getUTCFullYear ().toString ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        m = m < 10 ? ('0' + m) : m.toString ()
        d = d < 10 ? ('0' + d) : d.toString ()
        return Y + infix + m + infix + d
    }
    
    const ymdhms = (timestamp, infix = ' ') => {
        const date = new Date (timestamp)
        const Y = date.getUTCFullYear ()
        let m = date.getUTCMonth () + 1
        let d = date.getUTCDate ()
        let H = date.getUTCHours ()
        let M = date.getUTCMinutes ()
        let S = date.getUTCSeconds ()
        m = m < 10 ? ('0' + m) : m
        d = d < 10 ? ('0' + d) : d
        H = H < 10 ? ('0' + H) : H
        M = M < 10 ? ('0' + M) : M
        S = S < 10 ? ('0' + S) : S
        return Y + '-' + m + '-' + d + infix + H + ':' + M + ':' + S
    }
    
    module.exports =
    
        {
            now
            , microseconds
            , milliseconds
            , seconds
            , iso8601
            , parse8601
            , rfc2616
            , uuidv1
            , parseDate
            , mdy
            , ymd
            , ymdhms
            , setTimeout_safe
            , sleep: ms => new Promise (resolve => setTimeout_safe (resolve, ms))
            , TimedOut
            , timeout: async (ms, promise) => {
    
                let clear = () => {}
                const expires = new Promise (resolve => (clear = setTimeout_safe (resolve, ms)))
    
                try {
                    return await Promise.race ([promise, expires.then (() => { throw new TimedOut () })])
                } finally {
                    clear () // fixes https://github.com/ccxt/ccxt/issues/749
                }
            }
    }
    
    /*  ------------------------------------------------------------------------ */
    
    },{}],20:[function(require,module,exports){
    "use strict";
    
    /*  ------------------------------------------------------------------------ */
    
    const isNumber          = Number.isFinite
        , isInteger         = Number.isInteger
        , isArray           = Array.isArray
        , hasProps          = o => ((o !== undefined) && (o !== null))
        , isString          = s =>                  (typeof s === 'string')
        , isObject          = o => ((o !== null) && (typeof o === 'object'))
        , isRegExp          = o => (o instanceof RegExp)
        , isDictionary      = o => (isObject (o) && (Object.getPrototypeOf (o) === Object.prototype) && !isArray (o) && !isRegExp (o))
        , isStringCoercible = x => ((hasProps (x) && x.toString) || isNumber (x))
    
    /*  .............................................   */
    
    const prop = (o, k) => (isObject (o) ? o[k] : undefined)
        , prop2 = (o, k1, k2) => (!isObject (o) ? undefined : (((k1 in o) && (o[k1] !== null)) ? o[k1] : o[k2]))
    
    /*  .............................................   */
    
    const asFloat   = x => ((isNumber (x) || isString (x)) ? parseFloat (x)     : NaN)
        , asInteger = x => ((isNumber (x) || isString (x)) ? parseInt   (x, 10) : NaN)
    
    /*  .............................................   */
    
    module.exports = {
    
        isNumber
        , isInteger
        , isArray
        , isObject
        , isString
        , isStringCoercible
        , isDictionary
    
        , hasProps
        , prop
    
        , asFloat
        , asInteger
    
        , safeFloat:          (o, k,          $default, n =   asFloat (prop (o, k))) => (isNumber (n)          ? n                         : $default)
        , safeInteger:        (o, k,          $default, n = asInteger (prop (o, k))) => (isNumber (n)          ? n                         : $default)
        , safeIntegerProduct: (o, k, $factor, $default, n = asInteger (prop (o, k))) => (isNumber (n)          ? parseInt (n * $factor)    : $default)
        , safeTimestamp:      (o, k,          $default, n =   asFloat (prop (o, k))) => (isNumber (n)          ? parseInt (n * 1000)       : $default)
        , safeValue:          (o, k,          $default, x =            prop (o, k))  => (hasProps (x)          ? x                         : $default)
        , safeString:         (o, k,          $default, x =            prop (o, k))  => (isStringCoercible (x) ? String (x)                : $default)
        , safeStringLower:    (o, k,          $default, x =            prop (o, k))  => (isStringCoercible (x) ? String (x).toLowerCase () : $default)
        , safeStringUpper:    (o, k,          $default, x =            prop (o, k))  => (isStringCoercible (x) ? String (x).toUpperCase () : $default)
    
        // not using safeFloats with an array argument as we're trying to save some cycles here
        // we're not using safeFloat3 either because those cases are too rare to deserve their own optimization
    
        , safeFloat2:          (o, k1, k2,          $default, n =   asFloat (prop2 (o, k1, k2))) => (isNumber (n)          ? n                         : $default)
        , safeInteger2:        (o, k1, k2,          $default, n = asInteger (prop2 (o, k1, k2))) => (isNumber (n)          ? n                         : $default)
        , safeIntegerProduct2: (o, k1, k2, $factor, $default, n = asInteger (prop2 (o, k1, k2))) => (isNumber (n)          ? parseInt (n * $factor)    : $default)
        , safeTimestamp2:      (o, k1, k2,          $default, n =   asFloat (prop2 (o, k1, k2))) => (isNumber (n)          ? parseInt (n * 1000)       : $default)
        , safeValue2:          (o, k1, k2,          $default, x =            prop2 (o, k1, k2))  => (hasProps (x)          ? x                         : $default)
        , safeString2:         (o, k1, k2,          $default, x =            prop2 (o, k1, k2))  => (isStringCoercible (x) ? String (x)                : $default)
        , safeStringLower2:    (o, k1, k2,          $default, x =            prop2 (o, k1, k2))  => (isStringCoercible (x) ? String (x).toLowerCase () : $default)
        , safeStringUpper2:    (o, k1, k2,          $default, x =            prop2 (o, k1, k2))  => (isStringCoercible (x) ? String (x).toUpperCase () : $default)
    
    }
    
    /*  ------------------------------------------------------------------------ */
    
    },{}],21:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const hitbtc = require ('./hitbtc');
    // ---------------------------------------------------------------------------
    
    module.exports = class bequant extends hitbtc {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bequant',
                'name': 'Bequant',
                'countries': [ 'MT' ], // Malta
                'pro': true,
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/55248342-a75dfe00-525a-11e9-8aa2-05e9dca943c6.jpg',
                    'api': {
                        'public': 'https://api.bequant.io',
                        'private': 'https://api.bequant.io',
                    },
                    'www': 'https://bequant.io',
                    'doc': [
                        'https://api.bequant.io/',
                    ],
                    'fees': [
                        'https://bequant.io/fees-and-limits',
                    ],
                    'referral': 'https://bequant.io',
                },
            });
        }
    };
    
    },{"./hitbtc":85}],22:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AccountSuspended, ArgumentsRequired, AuthenticationError, DDoSProtection, ExchangeNotAvailable, InvalidOrder, OrderNotFound, PermissionDenied, InsufficientFunds, BadSymbol, RateLimitExceeded, BadRequest } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bibox extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bibox',
                'name': 'Bibox',
                'countries': [ 'CN', 'US', 'KR' ],
                'version': 'v1',
                'hostname': 'bibox365.com',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createMarketOrder': false, // or they will return https://github.com/ccxt/ccxt/issues/2338
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDeposits': true,
                    'fetchDepositAddress': true,
                    'fetchFundingFees': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'publicAPI': false,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '1hour',
                    '2h': '2hour',
                    '4h': '4hour',
                    '6h': '6hour',
                    '12h': '12hour',
                    '1d': 'day',
                    '1w': 'week',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/77257418-3262b000-6c85-11ea-8fb8-20bdf20b3592.jpg',
                    'api': 'https://api.{hostname}',
                    'www': 'https://www.bibox365.com',
                    'doc': [
                        'https://biboxcom.github.io/en/',
                    ],
                    'fees': 'https://bibox.zendesk.com/hc/en-us/articles/360002336133',
                    'referral': 'https://w2.bibox365.com/login/register?invite_code=05Kj3I',
                },
                'api': {
                    'public': {
                        'post': [
                            // TODO: rework for full endpoint/cmd paths here
                            'mdata',
                        ],
                        'get': [
                            'cquery',
                            'mdata',
                            'cdata',
                            'orderpending',
                        ],
                    },
                    'private': {
                        'post': [
                            'cquery',
                            'ctrade',
                            'user',
                            'orderpending',
                            'transfer',
                        ],
                    },
                    'v2private': {
                        'post': [
                            'assets/transfer/spot',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'taker': this.parseNumber ('0.001'),
                        'maker': this.parseNumber ('0.0008'),
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                        'withdraw': {},
                        'deposit': {},
                    },
                },
                'exceptions': {
                    '2011': AccountSuspended, // Account is locked
                    '2015': AuthenticationError, // Google authenticator is wrong
                    '2021': InsufficientFunds, // Insufficient balance available for withdrawal
                    '2027': InsufficientFunds, // Insufficient balance available (for trade)
                    '2033': OrderNotFound, // operation failed! Orders have been completed or revoked
                    '2065': InvalidOrder, // Precatory price is exorbitant, please reset
                    '2066': InvalidOrder, // Precatory price is low, please reset
                    '2067': InvalidOrder, // Does not support market orders
                    '2068': InvalidOrder, // The number of orders can not be less than
                    '2078': InvalidOrder, // unvalid order price
                    '2085': InvalidOrder, // Order quantity is too small
                    '2091': RateLimitExceeded, // request is too frequency, please try again later
                    '2092': InvalidOrder, // Minimum amount not met
                    '2131': InvalidOrder, // The order quantity cannot be greater than
                    '3000': BadRequest, // Requested parameter incorrect
                    '3002': BadRequest, // Parameter cannot be null
                    '3012': AuthenticationError, // invalid apiKey
                    '3016': BadSymbol, // Trading pair error
                    '3024': PermissionDenied, // wrong apikey permissions
                    '3025': AuthenticationError, // signature failed
                    '4000': ExchangeNotAvailable, // current network is unstable
                    '4003': DDoSProtection, // server busy please try again later
                },
                'commonCurrencies': {
                    'APENFT(NFT)': 'NFT',
                    'BOX': 'DefiBox',
                    'BPT': 'BlockPool Token',
                    'GTC': 'Game.com',
                    'KEY': 'Bihu',
                    'MTC': 'MTC Mesh Network', // conflict with MTC Docademic doc.com Token https://github.com/ccxt/ccxt/issues/6081 https://github.com/ccxt/ccxt/issues/3025
                    'NFT': 'NFT Protocol',
                    'PAI': 'PCHAIN',
                    'REVO': 'Revo Network',
                    'TERN': 'Ternio-ERC20',
                },
                'options': {
                    'fetchCurrencies': 'fetch_currencies_public', // or 'fetch_currencies_private' with apiKey and secret
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const request = {
                'cmd': 'pairList',
            };
            const response = await this.publicGetMdata (this.extend (request, params));
            //
            //     {
            //         "result": [
            //             {
            //                 "id":1,
            //                 "pair":"BIX_BTC",
            //                 "pair_type":0,
            //                 "area_id":7,
            //                 "is_hide":0,
            //                 "decimal":8,
            //                 "amount_scale":4
            //             }
            //         ],
            //         "cmd":"pairList",
            //         "ver":"1.1"
            //     }
            //
            const markets = this.safeValue (response, 'result');
            const request2 = {
                'cmd': 'tradeLimit',
            };
            const response2 = await this.publicGetOrderpending (this.extend (request2, params));
            //
            //    {
            //         result: {
            //             min_trade_price: { default: '0.00000001', USDT: '0.0001', DAI: '0.0001' },
            //             min_trade_amount: { default: '0.0001' },
            //             min_trade_money: {
            //                 USDT: '1',
            //                 USDC: '1',
            //                 DAI: '1',
            //                 GUSD: '1',
            //                 BIX: '3',
            //                 BTC: '0.0002',
            //                 ETH: '0.005'
            //             }
            //         },
            //         cmd: 'tradeLimit'
            //     }
            //
            const result2 = this.safeValue (response2, 'result', {});
            const minCosts = this.safeValue (result2, 'min_trade_money', {});
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const numericId = this.safeInteger (market, 'id');
                const id = this.safeString (market, 'pair');
                let baseId = undefined;
                let quoteId = undefined;
                if (id !== undefined) {
                    const parts = id.split ('_');
                    baseId = this.safeString (parts, 0);
                    quoteId = this.safeString (parts, 1);
                }
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeNumber (market, 'amount_scale'),
                    'price': this.safeNumber (market, 'decimal'),
                };
                result.push ({
                    'id': id,
                    'numericId': numericId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'info': market,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision['amount']),
                            'max': undefined,
                        },
                        'price': {
                            'min': Math.pow (10, -precision['price']),
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.safeNumber (minCosts, quoteId),
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            // we don't set values that are not defined by the exchange
            const timestamp = this.safeInteger (ticker, 'timestamp');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            } else {
                const baseId = this.safeString (ticker, 'coin_symbol');
                const quoteId = this.safeString (ticker, 'currency_symbol');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                symbol = base + '/' + quote;
            }
            const last = this.safeNumber (ticker, 'last');
            const change = this.safeNumber (ticker, 'change');
            const baseVolume = this.safeNumber2 (ticker, 'vol', 'vol24H');
            let percentage = this.safeString (ticker, 'percent');
            if (percentage !== undefined) {
                percentage = percentage.replace ('%', '');
                percentage = this.parseNumber (percentage);
            }
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': this.safeNumber (ticker, 'amount'),
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'cmd': 'ticker',
                'pair': market['id'],
            };
            const response = await this.publicGetMdata (this.extend (request, params));
            return this.parseTicker (response['result'], market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            const request = {
                'cmd': 'marketAll',
            };
            const response = await this.publicGetMdata (this.extend (request, params));
            const tickers = this.parseTickers (response['result'], symbols);
            const result = this.indexBy (tickers, 'symbol');
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeInteger2 (trade, 'time', 'createdAt');
            let side = this.safeInteger2 (trade, 'side', 'order_side');
            side = (side === 1) ? 'buy' : 'sell';
            let symbol = undefined;
            if (market === undefined) {
                let marketId = this.safeString (trade, 'pair');
                if (marketId === undefined) {
                    const baseId = this.safeString (trade, 'coin_symbol');
                    const quoteId = this.safeString (trade, 'currency_symbol');
                    if ((baseId !== undefined) && (quoteId !== undefined)) {
                        marketId = baseId + '_' + quoteId;
                    }
                }
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                }
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            let fee = undefined;
            const feeCostString = this.safeString (trade, 'fee');
            let feeCurrency = this.safeString (trade, 'fee_symbol');
            if (feeCurrency !== undefined) {
                if (feeCurrency in this.currencies_by_id) {
                    feeCurrency = this.currencies_by_id[feeCurrency]['code'];
                } else {
                    feeCurrency = this.safeCurrencyCode (feeCurrency);
                }
            }
            const feeRate = undefined; // todo: deduce from market if market is defined
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            if (feeCostString !== undefined) {
                fee = {
                    'cost': this.parseNumber (Precise.stringNeg (feeCostString)),
                    'currency': feeCurrency,
                    'rate': feeRate,
                };
            }
            const id = this.safeString (trade, 'id');
            return {
                'info': trade,
                'id': id,
                'order': undefined, // Bibox does not have it (documented) yet
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': 'limit',
                'takerOrMaker': undefined,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'cmd': 'deals',
                'pair': market['id'],
            };
            if (limit !== undefined) {
                request['size'] = limit; // default = 200
            }
            const response = await this.publicGetMdata (this.extend (request, params));
            return this.parseTrades (response['result'], market, since, limit);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'cmd': 'depth',
                'pair': market['id'],
            };
            if (limit !== undefined) {
                request['size'] = limit; // default = 200
            }
            const response = await this.publicGetMdata (this.extend (request, params));
            return this.parseOrderBook (response['result'], symbol, this.safeNumber (response['result'], 'update_time'), 'bids', 'asks', 'price', 'volume');
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "time":1591448220000,
            //         "open":"0.02507029",
            //         "high":"0.02507029",
            //         "low":"0.02506349",
            //         "close":"0.02506349",
            //         "vol":"5.92000000"
            //     }
            //
            return [
                this.safeInteger (ohlcv, 'time'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'vol'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = 1000, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'cmd': 'kline',
                'pair': market['id'],
                'period': this.timeframes[timeframe],
                'size': limit,
            };
            const response = await this.publicGetMdata (this.extend (request, params));
            //
            //     {
            //         "result":[
            //             {"time":1591448220000,"open":"0.02507029","high":"0.02507029","low":"0.02506349","close":"0.02506349","vol":"5.92000000"},
            //             {"time":1591448280000,"open":"0.02506449","high":"0.02506975","low":"0.02506108","close":"0.02506843","vol":"5.72000000"},
            //             {"time":1591448340000,"open":"0.02506698","high":"0.02506698","low":"0.02506452","close":"0.02506519","vol":"4.86000000"},
            //         ],
            //         "cmd":"kline",
            //         "ver":"1.1"
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOHLCVs (result, market, timeframe, since, limit);
        }
    
        async fetchCurrencies (params = {}) {
            const method = this.safeString (this.options, 'fetchCurrencies', 'fetch_currencies_public');
            return await this[method] (params);
        }
    
        async fetchCurrenciesPublic (params = {}) {
            const request = {
                'cmd': 'currencies',
            };
            const response = await this.publicGetCdata (this.extend (request, params));
            //
            // publicGetCdata
            //
            //     {
            //         "result":[
            //             {
            //                 "symbol":"BTC",
            //                 "name":"BTC",
            //                 "valid_decimals":8,
            //                 "original_decimals":8,
            //                 "is_erc20":0,
            //                 "enable_withdraw":1,
            //                 "enable_deposit":1,
            //                 "withdraw_min":0.005,
            //                 "describe_summary":"[{\"lang\":\"zh-cn\",\"text\":\"Bitcoin 比特币的概念最初由中本聪在2009年提出，是点对点的基于 SHA-256 算法的一种P2P形式的数字货币，点对点的传输意味着一个去中心化的支付系统。\"},{\"lang\":\"en-ww\",\"text\":\"Bitcoin is a digital asset and a payment system invented by Satoshi Nakamoto who published a related paper in 2008 and released it as open-source software in 2009. The system featured as peer-to-peer; users can transact directly without an intermediary.\"}]"
            //             }
            //         ],
            //         "cmd":"currencies"
            //     }
            //
            const currencies = this.safeValue (response, 'result');
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                const id = this.safeString (currency, 'symbol');
                const name = this.safeString (currency, 'name'); // contains hieroglyphs causing python ASCII bug
                const code = this.safeCurrencyCode (id);
                const precision = this.safeInteger (currency, 'valid_decimals');
                const deposit = this.safeValue (currency, 'enable_deposit');
                const withdraw = this.safeValue (currency, 'enable_withdraw');
                const active = (deposit && withdraw);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'name': name,
                    'active': active,
                    'fee': undefined,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'withdraw_min'),
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchCurrenciesPrivate (params = {}) {
            if (!this.apiKey || !this.secret) {
                throw new AuthenticationError (this.id + " fetchCurrencies is an authenticated endpoint, therefore it requires 'apiKey' and 'secret' credentials. If you don't need currency details, set exchange.has['fetchCurrencies'] = false before calling its methods.");
            }
            const request = {
                'cmd': 'transfer/coinList',
                'body': {},
            };
            const response = await this.privatePostTransfer (this.extend (request, params));
            //
            //     {
            //         "result":[
            //             {
            //                 "totalBalance":"14.57582269",
            //                 "balance":"14.57582269",
            //                 "freeze":"0.00000000",
            //                 "id":60,
            //                 "symbol":"USDT",
            //                 "icon_url":"/appimg/USDT_icon.png",
            //                 "describe_url":"[{\"lang\":\"zh-cn\",\"link\":\"https://bibox.zendesk.com/hc/zh-cn/articles/115004798234\"},{\"lang\":\"en-ww\",\"link\":\"https://bibox.zendesk.com/hc/en-us/articles/115004798234\"}]",
            //                 "name":"USDT",
            //                 "enable_withdraw":1,
            //                 "enable_deposit":1,
            //                 "enable_transfer":1,
            //                 "confirm_count":2,
            //                 "is_erc20":1,
            //                 "forbid_info":null,
            //                 "describe_summary":"[{\"lang\":\"zh-cn\",\"text\":\"USDT 是 Tether 公司推出的基于稳定价值货币美元（USD）的代币 Tether USD（简称USDT），1USDT=1美元，用户可以随时使用 USDT 与 USD 进行1:1的兑换。\"},{\"lang\":\"en-ww\",\"text\":\"USDT is a cryptocurrency asset issued on the Bitcoin blockchain via the Omni Layer Protocol. Each USDT unit is backed by a U.S Dollar held in the reserves of the Tether Limited and can be redeemed through the Tether Platform.\"}]",
            //                 "total_amount":4776930644,
            //                 "supply_amount":4642367414,
            //                 "price":"--",
            //                 "contract_father":"OMNI",
            //                 "supply_time":"--",
            //                 "comment":null,
            //                 "contract":"31",
            //                 "original_decimals":8,
            //                 "deposit_type":0,
            //                 "hasCobo":0,
            //                 "BTCValue":"0.00126358",
            //                 "CNYValue":"100.93381445",
            //                 "USDValue":"14.57524654",
            //                 "children":[
            //                     {"type":"OMNI","symbol":"USDT","enable_deposit":1,"enable_withdraw":1,"confirm_count":2},
            //                     {"type":"TRC20","symbol":"tUSDT","enable_deposit":1,"enable_withdraw":1,"confirm_count":20},
            //                     {"type":"ERC20","symbol":"eUSDT","enable_deposit":1,"enable_withdraw":1,"confirm_count":25}
            //                 ]
            //             },
            //         ],
            //         "cmd":"transfer/coinList"
            //     }
            //
            const currencies = this.safeValue (response, 'result');
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                const id = this.safeString (currency, 'symbol');
                const name = currency['name']; // contains hieroglyphs causing python ASCII bug
                const code = this.safeCurrencyCode (id);
                const precision = 8;
                const deposit = this.safeValue (currency, 'enable_deposit');
                const withdraw = this.safeValue (currency, 'enable_withdraw');
                const active = (deposit && withdraw);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'name': name,
                    'active': active,
                    'fee': undefined,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision),
                            'max': Math.pow (10, precision),
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': Math.pow (10, precision),
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const type = this.safeString (params, 'type', 'assets');
            params = this.omit (params, 'type');
            const request = {
                'cmd': 'transfer/' + type, // assets, mainAssets
                'body': this.extend ({
                    'select': 1, // return full info
                }, params),
            };
            const response = await this.privatePostTransfer (request);
            const balances = this.safeValue (response, 'result');
            const result = { 'info': balances };
            let indexed = undefined;
            if ('assets_list' in balances) {
                indexed = this.indexBy (balances['assets_list'], 'coin_symbol');
            } else {
                indexed = balances;
            }
            const keys = Object.keys (indexed);
            for (let i = 0; i < keys.length; i++) {
                const id = keys[i];
                let code = id.toUpperCase ();
                if (code.indexOf ('TOTAL_') >= 0) {
                    code = code.slice (6);
                }
                if (code in this.currencies_by_id) {
                    code = this.currencies_by_id[code]['code'];
                }
                const account = this.account ();
                const balance = indexed[id];
                if (typeof balance === 'string') {
                    account['free'] = balance;
                    account['total'] = balance;
                } else {
                    account['free'] = this.safeString (balance, 'balance');
                    account['used'] = this.safeString (balance, 'freeze');
                }
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {
                'page': 1,
            };
            if (code !== undefined) {
                currency = this.currency (code);
                request['symbol'] = currency['id'];
            }
            if (limit !== undefined) {
                request['size'] = limit;
            } else {
                request['size'] = 100;
            }
            const response = await this.privatePostTransfer ({
                'cmd': 'transfer/transferInList',
                'body': this.extend (request, params),
            });
            const deposits = this.safeValue (response['result'], 'items', []);
            for (let i = 0; i < deposits.length; i++) {
                deposits[i]['type'] = 'deposit';
            }
            return this.parseTransactions (deposits, currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {
                'page': 1,
            };
            if (code !== undefined) {
                currency = this.currency (code);
                request['symbol'] = currency['id'];
            }
            if (limit !== undefined) {
                request['size'] = limit;
            } else {
                request['size'] = 100;
            }
            const response = await this.privatePostTransfer ({
                'cmd': 'transfer/transferOutList',
                'body': this.extend (request, params),
            });
            const withdrawals = this.safeValue (response['result'], 'items', []);
            for (let i = 0; i < withdrawals.length; i++) {
                withdrawals[i]['type'] = 'withdrawal';
            }
            return this.parseTransactions (withdrawals, currency, since, limit);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         'id': 1023291,
            //         'coin_symbol': 'ETH',
            //         'to_address': '0x7263....',
            //         'amount': '0.49170000',
            //         'confirmCount': '16',
            //         'createdAt': 1553123867000,
            //         'status': 2
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         'id': 521844,
            //         'coin_symbol': 'ETH',
            //         'to_address': '0xfd4e....',
            //         'addr_remark': '',
            //         'amount': '0.39452750',
            //         'fee': '0.00600000',
            //         'createdAt': 1553226906000,
            //         'memo': '',
            //         'status': 3
            //     }
            //
            const id = this.safeString (transaction, 'id');
            const address = this.safeString (transaction, 'to_address');
            const currencyId = this.safeString (transaction, 'coin_symbol');
            const code = this.safeCurrencyCode (currencyId, currency);
            const timestamp = this.safeString (transaction, 'createdAt');
            let tag = this.safeString (transaction, 'addr_remark');
            const type = this.safeString (transaction, 'type');
            const status = this.parseTransactionStatusByType (this.safeString (transaction, 'status'), type);
            const amount = this.safeNumber (transaction, 'amount');
            let feeCost = this.safeNumber (transaction, 'fee');
            if (type === 'deposit') {
                feeCost = 0;
                tag = undefined;
            }
            const fee = {
                'cost': feeCost,
                'currency': code,
            };
            return {
                'info': transaction,
                'id': id,
                'txid': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'tag': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': fee,
            };
        }
    
        parseTransactionStatusByType (status, type = undefined) {
            const statuses = {
                'deposit': {
                    '1': 'pending',
                    '2': 'ok',
                },
                'withdrawal': {
                    '0': 'pending',
                    '3': 'ok',
                },
            };
            return this.safeString (this.safeValue (statuses, type, {}), status, status);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderType = (type === 'limit') ? 2 : 1;
            const orderSide = (side === 'buy') ? 1 : 2;
            const request = {
                'cmd': 'orderpending/trade',
                'body': this.extend ({
                    'pair': market['id'],
                    'account_type': 0,
                    'order_type': orderType,
                    'order_side': orderSide,
                    'pay_bix': 0,
                    'amount': amount,
                    'price': price,
                }, params),
            };
            const response = await this.privatePostOrderpending (request);
            return {
                'info': response,
                'id': this.safeString (response, 'result'),
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const request = {
                'cmd': 'orderpending/cancelTrade',
                'body': this.extend ({
                    'orders_id': id,
                }, params),
            };
            const response = await this.privatePostOrderpending (request);
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'cmd': 'orderpending/order',
                'body': this.extend ({
                    'id': id.toString (),
                    'account_type': 0, // 0 = spot account
                }, params),
            };
            const response = await this.privatePostOrderpending (request);
            const order = this.safeValue (response, 'result');
            if (this.isEmpty (order)) {
                throw new OrderNotFound (this.id + ' order ' + id + ' not found');
            }
            return this.parseOrder (order);
        }
    
        parseOrder (order, market = undefined) {
            let symbol = undefined;
            if (market === undefined) {
                let marketId = undefined;
                const baseId = this.safeString (order, 'coin_symbol');
                const quoteId = this.safeString (order, 'currency_symbol');
                if ((baseId !== undefined) && (quoteId !== undefined)) {
                    marketId = baseId + '_' + quoteId;
                }
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                }
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const rawType = this.safeString (order, 'order_type');
            const type = (rawType === '1') ? 'market' : 'limit';
            const timestamp = this.safeInteger (order, 'createdAt');
            const price = this.safeNumber (order, 'price');
            const average = this.safeNumber (order, 'deal_price');
            const filled = this.safeNumber (order, 'deal_amount');
            const amount = this.safeNumber (order, 'amount');
            const cost = this.safeNumber2 (order, 'deal_money', 'money');
            const rawSide = this.safeString (order, 'order_side');
            const side = (rawSide === '1') ? 'buy' : 'sell';
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const id = this.safeString (order, 'id');
            const feeCost = this.safeNumber (order, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': undefined,
                };
            }
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': cost,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        parseOrderStatus (status) {
            const statuses = {
                // original comments from bibox:
                '1': 'open', // pending
                '2': 'open', // part completed
                '3': 'closed', // completed
                '4': 'canceled', // part canceled
                '5': 'canceled', // canceled
                '6': 'canceled', // canceling
            };
            return this.safeString (statuses, status, status);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            let pair = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                pair = market['id'];
            }
            const size = limit ? limit : 200;
            const request = {
                'cmd': 'orderpending/orderPendingList',
                'body': this.extend ({
                    'pair': pair,
                    'account_type': 0, // 0 - regular, 1 - margin
                    'page': 1,
                    'size': size,
                }, params),
            };
            const response = await this.privatePostOrderpending (request);
            const orders = this.safeValue (response['result'], 'items', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = 200, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchClosedOrders() requires a `symbol` argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'cmd': 'orderpending/pendingHistoryList',
                'body': this.extend ({
                    'pair': market['id'],
                    'account_type': 0, // 0 - regular, 1 - margin
                    'page': 1,
                    'size': limit,
                }, params),
            };
            const response = await this.privatePostOrderpending (request);
            const orders = this.safeValue (response['result'], 'items', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a `symbol` argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const size = limit ? limit : 200;
            const request = {
                'cmd': 'orderpending/orderHistoryList',
                'body': this.extend ({
                    'pair': market['id'],
                    'account_type': 0, // 0 - regular, 1 - margin
                    'page': 1,
                    'size': size,
                    'coin_symbol': market['baseId'],
                    'currency_symbol': market['quoteId'],
                }, params),
            };
            const response = await this.privatePostOrderpending (request);
            const trades = this.safeValue (response['result'], 'items', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'cmd': 'transfer/transferIn',
                'body': this.extend ({
                    'coin_symbol': currency['id'],
                }, params),
            };
            const response = await this.privatePostTransfer (request);
            //
            //     {
            //         "result":"3Jx6RZ9TNMsAoy9NUzBwZf68QBppDruSKW","cmd":"transfer/transferIn"
            //     }
            //
            //     {
            //         "result":"{\"account\":\"PERSONALLY OMITTED\",\"memo\":\"PERSONALLY OMITTED\"}","cmd":"transfer/transferIn"
            //     }
            //
            const result = this.safeString (response, 'result');
            let address = result;
            let tag = undefined;
            if (this.isJsonEncodedObject (result)) {
                const parsed = JSON.parse (result);
                address = this.safeString (parsed, 'account');
                tag = this.safeString (parsed, 'memo');
            }
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            if (this.password === undefined) {
                if (!('trade_pwd' in params)) {
                    throw new ExchangeError (this.id + ' withdraw() requires this.password set on the exchange instance or a trade_pwd parameter');
                }
            }
            if (!('totp_code' in params)) {
                throw new ExchangeError (this.id + ' withdraw() requires a totp_code parameter for 2FA authentication');
            }
            const request = {
                'trade_pwd': this.password,
                'coin_symbol': currency['id'],
                'amount': amount,
                'addr': address,
            };
            if (tag !== undefined) {
                request['address_remark'] = tag;
            }
            const response = await this.privatePostTransfer ({
                'cmd': 'transfer/transferOut',
                'body': this.extend (request, params),
            });
            return {
                'info': response,
                'id': undefined,
            };
        }
    
        async fetchFundingFees (codes = undefined, params = {}) {
            // by default it will try load withdrawal fees of all currencies (with separate requests)
            // however if you define codes = [ 'ETH', 'BTC' ] in args it will only load those
            await this.loadMarkets ();
            const withdrawFees = {};
            const info = {};
            if (codes === undefined) {
                codes = Object.keys (this.currencies);
            }
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const currency = this.currency (code);
                const request = {
                    'cmd': 'transfer/coinConfig',
                    'body': this.extend ({
                        'coin_symbol': currency['id'],
                    }, params),
                };
                const response = await this.privatePostTransfer (request);
                info[code] = response;
                withdrawFees[code] = this.safeNumber (response['result'], 'withdraw_fee');
            }
            return {
                'info': info,
                'withdraw': withdrawFees,
                'deposit': {},
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.implodeHostname (this.urls['api']) + '/' + this.version + '/' + path;
            const cmds = this.json ([ params ]);
            if (api === 'public') {
                if (method !== 'GET') {
                    body = { 'cmds': cmds };
                } else if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else if (api === 'v2private') {
                this.checkRequiredCredentials ();
                url = this.implodeHostname (this.urls['api']) + '/v2/' + path;
                const json_params = this.json (params);
                body = {
                    'body': json_params,
                    'apikey': this.apiKey,
                    'sign': this.hmac (this.encode (json_params), this.encode (this.secret), 'md5'),
                };
            } else {
                this.checkRequiredCredentials ();
                body = {
                    'cmds': cmds,
                    'apikey': this.apiKey,
                    'sign': this.hmac (this.encode (cmds), this.encode (this.secret), 'md5'),
                };
            }
            if (body !== undefined) {
                body = this.json (body, { 'convertArraysToObjects': true });
            }
            headers = { 'Content-Type': 'application/json' };
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            if ('error' in response) {
                if ('code' in response['error']) {
                    const code = this.safeString (response['error'], 'code');
                    const feedback = this.id + ' ' + body;
                    this.throwExactlyMatchedException (this.exceptions, code, feedback);
                    throw new ExchangeError (feedback);
                }
                throw new ExchangeError (this.id + ' ' + body);
            }
            if (!('result' in response)) {
                throw new ExchangeError (this.id + ' ' + body);
            }
        }
    
        async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined, config = {}, context = {}) {
            const response = await this.fetch2 (path, api, method, params, headers, body, config, context);
            if (method === 'GET') {
                return response;
            } else {
                return response['result'][0];
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],23:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, AuthenticationError, OrderNotFound, InsufficientFunds, PermissionDenied, BadRequest, BadSymbol, RateLimitExceeded, InvalidOrder } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bigone extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bigone',
                'name': 'BigONE',
                'countries': [ 'CN' ],
                'version': 'v3',
                'rateLimit': 1200, // 500 request per 10 minutes
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrders': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': 'min1',
                    '5m': 'min5',
                    '15m': 'min15',
                    '30m': 'min30',
                    '1h': 'hour1',
                    '3h': 'hour3',
                    '4h': 'hour4',
                    '6h': 'hour6',
                    '12h': 'hour12',
                    '1d': 'day1',
                    '1w': 'week1',
                    '1M': 'month1',
                },
                'hostname': 'big.one', // or 'bigone.com'
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/69354403-1d532180-0c91-11ea-88ed-44c06cefdf87.jpg',
                    'api': {
                        'public': 'https://{hostname}/api/v3',
                        'private': 'https://{hostname}/api/v3/viewer',
                    },
                    'www': 'https://big.one',
                    'doc': 'https://open.big.one/docs/api.html',
                    'fees': 'https://bigone.zendesk.com/hc/en-us/articles/115001933374-BigONE-Fee-Policy',
                    'referral': 'https://b1.run/users/new?code=D3LLBVFT',
                },
                'api': {
                    'public': {
                        'get': [
                            'ping',
                            'asset_pairs',
                            'asset_pairs/{asset_pair_name}/depth',
                            'asset_pairs/{asset_pair_name}/trades',
                            'asset_pairs/{asset_pair_name}/ticker',
                            'asset_pairs/{asset_pair_name}/candles',
                            'asset_pairs/tickers',
                        ],
                    },
                    'private': {
                        'get': [
                            'accounts',
                            'fund/accounts',
                            'assets/{asset_symbol}/address',
                            'orders',
                            'orders/{id}',
                            'orders/multi',
                            'trades',
                            'withdrawals',
                            'deposits',
                        ],
                        'post': [
                            'orders',
                            'orders/{id}/cancel',
                            'orders/cancel',
                            'withdrawals',
                            'transfer',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.001'),
                        'taker': this.parseNumber ('0.001'),
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'exceptions': {
                    'exact': {
                        '10001': BadRequest, // syntax error
                        '10005': ExchangeError, // internal error
                        "Amount's scale must greater than AssetPair's base scale": InvalidOrder,
                        "Price mulit with amount should larger than AssetPair's min_quote_value": InvalidOrder,
                        '10007': BadRequest, // parameter error, {"code":10007,"message":"Amount's scale must greater than AssetPair's base scale"}
                        '10011': ExchangeError, // system error
                        '10013': OrderNotFound, // {"code":10013,"message":"Resource not found"}
                        '10014': InsufficientFunds, // {"code":10014,"message":"Insufficient funds"}
                        '10403': PermissionDenied, // permission denied
                        '10429': RateLimitExceeded, // too many requests
                        '40004': AuthenticationError, // {"code":40004,"message":"invalid jwt"}
                        '40103': AuthenticationError, // invalid otp code
                        '40104': AuthenticationError, // invalid asset pin code
                        '40301': PermissionDenied, // {"code":40301,"message":"Permission denied withdrawal create"}
                        '40302': ExchangeError, // already requested
                        '40601': ExchangeError, // resource is locked
                        '40602': ExchangeError, // resource is depleted
                        '40603': InsufficientFunds, // insufficient resource
                        '40605': InvalidOrder, // {"code":40605,"message":"Price less than the minimum order price"}
                        '40120': InvalidOrder, // Order is in trading
                        '40121': InvalidOrder, // Order is already cancelled or filled
                        '60100': BadSymbol, // {"code":60100,"message":"Asset pair is suspended"}
                    },
                    'broad': {
                    },
                },
                'commonCurrencies': {
                    'CRE': 'Cybereits',
                    'FXT': 'FXTTOKEN',
                    'MBN': 'Mobilian Coin',
                    'ONE': 'BigONE Token',
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetAssetPairs (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "id":"01e48809-b42f-4a38-96b1-c4c547365db1",
            //                 "name":"PCX-BTC",
            //                 "quote_scale":7,
            //                 "quote_asset":{
            //                     "id":"0df9c3c3-255a-46d7-ab82-dedae169fba9",
            //                     "symbol":"BTC",
            //                     "name":"Bitcoin",
            //                 },
            //                 "base_asset":{
            //                     "id":"405484f7-4b03-4378-a9c1-2bd718ecab51",
            //                     "symbol":"PCX",
            //                     "name":"ChainX",
            //                 },
            //                 "base_scale":3,
            //                 "min_quote_value":"0.0001",
            //             },
            //         ]
            //     }
            //
            const markets = this.safeValue (response, 'data', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'name');
                const uuid = this.safeString (market, 'id');
                const baseAsset = this.safeValue (market, 'base_asset', {});
                const quoteAsset = this.safeValue (market, 'quote_asset', {});
                const baseId = this.safeString (baseAsset, 'symbol');
                const quoteId = this.safeString (quoteAsset, 'symbol');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const amountPrecisionString = this.safeString (market, 'base_scale');
                const pricePrecisionString = this.safeString (market, 'quote_scale');
                const amountLimit = this.parsePrecision (amountPrecisionString);
                const priceLimit = this.parsePrecision (pricePrecisionString);
                const precision = {
                    'amount': parseInt (amountPrecisionString),
                    'price': parseInt (pricePrecisionString),
                };
                const minCost = this.safeNumber (market, 'min_quote_value');
                const entry = {
                    'id': id,
                    'uuid': uuid,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.parseNumber (amountLimit),
                            'max': undefined,
                        },
                        'price': {
                            'min': this.parseNumber (priceLimit),
                            'max': undefined,
                        },
                        'cost': {
                            'min': minCost,
                            'max': undefined,
                        },
                    },
                    'info': market,
                };
                result.push (entry);
            }
            return result;
        }
    
        async loadMarkets (reload = false, params = {}) {
            const markets = await super.loadMarkets (reload, params);
            let marketsByUuid = this.safeValue (this.options, 'marketsByUuid');
            if ((marketsByUuid === undefined) || reload) {
                marketsByUuid = {};
                for (let i = 0; i < this.symbols.length; i++) {
                    const symbol = this.symbols[i];
                    const market = this.markets[symbol];
                    const uuid = this.safeString (market, 'uuid');
                    marketsByUuid[uuid] = market;
                }
                this.options['marketsByUuid'] = marketsByUuid;
            }
            return markets;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         "asset_pair_name":"ETH-BTC",
            //         "bid":{"price":"0.021593","order_count":1,"quantity":"0.20936"},
            //         "ask":{"price":"0.021613","order_count":1,"quantity":"2.87064"},
            //         "open":"0.021795",
            //         "high":"0.021795",
            //         "low":"0.021471",
            //         "close":"0.021613",
            //         "volume":"117078.90431",
            //         "daily_change":"-0.000182"
            //     }
            //
            const marketId = this.safeString (ticker, 'asset_pair_name');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = undefined;
            const close = this.safeNumber (ticker, 'close');
            const bid = this.safeValue (ticker, 'bid', {});
            const ask = this.safeValue (ticker, 'ask', {});
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (bid, 'price'),
                'bidVolume': this.safeNumber (bid, 'quantity'),
                'ask': this.safeNumber (ask, 'price'),
                'askVolume': this.safeNumber (ask, 'quantity'),
                'vwap': undefined,
                'open': this.safeNumber (ticker, 'open'),
                'close': close,
                'last': close,
                'previousClose': undefined,
                'change': this.safeNumber (ticker, 'daily_change'),
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'asset_pair_name': market['id'],
            };
            const response = await this.publicGetAssetPairsAssetPairNameTicker (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":{
            //             "asset_pair_name":"ETH-BTC",
            //             "bid":{"price":"0.021593","order_count":1,"quantity":"0.20936"},
            //             "ask":{"price":"0.021613","order_count":1,"quantity":"2.87064"},
            //             "open":"0.021795",
            //             "high":"0.021795",
            //             "low":"0.021471",
            //             "close":"0.021613",
            //             "volume":"117078.90431",
            //             "daily_change":"-0.000182"
            //         }
            //     }
            //
            const ticker = this.safeValue (response, 'data', {});
            return this.parseTicker (ticker, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbols !== undefined) {
                const ids = this.marketIds (symbols);
                request['pair_names'] = ids.join (',');
            }
            const response = await this.publicGetAssetPairsTickers (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {
            //                 "asset_pair_name":"PCX-BTC",
            //                 "bid":{"price":"0.000234","order_count":1,"quantity":"0.518"},
            //                 "ask":{"price":"0.0002348","order_count":1,"quantity":"2.348"},
            //                 "open":"0.0002343",
            //                 "high":"0.0002348",
            //                 "low":"0.0002162",
            //                 "close":"0.0002348",
            //                 "volume":"12887.016",
            //                 "daily_change":"0.0000005"
            //             },
            //             {
            //                 "asset_pair_name":"GXC-USDT",
            //                 "bid":{"price":"0.5054","order_count":1,"quantity":"40.53"},
            //                 "ask":{"price":"0.5055","order_count":1,"quantity":"38.53"},
            //                 "open":"0.5262",
            //                 "high":"0.5323",
            //                 "low":"0.5055",
            //                 "close":"0.5055",
            //                 "volume":"603963.05",
            //                 "daily_change":"-0.0207"
            //             }
            //         ]
            //     }
            //
            const tickers = this.safeValue (response, 'data', []);
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const ticker = this.parseTicker (tickers[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetPing (params);
            //
            //     {
            //         "data": {
            //             "timestamp": 1527665262168391000
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const timestamp = this.safeInteger (data, 'timestamp');
            return parseInt (timestamp / 1000000);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'asset_pair_name': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 50, max 200
            }
            const response = await this.publicGetAssetPairsAssetPairNameDepth (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data": {
            //             "asset_pair_name": "EOS-BTC",
            //             "bids": [
            //                 { "price": "42", "order_count": 4, "quantity": "23.33363711" }
            //             ],
            //             "asks": [
            //                 { "price": "45", "order_count": 2, "quantity": "4193.3283464" }
            //             ]
            //         }
            //     }
            //
            const orderbook = this.safeValue (response, 'data', {});
            return this.parseOrderBook (orderbook, symbol, undefined, 'bids', 'asks', 'price', 'quantity');
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "id": 38199941,
            //         "price": "3378.67",
            //         "amount": "0.019812",
            //         "taker_side": "ASK",
            //         "created_at": "2019-01-29T06:05:56Z"
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "id": 10854280,
            //         "asset_pair_name": "XIN-USDT",
            //         "price": "70",
            //         "amount": "1",
            //         "taker_side": "ASK",
            //         "maker_order_id": 58284908,
            //         "taker_order_id": 58284909,
            //         "maker_fee": "0.0008",
            //         "taker_fee": "0.07",
            //         "side": "SELF_TRADING",
            //         "inserted_at": "2019-04-16T12:00:01Z"
            //     },
            //
            //     {
            //         "id": 10854263,
            //         "asset_pair_name": "XIN-USDT",
            //         "price": "75.7",
            //         "amount": "12.743149",
            //         "taker_side": "BID",
            //         "maker_order_id": null,
            //         "taker_order_id": 58284888,
            //         "maker_fee": null,
            //         "taker_fee": "0.0025486298",
            //         "side": "BID",
            //         "inserted_at": "2019-04-15T06:20:57Z"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString2 (trade, 'created_at', 'inserted_at'));
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const marketId = this.safeString (trade, 'asset_pair_name');
            const symbol = this.safeSymbol (marketId, market, '-');
            let side = this.safeString (trade, 'side');
            const takerSide = this.safeString (trade, 'taker_side');
            let takerOrMaker = undefined;
            if ((takerSide !== undefined) && (side !== undefined) && (side !== 'SELF_TRADING')) {
                takerOrMaker = (takerSide === side) ? 'taker' : 'maker';
            }
            if (side === undefined) {
                // taker side is not related to buy/sell side
                // the following code is probably a mistake
                side = (takerSide === 'ASK') ? 'sell' : 'buy';
            } else {
                if (side === 'BID') {
                    side = 'buy';
                } else if (side === 'ASK') {
                    side = 'sell';
                }
            }
            const makerOrderId = this.safeString (trade, 'maker_order_id');
            const takerOrderId = this.safeString (trade, 'taker_order_id');
            let orderId = undefined;
            if (makerOrderId !== undefined) {
                if (takerOrderId !== undefined) {
                    orderId = [ makerOrderId, takerOrderId ];
                } else {
                    orderId = makerOrderId;
                }
            } else if (takerOrderId !== undefined) {
                orderId = takerOrderId;
            }
            const id = this.safeString (trade, 'id');
            const result = {
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': 'limit',
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': this.parseNumber (cost),
                'info': trade,
            };
            let makerCurrencyCode = undefined;
            let takerCurrencyCode = undefined;
            if ((market !== undefined) && (takerOrMaker !== undefined)) {
                if (side === 'buy') {
                    if (takerOrMaker === 'maker') {
                        makerCurrencyCode = market['base'];
                        takerCurrencyCode = market['quote'];
                    } else {
                        makerCurrencyCode = market['quote'];
                        takerCurrencyCode = market['base'];
                    }
                } else {
                    if (takerOrMaker === 'maker') {
                        makerCurrencyCode = market['quote'];
                        takerCurrencyCode = market['base'];
                    } else {
                        makerCurrencyCode = market['base'];
                        takerCurrencyCode = market['quote'];
                    }
                }
            } else if (side === 'SELF_TRADING') {
                if (takerSide === 'BID') {
                    makerCurrencyCode = market['quote'];
                    takerCurrencyCode = market['base'];
                } else if (takerSide === 'ASK') {
                    makerCurrencyCode = market['base'];
                    takerCurrencyCode = market['quote'];
                }
            }
            const makerFeeCost = this.safeNumber (trade, 'maker_fee');
            const takerFeeCost = this.safeNumber (trade, 'taker_fee');
            if (makerFeeCost !== undefined) {
                if (takerFeeCost !== undefined) {
                    result['fees'] = [
                        { 'cost': makerFeeCost, 'currency': makerCurrencyCode },
                        { 'cost': takerFeeCost, 'currency': takerCurrencyCode },
                    ];
                } else {
                    result['fee'] = { 'cost': makerFeeCost, 'currency': makerCurrencyCode };
                }
            } else if (takerFeeCost !== undefined) {
                result['fee'] = { 'cost': takerFeeCost, 'currency': takerCurrencyCode };
            } else {
                result['fee'] = undefined;
            }
            return result;
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'asset_pair_name': market['id'],
            };
            const response = await this.publicGetAssetPairsAssetPairNameTrades (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "id": 38199941,
            //                 "price": "3378.67",
            //                 "amount": "0.019812",
            //                 "taker_side": "ASK",
            //                 "created_at": "2019-01-29T06:05:56Z"
            //             },
            //             {
            //                 "id": 38199934,
            //                 "price": "3376.14",
            //                 "amount": "0.019384",
            //                 "taker_side": "ASK",
            //                 "created_at": "2019-01-29T06:05:40Z"
            //             }
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'data', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         close: '0.021562',
            //         high: '0.021563',
            //         low: '0.02156',
            //         open: '0.021563',
            //         time: '2019-11-21T07:54:00Z',
            //         volume: '59.84376'
            //     }
            //
            return [
                this.parse8601 (this.safeString (ohlcv, 'time')),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (limit === undefined) {
                limit = 100; // default 100, max 500
            }
            const request = {
                'asset_pair_name': market['id'],
                'period': this.timeframes[timeframe],
                'limit': limit,
            };
            if (since !== undefined) {
                // const start = parseInt (since / 1000);
                const duration = this.parseTimeframe (timeframe);
                const end = this.sum (since, limit * duration * 1000);
                request['time'] = this.iso8601 (end);
            }
            const response = await this.publicGetAssetPairsAssetPairNameCandles (this.extend (request, params));
            //
            //     {
            //         code: 0,
            //         data: [
            //             {
            //                 close: '0.021656',
            //                 high: '0.021658',
            //                 low: '0.021652',
            //                 open: '0.021652',
            //                 time: '2019-11-21T09:30:00Z',
            //                 volume: '53.08664'
            //             },
            //             {
            //                 close: '0.021652',
            //                 high: '0.021656',
            //                 low: '0.021652',
            //                 open: '0.021656',
            //                 time: '2019-11-21T09:29:00Z',
            //                 volume: '88.39861'
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const type = this.safeString (params, 'type', '');
            params = this.omit (params, 'type');
            const method = 'privateGet' + this.capitalize (type) + 'Accounts';
            const response = await this[method] (params);
            //
            //     {
            //         "code":0,
            //         "data":[
            //             {"asset_symbol":"NKC","balance":"0","locked_balance":"0"},
            //             {"asset_symbol":"UBTC","balance":"0","locked_balance":"0"},
            //             {"asset_symbol":"READ","balance":"0","locked_balance":"0"},
            //         ],
            //     }
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const balances = this.safeValue (response, 'data', []);
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const symbol = this.safeString (balance, 'asset_symbol');
                const code = this.safeCurrencyCode (symbol);
                const account = this.account ();
                account['total'] = this.safeString (balance, 'balance');
                account['used'] = this.safeString (balance, 'locked_balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrder (order, market = undefined) {
            //
            //    {
            //        "id": 10,
            //        "asset_pair_name": "EOS-BTC",
            //        "price": "10.00",
            //        "amount": "10.00",
            //        "filled_amount": "9.0",
            //        "avg_deal_price": "12.0",
            //        "side": "ASK",
            //        "state": "FILLED",
            //        "created_at":"2019-01-29T06:05:56Z",
            //        "updated_at":"2019-01-29T06:05:56Z",
            //    }
            //
            const id = this.safeString (order, 'id');
            const marketId = this.safeString (order, 'asset_pair_name');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount');
            const filled = this.safeNumber (order, 'filled_amount');
            const status = this.parseOrderStatus (this.safeString (order, 'state'));
            let side = this.safeString (order, 'side');
            if (side === 'BID') {
                side = 'buy';
            } else {
                side = 'sell';
            }
            const lastTradeTimestamp = this.parse8601 (this.safeString (order, 'updated_at'));
            const average = this.safeNumber (order, 'avg_deal_price');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': undefined,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            side = (side === 'buy') ? 'BID' : 'ASK';
            const uppercaseType = type.toUpperCase ();
            const request = {
                'asset_pair_name': market['id'], // asset pair name BTC-USDT, required
                'side': side, // order side one of "ASK"/"BID", required
                'amount': this.amountToPrecision (symbol, amount), // order amount, string, required
                // 'price': this.priceToPrecision (symbol, price), // order price, string, required
                'type': uppercaseType,
                // 'operator': 'GTE', // stop orders only, GTE greater than and equal, LTE less than and equal
                // 'immediate_or_cancel': false, // limit orders only, must be false when post_only is true
                // 'post_only': false, // limit orders only, must be false when immediate_or_cancel is true
            };
            if (uppercaseType === 'LIMIT') {
                request['price'] = this.priceToPrecision (symbol, price);
            } else {
                const isStopLimit = (uppercaseType === 'STOP_LIMIT');
                const isStopMarket = (uppercaseType === 'STOP_MARKET');
                if (isStopLimit || isStopMarket) {
                    const stopPrice = this.safeNumber2 (params, 'stop_price', 'stopPrice');
                    if (stopPrice === undefined) {
                        throw new ArgumentsRequired (this.id + ' createOrder() requires a stop_price parameter');
                    }
                    request['stop_price'] = this.priceToPrecision (symbol, stopPrice);
                    params = this.omit (params, [ 'stop_price', 'stopPrice' ]);
                }
                if (isStopLimit) {
                    request['price'] = this.priceToPrecision (symbol, price);
                }
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            //
            //    {
            //        "id": 10,
            //        "asset_pair_name": "EOS-BTC",
            //        "price": "10.00",
            //        "amount": "10.00",
            //        "filled_amount": "9.0",
            //        "avg_deal_price": "12.0",
            //        "side": "ASK",
            //        "state": "FILLED",
            //        "created_at":"2019-01-29T06:05:56Z",
            //        "updated_at":"2019-01-29T06:05:56Z"
            //    }
            //
            const order = this.safeValue (response, 'data');
            return this.parseOrder (order, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = { 'id': id };
            const response = await this.privatePostOrdersIdCancel (this.extend (request, params));
            //    {
            //        "id": 10,
            //        "asset_pair_name": "EOS-BTC",
            //        "price": "10.00",
            //        "amount": "10.00",
            //        "filled_amount": "9.0",
            //        "avg_deal_price": "12.0",
            //        "side": "ASK",
            //        "state": "CANCELLED",
            //        "created_at":"2019-01-29T06:05:56Z",
            //        "updated_at":"2019-01-29T06:05:56Z"
            //    }
            const order = this.safeValue (response, 'data');
            return this.parseOrder (order);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'asset_pair_name': market['id'],
            };
            const response = await this.privatePostOrdersCancel (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data": {
            //             "cancelled":[
            //                 58272370,
            //                 58272377
            //             ],
            //             "failed": []
            //         }
            //     }
            //
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = { 'id': id };
            const response = await this.privateGetOrdersId (this.extend (request, params));
            const order = this.safeValue (response, 'data', {});
            return this.parseOrder (order);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'asset_pair_name': market['id'],
                // 'page_token': 'dxzef', // request page after this page token
                // 'side': 'ASK', // 'ASK' or 'BID', optional
                // 'state': 'FILLED', // 'CANCELLED', 'FILLED', 'PENDING'
                // 'limit' 20, // default 20, max 200
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 20, max 200
            }
            const response = await this.privateGetOrders (this.extend (request, params));
            //
            //    {
            //        "code":0,
            //        "data": [
            //             {
            //                 "id": 10,
            //                 "asset_pair_name": "ETH-BTC",
            //                 "price": "10.00",
            //                 "amount": "10.00",
            //                 "filled_amount": "9.0",
            //                 "avg_deal_price": "12.0",
            //                 "side": "ASK",
            //                 "state": "FILLED",
            //                 "created_at":"2019-01-29T06:05:56Z",
            //                 "updated_at":"2019-01-29T06:05:56Z",
            //             },
            //         ],
            //        "page_token":"dxzef",
            //    }
            //
            const orders = this.safeValue (response, 'data', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            const market = this.market (symbol);
            const request = {
                'asset_pair_name': market['id'],
                // 'page_token': 'dxzef', // request page after this page token
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 20, max 200
            }
            const response = await this.privateGetTrades (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "id": 10854280,
            //                 "asset_pair_name": "XIN-USDT",
            //                 "price": "70",
            //                 "amount": "1",
            //                 "taker_side": "ASK",
            //                 "maker_order_id": 58284908,
            //                 "taker_order_id": 58284909,
            //                 "maker_fee": "0.0008",
            //                 "taker_fee": "0.07",
            //                 "side": "SELF_TRADING",
            //                 "inserted_at": "2019-04-16T12:00:01Z"
            //             },
            //             {
            //                 "id": 10854263,
            //                 "asset_pair_name": "XIN-USDT",
            //                 "price": "75.7",
            //                 "amount": "12.743149",
            //                 "taker_side": "BID",
            //                 "maker_order_id": null,
            //                 "taker_order_id": 58284888,
            //                 "maker_fee": null,
            //                 "taker_fee": "0.0025486298",
            //                 "side": "BID",
            //                 "inserted_at": "2019-04-15T06:20:57Z"
            //             }
            //         ],
            //         "page_token":"dxfv"
            //     }
            //
            const trades = this.safeValue (response, 'data', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'PENDING': 'open',
                'FILLED': 'closed',
                'CANCELLED': 'canceled',
            };
            return this.safeString (statuses, status);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'state': 'PENDING',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'state': 'FILLED',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        nonce () {
            return this.microseconds () * 1000;
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const query = this.omit (params, this.extractParams (path));
            const baseUrl = this.implodeHostname (this.urls['api'][api]);
            let url = baseUrl + '/' + this.implodeParams (path, params);
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const request = {
                    'type': 'OpenAPIV2',
                    'sub': this.apiKey,
                    'nonce': nonce,
                    // 'recv_window': '30', // default 30
                };
                const jwt = this.jwt (request, this.encode (this.secret));
                headers = {
                    'Authorization': 'Bearer ' + jwt,
                };
                if (method === 'GET') {
                    if (Object.keys (query).length) {
                        url += '?' + this.urlencode (query);
                    }
                } else if (method === 'POST') {
                    headers['Content-Type'] = 'application/json';
                    body = this.json (query);
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset_symbol': currency['id'],
            };
            const response = await this.privateGetAssetsAssetSymbolAddress (this.extend (request, params));
            //
            // the actual response format is not the same as the documented one
            // the data key contains an array in the actual response
            //
            //     {
            //         "code":0,
            //         "message":"",
            //         "data":[
            //             {
            //                 "id":5521878,
            //                 "chain":"Bitcoin",
            //                 "value":"1GbmyKoikhpiQVZ1C9sbF17mTyvBjeobVe",
            //                 "memo":""
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const dataLength = data.length;
            if (dataLength < 1) {
                throw new ExchangeError (this.id + 'fetchDepositAddress() returned empty address response');
            }
            const firstElement = data[0];
            const address = this.safeString (firstElement, 'value');
            const tag = this.safeString (firstElement, 'memo');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                // what are other statuses here?
                'WITHHOLD': 'ok', // deposits
                'UNCONFIRMED': 'pending',
                'CONFIRMED': 'ok', // withdrawals
                'COMPLETED': 'ok',
                'PENDING': 'pending',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         "amount": "25.0",
            //         "asset_symbol": "BTS"
            //         "confirms": 100,
            //         "id": 5,
            //         "inserted_at": "2018-02-16T11:39:58.000Z",
            //         "is_internal": false,
            //         "kind": "default",
            //         "memo": "",
            //         "state": "WITHHOLD",
            //         "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
            //         "updated_at": "2018-11-09T10:20:09.000Z",
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         "amount": "5",
            //         "asset_symbol": "ETH",
            //         "completed_at": "2018-03-15T16:13:45.610463Z",
            //         "customer_id": "10",
            //         "id": 10,
            //         "inserted_at": "2018-03-15T16:13:45.610463Z",
            //         "is_internal": true,
            //         "note": "2018-03-15T16:13:45.610463Z",
            //         "state": "CONFIRMED",
            //         "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
            //         "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
            //     }
            //
            // withdraw
            //
            //     {
            //         "id":1077391,
            //         "customer_id":1082679,
            //         "amount":"21.9000000000000000",
            //         "txid":"",
            //         "is_internal":false,
            //         "kind":"on_chain",
            //         "state":"PENDING",
            //         "inserted_at":"2020-06-03T00:50:57+00:00",
            //         "updated_at":"2020-06-03T00:50:57+00:00",
            //         "memo":"",
            //         "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
            //         "fee":"0.1000000000000000",
            //         "asset_symbol":"XRP"
            //     }
            //
            const currencyId = this.safeString (transaction, 'asset_symbol');
            const code = this.safeCurrencyCode (currencyId);
            const id = this.safeInteger (transaction, 'id');
            const amount = this.safeNumber (transaction, 'amount');
            const status = this.parseTransactionStatus (this.safeString (transaction, 'state'));
            const timestamp = this.parse8601 (this.safeString (transaction, 'inserted_at'));
            const updated = this.parse8601 (this.safeString2 (transaction, 'updated_at', 'completed_at'));
            const txid = this.safeString (transaction, 'txid');
            const address = this.safeString (transaction, 'target_address');
            const tag = this.safeString (transaction, 'memo');
            const type = ('customer_id' in transaction) ? 'deposit' : 'withdrawal';
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': undefined,
                'address': undefined,
                'addressTo': address,
                'tagFrom': undefined,
                'tag': tag,
                'tagTo': undefined,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': undefined,
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'page_token': 'dxzef', // request page after this page token
                // 'limit': 50, // optional, default 50
                // 'kind': 'string', // optional - air_drop, big_holder_dividend, default, eosc_to_eos, internal, equally_airdrop, referral_mining, one_holder_dividend, single_customer, snapshotted_airdrop, trade_mining
                // 'asset_symbol': 'BTC', // optional
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['asset_symbol'] = currency['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 50
            }
            const response = await this.privateGetDeposits (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "page_token": "NQ==",
            //         "data": [
            //             {
            //                 "id": 5,
            //                 "amount": "25.0",
            //                 "confirms": 100,
            //                 "txid": "72e03037d144dae3d32b68b5045462b1049a0755",
            //                 "is_internal": false,
            //                 "inserted_at": "2018-02-16T11:39:58.000Z",
            //                 "updated_at": "2018-11-09T10:20:09.000Z",
            //                 "kind": "default",
            //                 "memo": "",
            //                 "state": "WITHHOLD",
            //                 "asset_symbol": "BTS"
            //             }
            //         ]
            //     }
            //
            const deposits = this.safeValue (response, 'data', []);
            return this.parseTransactions (deposits, code, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'page_token': 'dxzef', // request page after this page token
                // 'limit': 50, // optional, default 50
                // 'kind': 'string', // optional - air_drop, big_holder_dividend, default, eosc_to_eos, internal, equally_airdrop, referral_mining, one_holder_dividend, single_customer, snapshotted_airdrop, trade_mining
                // 'asset_symbol': 'BTC', // optional
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['asset_symbol'] = currency['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 50
            }
            const response = await this.privateGetWithdrawals (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "id": 10,
            //                 "customer_id": "10",
            //                 "asset_symbol": "ETH",
            //                 "amount": "5",
            //                 "state": "CONFIRMED",
            //                 "note": "2018-03-15T16:13:45.610463Z",
            //                 "txid": "0x4643bb6b393ac20a6175c713175734a72517c63d6f73a3ca90a15356f2e967da0",
            //                 "completed_at": "2018-03-15T16:13:45.610463Z",
            //                 "inserted_at": "2018-03-15T16:13:45.610463Z",
            //                 "is_internal": true,
            //                 "target_address": "0x4643bb6b393ac20a6175c713175734a72517c63d6f7"
            //             }
            //         ],
            //         "page_token":"dxvf"
            //     }
            //
            const withdrawals = this.safeValue (response, 'data', []);
            return this.parseTransactions (withdrawals, code, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'symbol': currency['id'],
                'target_address': address,
                'amount': this.currencyToPrecision (code, amount),
            };
            if (tag !== undefined) {
                request['memo'] = tag;
            }
            // requires write permission on the wallet
            const response = await this.privatePostWithdrawals (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "message":"",
            //         "data":{
            //             "id":1077391,
            //             "customer_id":1082679,
            //             "amount":"21.9000000000000000",
            //             "txid":"",
            //             "is_internal":false,
            //             "kind":"on_chain",
            //             "state":"PENDING",
            //             "inserted_at":"2020-06-03T00:50:57+00:00",
            //             "updated_at":"2020-06-03T00:50:57+00:00",
            //             "memo":"",
            //             "target_address":"rDYtYT3dBeuw376rvHqoZBKW3UmvguoBAf",
            //             "fee":"0.1000000000000000",
            //             "asset_symbol":"XRP"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseTransaction (data, currency);
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //      {"code":10013,"message":"Resource not found"}
            //      {"code":40004,"message":"invalid jwt"}
            //
            const code = this.safeString (response, 'code');
            const message = this.safeString (response, 'message');
            if (code !== '0') {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],24:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, ExchangeNotAvailable, InsufficientFunds, OrderNotFound, InvalidOrder, DDoSProtection, InvalidNonce, AuthenticationError, RateLimitExceeded, PermissionDenied, NotSupported, BadRequest, BadSymbol, AccountSuspended, OrderImmediatelyFillable } = require ('./base/errors');
    const { TRUNCATE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class binance extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'binance',
                'name': 'Binance',
                'countries': [ 'JP', 'MT' ], // Japan, Malta
                'rateLimit': 50,
                'certified': true,
                'pro': true,
                // new metainfo interface
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchCurrencies': true,
                    'fetchBalance': true,
                    'fetchBidsAsks': true,
                    'fetchClosedOrders': 'emulated',
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchFundingFees': true,
                    'fetchFundingHistory': true,
                    'fetchFundingRate': true,
                    'fetchFundingRates': true,
                    'fetchIsolatedPositions': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrders': true,
                    'fetchOrderBook': true,
                    'fetchPositions': true,
                    'fetchStatus': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTradingFee': true,
                    'fetchTradingFees': true,
                    'fetchTransactions': false,
                    'fetchWithdrawals': true,
                    'setLeverage': true,
                    'setMarginMode': true,
                    'withdraw': true,
                    'transfer': true,
                    'fetchTransfers': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '3m': '3m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '2h': '2h',
                    '4h': '4h',
                    '6h': '6h',
                    '8h': '8h',
                    '12h': '12h',
                    '1d': '1d',
                    '3d': '3d',
                    '1w': '1w',
                    '1M': '1M',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/29604020-d5483cdc-87ee-11e7-94c7-d1a8d9169293.jpg',
                    'test': {
                        'dapiPublic': 'https://testnet.binancefuture.com/dapi/v1',
                        'dapiPrivate': 'https://testnet.binancefuture.com/dapi/v1',
                        'fapiPublic': 'https://testnet.binancefuture.com/fapi/v1',
                        'fapiPrivate': 'https://testnet.binancefuture.com/fapi/v1',
                        'fapiPrivateV2': 'https://testnet.binancefuture.com/fapi/v2',
                        'public': 'https://testnet.binance.vision/api/v3',
                        'private': 'https://testnet.binance.vision/api/v3',
                        'v3': 'https://testnet.binance.vision/api/v3',
                        'v1': 'https://testnet.binance.vision/api/v1',
                    },
                    'api': {
                        'wapi': 'https://api.binance.com/wapi/v3',
                        'sapi': 'https://api.binance.com/sapi/v1',
                        'dapiPublic': 'https://dapi.binance.com/dapi/v1',
                        'dapiPrivate': 'https://dapi.binance.com/dapi/v1',
                        'dapiPrivateV2': 'https://dapi.binance.com/dapi/v2',
                        'dapiData': 'https://dapi.binance.com/futures/data',
                        'fapiPublic': 'https://fapi.binance.com/fapi/v1',
                        'fapiPrivate': 'https://fapi.binance.com/fapi/v1',
                        'fapiData': 'https://fapi.binance.com/futures/data',
                        'fapiPrivateV2': 'https://fapi.binance.com/fapi/v2',
                        'public': 'https://api.binance.com/api/v3',
                        'private': 'https://api.binance.com/api/v3',
                        'v3': 'https://api.binance.com/api/v3',
                        'v1': 'https://api.binance.com/api/v1',
                    },
                    'www': 'https://www.binance.com',
                    'referral': {
                        'url': 'https://www.binance.com/en/register?ref=BLEJC98C',
                        'discount': 0.2,
                    },
                    'doc': [
                        'https://binance-docs.github.io/apidocs/spot/en',
                    ],
                    'api_management': 'https://www.binance.com/en/usercenter/settings/api-management',
                    'fees': 'https://www.binance.com/en/fee/schedule',
                },
                'depth': 1,
                'api': {
                    // the API structure below will need 3-layer apidefs
                    'sapi': {
                        'get': {
                            'accountSnapshot': 1,
                            'system/status': 1,
                            // these endpoints require this.apiKey
                            'margin/asset': 1,
                            'margin/pair': 1,
                            'margin/allAssets': 1,
                            'margin/allPairs': 1,
                            'margin/priceIndex': 1,
                            // these endpoints require this.apiKey + this.secret
                            'asset/assetDividend': 1,
                            'asset/dribblet': 1,
                            'asset/transfer': 1,
                            'asset/assetDetail': 1,
                            'asset/tradeFee': 1,
                            'asset/get-funding-asset': 1,
                            'margin/loan': 1,
                            'margin/repay': 1,
                            'margin/account': 1,
                            'margin/transfer': 1,
                            'margin/interestHistory': 1,
                            'margin/forceLiquidationRec': 1,
                            'margin/order': 1,
                            'margin/openOrders': 1,
                            'margin/allOrders': 1,
                            'margin/myTrades': 1,
                            'margin/maxBorrowable': 5,
                            'margin/maxTransferable': 5,
                            'margin/isolated/transfer': 1,
                            'margin/isolated/account': 1,
                            'margin/isolated/pair': 1,
                            'margin/isolated/allPairs': 1,
                            'margin/interestRateHistory': 1,
                            'margin/orderList': 2,
                            'margin/allOrderList': 10,
                            'margin/openOrderList': 3,
                            'fiat/orders': 1,
                            'fiat/payments': 1,
                            'futures/transfer': 5,
                            'futures/loan/borrow/history': 1,
                            'futures/loan/repay/history': 1,
                            'futures/loan/wallet': 1,
                            'futures/loan/configs': 1,
                            'futures/loan/calcAdjustLevel': 1,
                            'futures/loan/calcMaxAdjustAmount': 1,
                            'futures/loan/adjustCollateral/history': 1,
                            'futures/loan/liquidationHistory': 1,
                            // https://binance-docs.github.io/apidocs/spot/en/#withdraw-sapi
                            'capital/config/getall': 1, // get networks for withdrawing USDT ERC20 vs USDT Omni
                            'capital/deposit/address': 1,
                            'capital/deposit/hisrec': 1,
                            'capital/deposit/subAddress': 1,
                            'capital/deposit/subHisrec': 1,
                            'capital/withdraw/history': 1,
                            'bnbBurn': 1,
                            'sub-account/assets': 1,
                            'sub-account/futures/account': 1,
                            'sub-account/futures/accountSummary': 20,
                            'sub-account/futures/positionRisk': 1,
                            'sub-account/futures/internalTransfer': 1,
                            'sub-account/list': 1,
                            'sub-account/margin/account': 1,
                            'sub-account/margin/accountSummary': 1,
                            'sub-account/spotSummary': 5,
                            'sub-account/status': 1,
                            'sub-account/sub/transfer/history': 1,
                            'sub-account/transfer/subUserHistory': 1,
                            'sub-account/universalTransfer': 1,
                            // lending endpoints
                            'lending/daily/product/list': 1,
                            'lending/daily/userLeftQuota': 1,
                            'lending/daily/userRedemptionQuota': 1,
                            'lending/daily/token/position': 1,
                            'lending/union/account': 1,
                            'lending/union/purchaseRecord': 1,
                            'lending/union/redemptionRecord': 1,
                            'lending/union/interestHistory': 1,
                            'lending/project/list': 1,
                            'lending/project/position/list': 1,
                            // mining endpoints
                            'mining/pub/algoList': 1,
                            'mining/pub/coinList': 1,
                            'mining/worker/detail': 5,
                            'mining/worker/list': 5,
                            'mining/payment/list': 5,
                            'mining/statistics/user/status': 5,
                            'mining/statistics/user/list': 5,
                            // liquid swap endpoints
                            'bswap/pools': 1,
                            'bswap/liquidity': { 'cost': 1, 'noPoolId': 10 },
                            'bswap/liquidityOps': 2,
                            'bswap/quote': 2,
                            'bswap/swap': 1,
                            // leveraged token endpoints
                            'blvt/tokenInfo': 1,
                            'blvt/subscribe/record': 1,
                            'blvt/redeem/record': 1,
                            'blvt/userLimit': 1,
                            // broker api
                            'apiReferral/ifNewUser': 1,
                            'apiReferral/customization': 1,
                            'apiReferral/userCustomization': 1,
                            'apiReferral/rebate/recentRecord': 1,
                            'apiReferral/rebate/historicalRecord': 1,
                            'apiReferral/kickback/recentRecord': 1,
                            'apiReferral/kickback/historicalRecord': 1,
                            // brokerage API
                            'broker/subAccountApi': 1,
                            'broker/subAccount': 1,
                            'broker/subAccountApi/commission/futures': 1,
                            'broker/subAccountApi/commission/coinFutures': 1,
                            'broker/info': 1,
                            'broker/transfer': 1,
                            'broker/transfer/futures': 1,
                            'broker/rebate/recentRecord': 1,
                            'broker/rebate/historicalRecord': 1,
                            'broker/subAccount/bnbBurn/status': 1,
                            'broker/subAccount/depositHist': 1,
                            'broker/subAccount/spotSummary': 1,
                            'broker/subAccount/marginSummary': 1,
                            'broker/subAccount/futuresSummary': 1,
                            'broker/rebate/futures/recentRecord': 1,
                            'broker/subAccountApi/ipRestriction': 1,
                            'broker/universalTransfer': 1,
                            // v2 not supported yet
                            // GET /sapi/v2/broker/subAccount/futuresSummary
                            'account/apiRestrictions': 1,
                            // subaccounts
                            'managed-subaccount/asset': 1,
                        },
                        'post': {
                            'asset/dust': 1,
                            'asset/transfer': 1,
                            'asset/get-funding-asset': 1,
                            'account/disableFastWithdrawSwitch': 1,
                            'account/enableFastWithdrawSwitch': 1,
                            'capital/withdraw/apply': 1,
                            'margin/transfer': 1,
                            'margin/loan': 1,
                            'margin/repay': 1,
                            'margin/order': 4,
                            'margin/order/oco': 1,
                            'margin/isolated/create': 1,
                            'margin/isolated/transfer': 1,
                            'bnbBurn': 1,
                            'sub-account/margin/transfer': 1,
                            'sub-account/margin/enable': 1,
                            // 'sub-account/margin/enable': 1,
                            'sub-account/futures/enable': 1,
                            'sub-account/futures/transfer': 1,
                            'sub-account/futures/internalTransfer': 1,
                            'sub-account/transfer/subToSub': 1,
                            'sub-account/transfer/subToMaster': 1,
                            'sub-account/universalTransfer': 1,
                            'managed-subaccount/deposit': 1,
                            'managed-subaccount/withdraw': 1,
                            'userDataStream': 1,
                            'userDataStream/isolated': 1,
                            'futures/transfer': 1,
                            'futures/loan/borrow': 20,
                            'futures/loan/repay': 20,
                            'futures/loan/adjustCollateral': 20,
                            // lending
                            'lending/customizedFixed/purchase': 1,
                            'lending/daily/purchase': 1,
                            'lending/daily/redeem': 1,
                            // liquid swap endpoints
                            'bswap/liquidityAdd': 2,
                            'bswap/liquidityRemove': 2,
                            'bswap/swap': 2,
                            // leveraged token endpoints
                            'blvt/subscribe': 1,
                            'blvt/redeem': 1,
                            // brokerage API
                            'apiReferral/customization': 1,
                            'apiReferral/userCustomization': 1,
                            'apiReferral/rebate/historicalRecord': 1,
                            'apiReferral/kickback/historicalRecord': 1,
                            'broker/subAccount': 1,
                            'broker/subAccount/margin': 1,
                            'broker/subAccount/futures': 1,
                            'broker/subAccountApi': 1,
                            'broker/subAccountApi/permission': 1,
                            'broker/subAccountApi/commission': 1,
                            'broker/subAccountApi/commission/futures': 1,
                            'broker/subAccountApi/commission/coinFutures': 1,
                            'broker/transfer': 1,
                            'broker/transfer/futures': 1,
                            'broker/rebate/historicalRecord': 1,
                            'broker/subAccount/bnbBurn/spot': 1,
                            'broker/subAccount/bnbBurn/marginInterest': 1,
                            'broker/subAccount/blvt': 1,
                            'broker/subAccountApi/ipRestriction': 1,
                            'broker/subAccountApi/ipRestriction/ipList': 1,
                            'broker/universalTransfer': 1,
                            'broker/subAccountApi/permission/universalTransfer': 1,
                            'broker/subAccountApi/permission/vanillaOptions': 1,
                        },
                        'put': {
                            'userDataStream': 1,
                            'userDataStream/isolated': 1,
                        },
                        'delete': {
                            'margin/openOrders': 1,
                            'margin/order': 1,
                            'margin/orderList': 1,
                            'userDataStream': 1,
                            'userDataStream/isolated': 1,
                            // brokerage API
                            'broker/subAccountApi': 1,
                            'broker/subAccountApi/ipRestriction/ipList': 1,
                        },
                    },
                    // deprecated
                    'wapi': {
                        'post': {
                            'withdraw': 1,
                            'sub-account/transfer': 1,
                        },
                        'get': {
                            'depositHistory': 1,
                            'withdrawHistory': 1,
                            'depositAddress': 1,
                            'accountStatus': 1,
                            'systemStatus': 1,
                            'apiTradingStatus': 1,
                            'userAssetDribbletLog': 1,
                            'tradeFee': 1,
                            'assetDetail': 1,
                            'sub-account/list': 1,
                            'sub-account/transfer/history': 1,
                            'sub-account/assets': 1,
                        },
                    },
                    'dapiPublic': {
                        'get': {
                            'ping': 1,
                            'time': 1,
                            'exchangeInfo': 1,
                            'depth': { 'cost': 2, 'byLimit': [ [ 50, 2 ], [ 100, 5 ], [ 500, 10 ], [ 1000, 20 ] ] },
                            'trades': 1,
                            'historicalTrades': 20,
                            'aggTrades': 20,
                            'premiumIndex': 10,
                            'fundingRate': 1,
                            'klines': { 'cost': 1, 'byLimit': [ [ 99, 1 ], [ 499, 2 ], [ 1000, 5 ], [ 10000, 10 ] ] },
                            'continuousKlines': { 'cost': 1, 'byLimit': [ [ 99, 1 ], [ 499, 2 ], [ 1000, 5 ], [ 10000, 10 ] ] },
                            'indexPriceKlines': { 'cost': 1, 'byLimit': [ [ 99, 1 ], [ 499, 2 ], [ 1000, 5 ], [ 10000, 10 ] ] },
                            'markPriceKlines': { 'cost': 1, 'byLimit': [ [ 99, 1 ], [ 499, 2 ], [ 1000, 5 ], [ 10000, 10 ] ] },
                            'ticker/24hr': { 'cost': 1, 'noSymbol': 40 },
                            'ticker/price': { 'cost': 1, 'noSymbol': 2 },
                            'ticker/bookTicker': { 'cost': 1, 'noSymbol': 2 },
                            'openInterest': 1,
                        },
                    },
                    'dapiData': {
                        'get': {
                            'openInterestHist': 1,
                            'topLongShortAccountRatio': 1,
                            'topLongShortPositionRatio': 1,
                            'globalLongShortAccountRatio': 1,
                            'takerBuySellVol': 1,
                            'basis': 1,
                        },
                    },
                    'dapiPrivate': {
                        'get': {
                            'positionSide/dual': 30,
                            'order': 1,
                            'openOrder': 1,
                            'openOrders': { 'cost': 1, 'noSymbol': 5 },
                            'allOrders': { 'cost': 20, 'noSymbol': 40 },
                            'balance': 1,
                            'account': 5,
                            'positionMargin/history': 1,
                            'positionRisk': 1,
                            'userTrades': { 'cost': 20, 'noSymbol': 40 },
                            'income': 20,
                            'leverageBracket': 1,
                            'forceOrders': { 'cost': 20, 'noSymbol': 50 },
                            'adlQuantile': 5,
                        },
                        'post': {
                            'positionSide/dual': 1,
                            'order': 4,
                            'batchOrders': 5,
                            'countdownCancelAll': 10,
                            'leverage': 1,
                            'marginType': 1,
                            'positionMargin': 1,
                            'listenKey': 1,
                        },
                        'put': {
                            'listenKey': 1,
                        },
                        'delete': {
                            'order': 1,
                            'allOpenOrders': 1,
                            'batchOrders': 5,
                            'listenKey': 1,
                        },
                    },
                    'dapiPrivateV2': {
                        'get': {
                            'leverageBracket': 1,
                        },
                    },
                    'fapiPublic': {
                        'get': {
                            'ping': 1,
                            'time': 1,
                            'exchangeInfo': 1,
                            'depth': { 'cost': 2, 'byLimit': [ [ 50, 2 ], [ 100, 5 ], [ 500, 10 ], [ 1000, 20 ] ] },
                            'trades': 1,
                            'historicalTrades': 20,
                            'aggTrades': 20,
                            'klines': { 'cost': 1, 'byLimit': [ [ 99, 1 ], [ 499, 2 ], [ 1000, 5 ], [ 10000, 10 ] ] },
                            'continuousKlines': { 'cost': 1, 'byLimit': [ [ 99, 1 ], [ 499, 2 ], [ 1000, 5 ], [ 10000, 10 ] ] },
                            'fundingRate': 1,
                            'premiumIndex': 1,
                            'ticker/24hr': { 'cost': 1, 'noSymbol': 40 },
                            'ticker/price': { 'cost': 1, 'noSymbol': 2 },
                            'ticker/bookTicker': { 'cost': 1, 'noSymbol': 2 },
                            'openInterest': 1,
                            'indexInfo': 1,
                            'apiTradingStatus': { 'cost': 1, 'noSymbol': 10 },
                            'lvtKlines': 1,
                        },
                    },
                    'fapiData': {
                        'get': {
                            'openInterestHist': 1,
                            'topLongShortAccountRatio': 1,
                            'topLongShortPositionRatio': 1,
                            'globalLongShortAccountRatio': 1,
                            'takerlongshortRatio': 1,
                        },
                    },
                    'fapiPrivate': {
                        'get': {
                            'forceOrders': { 'cost': 20, 'noSymbol': 50 },
                            'allOrders': 5,
                            'openOrder': 1,
                            'openOrders': 1,
                            'order': 1,
                            'account': 5,
                            'balance': 5,
                            'leverageBracket': 1,
                            'positionMargin/history': 1,
                            'positionRisk': 5,
                            'positionSide/dual': 30,
                            'userTrades': 5,
                            'income': 30,
                            'commissionRate': 20,
                            'apiTradingStatus': 1,
                            'multiAssetsMargin': 30,
                            // broker endpoints
                            'apiReferral/ifNewUser': 1,
                            'apiReferral/customization': 1,
                            'apiReferral/userCustomization': 1,
                            'apiReferral/traderNum': 1,
                            'apiReferral/overview': 1,
                            'apiReferral/tradeVol': 1,
                            'apiReferral/rebateVol': 1,
                            'apiReferral/traderSummary': 1,
                            'adlQuantile': 5,
                        },
                        'post': {
                            'batchOrders': 5,
                            'positionSide/dual': 1,
                            'positionMargin': 1,
                            'marginType': 1,
                            'order': 4,
                            'leverage': 1,
                            'listenKey': 1,
                            'countdownCancelAll': 10,
                            'multiAssetsMargin': 1,
                            // broker endpoints
                            'apiReferral/customization': 1,
                            'apiReferral/userCustomization': 1,
                        },
                        'put': {
                            'listenKey': 1,
                        },
                        'delete': {
                            'batchOrders': 1,
                            'order': 1,
                            'allOpenOrders': 1,
                            'listenKey': 1,
                        },
                    },
                    'fapiPrivateV2': {
                        'get': {
                            'account': 1,
                            'balance': 1,
                            'positionRisk': 1,
                        },
                    },
                    'v3': {
                        'get': {
                            'ticker/price': { 'cost': 1, 'noSymbol': 2 },
                            'ticker/bookTicker': { 'cost': 1, 'noSymbol': 2 },
                        },
                    },
                    'public': {
                        'get': {
                            'ping': 1,
                            'time': 1,
                            'depth': { 'cost': 1, 'byLimit': [ [ 100, 1 ], [ 500, 5 ], [ 1000, 10 ], [ 5000, 50 ] ] },
                            'trades': 1,
                            'aggTrades': 1,
                            'historicalTrades': 5,
                            'klines': 1,
                            'ticker/24hr': { 'cost': 1, 'noSymbol': 40 },
                            'ticker/price': { 'cost': 1, 'noSymbol': 2 },
                            'ticker/bookTicker': { 'cost': 1, 'noSymbol': 2 },
                            'exchangeInfo': 10,
                        },
                        'put': {
                            'userDataStream': 1,
                        },
                        'post': {
                            'userDataStream': 1,
                        },
                        'delete': {
                            'userDataStream': 1,
                        },
                    },
                    'private': {
                        'get': {
                            'allOrderList': 10, // oco
                            'openOrderList': 3, // oco
                            'orderList': 2, // oco
                            'order': 2,
                            'openOrders': { 'cost': 3, 'noSymbol': 40 },
                            'allOrders': 10,
                            'account': 10,
                            'myTrades': 10,
                        },
                        'post': {
                            'order/oco': 1,
                            'order': 4,
                            'order/test': 1,
                        },
                        'delete': {
                            'openOrders': 1, // added on 2020-04-25 for canceling all open orders per symbol
                            'orderList': 1, // oco
                            'order': 1,
                        },
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'tierBased': false,
                        'percentage': true,
                        'taker': this.parseNumber ('0.001'),
                        'maker': this.parseNumber ('0.001'),
                    },
                    'future': {
                        'trading': {
                            'feeSide': 'quote',
                            'tierBased': true,
                            'percentage': true,
                            'taker': this.parseNumber ('0.000400'),
                            'maker': this.parseNumber ('0.000200'),
                            'tiers': {
                                'taker': [
                                    [ this.parseNumber ('0'), this.parseNumber ('0.000400') ],
                                    [ this.parseNumber ('250'), this.parseNumber ('0.000400') ],
                                    [ this.parseNumber ('2500'), this.parseNumber ('0.000350') ],
                                    [ this.parseNumber ('7500'), this.parseNumber ('0.000320') ],
                                    [ this.parseNumber ('22500'), this.parseNumber ('0.000300') ],
                                    [ this.parseNumber ('50000'), this.parseNumber ('0.000270') ],
                                    [ this.parseNumber ('100000'), this.parseNumber ('0.000250') ],
                                    [ this.parseNumber ('200000'), this.parseNumber ('0.000220') ],
                                    [ this.parseNumber ('400000'), this.parseNumber ('0.000200') ],
                                    [ this.parseNumber ('750000'), this.parseNumber ('0.000170') ],
                                ],
                                'maker': [
                                    [ this.parseNumber ('0'), this.parseNumber ('0.000200') ],
                                    [ this.parseNumber ('250'), this.parseNumber ('0.000160') ],
                                    [ this.parseNumber ('2500'), this.parseNumber ('0.000140') ],
                                    [ this.parseNumber ('7500'), this.parseNumber ('0.000120') ],
                                    [ this.parseNumber ('22500'), this.parseNumber ('0.000100') ],
                                    [ this.parseNumber ('50000'), this.parseNumber ('0.000080') ],
                                    [ this.parseNumber ('100000'), this.parseNumber ('0.000060') ],
                                    [ this.parseNumber ('200000'), this.parseNumber ('0.000040') ],
                                    [ this.parseNumber ('400000'), this.parseNumber ('0.000020') ],
                                    [ this.parseNumber ('750000'), this.parseNumber ('0') ],
                                ],
                            },
                        },
                    },
                    'delivery': {
                        'trading': {
                            'feeSide': 'base',
                            'tierBased': true,
                            'percentage': true,
                            'taker': this.parseNumber ('0.000500'),
                            'maker': this.parseNumber ('0.000100'),
                            'tiers': {
                                'taker': [
                                    [ this.parseNumber ('0'), this.parseNumber ('0.000500') ],
                                    [ this.parseNumber ('250'), this.parseNumber ('0.000450') ],
                                    [ this.parseNumber ('2500'), this.parseNumber ('0.000400') ],
                                    [ this.parseNumber ('7500'), this.parseNumber ('0.000300') ],
                                    [ this.parseNumber ('22500'), this.parseNumber ('0.000250') ],
                                    [ this.parseNumber ('50000'), this.parseNumber ('0.000240') ],
                                    [ this.parseNumber ('100000'), this.parseNumber ('0.000240') ],
                                    [ this.parseNumber ('200000'), this.parseNumber ('0.000240') ],
                                    [ this.parseNumber ('400000'), this.parseNumber ('0.000240') ],
                                    [ this.parseNumber ('750000'), this.parseNumber ('0.000240') ],
                                ],
                                'maker': [
                                    [ this.parseNumber ('0'), this.parseNumber ('0.000100') ],
                                    [ this.parseNumber ('250'), this.parseNumber ('0.000080') ],
                                    [ this.parseNumber ('2500'), this.parseNumber ('0.000050') ],
                                    [ this.parseNumber ('7500'), this.parseNumber ('0.0000030') ],
                                    [ this.parseNumber ('22500'), this.parseNumber ('0') ],
                                    [ this.parseNumber ('50000'), this.parseNumber ('-0.000050') ],
                                    [ this.parseNumber ('100000'), this.parseNumber ('-0.000060') ],
                                    [ this.parseNumber ('200000'), this.parseNumber ('-0.000070') ],
                                    [ this.parseNumber ('400000'), this.parseNumber ('-0.000080') ],
                                    [ this.parseNumber ('750000'), this.parseNumber ('-0.000090') ],
                                ],
                            },
                        },
                    },
                },
                'commonCurrencies': {
                    'BCC': 'BCC', // kept for backward-compatibility https://github.com/ccxt/ccxt/issues/4848
                    'YOYO': 'YOYOW',
                },
                // exchange-specific options
                'options': {
                    'fetchCurrencies': true, // this is a private call and it requires API keys
                    // 'fetchTradesMethod': 'publicGetAggTrades', // publicGetTrades, publicGetHistoricalTrades
                    'defaultTimeInForce': 'GTC', // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
                    'defaultType': 'spot', // 'spot', 'future', 'margin', 'delivery'
                    'hasAlreadyAuthenticatedSuccessfully': false,
                    'warnOnFetchOpenOrdersWithoutSymbol': true,
                    'recvWindow': 5 * 1000, // 5 sec, binance default
                    'timeDifference': 0, // the difference between system clock and Binance clock
                    'adjustForTimeDifference': false, // controls the adjustment logic upon instantiation
                    'parseOrderToPrecision': false, // force amounts and costs in parseOrder to precision
                    'newOrderRespType': {
                        'market': 'FULL', // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
                        'limit': 'FULL', // we change it from 'ACK' by default to 'FULL' (returns immediately if limit is not hit)
                    },
                    'quoteOrderQty': true, // whether market orders support amounts in quote currency
                    'broker': {
                        'spot': 'x-R4BD3S82',
                        'margin': 'x-R4BD3S82',
                        'future': 'x-xcKtGhcu',
                        'delivery': 'x-xcKtGhcu',
                    },
                    'accountsByType': {
                        'main': 'MAIN',
                        'spot': 'MAIN',
                        'margin': 'MARGIN',
                        'future': 'UMFUTURE',
                        'delivery': 'CMFUTURE',
                        'mining': 'MINING',
                    },
                    'typesByAccount': {
                        'MAIN': 'spot',
                        'MARGIN': 'margin',
                        'UMFUTURE': 'future',
                        'CMFUTURE': 'delivery',
                        'MINING': 'mining',
                    },
                    'legalMoney': {
                        'MXN': true,
                        'UGX': true,
                        'SEK': true,
                        'CHF': true,
                        'VND': true,
                        'AED': true,
                        'DKK': true,
                        'KZT': true,
                        'HUF': true,
                        'PEN': true,
                        'PHP': true,
                        'USD': true,
                        'TRY': true,
                        'EUR': true,
                        'NGN': true,
                        'PLN': true,
                        'BRL': true,
                        'ZAR': true,
                        'KES': true,
                        'ARS': true,
                        'RUB': true,
                        'AUD': true,
                        'NOK': true,
                        'CZK': true,
                        'GBP': true,
                        'UAH': true,
                        'GHS': true,
                        'HKD': true,
                        'CAD': true,
                        'INR': true,
                        'JPY': true,
                        'NZD': true,
                    },
                },
                // https://binance-docs.github.io/apidocs/spot/en/#error-codes-2
                'exceptions': {
                    'exact': {
                        'System abnormality': ExchangeError, // {"code":-1000,"msg":"System abnormality"}
                        'You are not authorized to execute this request.': PermissionDenied, // {"msg":"You are not authorized to execute this request."}
                        'API key does not exist': AuthenticationError,
                        'Order would trigger immediately.': OrderImmediatelyFillable,
                        'Stop price would trigger immediately.': OrderImmediatelyFillable, // {"code":-2010,"msg":"Stop price would trigger immediately."}
                        'Order would immediately match and take.': OrderImmediatelyFillable, // {"code":-2010,"msg":"Order would immediately match and take."}
                        'Account has insufficient balance for requested action.': InsufficientFunds,
                        'Rest API trading is not enabled.': ExchangeNotAvailable,
                        "You don't have permission.": PermissionDenied, // {"msg":"You don't have permission.","success":false}
                        'Market is closed.': ExchangeNotAvailable, // {"code":-1013,"msg":"Market is closed."}
                        'Too many requests.': DDoSProtection, // {"msg":"Too many requests. Please try again later.","success":false}
                        '-1000': ExchangeNotAvailable, // {"code":-1000,"msg":"An unknown error occured while processing the request."}
                        '-1001': ExchangeNotAvailable, // 'Internal error; unable to process your request. Please try again.'
                        '-1002': AuthenticationError, // 'You are not authorized to execute this request.'
                        '-1003': RateLimitExceeded, // {"code":-1003,"msg":"Too much request weight used, current limit is 1200 request weight per 1 MINUTE. Please use the websocket for live updates to avoid polling the API."}
                        '-1013': InvalidOrder, // createOrder -> 'invalid quantity'/'invalid price'/MIN_NOTIONAL
                        '-1015': RateLimitExceeded, // 'Too many new orders; current limit is %s orders per %s.'
                        '-1016': ExchangeNotAvailable, // 'This service is no longer available.',
                        '-1020': BadRequest, // 'This operation is not supported.'
                        '-1021': InvalidNonce, // 'your time is ahead of server'
                        '-1022': AuthenticationError, // {"code":-1022,"msg":"Signature for this request is not valid."}
                        '-1100': BadRequest, // createOrder(symbol, 1, asdf) -> 'Illegal characters found in parameter 'price'
                        '-1101': BadRequest, // Too many parameters; expected %s and received %s.
                        '-1102': BadRequest, // Param %s or %s must be sent, but both were empty
                        '-1103': BadRequest, // An unknown parameter was sent.
                        '-1104': BadRequest, // Not all sent parameters were read, read 8 parameters but was sent 9
                        '-1105': BadRequest, // Parameter %s was empty.
                        '-1106': BadRequest, // Parameter %s sent when not required.
                        '-1111': BadRequest, // Precision is over the maximum defined for this asset.
                        '-1112': InvalidOrder, // No orders on book for symbol.
                        '-1114': BadRequest, // TimeInForce parameter sent when not required.
                        '-1115': BadRequest, // Invalid timeInForce.
                        '-1116': BadRequest, // Invalid orderType.
                        '-1117': BadRequest, // Invalid side.
                        '-1118': BadRequest, // New client order ID was empty.
                        '-1119': BadRequest, // Original client order ID was empty.
                        '-1120': BadRequest, // Invalid interval.
                        '-1121': BadSymbol, // Invalid symbol.
                        '-1125': AuthenticationError, // This listenKey does not exist.
                        '-1127': BadRequest, // More than %s hours between startTime and endTime.
                        '-1128': BadRequest, // {"code":-1128,"msg":"Combination of optional parameters invalid."}
                        '-1130': BadRequest, // Data sent for paramter %s is not valid.
                        '-1131': BadRequest, // recvWindow must be less than 60000
                        '-2008': AuthenticationError, // {"code":-2008,"msg":"Invalid Api-Key ID."}
                        '-2010': ExchangeError, // generic error code for createOrder -> 'Account has insufficient balance for requested action.', {"code":-2010,"msg":"Rest API trading is not enabled."}, etc...
                        '-2011': OrderNotFound, // cancelOrder(1, 'BTC/USDT') -> 'UNKNOWN_ORDER'
                        '-2013': OrderNotFound, // fetchOrder (1, 'BTC/USDT') -> 'Order does not exist'
                        '-2014': AuthenticationError, // { "code":-2014, "msg": "API-key format invalid." }
                        '-2015': AuthenticationError, // "Invalid API-key, IP, or permissions for action."
                        '-2019': InsufficientFunds, // {"code":-2019,"msg":"Margin is insufficient."}
                        '-3005': InsufficientFunds, // {"code":-3005,"msg":"Transferring out not allowed. Transfer out amount exceeds max amount."}
                        '-3006': InsufficientFunds, // {"code":-3006,"msg":"Your borrow amount has exceed maximum borrow amount."}
                        '-3008': InsufficientFunds, // {"code":-3008,"msg":"Borrow not allowed. Your borrow amount has exceed maximum borrow amount."}
                        '-3010': ExchangeError, // {"code":-3010,"msg":"Repay not allowed. Repay amount exceeds borrow amount."}
                        '-3015': ExchangeError, // {"code":-3015,"msg":"Repay amount exceeds borrow amount."}
                        '-3022': AccountSuspended, // You account's trading is banned.
                        '-4028': BadRequest, // {"code":-4028,"msg":"Leverage 100 is not valid"}
                        '-3020': InsufficientFunds, // {"code":-3020,"msg":"Transfer out amount exceeds max amount."}
                        '-3041': InsufficientFunds, // {"code":-3041,"msg":"Balance is not enough"}
                        '-5013': InsufficientFunds, // Asset transfer failed: insufficient balance"
                        '-11008': InsufficientFunds, // {"code":-11008,"msg":"Exceeding the account's maximum borrowable limit."}
                        '-4051': InsufficientFunds, // {"code":-4051,"msg":"Isolated balance insufficient."}
                    },
                    'broad': {
                        'has no operation privilege': PermissionDenied,
                        'MAX_POSITION': InvalidOrder, // {"code":-2010,"msg":"Filter failure: MAX_POSITION"}
                    },
                },
            });
        }
    
        costToPrecision (symbol, cost) {
            return this.decimalToPrecision (cost, TRUNCATE, this.markets[symbol]['precision']['quote'], this.precisionMode, this.paddingMode);
        }
    
        currencyToPrecision (currency, fee) {
            // info is available in currencies only if the user has configured his api keys
            if ('info' in this.currencies[currency]) {
                return this.decimalToPrecision (fee, TRUNCATE, this.currencies[currency]['precision'], this.precisionMode, this.paddingMode);
            } else {
                return this.numberToString (fee);
            }
        }
    
        nonce () {
            return this.milliseconds () - this.options['timeDifference'];
        }
    
        async fetchTime (params = {}) {
            const type = this.safeString2 (this.options, 'fetchTime', 'defaultType', 'spot');
            let method = 'publicGetTime';
            if (type === 'future') {
                method = 'fapiPublicGetTime';
            } else if (type === 'delivery') {
                method = 'dapiPublicGetTime';
            }
            const response = await this[method] (params);
            return this.safeInteger (response, 'serverTime');
        }
    
        async loadTimeDifference (params = {}) {
            const serverTime = await this.fetchTime (params);
            const after = this.milliseconds ();
            this.options['timeDifference'] = after - serverTime;
            return this.options['timeDifference'];
        }
    
        async fetchCurrencies (params = {}) {
            const fetchCurrenciesEnabled = this.safeValue (this.options, 'fetchCurrencies');
            if (!fetchCurrenciesEnabled) {
                return undefined;
            }
            // this endpoint requires authentication
            // while fetchCurrencies is a public API method by design
            // therefore we check the keys here
            // and fallback to generating the currencies from the markets
            if (!this.checkRequiredCredentials (false)) {
                return undefined;
            }
            // sandbox/testnet does not support sapi endpoints
            const apiBackup = this.safeString (this.urls, 'apiBackup');
            if (apiBackup !== undefined) {
                return undefined;
            }
            const response = await this.sapiGetCapitalConfigGetall (params);
            const result = {};
            for (let i = 0; i < response.length; i++) {
                //
                //     {
                //         coin: 'LINK',
                //         depositAllEnable: true,
                //         withdrawAllEnable: true,
                //         name: 'ChainLink',
                //         free: '0.06168',
                //         locked: '0',
                //         freeze: '0',
                //         withdrawing: '0',
                //         ipoing: '0',
                //         ipoable: '0',
                //         storage: '0',
                //         isLegalMoney: false,
                //         trading: true,
                //         networkList: [
                //             {
                //                 network: 'BNB',
                //                 coin: 'LINK',
                //                 withdrawIntegerMultiple: '0',
                //                 isDefault: false,
                //                 depositEnable: true,
                //                 withdrawEnable: true,
                //                 depositDesc: '',
                //                 withdrawDesc: '',
                //                 specialTips: 'Both a MEMO and an Address are required to successfully deposit your LINK BEP2 tokens to Binance.',
                //                 name: 'BEP2',
                //                 resetAddressStatus: false,
                //                 addressRegex: '^(bnb1)[0-9a-z]{38}$',
                //                 memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
                //                 withdrawFee: '0.002',
                //                 withdrawMin: '0.01',
                //                 withdrawMax: '9999999',
                //                 minConfirm: 1,
                //                 unLockConfirm: 0
                //             },
                //             {
                //                 network: 'BSC',
                //                 coin: 'LINK',
                //                 withdrawIntegerMultiple: '0.00000001',
                //                 isDefault: false,
                //                 depositEnable: true,
                //                 withdrawEnable: true,
                //                 depositDesc: '',
                //                 withdrawDesc: '',
                //                 specialTips: '',
                //                 name: 'BEP20 (BSC)',
                //                 resetAddressStatus: false,
                //                 addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                //                 memoRegex: '',
                //                 withdrawFee: '0.005',
                //                 withdrawMin: '0.01',
                //                 withdrawMax: '9999999',
                //                 minConfirm: 15,
                //                 unLockConfirm: 0
                //             },
                //             {
                //                 network: 'ETH',
                //                 coin: 'LINK',
                //                 withdrawIntegerMultiple: '0.00000001',
                //                 isDefault: true,
                //                 depositEnable: true,
                //                 withdrawEnable: true,
                //                 depositDesc: '',
                //                 withdrawDesc: '',
                //                 name: 'ERC20',
                //                 resetAddressStatus: false,
                //                 addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
                //                 memoRegex: '',
                //                 withdrawFee: '0.34',
                //                 withdrawMin: '0.68',
                //                 withdrawMax: '0',
                //                 minConfirm: 12,
                //                 unLockConfirm: 0
                //             }
                //         ]
                //     }
                //
                const entry = response[i];
                const id = this.safeString (entry, 'coin');
                const name = this.safeString (entry, 'name');
                const code = this.safeCurrencyCode (id);
                const precision = undefined;
                let isWithdrawEnabled = true;
                let isDepositEnabled = true;
                const networkList = this.safeValue (entry, 'networkList', []);
                const fees = {};
                let fee = undefined;
                for (let j = 0; j < networkList.length; j++) {
                    const networkItem = networkList[j];
                    const network = this.safeString (networkItem, 'network');
                    // const name = this.safeString (networkItem, 'name');
                    const withdrawFee = this.safeNumber (networkItem, 'withdrawFee');
                    const depositEnable = this.safeValue (networkItem, 'depositEnable');
                    const withdrawEnable = this.safeValue (networkItem, 'withdrawEnable');
                    isDepositEnabled = isDepositEnabled || depositEnable;
                    isWithdrawEnabled = isWithdrawEnabled || withdrawEnable;
                    fees[network] = withdrawFee;
                    const isDefault = this.safeValue (networkItem, 'isDefault');
                    if (isDefault || fee === undefined) {
                        fee = withdrawFee;
                    }
                }
                const trading = this.safeValue (entry, 'trading');
                const active = (isWithdrawEnabled && isDepositEnabled && trading);
                result[code] = {
                    'id': id,
                    'name': name,
                    'code': code,
                    'precision': precision,
                    'info': entry,
                    'active': active,
                    'fee': fee,
                    'fees': fees,
                    'limits': this.limits,
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const defaultType = this.safeString2 (this.options, 'fetchMarkets', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            if ((type !== 'spot') && (type !== 'future') && (type !== 'margin') && (type !== 'delivery')) {
                throw new ExchangeError (this.id + " does not support '" + type + "' type, set exchange.options['defaultType'] to 'spot', 'margin', 'delivery' or 'future'"); // eslint-disable-line quotes
            }
            let method = 'publicGetExchangeInfo';
            if (type === 'future') {
                method = 'fapiPublicGetExchangeInfo';
            } else if (type === 'delivery') {
                method = 'dapiPublicGetExchangeInfo';
            }
            const response = await this[method] (query);
            //
            // spot / margin
            //
            //     {
            //         "timezone":"UTC",
            //         "serverTime":1575416692969,
            //         "rateLimits":[
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
            //             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":10,"limit":100},
            //             {"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":200000}
            //         ],
            //         "exchangeFilters":[],
            //         "symbols":[
            //             {
            //                 "symbol":"ETHBTC",
            //                 "status":"TRADING",
            //                 "baseAsset":"ETH",
            //                 "baseAssetPrecision":8,
            //                 "quoteAsset":"BTC",
            //                 "quotePrecision":8,
            //                 "baseCommissionPrecision":8,
            //                 "quoteCommissionPrecision":8,
            //                 "orderTypes":["LIMIT","LIMIT_MAKER","MARKET","STOP_LOSS_LIMIT","TAKE_PROFIT_LIMIT"],
            //                 "icebergAllowed":true,
            //                 "ocoAllowed":true,
            //                 "quoteOrderQtyMarketAllowed":true,
            //                 "isSpotTradingAllowed":true,
            //                 "isMarginTradingAllowed":true,
            //                 "filters":[
            //                     {"filterType":"PRICE_FILTER","minPrice":"0.00000100","maxPrice":"100000.00000000","tickSize":"0.00000100"},
            //                     {"filterType":"PERCENT_PRICE","multiplierUp":"5","multiplierDown":"0.2","avgPriceMins":5},
            //                     {"filterType":"LOT_SIZE","minQty":"0.00100000","maxQty":"100000.00000000","stepSize":"0.00100000"},
            //                     {"filterType":"MIN_NOTIONAL","minNotional":"0.00010000","applyToMarket":true,"avgPriceMins":5},
            //                     {"filterType":"ICEBERG_PARTS","limit":10},
            //                     {"filterType":"MARKET_LOT_SIZE","minQty":"0.00000000","maxQty":"63100.00000000","stepSize":"0.00000000"},
            //                     {"filterType":"MAX_NUM_ALGO_ORDERS","maxNumAlgoOrders":5}
            //                 ]
            //             },
            //         ],
            //     }
            //
            // futures/usdt-margined (fapi)
            //
            //     {
            //         "timezone":"UTC",
            //         "serverTime":1575417244353,
            //         "rateLimits":[
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
            //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":1200}
            //         ],
            //         "exchangeFilters":[],
            //         "symbols":[
            //             {
            //                 "symbol":"BTCUSDT",
            //                 "status":"TRADING",
            //                 "maintMarginPercent":"2.5000",
            //                 "requiredMarginPercent":"5.0000",
            //                 "baseAsset":"BTC",
            //                 "quoteAsset":"USDT",
            //                 "pricePrecision":2,
            //                 "quantityPrecision":3,
            //                 "baseAssetPrecision":8,
            //                 "quotePrecision":8,
            //                 "filters":[
            //                     {"minPrice":"0.01","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.01"},
            //                     {"stepSize":"0.001","filterType":"LOT_SIZE","maxQty":"1000","minQty":"0.001"},
            //                     {"stepSize":"0.001","filterType":"MARKET_LOT_SIZE","maxQty":"1000","minQty":"0.001"},
            //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
            //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
            //                 ],
            //                 "orderTypes":["LIMIT","MARKET","STOP"],
            //                 "timeInForce":["GTC","IOC","FOK","GTX"]
            //             }
            //         ]
            //     }
            //
            // delivery/coin-margined (dapi)
            //
            //     {
            //         "timezone": "UTC",
            //         "serverTime": 1597667052958,
            //         "rateLimits": [
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":6000},
            //             {"rateLimitType":"ORDERS","interval":"MINUTE","intervalNum":1,"limit":6000}
            //         ],
            //         "exchangeFilters": [],
            //         "symbols": [
            //             {
            //                 "symbol": "BTCUSD_200925",
            //                 "pair": "BTCUSD",
            //                 "contractType": "CURRENT_QUARTER",
            //                 "deliveryDate": 1601020800000,
            //                 "onboardDate": 1590739200000,
            //                 "contractStatus": "TRADING",
            //                 "contractSize": 100,
            //                 "marginAsset": "BTC",
            //                 "maintMarginPercent": "2.5000",
            //                 "requiredMarginPercent": "5.0000",
            //                 "baseAsset": "BTC",
            //                 "quoteAsset": "USD",
            //                 "pricePrecision": 1,
            //                 "quantityPrecision": 0,
            //                 "baseAssetPrecision": 8,
            //                 "quotePrecision": 8,
            //                 "equalQtyPrecision": 4,
            //                 "filters": [
            //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
            //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"stepSize":"0","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
            //                     {"multiplierDown":"0.9500","multiplierUp":"1.0500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
            //                 ],
            //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
            //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
            //             },
            //             {
            //                 "symbol": "BTCUSD_PERP",
            //                 "pair": "BTCUSD",
            //                 "contractType": "PERPETUAL",
            //                 "deliveryDate": 4133404800000,
            //                 "onboardDate": 1596006000000,
            //                 "contractStatus": "TRADING",
            //                 "contractSize": 100,
            //                 "marginAsset": "BTC",
            //                 "maintMarginPercent": "2.5000",
            //                 "requiredMarginPercent": "5.0000",
            //                 "baseAsset": "BTC",
            //                 "quoteAsset": "USD",
            //                 "pricePrecision": 1,
            //                 "quantityPrecision": 0,
            //                 "baseAssetPrecision": 8,
            //                 "quotePrecision": 8,
            //                 "equalQtyPrecision": 4,
            //                 "filters": [
            //                     {"minPrice":"0.1","maxPrice":"100000","filterType":"PRICE_FILTER","tickSize":"0.1"},
            //                     {"stepSize":"1","filterType":"LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"stepSize":"1","filterType":"MARKET_LOT_SIZE","maxQty":"100000","minQty":"1"},
            //                     {"limit":200,"filterType":"MAX_NUM_ORDERS"},
            //                     {"multiplierDown":"0.8500","multiplierUp":"1.1500","multiplierDecimal":"4","filterType":"PERCENT_PRICE"}
            //                 ],
            //                 "orderTypes": ["LIMIT","MARKET","STOP","STOP_MARKET","TAKE_PROFIT","TAKE_PROFIT_MARKET","TRAILING_STOP_MARKET"],
            //                 "timeInForce": ["GTC","IOC","FOK","GTX"]
            //             }
            //         ]
            //     }
            //
            if (this.options['adjustForTimeDifference']) {
                await this.loadTimeDifference ();
            }
            const markets = this.safeValue (response, 'symbols', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const spot = (type === 'spot');
                const future = (type === 'future');
                const delivery = (type === 'delivery');
                const id = this.safeString (market, 'symbol');
                const lowercaseId = this.safeStringLower (market, 'symbol');
                const baseId = this.safeString (market, 'baseAsset');
                const quoteId = this.safeString (market, 'quoteAsset');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const contractType = this.safeString (market, 'contractType');
                const idSymbol = (future || delivery) && (contractType !== 'PERPETUAL');
                let symbol = undefined;
                let expiry = undefined;
                if (idSymbol) {
                    symbol = id;
                    expiry = this.safeInteger (market, 'deliveryDate');
                } else {
                    symbol = base + '/' + quote;
                }
                const filters = this.safeValue (market, 'filters', []);
                const filtersByType = this.indexBy (filters, 'filterType');
                const precision = {
                    'base': this.safeInteger (market, 'baseAssetPrecision'),
                    'quote': this.safeInteger (market, 'quotePrecision'),
                    'amount': this.safeInteger (market, 'quantityPrecision'),
                    'price': this.safeInteger (market, 'pricePrecision'),
                };
                const status = this.safeString2 (market, 'status', 'contractStatus');
                const active = (status === 'TRADING');
                const margin = this.safeValue (market, 'isMarginTradingAllowed', false);
                let contractSize = undefined;
                let fees = this.fees;
                if (future || delivery) {
                    contractSize = this.safeString (market, 'contractSize', '1');
                    fees = this.fees[type];
                }
                const maker = fees['trading']['maker'];
                const taker = fees['trading']['taker'];
                const entry = {
                    'id': id,
                    'lowercaseId': lowercaseId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                    'spot': spot,
                    'type': type,
                    'margin': margin,
                    'future': future,
                    'delivery': delivery,
                    'linear': future,
                    'inverse': delivery,
                    'expiry': expiry,
                    'expiryDatetime': this.iso8601 (expiry),
                    'active': active,
                    'precision': precision,
                    'contractSize': contractSize,
                    'maker': maker,
                    'taker': taker,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                };
                if ('PRICE_FILTER' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'PRICE_FILTER', {});
                    const tickSize = this.safeString (filter, 'tickSize');
                    entry['precision']['price'] = this.precisionFromString (tickSize);
                    // PRICE_FILTER reports zero values for maxPrice
                    // since they updated filter types in November 2018
                    // https://github.com/ccxt/ccxt/issues/4286
                    // therefore limits['price']['max'] doesn't have any meaningful value except undefined
                    entry['limits']['price'] = {
                        'min': this.safeNumber (filter, 'minPrice'),
                        'max': this.safeNumber (filter, 'maxPrice'),
                    };
                    entry['precision']['price'] = this.precisionFromString (filter['tickSize']);
                }
                if ('LOT_SIZE' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'LOT_SIZE', {});
                    const stepSize = this.safeString (filter, 'stepSize');
                    entry['precision']['amount'] = this.precisionFromString (stepSize);
                    entry['limits']['amount'] = {
                        'min': this.safeNumber (filter, 'minQty'),
                        'max': this.safeNumber (filter, 'maxQty'),
                    };
                }
                if ('MARKET_LOT_SIZE' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'MARKET_LOT_SIZE', {});
                    entry['limits']['market'] = {
                        'min': this.safeNumber (filter, 'minQty'),
                        'max': this.safeNumber (filter, 'maxQty'),
                    };
                }
                if ('MIN_NOTIONAL' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'MIN_NOTIONAL', {});
                    entry['limits']['cost']['min'] = this.safeNumber2 (filter, 'minNotional', 'notional');
                }
                result.push (entry);
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString2 (this.options, 'fetchBalance', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            let method = 'privateGetAccount';
            if (type === 'future') {
                const options = this.safeValue (this.options, 'future', {});
                const fetchBalanceOptions = this.safeValue (options, 'fetchBalance', {});
                method = this.safeString (fetchBalanceOptions, 'method', 'fapiPrivateV2GetAccount');
            } else if (type === 'delivery') {
                const options = this.safeValue (this.options, 'delivery', {});
                const fetchBalanceOptions = this.safeValue (options, 'fetchBalance', {});
                method = this.safeString (fetchBalanceOptions, 'method', 'dapiPrivateGetAccount');
            } else if (type === 'margin') {
                method = 'sapiGetMarginAccount';
            } else if (type === 'savings') {
                method = 'sapiGetLendingUnionAccount';
            } else if (type === 'pay') {
                method = 'sapiPostAssetGetFundingAsset';
            }
            const query = this.omit (params, 'type');
            const response = await this[method] (query);
            //
            // spot
            //
            //     {
            //         makerCommission: 10,
            //         takerCommission: 10,
            //         buyerCommission: 0,
            //         sellerCommission: 0,
            //         canTrade: true,
            //         canWithdraw: true,
            //         canDeposit: true,
            //         updateTime: 1575357359602,
            //         accountType: "MARGIN",
            //         balances: [
            //             { asset: "BTC", free: "0.00219821", locked: "0.00000000"  },
            //         ]
            //     }
            //
            // margin
            //
            //     {
            //         "borrowEnabled":true,
            //         "marginLevel":"999.00000000",
            //         "totalAssetOfBtc":"0.00000000",
            //         "totalLiabilityOfBtc":"0.00000000",
            //         "totalNetAssetOfBtc":"0.00000000",
            //         "tradeEnabled":true,
            //         "transferEnabled":true,
            //         "userAssets":[
            //             {"asset":"MATIC","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
            //             {"asset":"VET","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"},
            //             {"asset":"USDT","borrowed":"0.00000000","free":"0.00000000","interest":"0.00000000","locked":"0.00000000","netAsset":"0.00000000"}
            //         ],
            //     }
            //
            // futures (fapi)
            //
            //     fapiPrivateGetAccount
            //
            //     {
            //         "feeTier":0,
            //         "canTrade":true,
            //         "canDeposit":true,
            //         "canWithdraw":true,
            //         "updateTime":0,
            //         "totalInitialMargin":"0.00000000",
            //         "totalMaintMargin":"0.00000000",
            //         "totalWalletBalance":"4.54000000",
            //         "totalUnrealizedProfit":"0.00000000",
            //         "totalMarginBalance":"4.54000000",
            //         "totalPositionInitialMargin":"0.00000000",
            //         "totalOpenOrderInitialMargin":"0.00000000",
            //         "maxWithdrawAmount":"4.54000000",
            //         "assets":[
            //             {
            //                 "asset":"USDT",
            //                 "walletBalance":"4.54000000",
            //                 "unrealizedProfit":"0.00000000",
            //                 "marginBalance":"4.54000000",
            //                 "maintMargin":"0.00000000",
            //                 "initialMargin":"0.00000000",
            //                 "positionInitialMargin":"0.00000000",
            //                 "openOrderInitialMargin":"0.00000000",
            //                 "maxWithdrawAmount":"4.54000000"
            //             }
            //         ],
            //         "positions":[
            //             {
            //                 "symbol":"BTCUSDT",
            //                 "initialMargin":"0.00000",
            //                 "maintMargin":"0.00000",
            //                 "unrealizedProfit":"0.00000000",
            //                 "positionInitialMargin":"0.00000",
            //                 "openOrderInitialMargin":"0.00000"
            //             }
            //         ]
            //     }
            //
            //     fapiPrivateV2GetAccount
            //
            //     {
            //         "feeTier":0,
            //         "canTrade":true,
            //         "canDeposit":true,
            //         "canWithdraw":true,
            //         "updateTime":0,
            //         "totalInitialMargin":"0.00000000",
            //         "totalMaintMargin":"0.00000000",
            //         "totalWalletBalance":"0.00000000",
            //         "totalUnrealizedProfit":"0.00000000",
            //         "totalMarginBalance":"0.00000000",
            //         "totalPositionInitialMargin":"0.00000000",
            //         "totalOpenOrderInitialMargin":"0.00000000",
            //         "totalCrossWalletBalance":"0.00000000",
            //         "totalCrossUnPnl":"0.00000000",
            //         "availableBalance":"0.00000000",
            //         "maxWithdrawAmount":"0.00000000",
            //         "assets":[
            //             {
            //                 "asset":"BNB",
            //                 "walletBalance":"0.01000000",
            //                 "unrealizedProfit":"0.00000000",
            //                 "marginBalance":"0.01000000",
            //                 "maintMargin":"0.00000000",
            //                 "initialMargin":"0.00000000",
            //                 "positionInitialMargin":"0.00000000",
            //                 "openOrderInitialMargin":"0.00000000",
            //                 "maxWithdrawAmount":"0.01000000",
            //                 "crossWalletBalance":"0.01000000",
            //                 "crossUnPnl":"0.00000000",
            //                 "availableBalance":"0.01000000"
            //             }
            //         ],
            //         "positions":[
            //             {
            //                 "symbol":"BTCUSDT",
            //                 "initialMargin":"0",
            //                 "maintMargin":"0",
            //                 "unrealizedProfit":"0.00000000",
            //                 "positionInitialMargin":"0",
            //                 "openOrderInitialMargin":"0",
            //                 "leverage":"20",
            //                 "isolated":false,
            //                 "entryPrice":"0.00000",
            //                 "maxNotional":"5000000",
            //                 "positionSide":"BOTH"
            //             },
            //         ]
            //     }
            //
            //     fapiPrivateV2GetBalance
            //
            //     [
            //         {
            //             "accountAlias":"FzFzXquXXqoC",
            //             "asset":"BNB",
            //             "balance":"0.01000000",
            //             "crossWalletBalance":"0.01000000",
            //             "crossUnPnl":"0.00000000",
            //             "availableBalance":"0.01000000",
            //             "maxWithdrawAmount":"0.01000000"
            //         }
            //     ]
            //
            // savings
            //
            //     {
            //       "totalAmountInBTC": "0.3172",
            //       "totalAmountInUSDT": "10000",
            //       "totalFixedAmountInBTC": "0.3172",
            //       "totalFixedAmountInUSDT": "10000",
            //       "totalFlexibleInBTC": "0",
            //       "totalFlexibleInUSDT": "0",
            //       "positionAmountVos": [
            //         {
            //           "asset": "USDT",
            //           "amount": "10000",
            //           "amountInBTC": "0.3172",
            //           "amountInUSDT": "10000"
            //         },
            //         {
            //           "asset": "BUSD",
            //           "amount": "0",
            //           "amountInBTC": "0",
            //           "amountInUSDT": "0"
            //         }
            //       ]
            //     }
            //
            // binance pay
            //
            //     [
            //       {
            //         "asset": "BUSD",
            //         "free": "1129.83",
            //         "locked": "0",
            //         "freeze": "0",
            //         "withdrawing": "0"
            //       }
            //     ]
            //
            const result = {
                'info': response,
            };
            let timestamp = undefined;
            if ((type === 'spot') || (type === 'margin')) {
                timestamp = this.safeInteger (response, 'updateTime');
                const balances = this.safeValue2 (response, 'balances', 'userAssets', []);
                for (let i = 0; i < balances.length; i++) {
                    const balance = balances[i];
                    const currencyId = this.safeString (balance, 'asset');
                    const code = this.safeCurrencyCode (currencyId);
                    const account = this.account ();
                    account['free'] = this.safeString (balance, 'free');
                    account['used'] = this.safeString (balance, 'locked');
                    result[code] = account;
                }
            } else if (type === 'savings') {
                const positionAmountVos = this.safeValue (response, 'positionAmountVos');
                for (let i = 0; i < positionAmountVos.length; i++) {
                    const entry = positionAmountVos[i];
                    const currencyId = this.safeString (entry, 'asset');
                    const code = this.safeCurrencyCode (currencyId);
                    const account = this.account ();
                    const usedAndTotal = this.safeString (entry, 'amount');
                    account['total'] = usedAndTotal;
                    account['used'] = usedAndTotal;
                    result[code] = account;
                }
            } else if (type === 'pay') {
                for (let i = 0; i < response.length; i++) {
                    const entry = response[i];
                    const account = this.account ();
                    const currencyId = this.safeString (entry, 'asset');
                    const code = this.safeCurrencyCode (currencyId);
                    account['free'] = this.safeString (entry, 'free');
                    const frozen = this.safeString (entry, 'freeze');
                    const withdrawing = this.safeString (entry, 'withdrawing');
                    const locked = this.safeString (entry, 'locked');
                    account['used'] = Precise.stringAdd (frozen, Precise.stringAdd (locked, withdrawing));
                    result[code] = account;
                }
            } else {
                let balances = response;
                if (!Array.isArray (response)) {
                    balances = this.safeValue (response, 'assets', []);
                }
                for (let i = 0; i < balances.length; i++) {
                    const balance = balances[i];
                    const currencyId = this.safeString (balance, 'asset');
                    const code = this.safeCurrencyCode (currencyId);
                    const account = this.account ();
                    account['free'] = this.safeString (balance, 'availableBalance');
                    account['used'] = this.safeString (balance, 'initialMargin');
                    account['total'] = this.safeString2 (balance, 'marginBalance', 'balance');
                    result[code] = account;
                }
            }
            result['timestamp'] = timestamp;
            result['datetime'] = this.iso8601 (timestamp);
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 100, max 5000, see https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#order-book
            }
            let method = 'publicGetDepth';
            if (market['linear']) {
                method = 'fapiPublicGetDepth';
            } else if (market['inverse']) {
                method = 'dapiPublicGetDepth';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // future
            //
            //     {
            //         "lastUpdateId":333598053905,
            //         "E":1618631511986,
            //         "T":1618631511964,
            //         "bids":[
            //             ["2493.56","20.189"],
            //             ["2493.54","1.000"],
            //             ["2493.51","0.005"],["2493.37","0.280"],["2493.31","0.865"],["2493.30","0.514"],["2493.29","2.309"],["2493.25","1.500"],["2493.23","0.012"],["2493.22","7.240"],["2493.21","3.349"],["2493.20","2.030"],["2493.19","58.118"],["2493.18","174.836"],["2493.17","14.436"],["2493.12","2.000"],["2493.09","3.232"],["2493.08","2.010"],["2493.07","2.000"],["2493.06","2.000"],["2493.05","2.684"],["2493.04","2.000"],["2493.03","2.000"],["2493.02","5.000"],["2493.01","2.000"],["2493.00","1.035"],["2492.99","8.546"],["2492.98","4.012"],["2492.96","40.937"],["2492.95","40.595"],["2492.94","21.051"],["2492.92","4.012"],["2492.91","0.200"],["2492.85","2.000"],["2492.83","24.929"],["2492.81","50.000"],["2492.80","0.030"],["2492.76","0.264"],["2492.73","32.098"],["2492.71","32.664"],["2492.70","4.228"],["2492.65","1.230"],["2492.61","5.598"],["2492.60","34.786"],["2492.58","10.393"],["2492.54","4.543"],["2492.50","0.400"],["2492.49","0.600"],["2492.48","4.941"],["2492.45","1.207"],["2492.43","4.878"],["2492.40","4.762"],["2492.39","36.489"],["2492.37","3.000"],["2492.36","4.882"],["2492.33","28.117"],["2492.29","0.490"],["2492.28","76.365"],["2492.27","0.200"],["2492.23","3.804"],["2492.22","1.000"],["2492.19","20.011"],["2492.17","13.500"],["2492.16","4.058"],["2492.14","35.673"],["2492.13","1.915"],["2492.12","76.896"],["2492.10","8.050"],["2492.01","16.615"],["2492.00","10.335"],["2491.95","5.880"],["2491.93","10.000"],["2491.92","3.916"],["2491.90","0.795"],["2491.87","22.000"],["2491.85","1.260"],["2491.84","4.014"],["2491.83","6.668"],["2491.73","0.855"],["2491.72","7.572"],["2491.71","7.000"],["2491.68","3.916"],["2491.66","2.500"],["2491.64","4.945"],["2491.63","2.302"],["2491.62","4.012"],["2491.61","16.170"],["2491.60","0.793"],["2491.59","0.403"],["2491.57","17.445"],["2491.56","88.177"],["2491.53","10.000"],["2491.47","0.013"],["2491.45","0.157"],["2491.44","11.733"],["2491.39","3.593"],["2491.38","3.570"],["2491.36","28.077"],["2491.35","0.808"],["2491.30","0.065"],["2491.29","4.880"],["2491.27","22.000"],["2491.24","9.021"],["2491.23","68.393"],["2491.22","0.050"],["2491.21","1.316"],["2491.20","4.000"],["2491.19","0.108"],["2491.18","0.498"],["2491.17","5.000"],["2491.14","10.000"],["2491.13","0.383"],["2491.12","125.959"],["2491.10","0.870"],["2491.08","10.518"],["2491.05","54.743"],["2491.01","7.980"],["2490.96","3.916"],["2490.95","0.135"],["2490.91","0.140"],["2490.89","8.424"],["2490.88","5.930"],["2490.84","1.208"],["2490.83","2.005"],["2490.82","5.517"],["2490.81","73.707"],["2490.80","1.042"],["2490.79","9.626"],["2490.72","3.916"],["2490.70","0.148"],["2490.69","0.403"],["2490.68","0.012"],["2490.67","21.887"],["2490.66","0.008"],["2490.64","11.500"],["2490.61","0.005"],["2490.58","68.175"],["2490.55","0.218"],["2490.54","14.132"],["2490.53","5.157"],["2490.50","0.018"],["2490.49","9.216"],["2490.48","3.979"],["2490.47","1.884"],["2490.44","0.003"],["2490.36","14.132"],["2490.35","2.008"],["2490.34","0.200"],["2490.33","0.015"],["2490.30","0.065"],["2490.29","5.500"],["2490.28","24.203"],["2490.26","4.373"],["2490.25","0.026"],["2490.24","4.000"],["2490.23","177.628"],["2490.22","14.132"],["2490.21","0.181"],["2490.20","0.645"],["2490.19","9.024"],["2490.18","0.108"],["2490.17","0.085"],["2490.16","0.077"],["2490.14","0.275"],["2490.10","0.080"],["2490.07","0.015"],["2490.04","6.056"],["2490.00","6.796"],["2489.98","0.005"],["2489.97","0.258"],["2489.96","10.084"],["2489.95","1.202"],["2489.91","10.121"],["2489.90","10.084"],["2489.88","0.040"],["2489.87","0.004"],["2489.85","0.003"],["2489.76","3.916"],["2489.73","10.084"],["2489.71","0.272"],["2489.70","12.834"],["2489.67","0.403"],["2489.66","0.362"],["2489.64","0.738"],["2489.63","193.236"],["2489.62","14.152"],["2489.61","0.157"],["2489.59","4.011"],["2489.57","0.015"],["2489.55","0.046"],["2489.52","3.921"],["2489.51","0.005"],["2489.45","80.000"],["2489.44","0.649"],["2489.43","10.088"],["2489.39","0.009"],["2489.37","14.132"],["2489.35","72.262"],["2489.34","10.084"],["2489.33","14.136"],["2489.32","23.953"],["2489.30","0.065"],["2489.28","8.136"],["2489.24","8.022"],["2489.19","14.132"],["2489.18","0.085"],["2489.17","0.108"],["2489.14","10.084"],["2489.13","3.142"],["2489.12","77.827"],["2489.11","10.084"],["2489.10","0.080"],["2489.09","50.024"],["2489.04","3.916"],["2489.03","0.008"],["2489.01","10.084"],["2488.99","0.135"],["2488.98","0.187"],["2488.96","0.324"],["2488.92","0.064"],["2488.85","16.056"],["2488.83","14.132"],["2488.80","3.916"],["2488.79","10.084"],["2488.77","4.414"],["2488.76","0.005"],["2488.75","13.685"],["2488.73","0.020"],["2488.69","0.157"],["2488.60","80.000"],["2488.58","10.164"],["2488.57","0.004"],["2488.56","3.933"],["2488.54","3.311"],["2488.51","12.814"],["2488.50","80.099"],["2488.48","0.684"],["2488.44","0.024"],["2488.42","68.180"],["2488.39","4.412"],["2488.38","26.138"],["2488.34","44.134"],["2488.32","8.014"],["2488.30","0.065"],["2488.29","0.009"],["2488.27","4.513"],["2488.26","4.222"],["2488.25","80.000"],["2488.23","0.007"],["2488.22","0.281"],["2488.19","0.100"],["2488.18","80.100"],["2488.17","80.000"],["2488.16","8.197"],["2488.15","79.184"],["2488.13","0.025"],["2488.11","0.050"],["2488.10","0.080"],["2488.08","3.919"],["2488.04","40.103"],["2488.03","0.120"],["2488.02","0.008"],["2488.01","0.140"],["2488.00","0.406"],["2487.99","0.384"],["2487.98","0.060"],["2487.96","8.010"],["2487.94","0.246"],["2487.93","0.020"],["2487.91","0.136"],["2487.87","0.403"],["2487.84","17.910"],["2487.81","0.005"],["2487.80","0.073"],["2487.74","36.000"],["2487.73","3.225"],["2487.72","0.018"],["2487.71","0.319"],["2487.70","0.006"],["2487.66","0.003"],["2487.64","0.003"],["2487.63","0.008"],["2487.62","0.040"],["2487.60","3.916"],["2487.54","0.805"],["2487.52","0.022"],["2487.51","0.003"],["2487.50","0.051"],["2487.49","6.081"],["2487.47","80.015"],["2487.46","4.735"],["2487.45","30.000"],["2487.41","0.096"],["2487.40","0.078"],["2487.39","0.103"],["2487.37","2.279"],["2487.36","8.152"],["2487.35","2.145"],["2487.32","12.816"],["2487.31","10.023"],["2487.30","0.157"],["2487.27","0.005"],["2487.26","4.010"],["2487.25","0.008"],["2487.24","0.003"],["2487.23","0.014"],["2487.20","0.085"],["2487.17","0.011"],["2487.14","3.217"],["2487.12","3.916"],["2487.11","0.300"],["2487.10","0.088"],["2487.08","10.097"],["2487.07","1.467"],["2487.04","0.600"],["2487.01","18.363"],["2487.00","0.292"],["2486.99","0.014"],["2486.98","0.144"],["2486.97","0.443"],["2486.92","0.005"],["2486.91","0.016"],["2486.89","3.364"],["2486.88","4.166"],["2486.84","24.306"],["2486.83","0.181"],["2486.81","0.015"],["2486.80","0.082"],["2486.79","0.007"],["2486.76","0.011"],["2486.74","0.050"],["2486.73","0.782"],["2486.72","0.004"],["2486.69","0.003"],["2486.68","8.018"],["2486.66","10.004"],["2486.65","40.391"],["2486.64","3.916"],["2486.61","0.489"],["2486.60","0.196"],["2486.57","0.396"],["2486.55","4.015"],["2486.51","3.000"],["2486.50","0.003"],["2486.48","0.005"],["2486.47","0.010"],["2486.45","4.011"],["2486.44","0.602"],["2486.43","0.566"],["2486.42","3.140"],["2486.40","3.958"],["2486.39","0.003"],["2486.34","0.010"],["2486.31","6.281"],["2486.27","0.005"],["2486.26","0.004"],["2486.23","10.088"],["2486.22","0.015"],["2486.17","0.030"],["2486.16","3.916"],["2486.15","0.020"],["2486.13","13.130"],["2486.12","82.414"],["2486.11","0.244"],["2486.10","0.132"],["2486.08","0.720"],["2486.06","0.385"],["2486.01","0.004"],["2486.00","2.359"],["2485.99","154.159"],["2485.98","20.054"],["2485.96","1.000"],["2485.95","0.190"],["2485.92","4.463"],["2485.90","1.557"],["2485.87","0.402"],["2485.85","0.114"],["2485.81","0.900"],["2485.76","4.700"],["2485.75","0.300"],["2485.74","0.196"],["2485.73","4.010"],["2485.72","0.323"],["2485.70","0.263"],["2485.69","0.261"],["2485.68","3.688"],["2485.67","0.005"],["2485.64","1.216"],["2485.63","0.005"],["2485.62","0.015"],["2485.61","0.033"],["2485.60","0.004"],["2485.58","2.012"],["2485.56","0.020"],["2485.54","0.699"],["2485.52","0.003"],["2485.51","1.830"],["2485.48","5.964"],["2485.47","0.015"],["2485.44","7.251"],["2485.43","0.006"],["2485.42","0.644"],["2485.40","8.026"],["2485.38","0.489"],["2485.36","0.014"],["2485.35","0.005"],["2485.31","1.507"],["2485.30","2.107"],["2485.29","0.039"],["2485.28","0.642"],["2485.26","1.990"],["2485.25","4.996"],["2485.23","0.003"],["2485.22","0.277"],["2485.21","0.121"],["2485.20","3.952"],["2485.18","0.006"],["2485.17","0.043"],["2485.15","4.008"],["2485.14","4.434"],["2485.13","1.003"],["2485.05","0.204"],["2485.04","0.254"],["2485.02","5.000"],["2485.01","0.050"],["2485.00","80.821"],["2484.96","3.941"],["2484.95","10.023"],["2484.94","13.935"],["2484.92","0.059"],["2484.90","150.000"],["2484.89","0.004"],["2484.88","150.127"],["2484.87","0.004"],["2484.85","0.100"],["2484.83","0.006"],["2484.82","0.030"],["2484.81","1.246"],["2484.80","0.003"],["2484.79","0.045"],["2484.77","0.003"],["2484.74","0.036"],["2484.72","3.919"],["2484.70","0.134"],["2484.68","1.111"],["2484.66","76.955"],["2484.60","2.580"],["2484.59","31.432"],["2484.58","1.468"],["2484.55","1.153"],["2484.54","0.265"],["2484.53","20.024"],["2484.51","1.047"],["2484.50","0.818"],["2484.49","0.022"],["2484.48","3.887"],["2484.46","0.048"],["2484.45","0.224"],["2484.44","0.174"],["2484.43","223.079"],["2484.42","0.014"],["2484.41","1.115"],["2484.39","26.090"],["2484.38","0.066"],["2484.37","0.121"],["2484.34","0.255"],["2484.33","23.968"],["2484.29","0.085"],["2484.27","1.128"],["2484.26","1.456"],["2484.24","3.916"],["2484.23","28.126"],["2484.22","1.329"],["2484.19","2.015"],["2484.18","0.263"],["2484.15","15.489"],["2484.14","1.135"],["2484.13","0.572"],["2484.12","8.032"],["2484.11","0.021"],["2484.09","0.059"],["2484.08","0.038"],["2484.07","0.147"],["2484.05","24.156"],["2484.04","0.008"],["2484.01","1.184"],["2484.00","4.641"],["2483.99","0.006"],["2483.97","0.294"],["2483.96","0.424"],["2483.94","3.660"],["2483.93","2.067"],["2483.92","0.008"],["2483.89","0.141"],["2483.88","1.089"],
            //             ["2483.87","110.000"],["2483.85","4.018"],["2483.81","150.077"],["2483.80","0.003"],["2483.77","0.020"]
            //         ],
            //         "asks":[
            //             ["2493.57","0.877"],
            //             ["2493.62","0.063"],
            //             ["2493.71","12.054"],
            //         ]
            //     }
            const timestamp = this.safeInteger (response, 'T');
            const orderbook = this.parseOrderBook (response, symbol, timestamp);
            orderbook['nonce'] = this.safeInteger (response, 'lastUpdateId');
            return orderbook;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         symbol: 'ETHBTC',
            //         priceChange: '0.00068700',
            //         priceChangePercent: '2.075',
            //         weightedAvgPrice: '0.03342681',
            //         prevClosePrice: '0.03310300',
            //         lastPrice: '0.03378900',
            //         lastQty: '0.07700000',
            //         bidPrice: '0.03378900',
            //         bidQty: '7.16800000',
            //         askPrice: '0.03379000',
            //         askQty: '24.00000000',
            //         openPrice: '0.03310200',
            //         highPrice: '0.03388900',
            //         lowPrice: '0.03306900',
            //         volume: '205478.41000000',
            //         quoteVolume: '6868.48826294',
            //         openTime: 1601469986932,
            //         closeTime: 1601556386932,
            //         firstId: 196098772,
            //         lastId: 196186315,
            //         count: 87544
            //     }
            //
            // coinm
            //     {
            //         baseVolume: '214549.95171161',
            //         closeTime: '1621965286847',
            //         count: '1283779',
            //         firstId: '152560106',
            //         highPrice: '39938.3',
            //         lastId: '153843955',
            //         lastPrice: '37993.4',
            //         lastQty: '1',
            //         lowPrice: '36457.2',
            //         openPrice: '37783.4',
            //         openTime: '1621878840000',
            //         pair: 'BTCUSD',
            //         priceChange: '210.0',
            //         priceChangePercent: '0.556',
            //         symbol: 'BTCUSD_PERP',
            //         volume: '81990451',
            //         weightedAvgPrice: '38215.08713747'
            //     }
            //
            const timestamp = this.safeInteger (ticker, 'closeTime');
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber (ticker, 'lastPrice');
            const isCoinm = ('baseVolume' in ticker);
            let baseVolume = undefined;
            let quoteVolume = undefined;
            if (isCoinm) {
                baseVolume = this.safeNumber (ticker, 'baseVolume');
                quoteVolume = this.safeNumber (ticker, 'volume');
            } else {
                baseVolume = this.safeNumber (ticker, 'volume');
                quoteVolume = this.safeNumber (ticker, 'quoteVolume');
            }
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'highPrice'),
                'low': this.safeNumber (ticker, 'lowPrice'),
                'bid': this.safeNumber (ticker, 'bidPrice'),
                'bidVolume': this.safeNumber (ticker, 'bidQty'),
                'ask': this.safeNumber (ticker, 'askPrice'),
                'askVolume': this.safeNumber (ticker, 'askQty'),
                'vwap': this.safeNumber (ticker, 'weightedAvgPrice'),
                'open': this.safeNumber (ticker, 'openPrice'),
                'close': last,
                'last': last,
                'previousClose': this.safeNumber (ticker, 'prevClosePrice'), // previous day close
                'change': this.safeNumber (ticker, 'priceChange'),
                'percentage': this.safeNumber (ticker, 'priceChangePercent'),
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchStatus (params = {}) {
            const response = await this.sapiGetSystemStatus (params);
            let status = this.safeString (response, 'status');
            if (status !== undefined) {
                status = (status === '0') ? 'ok' : 'maintenance';
                this.status = this.extend (this.status, {
                    'status': status,
                    'updated': this.milliseconds (),
                });
            }
            return this.status;
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            let method = 'publicGetTicker24hr';
            if (market['linear']) {
                method = 'fapiPublicGetTicker24hr';
            } else if (market['inverse']) {
                method = 'dapiPublicGetTicker24hr';
            }
            const response = await this[method] (this.extend (request, params));
            if (Array.isArray (response)) {
                const firstTicker = this.safeValue (response, 0, {});
                return this.parseTicker (firstTicker, market);
            }
            return this.parseTicker (response, market);
        }
    
        async fetchBidsAsks (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString2 (this.options, 'fetchBidsAsks', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            let method = undefined;
            if (type === 'future') {
                method = 'fapiPublicGetTickerBookTicker';
            } else if (type === 'delivery') {
                method = 'dapiPublicGetTickerBookTicker';
            } else {
                method = 'publicGetTickerBookTicker';
            }
            const response = await this[method] (query);
            return this.parseTickers (response, symbols);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString2 (this.options, 'fetchTickers', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            let defaultMethod = undefined;
            if (type === 'future') {
                defaultMethod = 'fapiPublicGetTicker24hr';
            } else if (type === 'delivery') {
                defaultMethod = 'dapiPublicGetTicker24hr';
            } else {
                defaultMethod = 'publicGetTicker24hr';
            }
            const method = this.safeString (this.options, 'fetchTickersMethod', defaultMethod);
            const response = await this[method] (query);
            return this.parseTickers (response, symbols);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1591478520000,
            //         "0.02501300",
            //         "0.02501800",
            //         "0.02500000",
            //         "0.02500000",
            //         "22.19000000",
            //         1591478579999,
            //         "0.55490906",
            //         40,
            //         "10.92900000",
            //         "0.27336462",
            //         "0"
            //     ]
            //
            return [
                this.safeInteger (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            // binance docs say that the default limit 500, max 1500 for futures, max 1000 for spot markets
            // the reality is that the time range wider than 500 candles won't work right
            const defaultLimit = 500;
            const maxLimit = 1500;
            limit = (limit === undefined) ? defaultLimit : Math.min (limit, maxLimit);
            const request = {
                'symbol': market['id'],
                'interval': this.timeframes[timeframe],
                'limit': limit,
            };
            const duration = this.parseTimeframe (timeframe);
            if (since !== undefined) {
                request['startTime'] = since;
                if (since > 0) {
                    const endTime = this.sum (since, limit * duration * 1000 - 1);
                    const now = this.milliseconds ();
                    request['endTime'] = Math.min (now, endTime);
                }
            }
            let method = 'publicGetKlines';
            if (market['linear']) {
                method = 'fapiPublicGetKlines';
            } else if (market['inverse']) {
                method = 'dapiPublicGetKlines';
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     [
            //         [1591478520000,"0.02501300","0.02501800","0.02500000","0.02500000","22.19000000",1591478579999,"0.55490906",40,"10.92900000","0.27336462","0"],
            //         [1591478580000,"0.02499600","0.02500900","0.02499400","0.02500300","21.34700000",1591478639999,"0.53370468",24,"7.53800000","0.18850725","0"],
            //         [1591478640000,"0.02500800","0.02501100","0.02500300","0.02500800","154.14200000",1591478699999,"3.85405839",97,"5.32300000","0.13312641","0"],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            if ('isDustTrade' in trade) {
                return this.parseDustTrade (trade, market);
            }
            //
            // aggregate trades
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
            //
            //     {
            //         "a": 26129,         // Aggregate tradeId
            //         "p": "0.01633102",  // Price
            //         "q": "4.70443515",  // Quantity
            //         "f": 27781,         // First tradeId
            //         "l": 27781,         // Last tradeId
            //         "T": 1498793709153, // Timestamp
            //         "m": true,          // Was the buyer the maker?
            //         "M": true           // Was the trade the best price match?
            //     }
            //
            // recent public trades and old public trades
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#recent-trades-list
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#old-trade-lookup-market_data
            //
            //     {
            //         "id": 28457,
            //         "price": "4.00000100",
            //         "qty": "12.00000000",
            //         "time": 1499865549590,
            //         "isBuyerMaker": true,
            //         "isBestMatch": true
            //     }
            //
            // private trades
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#account-trade-list-user_data
            //
            //     {
            //         "symbol": "BNBBTC",
            //         "id": 28457,
            //         "orderId": 100234,
            //         "price": "4.00000100",
            //         "qty": "12.00000000",
            //         "commission": "10.10000000",
            //         "commissionAsset": "BNB",
            //         "time": 1499865549590,
            //         "isBuyer": true,
            //         "isMaker": false,
            //         "isBestMatch": true
            //     }
            //
            // futures trades
            // https://binance-docs.github.io/apidocs/futures/en/#account-trade-list-user_data
            //
            //     {
            //       "accountId": 20,
            //       "buyer": False,
            //       "commission": "-0.07819010",
            //       "commissionAsset": "USDT",
            //       "counterPartyId": 653,
            //       "id": 698759,
            //       "maker": False,
            //       "orderId": 25851813,
            //       "price": "7819.01",
            //       "qty": "0.002",
            //       "quoteQty": "0.01563",
            //       "realizedPnl": "-0.91539999",
            //       "side": "SELL",
            //       "symbol": "BTCUSDT",
            //       "time": 1569514978020
            //     }
            //     {
            //       "symbol": "BTCUSDT",
            //       "id": 477128891,
            //       "orderId": 13809777875,
            //       "side": "SELL",
            //       "price": "38479.55",
            //       "qty": "0.001",
            //       "realizedPnl": "-0.00009534",
            //       "marginAsset": "USDT",
            //       "quoteQty": "38.47955",
            //       "commission": "-0.00076959",
            //       "commissionAsset": "USDT",
            //       "time": 1612733566708,
            //       "positionSide": "BOTH",
            //       "maker": true,
            //       "buyer": false
            //     }
            //
            const timestamp = this.safeInteger2 (trade, 'T', 'time');
            const priceString = this.safeString2 (trade, 'p', 'price');
            const amountString = this.safeString2 (trade, 'q', 'qty');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const marketId = this.safeString (trade, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const costString = Precise.stringMul (priceString, amountString);
            const cost = this.parseNumber (costString);
            let id = this.safeString2 (trade, 't', 'a');
            id = this.safeString (trade, 'id', id);
            let side = undefined;
            const orderId = this.safeString (trade, 'orderId');
            if ('m' in trade) {
                side = trade['m'] ? 'sell' : 'buy'; // this is reversed intentionally
            } else if ('isBuyerMaker' in trade) {
                side = trade['isBuyerMaker'] ? 'sell' : 'buy';
            } else if ('side' in trade) {
                side = this.safeStringLower (trade, 'side');
            } else {
                if ('isBuyer' in trade) {
                    side = trade['isBuyer'] ? 'buy' : 'sell'; // this is a true side
                }
            }
            let fee = undefined;
            if ('commission' in trade) {
                fee = {
                    'cost': this.safeNumber (trade, 'commission'),
                    'currency': this.safeCurrencyCode (this.safeString (trade, 'commissionAsset')),
                };
            }
            let takerOrMaker = undefined;
            if ('isMaker' in trade) {
                takerOrMaker = trade['isMaker'] ? 'maker' : 'taker';
            }
            if ('maker' in trade) {
                takerOrMaker = trade['maker'] ? 'maker' : 'taker';
            }
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                // 'fromId': 123,    // ID to get aggregate trades from INCLUSIVE.
                // 'startTime': 456, // Timestamp in ms to get aggregate trades from INCLUSIVE.
                // 'endTime': 789,   // Timestamp in ms to get aggregate trades until INCLUSIVE.
                // 'limit': 500,     // default = 500, maximum = 1000
            };
            const defaultType = this.safeString2 (this.options, 'fetchTrades', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            let defaultMethod = undefined;
            if (type === 'future') {
                defaultMethod = 'fapiPublicGetAggTrades';
            } else if (type === 'delivery') {
                defaultMethod = 'dapiPublicGetAggTrades';
            } else {
                defaultMethod = 'publicGetAggTrades';
            }
            let method = this.safeString (this.options, 'fetchTradesMethod', defaultMethod);
            if (method === 'publicGetAggTrades') {
                if (since !== undefined) {
                    request['startTime'] = since;
                    // https://github.com/ccxt/ccxt/issues/6400
                    // https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#compressedaggregate-trades-list
                    request['endTime'] = this.sum (since, 3600000);
                }
                if (type === 'future') {
                    method = 'fapiPublicGetAggTrades';
                } else if (type === 'delivery') {
                    method = 'dapiPublicGetAggTrades';
                }
            } else if (method === 'publicGetHistoricalTrades') {
                if (type === 'future') {
                    method = 'fapiPublicGetHistoricalTrades';
                } else if (type === 'delivery') {
                    method = 'dapiPublicGetHistoricalTrades';
                }
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default = 500, maximum = 1000
            }
            //
            // Caveats:
            // - default limit (500) applies only if no other parameters set, trades up
            //   to the maximum limit may be returned to satisfy other parameters
            // - if both limit and time window is set and time window contains more
            //   trades than the limit then the last trades from the window are returned
            // - 'tradeId' accepted and returned by this method is "aggregate" trade id
            //   which is different from actual trade id
            // - setting both fromId and time window results in error
            const response = await this[method] (this.extend (request, query));
            //
            // aggregate trades
            //
            //     [
            //         {
            //             "a": 26129,         // Aggregate tradeId
            //             "p": "0.01633102",  // Price
            //             "q": "4.70443515",  // Quantity
            //             "f": 27781,         // First tradeId
            //             "l": 27781,         // Last tradeId
            //             "T": 1498793709153, // Timestamp
            //             "m": true,          // Was the buyer the maker?
            //             "M": true           // Was the trade the best price match?
            //         }
            //     ]
            //
            // recent public trades and historical public trades
            //
            //     [
            //         {
            //             "id": 28457,
            //             "price": "4.00000100",
            //             "qty": "12.00000000",
            //             "time": 1499865549590,
            //             "isBuyerMaker": true,
            //             "isBestMatch": true
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'NEW': 'open',
                'PARTIALLY_FILLED': 'open',
                'FILLED': 'closed',
                'CANCELED': 'canceled',
                'PENDING_CANCEL': 'canceling', // currently unused
                'REJECTED': 'rejected',
                'EXPIRED': 'expired',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // spot
            //
            //     {
            //         "symbol": "LTCBTC",
            //         "orderId": 1,
            //         "clientOrderId": "myOrder1",
            //         "price": "0.1",
            //         "origQty": "1.0",
            //         "executedQty": "0.0",
            //         "cummulativeQuoteQty": "0.0",
            //         "status": "NEW",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "side": "BUY",
            //         "stopPrice": "0.0",
            //         "icebergQty": "0.0",
            //         "time": 1499827319559,
            //         "updateTime": 1499827319559,
            //         "isWorking": true
            //     }
            //
            // futures
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "orderId": 1,
            //         "clientOrderId": "myOrder1",
            //         "price": "0.1",
            //         "origQty": "1.0",
            //         "executedQty": "1.0",
            //         "cumQuote": "10.0",
            //         "status": "NEW",
            //         "timeInForce": "GTC",
            //         "type": "LIMIT",
            //         "side": "BUY",
            //         "stopPrice": "0.0",
            //         "updateTime": 1499827319559
            //     }
            //
            // createOrder with { "newOrderRespType": "FULL" }
            //
            //     {
            //       "symbol": "BTCUSDT",
            //       "orderId": 5403233939,
            //       "orderListId": -1,
            //       "clientOrderId": "x-R4BD3S825e669e75b6c14f69a2c43e",
            //       "transactTime": 1617151923742,
            //       "price": "0.00000000",
            //       "origQty": "0.00050000",
            //       "executedQty": "0.00050000",
            //       "cummulativeQuoteQty": "29.47081500",
            //       "status": "FILLED",
            //       "timeInForce": "GTC",
            //       "type": "MARKET",
            //       "side": "BUY",
            //       "fills": [
            //         {
            //           "price": "58941.63000000",
            //           "qty": "0.00050000",
            //           "commission": "0.00007050",
            //           "commissionAsset": "BNB",
            //           "tradeId": 737466631
            //         }
            //       ]
            //     }
            //
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const filledString = this.safeString (order, 'executedQty', '0');
            const filled = this.parseNumber (filledString);
            const filledFloat = parseFloat (filledString);
            let timestamp = undefined;
            let lastTradeTimestamp = undefined;
            if ('time' in order) {
                timestamp = this.safeInteger (order, 'time');
            } else if ('transactTime' in order) {
                timestamp = this.safeInteger (order, 'transactTime');
            } else if ('updateTime' in order) {
                if (status === 'open') {
                    if (filledFloat > 0) {
                        lastTradeTimestamp = this.safeInteger (order, 'updateTime');
                    } else {
                        timestamp = this.safeInteger (order, 'updateTime');
                    }
                }
            }
            const averageString = this.safeString (order, 'avgPrice');
            const average = this.parseNumber (this.omitZero (averageString));
            const priceString = this.safeString (order, 'price');
            const price = this.parseNumber (this.omitZero (priceString));
            const amount = this.safeNumber (order, 'origQty');
            // - Spot/Margin market: cummulativeQuoteQty
            // - Futures market: cumQuote.
            //   Note this is not the actual cost, since Binance futures uses leverage to calculate margins.
            const cost = this.safeNumber2 (order, 'cummulativeQuoteQty', 'cumQuote');
            const id = this.safeString (order, 'orderId');
            let type = this.safeStringLower (order, 'type');
            const side = this.safeStringLower (order, 'side');
            const fills = this.safeValue (order, 'fills', []);
            const trades = this.parseTrades (fills, market);
            const clientOrderId = this.safeString (order, 'clientOrderId');
            const timeInForce = this.safeString (order, 'timeInForce');
            const postOnly = (type === 'limit_maker') || (timeInForce === 'GTX');
            if (type === 'limit_maker') {
                type = 'limit';
            }
            const stopPriceString = this.safeString (order, 'stopPrice');
            const stopPrice = this.parseNumber (this.omitZero (stopPriceString));
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': cost,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': undefined,
                'trades': trades,
            });
        }
    
        async createReduceOnlyOrder (symbol, type, side, amount, price = undefined, params = {}) {
            const request = {
                'reduceOnly': true,
            };
            return await this.createOrder (symbol, type, side, amount, price, this.extend (request, params));
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const defaultType = this.safeString2 (this.options, 'createOrder', 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            const clientOrderId = this.safeString2 (params, 'newClientOrderId', 'clientOrderId');
            params = this.omit (params, [ 'type', 'newClientOrderId', 'clientOrderId' ]);
            const reduceOnly = this.safeValue (params, 'reduceOnly');
            if (reduceOnly !== undefined) {
                if ((orderType !== 'future') && (orderType !== 'delivery')) {
                    throw new InvalidOrder (this.id + ' createOrder() does not support reduceOnly for ' + orderType + ' orders, reduceOnly orders are supported for futures and perpetuals only');
                }
            }
            let method = 'privatePostOrder';
            if (orderType === 'future') {
                method = 'fapiPrivatePostOrder';
            } else if (orderType === 'delivery') {
                method = 'dapiPrivatePostOrder';
            } else if (orderType === 'margin') {
                method = 'sapiPostMarginOrder';
            }
            // the next 5 lines are added to support for testing orders
            if (market['spot']) {
                const test = this.safeValue (params, 'test', false);
                if (test) {
                    method += 'Test';
                }
                params = this.omit (params, 'test');
            }
            const uppercaseType = type.toUpperCase ();
            const validOrderTypes = this.safeValue (market['info'], 'orderTypes');
            if (!this.inArray (uppercaseType, validOrderTypes)) {
                throw new InvalidOrder (this.id + ' ' + type + ' is not a valid order type in market ' + symbol);
            }
            const request = {
                'symbol': market['id'],
                'type': uppercaseType,
                'side': side.toUpperCase (),
            };
            if (clientOrderId === undefined) {
                const broker = this.safeValue (this.options, 'broker');
                if (broker !== undefined) {
                    const brokerId = this.safeString (broker, orderType);
                    if (brokerId !== undefined) {
                        request['newClientOrderId'] = brokerId + this.uuid22 ();
                    }
                }
            } else {
                request['newClientOrderId'] = clientOrderId;
            }
            if ((orderType === 'spot') || (orderType === 'margin')) {
                request['newOrderRespType'] = this.safeValue (this.options['newOrderRespType'], type, 'RESULT'); // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
            } else {
                // delivery and future
                request['newOrderRespType'] = 'RESULT';  // "ACK", "RESULT", default "ACK"
            }
            // additional required fields depending on the order type
            let timeInForceIsRequired = false;
            let priceIsRequired = false;
            let stopPriceIsRequired = false;
            let quantityIsRequired = false;
            //
            // spot/margin
            //
            //     LIMIT                timeInForce, quantity, price
            //     MARKET               quantity or quoteOrderQty
            //     STOP_LOSS            quantity, stopPrice
            //     STOP_LOSS_LIMIT      timeInForce, quantity, price, stopPrice
            //     TAKE_PROFIT          quantity, stopPrice
            //     TAKE_PROFIT_LIMIT    timeInForce, quantity, price, stopPrice
            //     LIMIT_MAKER          quantity, price
            //
            // futures
            //
            //     LIMIT                timeInForce, quantity, price
            //     MARKET               quantity
            //     STOP/TAKE_PROFIT     quantity, price, stopPrice
            //     STOP_MARKET          stopPrice
            //     TAKE_PROFIT_MARKET   stopPrice
            //     TRAILING_STOP_MARKET callbackRate
            //
            if (uppercaseType === 'MARKET') {
                const quoteOrderQty = this.safeValue (this.options, 'quoteOrderQty', false);
                if (quoteOrderQty) {
                    const quoteOrderQty = this.safeNumber (params, 'quoteOrderQty');
                    const precision = market['precision']['price'];
                    if (quoteOrderQty !== undefined) {
                        request['quoteOrderQty'] = this.decimalToPrecision (quoteOrderQty, TRUNCATE, precision, this.precisionMode);
                        params = this.omit (params, 'quoteOrderQty');
                    } else if (price !== undefined) {
                        request['quoteOrderQty'] = this.decimalToPrecision (amount * price, TRUNCATE, precision, this.precisionMode);
                    } else {
                        quantityIsRequired = true;
                    }
                } else {
                    quantityIsRequired = true;
                }
            } else if (uppercaseType === 'LIMIT') {
                priceIsRequired = true;
                timeInForceIsRequired = true;
                quantityIsRequired = true;
            } else if ((uppercaseType === 'STOP_LOSS') || (uppercaseType === 'TAKE_PROFIT')) {
                stopPriceIsRequired = true;
                quantityIsRequired = true;
                if (market['linear'] || market['inverse']) {
                    priceIsRequired = true;
                }
            } else if ((uppercaseType === 'STOP_LOSS_LIMIT') || (uppercaseType === 'TAKE_PROFIT_LIMIT')) {
                quantityIsRequired = true;
                stopPriceIsRequired = true;
                priceIsRequired = true;
                timeInForceIsRequired = true;
            } else if (uppercaseType === 'LIMIT_MAKER') {
                priceIsRequired = true;
                quantityIsRequired = true;
            } else if (uppercaseType === 'STOP') {
                quantityIsRequired = true;
                stopPriceIsRequired = true;
                priceIsRequired = true;
            } else if ((uppercaseType === 'STOP_MARKET') || (uppercaseType === 'TAKE_PROFIT_MARKET')) {
                const closePosition = this.safeValue (params, 'closePosition');
                if (closePosition === undefined) {
                    quantityIsRequired = true;
                }
                stopPriceIsRequired = true;
            } else if (uppercaseType === 'TRAILING_STOP_MARKET') {
                quantityIsRequired = true;
                const callbackRate = this.safeNumber (params, 'callbackRate');
                if (callbackRate === undefined) {
                    throw new InvalidOrder (this.id + ' createOrder() requires a callbackRate extra param for a ' + type + ' order');
                }
            }
            if (quantityIsRequired) {
                request['quantity'] = this.amountToPrecision (symbol, amount);
            }
            if (priceIsRequired) {
                if (price === undefined) {
                    throw new InvalidOrder (this.id + ' createOrder() requires a price argument for a ' + type + ' order');
                }
                request['price'] = this.priceToPrecision (symbol, price);
            }
            if (timeInForceIsRequired) {
                request['timeInForce'] = this.options['defaultTimeInForce']; // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
            }
            if (stopPriceIsRequired) {
                const stopPrice = this.safeNumber (params, 'stopPrice');
                if (stopPrice === undefined) {
                    throw new InvalidOrder (this.id + ' createOrder() requires a stopPrice extra param for a ' + type + ' order');
                } else {
                    params = this.omit (params, 'stopPrice');
                    request['stopPrice'] = this.priceToPrecision (symbol, stopPrice);
                }
            }
            const response = await this[method] (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const defaultType = this.safeString2 (this.options, 'fetchOrder', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            let method = 'privateGetOrder';
            if (type === 'future') {
                method = 'fapiPrivateGetOrder';
            } else if (type === 'delivery') {
                method = 'dapiPrivateGetOrder';
            } else if (type === 'margin') {
                method = 'sapiGetMarginOrder';
            }
            const request = {
                'symbol': market['id'],
            };
            const clientOrderId = this.safeValue2 (params, 'origClientOrderId', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['origClientOrderId'] = clientOrderId;
            } else {
                request['orderId'] = id;
            }
            const query = this.omit (params, [ 'type', 'clientOrderId', 'origClientOrderId' ]);
            const response = await this[method] (this.extend (request, query));
            return this.parseOrder (response, market);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const defaultType = this.safeString2 (this.options, 'fetchOrders', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            let method = 'privateGetAllOrders';
            if (type === 'future') {
                method = 'fapiPrivateGetAllOrders';
            } else if (type === 'delivery') {
                method = 'dapiPrivateGetAllOrders';
            } else if (type === 'margin') {
                method = 'sapiGetMarginAllOrders';
            }
            const request = {
                'symbol': market['id'],
            };
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const query = this.omit (params, 'type');
            const response = await this[method] (this.extend (request, query));
            //
            //  spot
            //
            //     [
            //         {
            //             "symbol": "LTCBTC",
            //             "orderId": 1,
            //             "clientOrderId": "myOrder1",
            //             "price": "0.1",
            //             "origQty": "1.0",
            //             "executedQty": "0.0",
            //             "cummulativeQuoteQty": "0.0",
            //             "status": "NEW",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "stopPrice": "0.0",
            //             "icebergQty": "0.0",
            //             "time": 1499827319559,
            //             "updateTime": 1499827319559,
            //             "isWorking": true
            //         }
            //     ]
            //
            //  futures
            //
            //     [
            //         {
            //             "symbol": "BTCUSDT",
            //             "orderId": 1,
            //             "clientOrderId": "myOrder1",
            //             "price": "0.1",
            //             "origQty": "1.0",
            //             "executedQty": "1.0",
            //             "cumQuote": "10.0",
            //             "status": "NEW",
            //             "timeInForce": "GTC",
            //             "type": "LIMIT",
            //             "side": "BUY",
            //             "stopPrice": "0.0",
            //             "updateTime": 1499827319559
            //         }
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            let query = undefined;
            let type = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                const defaultType = this.safeString2 (this.options, 'fetchOpenOrders', 'defaultType', 'spot');
                type = this.safeString (params, 'type', defaultType);
                query = this.omit (params, 'type');
            } else if (this.options['warnOnFetchOpenOrdersWithoutSymbol']) {
                const symbols = this.symbols;
                const numSymbols = symbols.length;
                const fetchOpenOrdersRateLimit = parseInt (numSymbols / 2);
                throw new ExchangeError (this.id + ' fetchOpenOrders WARNING: fetching open orders without specifying a symbol is rate-limited to one call per ' + fetchOpenOrdersRateLimit.toString () + ' seconds. Do not call this method frequently to avoid ban. Set ' + this.id + '.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.');
            } else {
                const defaultType = this.safeString2 (this.options, 'fetchOpenOrders', 'defaultType', 'spot');
                type = this.safeString (params, 'type', defaultType);
                query = this.omit (params, 'type');
            }
            let method = 'privateGetOpenOrders';
            if (type === 'future') {
                method = 'fapiPrivateGetOpenOrders';
            } else if (type === 'delivery') {
                method = 'dapiPrivateGetOpenOrders';
            } else if (type === 'margin') {
                method = 'sapiGetMarginOpenOrders';
            }
            const response = await this[method] (this.extend (request, query));
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const orders = await this.fetchOrders (symbol, since, limit, params);
            return this.filterBy (orders, 'status', 'closed');
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const defaultType = this.safeString2 (this.options, 'fetchOpenOrders', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            // https://github.com/ccxt/ccxt/issues/6507
            const origClientOrderId = this.safeValue2 (params, 'origClientOrderId', 'clientOrderId');
            const request = {
                'symbol': market['id'],
                // 'orderId': id,
                // 'origClientOrderId': id,
            };
            if (origClientOrderId === undefined) {
                request['orderId'] = id;
            } else {
                request['origClientOrderId'] = origClientOrderId;
            }
            let method = 'privateDeleteOrder';
            if (type === 'future') {
                method = 'fapiPrivateDeleteOrder';
            } else if (type === 'delivery') {
                method = 'dapiPrivateDeleteOrder';
            } else if (type === 'margin') {
                method = 'sapiDeleteMarginOrder';
            }
            const query = this.omit (params, [ 'type', 'origClientOrderId', 'clientOrderId' ]);
            const response = await this[method] (this.extend (request, query));
            return this.parseOrder (response);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelAllOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const defaultType = this.safeString2 (this.options, 'cancelAllOrders', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            let method = 'privateDeleteOpenOrders';
            if (type === 'margin') {
                method = 'sapiDeleteMarginOpenOrders';
            } else if (type === 'future') {
                method = 'fapiPrivateDeleteAllOpenOrders';
            } else if (type === 'delivery') {
                method = 'dapiPrivateDeleteAllOpenOrders';
            }
            const response = await this[method] (this.extend (request, query));
            if (Array.isArray (response)) {
                return this.parseOrders (response, market);
            } else {
                return response;
            }
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const defaultType = this.safeString2 (this.options, 'fetchMyTrades', 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            let method = undefined;
            if (type === 'spot') {
                method = 'privateGetMyTrades';
            } else if (type === 'margin') {
                method = 'sapiGetMarginMyTrades';
            } else if (type === 'future') {
                method = 'fapiPrivateGetUserTrades';
            } else if (type === 'delivery') {
                method = 'dapiPrivateGetUserTrades';
            }
            const request = {
                'symbol': market['id'],
            };
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot trade
            //
            //     [
            //         {
            //             "symbol": "BNBBTC",
            //             "id": 28457,
            //             "orderId": 100234,
            //             "price": "4.00000100",
            //             "qty": "12.00000000",
            //             "commission": "10.10000000",
            //             "commissionAsset": "BNB",
            //             "time": 1499865549590,
            //             "isBuyer": true,
            //             "isMaker": false,
            //             "isBestMatch": true,
            //         }
            //     ]
            //
            // futures trade
            //
            //     [
            //         {
            //             "accountId": 20,
            //             "buyer": False,
            //             "commission": "-0.07819010",
            //             "commissionAsset": "USDT",
            //             "counterPartyId": 653,
            //             "id": 698759,
            //             "maker": False,
            //             "orderId": 25851813,
            //             "price": "7819.01",
            //             "qty": "0.002",
            //             "quoteQty": "0.01563",
            //             "realizedPnl": "-0.91539999",
            //             "side": "SELL",
            //             "symbol": "BTCUSDT",
            //             "time": 1569514978020
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchMyDustTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            //
            // Binance provides an opportunity to trade insignificant (i.e. non-tradable and non-withdrawable)
            // token leftovers (of any asset) into `BNB` coin which in turn can be used to pay trading fees with it.
            // The corresponding trades history is called the `Dust Log` and can be requested via the following end-point:
            // https://github.com/binance-exchange/binance-official-api-docs/blob/master/wapi-api.md#dustlog-user_data
            //
            await this.loadMarkets ();
            const request = {};
            if (since !== undefined) {
                request['startTime'] = since;
                request['endTime'] = this.sum (since, 7776000000);
            }
            const response = await this.sapiGetAssetDribblet (this.extend (request, params));
            //     {
            //       "total": "4",
            //       "userAssetDribblets": [
            //         {
            //           "operateTime": "1627575731000",
            //           "totalServiceChargeAmount": "0.00001453",
            //           "totalTransferedAmount": "0.00072693",
            //           "transId": "70899815863",
            //           "userAssetDribbletDetails": [
            //             {
            //               "fromAsset": "LTC",
            //               "amount": "0.000006",
            //               "transferedAmount": "0.00000267",
            //               "serviceChargeAmount": "0.00000005",
            //               "operateTime": "1627575731000",
            //               "transId": "70899815863"
            //             },
            //             {
            //               "fromAsset": "GBP",
            //               "amount": "0.15949157",
            //               "transferedAmount": "0.00072426",
            //               "serviceChargeAmount": "0.00001448",
            //               "operateTime": "1627575731000",
            //               "transId": "70899815863"
            //             }
            //           ]
            //         },
            //       ]
            //     }
            const results = this.safeValue (response, 'userAssetDribblets', []);
            const rows = this.safeInteger (response, 'total', 0);
            const data = [];
            for (let i = 0; i < rows; i++) {
                const logs = this.safeValue (results[i], 'userAssetDribbletDetails', []);
                for (let j = 0; j < logs.length; j++) {
                    logs[j]['isDustTrade'] = true;
                    data.push (logs[j]);
                }
            }
            const trades = this.parseTrades (data, undefined, since, limit);
            return this.filterBySinceLimit (trades, since, limit);
        }
    
        parseDustTrade (trade, market = undefined) {
            //
            //     {
            //       "fromAsset": "USDT",
            //       "amount": "0.009669",
            //       "transferedAmount": "0.00002992",
            //       "serviceChargeAmount": "0.00000059",
            //       "operateTime": "1628076010000",
            //       "transId": "71416578712",
            //       "isDustTrade": true
            //     }
            //
            const orderId = this.safeString (trade, 'transId');
            const timestamp = this.safeInteger (trade, 'operateTime');
            const currencyId = this.safeString (trade, 'fromAsset');
            const tradedCurrency = this.safeCurrencyCode (currencyId);
            const bnb = this.currency ('BNB');
            const earnedCurrency = bnb['code'];
            const applicantSymbol = earnedCurrency + '/' + tradedCurrency;
            let tradedCurrencyIsQuote = false;
            if (applicantSymbol in this.markets) {
                tradedCurrencyIsQuote = true;
            }
            //
            // Warning
            // Binance dust trade `fee` is already excluded from the `BNB` earning reported in the `Dust Log`.
            // So the parser should either set the `fee.cost` to `0` or add it on top of the earned
            // BNB `amount` (or `cost` depending on the trade `side`). The second of the above options
            // is much more illustrative and therefore preferable.
            //
            const feeCostString = this.safeString (trade, 'serviceChargeAmount');
            const fee = {
                'currency': earnedCurrency,
                'cost': this.parseNumber (feeCostString),
            };
            let symbol = undefined;
            let amountString = undefined;
            let costString = undefined;
            let side = undefined;
            if (tradedCurrencyIsQuote) {
                symbol = applicantSymbol;
                amountString = Precise.stringAdd (this.safeString (trade, 'transferedAmount'), feeCostString);
                costString = this.safeString (trade, 'amount');
                side = 'buy';
            } else {
                symbol = tradedCurrency + '/' + earnedCurrency;
                amountString = this.safeString (trade, 'amount');
                costString = Precise.stringAdd (this.safeString (trade, 'transferedAmount'), feeCostString);
                side = 'sell';
            }
            let priceString = undefined;
            if (costString !== undefined) {
                if (amountString) {
                    priceString = Precise.stringDiv (costString, amountString);
                }
            }
            const id = undefined;
            const amount = this.parseNumber (amountString);
            const price = this.parseNumber (priceString);
            const cost = this.parseNumber (costString);
            const type = undefined;
            const takerOrMaker = undefined;
            return {
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': type,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'amount': amount,
                'price': price,
                'cost': cost,
                'fee': fee,
                'info': trade,
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            let response = undefined;
            const request = {};
            const legalMoney = this.safeValue (this.options, 'legalMoney', {});
            if (code in legalMoney) {
                if (code !== undefined) {
                    currency = this.currency (code);
                }
                request['transactionType'] = 0;
                if (since !== undefined) {
                    request['beginTime'] = since;
                }
                const raw = await this.sapiGetFiatOrders (this.extend (request, params));
                response = this.safeValue (raw, 'data');
                //     {
                //       "code": "000000",
                //       "message": "success",
                //       "data": [
                //         {
                //           "orderNo": "25ced37075c1470ba8939d0df2316e23",
                //           "fiatCurrency": "EUR",
                //           "indicatedAmount": "15.00",
                //           "amount": "15.00",
                //           "totalFee": "0.00",
                //           "method": "card",
                //           "status": "Failed",
                //           "createTime": 1627501026000,
                //           "updateTime": 1627501027000
                //         }
                //       ],
                //       "total": 1,
                //       "success": true
                //     }
            } else {
                if (code !== undefined) {
                    currency = this.currency (code);
                    request['coin'] = currency['id'];
                }
                if (since !== undefined) {
                    request['startTime'] = since;
                    // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                    request['endTime'] = this.sum (since, 7776000000);
                }
                if (limit !== undefined) {
                    request['limit'] = limit;
                }
                response = await this.sapiGetCapitalDepositHisrec (this.extend (request, params));
                //     [
                //       {
                //         "amount": "0.01844487",
                //         "coin": "BCH",
                //         "network": "BCH",
                //         "status": 1,
                //         "address": "1NYxAJhW2281HK1KtJeaENBqHeygA88FzR",
                //         "addressTag": "",
                //         "txId": "bafc5902504d6504a00b7d0306a41154cbf1d1b767ab70f3bc226327362588af",
                //         "insertTime": 1610784980000,
                //         "transferType": 0,
                //         "confirmTimes": "2/2"
                //       },
                //       {
                //         "amount": "4500",
                //         "coin": "USDT",
                //         "network": "BSC",
                //         "status": 1,
                //         "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
                //         "addressTag": "",
                //         "txId": "Internal transfer 51376627901",
                //         "insertTime": 1618394381000,
                //         "transferType": 1,
                //         "confirmTimes": "1/15"
                //     }
                //   ]
            }
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const legalMoney = this.safeValue (this.options, 'legalMoney', {});
            const request = {};
            let response = undefined;
            let currency = undefined;
            if (code in legalMoney) {
                if (code !== undefined) {
                    currency = this.currency (code);
                }
                request['transactionType'] = 1;
                if (since !== undefined) {
                    request['beginTime'] = since;
                }
                const raw = await this.sapiGetFiatOrders (this.extend (request, params));
                response = this.safeValue (raw, 'data');
                //     {
                //       "code": "000000",
                //       "message": "success",
                //       "data": [
                //         {
                //           "orderNo": "CJW706452266115170304",
                //           "fiatCurrency": "GBP",
                //           "indicatedAmount": "10001.50",
                //           "amount": "100.00",
                //           "totalFee": "1.50",
                //           "method": "bank transfer",
                //           "status": "Successful",
                //           "createTime": 1620037745000,
                //           "updateTime": 1620038480000
                //         },
                //         {
                //           "orderNo": "CJW706287492781891584",
                //           "fiatCurrency": "GBP",
                //           "indicatedAmount": "10001.50",
                //           "amount": "100.00",
                //           "totalFee": "1.50",
                //           "method": "bank transfer",
                //           "status": "Successful",
                //           "createTime": 1619998460000,
                //           "updateTime": 1619998823000
                //         }
                //       ],
                //       "total": 39,
                //       "success": true
                //     }
            } else {
                if (code !== undefined) {
                    currency = this.currency (code);
                    request['coin'] = currency['id'];
                }
                if (since !== undefined) {
                    request['startTime'] = since;
                    // max 3 months range https://github.com/ccxt/ccxt/issues/6495
                    request['endTime'] = this.sum (since, 7776000000);
                }
                if (limit !== undefined) {
                    request['limit'] = limit;
                }
                response = await this.sapiGetCapitalWithdrawHistory (this.extend (request, params));
                //     [
                //       {
                //         "id": "69e53ad305124b96b43668ceab158a18",
                //         "amount": "28.75",
                //         "transactionFee": "0.25",
                //         "coin": "XRP",
                //         "status": 6,
                //         "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
                //         "addressTag": "101286922",
                //         "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
                //         "applyTime": "2021-04-15 12:09:16",
                //         "network": "XRP",
                //         "transferType": 0
                //       },
                //       {
                //         "id": "9a67628b16ba4988ae20d329333f16bc",
                //         "amount": "20",
                //         "transactionFee": "20",
                //         "coin": "USDT",
                //         "status": 6,
                //         "address": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
                //         "txId": "0x77fbf2cf2c85b552f0fd31fd2e56dc95c08adae031d96f3717d8b17e1aea3e46",
                //         "applyTime": "2021-04-15 12:06:53",
                //         "network": "ETH",
                //         "transferType": 0
                //       },
                //       {
                //         "id": "a7cdc0afbfa44a48bd225c9ece958fe2",
                //         "amount": "51",
                //         "transactionFee": "1",
                //         "coin": "USDT",
                //         "status": 6,
                //         "address": "TYDmtuWL8bsyjvcauUTerpfYyVhFtBjqyo",
                //         "txId": "168a75112bce6ceb4823c66726ad47620ad332e69fe92d9cb8ceb76023f9a028",
                //         "applyTime": "2021-04-13 12:46:59",
                //         "network": "TRX",
                //         "transferType": 0
                //       }
                //     ]
            }
            return this.parseTransactions (response, currency, since, limit);
        }
    
        parseTransactionStatusByType (status, type = undefined) {
            const statusesByType = {
                'deposit': {
                    '0': 'pending',
                    '1': 'ok',
                    // Fiat
                    // Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
                    'Processing': 'pending',
                    'Failed': 'failed',
                    'Successful': 'ok',
                    'Refunding': 'canceled',
                    'Refunded': 'canceled',
                    'Refund Failed': 'failed',
                },
                'withdrawal': {
                    '0': 'pending', // Email Sent
                    '1': 'canceled', // Cancelled (different from 1 = ok in deposits)
                    '2': 'pending', // Awaiting Approval
                    '3': 'failed', // Rejected
                    '4': 'pending', // Processing
                    '5': 'failed', // Failure
                    '6': 'ok', // Completed
                    // Fiat
                    // Processing, Failed, Successful, Finished, Refunding, Refunded, Refund Failed, Order Partial credit Stopped
                    'Processing': 'pending',
                    'Failed': 'failed',
                    'Successful': 'ok',
                    'Refunding': 'canceled',
                    'Refunded': 'canceled',
                    'Refund Failed': 'failed',
                },
            };
            const statuses = this.safeValue (statusesByType, type, {});
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //       "amount": "4500",
            //       "coin": "USDT",
            //       "network": "BSC",
            //       "status": 1,
            //       "address": "0xc9c923c87347ca0f3451d6d308ce84f691b9f501",
            //       "addressTag": "",
            //       "txId": "Internal transfer 51376627901",
            //       "insertTime": 1618394381000,
            //       "transferType": 1,
            //       "confirmTimes": "1/15"
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //       "id": "69e53ad305124b96b43668ceab158a18",
            //       "amount": "28.75",
            //       "transactionFee": "0.25",
            //       "coin": "XRP",
            //       "status": 6,
            //       "address": "r3T75fuLjX51mmfb5Sk1kMNuhBgBPJsjza",
            //       "addressTag": "101286922",
            //       "txId": "19A5B24ED0B697E4F0E9CD09FCB007170A605BC93C9280B9E6379C5E6EF0F65A",
            //       "applyTime": "2021-04-15 12:09:16",
            //       "network": "XRP",
            //       "transferType": 0
            //     }
            //
            // fiat transaction
            // withdraw
            //     {
            //       "orderNo": "CJW684897551397171200",
            //       "fiatCurrency": "GBP",
            //       "indicatedAmount": "29.99",
            //       "amount": "28.49",
            //       "totalFee": "1.50",
            //       "method": "bank transfer",
            //       "status": "Successful",
            //       "createTime": 1614898701000,
            //       "updateTime": 1614898820000
            //     }
            //
            // deposit
            //     {
            //       "orderNo": "25ced37075c1470ba8939d0df2316e23",
            //       "fiatCurrency": "EUR",
            //       "indicatedAmount": "15.00",
            //       "amount": "15.00",
            //       "totalFee": "0.00",
            //       "method": "card",
            //       "status": "Failed",
            //       "createTime": "1627501026000",
            //       "updateTime": "1627501027000"
            //     }
            //
            const id = this.safeString2 (transaction, 'id', 'orderNo');
            const address = this.safeString (transaction, 'address');
            let tag = this.safeString (transaction, 'addressTag'); // set but unused
            if (tag !== undefined) {
                if (tag.length < 1) {
                    tag = undefined;
                }
            }
            let txid = this.safeString (transaction, 'txId');
            if ((txid !== undefined) && (txid.indexOf ('Internal transfer ') >= 0)) {
                txid = txid.slice (18);
            }
            const currencyId = this.safeString2 (transaction, 'coin', 'fiatCurrency');
            const code = this.safeCurrencyCode (currencyId, currency);
            let timestamp = undefined;
            const insertTime = this.safeInteger2 (transaction, 'insertTime', 'createTime');
            const applyTime = this.parse8601 (this.safeString (transaction, 'applyTime'));
            let type = this.safeString (transaction, 'type');
            if (type === undefined) {
                if ((insertTime !== undefined) && (applyTime === undefined)) {
                    type = 'deposit';
                    timestamp = insertTime;
                } else if ((insertTime === undefined) && (applyTime !== undefined)) {
                    type = 'withdrawal';
                    timestamp = applyTime;
                }
            }
            const status = this.parseTransactionStatusByType (this.safeString (transaction, 'status'), type);
            const amount = this.safeNumber (transaction, 'amount');
            const feeCost = this.safeNumber2 (transaction, 'transactionFee', 'totalFee');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = { 'currency': code, 'cost': feeCost };
            }
            const updated = this.safeInteger2 (transaction, 'successTime', 'updateTime');
            let internal = this.safeInteger (transaction, 'transferType', false);
            internal = internal ? true : false;
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'addressTo': address,
                'addressFrom': undefined,
                'tag': tag,
                'tagTo': tag,
                'tagFrom': undefined,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'internal': internal,
                'fee': fee,
            };
        }
    
        parseTransferStatus (status) {
            const statuses = {
                'CONFIRMED': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransfer (transfer, currency = undefined) {
            //
            // transfer
            //
            //     {
            //         "tranId":13526853623
            //     }
            //
            // fetchTransfers
            //
            //     {
            //         timestamp: 1614640878000,
            //         asset: 'USDT',
            //         amount: '25',
            //         type: 'MAIN_UMFUTURE',
            //         status: 'CONFIRMED',
            //         tranId: 43000126248
            //     }
            //
            const id = this.safeString (transfer, 'tranId');
            const currencyId = this.safeString (transfer, 'asset');
            const code = this.safeCurrencyCode (currencyId, currency);
            const amount = this.safeNumber (transfer, 'amount');
            const type = this.safeString (transfer, 'type');
            let fromAccount = undefined;
            let toAccount = undefined;
            const typesByAccount = this.safeValue (this.options, 'typesByAccount', {});
            if (type !== undefined) {
                const parts = type.split ('_');
                fromAccount = this.safeValue (parts, 0);
                toAccount = this.safeValue (parts, 1);
                fromAccount = this.safeString (typesByAccount, fromAccount, fromAccount);
                toAccount = this.safeString (typesByAccount, toAccount, toAccount);
            }
            const timestamp = this.safeInteger (transfer, 'timestamp');
            const status = this.parseTransferStatus (this.safeString (transfer, 'status'));
            return {
                'info': transfer,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'currency': code,
                'amount': amount,
                'fromAccount': fromAccount,
                'toAccount': toAccount,
                'status': status,
            };
        }
    
        parseIncome (income, market = undefined) {
            //
            //     {
            //       "symbol": "ETHUSDT",
            //       "incomeType": "FUNDING_FEE",
            //       "income": "0.00134317",
            //       "asset": "USDT",
            //       "time": "1621584000000",
            //       "info": "FUNDING_FEE",
            //       "tranId": "4480321991774044580",
            //       "tradeId": ""
            //     }
            //
            const marketId = this.safeString (income, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const amount = this.safeNumber (income, 'income');
            const currencyId = this.safeString (income, 'asset');
            const code = this.safeCurrencyCode (currencyId);
            const id = this.safeString (income, 'tranId');
            const timestamp = this.safeInteger (income, 'time');
            return {
                'info': income,
                'symbol': symbol,
                'code': code,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'id': id,
                'amount': amount,
            };
        }
    
        parseIncomes (incomes, market = undefined, since = undefined, limit = undefined) {
            const result = [];
            for (let i = 0; i < incomes.length; i++) {
                const entry = incomes[i];
                const parsed = this.parseIncome (entry, market);
                result.push (parsed);
            }
            return this.filterBySinceLimit (result, since, limit, 'timestamp');
        }
    
        async transfer (code, amount, fromAccount, toAccount, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            let type = this.safeString (params, 'type');
            if (type === undefined) {
                const accountsByType = this.safeValue (this.options, 'accountsByType', {});
                const fromId = this.safeString (accountsByType, fromAccount, fromAccount);
                const toId = this.safeString (accountsByType, toAccount, toAccount);
                if (fromId === undefined) {
                    const keys = Object.keys (accountsByType);
                    throw new ExchangeError (this.id + ' fromAccount must be one of ' + keys.join (', '));
                }
                if (toId === undefined) {
                    const keys = Object.keys (accountsByType);
                    throw new ExchangeError (this.id + ' toAccount must be one of ' + keys.join (', '));
                }
                type = fromId + '_' + toId;
            }
            const request = {
                'asset': currency['id'],
                'amount': this.currencyToPrecision (code, amount),
                'type': type,
            };
            const response = await this.sapiPostAssetTransfer (this.extend (request, params));
            //
            //     {
            //         "tranId":13526853623
            //     }
            //
            const transfer = this.parseTransfer (response, currency);
            return this.extend (transfer, {
                'amount': amount,
                'currency': code,
                'fromAccount': fromAccount,
                'toAccount': toAccount,
            });
        }
    
        async fetchTransfers (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const defaultType = this.safeString2 (this.options, 'fetchTransfers', 'defaultType', 'spot');
            const fromAccount = this.safeString (params, 'fromAccount', defaultType);
            const defaultTo = (fromAccount === 'future') ? 'spot' : 'future';
            const toAccount = this.safeString (params, 'toAccount', defaultTo);
            let type = this.safeString (params, 'type');
            const accountsByType = this.safeValue (this.options, 'accountsByType', {});
            const fromId = this.safeString (accountsByType, fromAccount);
            const toId = this.safeString (accountsByType, toAccount);
            if (type === undefined) {
                if (fromId === undefined) {
                    const keys = Object.keys (accountsByType);
                    throw new ExchangeError (this.id + ' fromAccount parameter must be one of ' + keys.join (', '));
                }
                if (toId === undefined) {
                    const keys = Object.keys (accountsByType);
                    throw new ExchangeError (this.id + ' toAccount parameter must be one of ' + keys.join (', '));
                }
                type = fromId + '_' + toId;
            }
            const request = {
                'type': type,
            };
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['size'] = limit;
            }
            const response = await this.sapiGetAssetTransfer (this.extend (request, params));
            //
            //     {
            //         total: 3,
            //         rows: [
            //             {
            //                 timestamp: 1614640878000,
            //                 asset: 'USDT',
            //                 amount: '25',
            //                 type: 'MAIN_UMFUTURE',
            //                 status: 'CONFIRMED',
            //                 tranId: 43000126248
            //             },
            //         ]
            //     }
            //
            const rows = this.safeValue (response, 'rows', []);
            return this.parseTransfers (rows, currency, since, limit);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'coin': currency['id'],
                // 'network': 'ETH', // 'BSC', 'XMR', you can get network and isDefault in networkList in the response of sapiGetCapitalConfigDetail
            };
            // has support for the 'network' parameter
            // https://binance-docs.github.io/apidocs/spot/en/#deposit-address-supporting-network-user_data
            const response = await this.sapiGetCapitalDepositAddress (this.extend (request, params));
            //
            //     {
            //         currency: 'XRP',
            //         address: 'rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh',
            //         tag: '108618262',
            //         info: {
            //             coin: 'XRP',
            //             address: 'rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh',
            //             tag: '108618262',
            //             url: 'https://bithomp.com/explorer/rEb8TK3gBgk5auZkwc6sHnwrGVJH8DuaLh'
            //         }
            //     }
            //
            const address = this.safeString (response, 'address');
            const tag = this.safeString (response, 'tag');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async fetchFundingFees (codes = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.sapiGetCapitalConfigGetall (params);
            //
            //  [
            //     {
            //       coin: 'BAT',
            //       depositAllEnable: true,
            //       withdrawAllEnable: true,
            //       name: 'Basic Attention Token',
            //       free: '0',
            //       locked: '0',
            //       freeze: '0',
            //       withdrawing: '0',
            //       ipoing: '0',
            //       ipoable: '0',
            //       storage: '0',
            //       isLegalMoney: false,
            //       trading: true,
            //       networkList: [
            //         {
            //           network: 'BNB',
            //           coin: 'BAT',
            //           withdrawIntegerMultiple: '0.00000001',
            //           isDefault: false,
            //           depositEnable: true,
            //           withdrawEnable: true,
            //           depositDesc: '',
            //           withdrawDesc: '',
            //           specialTips: 'The name of this asset is Basic Attention Token (BAT). Both a MEMO and an Address are required to successfully deposit your BEP2 tokens to Binance.',
            //           name: 'BEP2',
            //           resetAddressStatus: false,
            //           addressRegex: '^(bnb1)[0-9a-z]{38}$',
            //           memoRegex: '^[0-9A-Za-z\\-_]{1,120}$',
            //           withdrawFee: '0.27',
            //           withdrawMin: '0.54',
            //           withdrawMax: '10000000000',
            //           minConfirm: '1',
            //           unLockConfirm: '0'
            //         },
            //         {
            //           network: 'BSC',
            //           coin: 'BAT',
            //           withdrawIntegerMultiple: '0.00000001',
            //           isDefault: false,
            //           depositEnable: true,
            //           withdrawEnable: true,
            //           depositDesc: '',
            //           withdrawDesc: '',
            //           specialTips: 'The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 9766e.',
            //           name: 'BEP20 (BSC)',
            //           resetAddressStatus: false,
            //           addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
            //           memoRegex: '',
            //           withdrawFee: '0.27',
            //           withdrawMin: '0.54',
            //           withdrawMax: '10000000000',
            //           minConfirm: '15',
            //           unLockConfirm: '0'
            //         },
            //         {
            //           network: 'ETH',
            //           coin: 'BAT',
            //           withdrawIntegerMultiple: '0.00000001',
            //           isDefault: true,
            //           depositEnable: true,
            //           withdrawEnable: true,
            //           depositDesc: '',
            //           withdrawDesc: '',
            //           specialTips: 'The name of this asset is Basic Attention Token. Please ensure you are depositing Basic Attention Token (BAT) tokens under the contract address ending in 887ef.',
            //           name: 'ERC20',
            //           resetAddressStatus: false,
            //           addressRegex: '^(0x)[0-9A-Fa-f]{40}$',
            //           memoRegex: '',
            //           withdrawFee: '27',
            //           withdrawMin: '54',
            //           withdrawMax: '10000000000',
            //           minConfirm: '12',
            //           unLockConfirm: '0'
            //         }
            //       ]
            //     }
            //  ]
            //
            const withdrawFees = {};
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const currencyId = this.safeString (entry, 'coin');
                const code = this.safeCurrencyCode (currencyId);
                const networkList = this.safeValue (entry, 'networkList');
                withdrawFees[code] = {};
                for (let j = 0; j < networkList.length; j++) {
                    const networkEntry = networkList[j];
                    const networkId = this.safeString (networkEntry, 'network');
                    const networkCode = this.safeCurrencyCode (networkId);
                    const fee = this.safeNumber (networkEntry, 'withdrawFee');
                    withdrawFees[code][networkCode] = fee;
                }
            }
            return {
                'withdraw': withdrawFees,
                'deposit': {},
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'coin': currency['id'],
                'address': address,
                'amount': amount,
                // https://binance-docs.github.io/apidocs/spot/en/#withdraw-sapi
                // issue sapiGetCapitalConfigGetall () to get networks for withdrawing USDT ERC20 vs USDT Omni
                // 'network': 'ETH', // 'BTC', 'TRX', etc, optional
            };
            if (tag !== undefined) {
                request['addressTag'] = tag;
            }
            const response = await this.sapiPostCapitalWithdrawApply (this.extend (request, params));
            //     { id: '9a67628b16ba4988ae20d329333f16bc' }
            return {
                'info': response,
                'id': this.safeString (response, 'id'),
            };
        }
    
        parseTradingFee (fee, market = undefined) {
            //
            //     {
            //         "symbol": "ADABNB",
            //         "makerCommission": 0.001,
            //         "takerCommission": 0.001
            //     }
            //
            const marketId = this.safeString (fee, 'symbol');
            const symbol = this.safeSymbol (marketId);
            return {
                'info': fee,
                'symbol': symbol,
                'maker': this.safeNumber (fee, 'makerCommission'),
                'taker': this.safeNumber (fee, 'takerCommission'),
            };
        }
    
        async fetchTradingFee (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.sapiGetAssetTradeFee (this.extend (request, params));
            //
            //     [
            //       {
            //         "symbol": "BTCUSDT",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       }
            //     ]
            //
            const first = this.safeValue (response, 0, {});
            return this.parseTradingFee (first);
        }
    
        async fetchTradingFees (params = {}) {
            await this.loadMarkets ();
            let method = undefined;
            const defaultType = this.safeString2 (this.options, 'fetchFundingRates', 'defaultType', 'future');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            if ((type === 'spot') || (type === 'margin')) {
                method = 'sapiGetAssetTradeFee';
            } else if (type === 'future') {
                method = 'fapiPrivateGetAccount';
            } else if (type === 'delivery') {
                method = 'dapiPrivateGetAccount';
            }
            const response = await this[method] (query);
            //
            // sapi / spot
            //
            //    [
            //       {
            //         "symbol": "ZRXBNB",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //       {
            //         "symbol": "ZRXBTC",
            //         "makerCommission": "0.001",
            //         "takerCommission": "0.001"
            //       },
            //    ]
            //
            // fapi / future / linear
            //
            //     {
            //         "feeTier": 0,       // account commisssion tier
            //         "canTrade": true,   // if can trade
            //         "canDeposit": true,     // if can transfer in asset
            //         "canWithdraw": true,    // if can transfer out asset
            //         "updateTime": 0,
            //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
            //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
            //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
            //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
            //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
            //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
            //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
            //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
            //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
            //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
            //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
            //         ...
            //     }
            //
            // dapi / delivery / inverse
            //
            //     {
            //         "canDeposit": true,
            //         "canTrade": true,
            //         "canWithdraw": true,
            //         "feeTier": 2,
            //         "updateTime": 0
            //     }
            //
            if ((type === 'spot') || (type === 'margin')) {
                //
                //    [
                //       {
                //         "symbol": "ZRXBNB",
                //         "makerCommission": "0.001",
                //         "takerCommission": "0.001"
                //       },
                //       {
                //         "symbol": "ZRXBTC",
                //         "makerCommission": "0.001",
                //         "takerCommission": "0.001"
                //       },
                //    ]
                //
                const result = {};
                for (let i = 0; i < response.length; i++) {
                    const fee = this.parseTradingFee (response[i]);
                    const symbol = fee['symbol'];
                    result[symbol] = fee;
                }
                return result;
            } else if (type === 'future') {
                //
                //     {
                //         "feeTier": 0,       // account commisssion tier
                //         "canTrade": true,   // if can trade
                //         "canDeposit": true,     // if can transfer in asset
                //         "canWithdraw": true,    // if can transfer out asset
                //         "updateTime": 0,
                //         "totalInitialMargin": "0.00000000",    // total initial margin required with current mark price (useless with isolated positions), only for USDT asset
                //         "totalMaintMargin": "0.00000000",     // total maintenance margin required, only for USDT asset
                //         "totalWalletBalance": "23.72469206",     // total wallet balance, only for USDT asset
                //         "totalUnrealizedProfit": "0.00000000",   // total unrealized profit, only for USDT asset
                //         "totalMarginBalance": "23.72469206",     // total margin balance, only for USDT asset
                //         "totalPositionInitialMargin": "0.00000000",    // initial margin required for positions with current mark price, only for USDT asset
                //         "totalOpenOrderInitialMargin": "0.00000000",   // initial margin required for open orders with current mark price, only for USDT asset
                //         "totalCrossWalletBalance": "23.72469206",      // crossed wallet balance, only for USDT asset
                //         "totalCrossUnPnl": "0.00000000",      // unrealized profit of crossed positions, only for USDT asset
                //         "availableBalance": "23.72469206",       // available balance, only for USDT asset
                //         "maxWithdrawAmount": "23.72469206"     // maximum amount for transfer out, only for USDT asset
                //         ...
                //     }
                //
                const symbols = Object.keys (this.markets);
                const result = {};
                const feeTier = this.safeInteger (response, 'feeTier');
                const feeTiers = this.fees[type]['trading']['tiers'];
                const maker = feeTiers['maker'][feeTier][1];
                const taker = feeTiers['taker'][feeTier][1];
                for (let i = 0; i < symbols.length; i++) {
                    const symbol = symbols[i];
                    result[symbol] = {
                        'info': {
                            'feeTier': feeTier,
                        },
                        'symbol': symbol,
                        'maker': maker,
                        'taker': taker,
                    };
                }
                return result;
            } else if (type === 'delivery') {
                //
                //     {
                //         "canDeposit": true,
                //         "canTrade": true,
                //         "canWithdraw": true,
                //         "feeTier": 2,
                //         "updateTime": 0
                //     }
                //
                const symbols = Object.keys (this.markets);
                const result = {};
                const feeTier = this.safeInteger (response, 'feeTier');
                const feeTiers = this.fees[type]['trading']['tiers'];
                const maker = feeTiers['maker'][feeTier][1];
                const taker = feeTiers['taker'][feeTier][1];
                for (let i = 0; i < symbols.length; i++) {
                    const symbol = symbols[i];
                    result[symbol] = {
                        'info': {
                            'feeTier': feeTier,
                        },
                        'symbol': symbol,
                        'maker': maker,
                        'taker': taker,
                    };
                }
                return result;
            }
        }
    
        async futuresTransfer (code, amount, type, params = {}) {
            if ((type < 1) || (type > 4)) {
                throw new ArgumentsRequired (this.id + ' type must be between 1 and 4');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset': currency['id'],
                'amount': amount,
                'type': type,
            };
            const response = await this.sapiPostFuturesTransfer (this.extend (request, params));
            //
            //   {
            //       "tranId": 100000001
            //   }
            //
            return this.parseTransfer (response, currency);
        }
    
        async fetchFundingRate (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            if (market['linear']) {
                method = 'fapiPublicGetPremiumIndex';
            } else if (market['inverse']) {
                method = 'dapiPublicGetPremiumIndex';
            } else {
                throw NotSupported (this.id + ' setMarginMode() supports linear and inverse contracts only');
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "symbol": "BTCUSDT",
            //         "markPrice": "45802.81129892",
            //         "indexPrice": "45745.47701915",
            //         "estimatedSettlePrice": "45133.91753671",
            //         "lastFundingRate": "0.00063521",
            //         "interestRate": "0.00010000",
            //         "nextFundingTime": "1621267200000",
            //         "time": "1621252344001"
            //     }
            //
            return this.parseFundingRate (response);
        }
    
        async fetchFundingRates (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            let method = undefined;
            const defaultType = this.safeString2 (this.options, 'fetchFundingRates', 'defaultType', 'future');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            if (type === 'future') {
                method = 'fapiPublicGetPremiumIndex';
            } else if (type === 'delivery') {
                method = 'dapiPublicGetPremiumIndex';
            } else {
                throw NotSupported (this.id + ' setMarginMode() supports linear and inverse contracts only');
            }
            const response = await this[method] (query);
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const parsed = this.parseFundingRate (entry);
                result.push (parsed);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        parseFundingRate (premiumIndex, market = undefined) {
            // ensure it matches with https://www.binance.com/en/futures/funding-history/0
            //
            //   {
            //     "symbol": "BTCUSDT",
            //     "markPrice": "45802.81129892",
            //     "indexPrice": "45745.47701915",
            //     "estimatedSettlePrice": "45133.91753671",
            //     "lastFundingRate": "0.00063521",
            //     "interestRate": "0.00010000",
            //     "nextFundingTime": "1621267200000",
            //     "time": "1621252344001"
            //  }
            //
            const timestamp = this.safeInteger (premiumIndex, 'time');
            const marketId = this.safeString (premiumIndex, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const markPrice = this.safeNumber (premiumIndex, 'markPrice');
            const indexPrice = this.safeNumber (premiumIndex, 'indexPrice');
            const interestRate = this.safeNumber (premiumIndex, 'interestRate');
            // current funding rate
            const fundingRate = this.safeNumber (premiumIndex, 'lastFundingRate');
            const nextFundingTime = this.safeInteger (premiumIndex, 'nextFundingTime');
            return {
                'info': premiumIndex,
                'symbol': symbol,
                'markPrice': markPrice,
                'indexPrice': indexPrice,
                'interestRate': interestRate,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fundingRate': fundingRate,
                'nextFundingTimestamp': nextFundingTime,
                'nextFundingDatetime': this.iso8601 (nextFundingTime),
            };
        }
    
        parseAccountPositions (account) {
            const positions = this.safeValue (account, 'positions');
            const assets = this.safeValue (account, 'assets');
            const balances = {};
            for (let i = 0; i < assets.length; i++) {
                const entry = assets[i];
                const currencyId = this.safeString (entry, 'asset');
                const code = this.safeCurrencyCode (currencyId);
                const crossWalletBalance = this.safeString (entry, 'crossWalletBalance');
                const crossUnPnl = this.safeString (entry, 'crossUnPnl');
                balances[code] = {
                    'crossMargin': Precise.stringAdd (crossWalletBalance, crossUnPnl),
                    'crossWalletBalance': crossWalletBalance,
                };
            }
            const result = [];
            for (let i = 0; i < positions.length; i++) {
                const position = positions[i];
                const marketId = this.safeString (position, 'symbol');
                const market = this.safeMarket (marketId);
                const code = (this.options['defaultType'] === 'future') ? market['quote'] : market['base'];
                const parsed = this.parsePosition (this.extend (position, {
                    'crossMargin': balances[code]['crossMargin'],
                    'crossWalletBalance': balances[code]['crossWalletBalance'],
                }), market);
                result.push (parsed);
            }
            return result;
        }
    
        parsePosition (position, market = undefined) {
            //
            // usdm
            //    {
            //       "symbol": "BTCBUSD",
            //       "initialMargin": "0",
            //       "maintMargin": "0",
            //       "unrealizedProfit": "0.00000000",
            //       "positionInitialMargin": "0",
            //       "openOrderInitialMargin": "0",
            //       "leverage": "20",
            //       "isolated": false,
            //       "entryPrice": "0.0000",
            //       "maxNotional": "100000",
            //       "positionSide": "BOTH",
            //       "positionAmt": "0.000",
            //       "notional": "0",
            //       "isolatedWallet": "0",
            //       "updateTime": "0",
            //       "crossMargin": "100.93634809",
            //     }
            //
            // coinm
            //     {
            //       "symbol": "BTCUSD_210625",
            //       "initialMargin": "0.00024393",
            //       "maintMargin": "0.00002439",
            //       "unrealizedProfit": "-0.00000163",
            //       "positionInitialMargin": "0.00024393",
            //       "openOrderInitialMargin": "0",
            //       "leverage": "10",
            //       "isolated": false,
            //       "positionSide": "BOTH",
            //       "entryPrice": "41021.20000069",
            //       "maxQty": "100",
            //       "notionalValue": "0.00243939",
            //       "isolatedWallet": "0",
            //       "crossMargin": "0.314"
            //       "crossWalletBalance": "34",
            //     }
            //
            const marketId = this.safeString (position, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = market['symbol'];
            const leverageString = this.safeString (position, 'leverage');
            const leverage = parseInt (leverageString);
            const initialMarginString = this.safeString (position, 'initialMargin');
            const initialMargin = this.parseNumber (initialMarginString);
            let initialMarginPercentageString = Precise.stringDiv ('1', leverageString, 8);
            const rational = (1000 % leverage) === 0;
            if (!rational) {
                initialMarginPercentageString = Precise.stringDiv (Precise.stringAdd (initialMarginPercentageString, '1e-8'), '1', 8);
            }
            const usdm = ('notional' in position);
            const maintenanceMarginString = this.safeString (position, 'maintMargin');
            const maintenanceMargin = this.parseNumber (maintenanceMarginString);
            const entryPriceString = this.safeString (position, 'entryPrice');
            let entryPrice = this.parseNumber (entryPriceString);
            const notionalString = this.safeString2 (position, 'notional', 'notionalValue');
            const notionalStringAbs = Precise.stringAbs (notionalString);
            const notionalFloat = parseFloat (notionalString);
            const notionalFloatAbs = parseFloat (notionalStringAbs);
            const notional = this.parseNumber (Precise.stringAbs (notionalString));
            let contractsString = this.safeString (position, 'positionAmt');
            let contractsStringAbs = Precise.stringAbs (contractsString);
            if (contractsString === undefined) {
                const entryNotional = Precise.stringMul (Precise.stringMul (leverageString, initialMarginString), entryPriceString);
                contractsString = Precise.stringDiv (entryNotional, market['contractSize']);
                contractsStringAbs = Precise.stringDiv (Precise.stringAdd (contractsString, '0.5'), '1', 0);
            }
            const contracts = this.parseNumber (contractsStringAbs);
            const leverageBrackets = this.safeValue (this.options, 'leverageBrackets', {});
            const leverageBracket = this.safeValue (leverageBrackets, symbol, []);
            let maintenanceMarginPercentageString = undefined;
            for (let i = 0; i < leverageBracket.length; i++) {
                const bracket = leverageBracket[i];
                if (notionalFloatAbs < bracket[0]) {
                    break;
                }
                maintenanceMarginPercentageString = bracket[1];
            }
            const maintenanceMarginPercentage = this.parseNumber (maintenanceMarginPercentageString);
            const unrealizedPnlString = this.safeString (position, 'unrealizedProfit');
            const unrealizedPnl = this.parseNumber (unrealizedPnlString);
            let timestamp = this.safeInteger (position, 'updateTime');
            if (timestamp === 0) {
                timestamp = undefined;
            }
            const isolated = this.safeValue (position, 'isolated');
            let marginType = undefined;
            let collateralString = undefined;
            let walletBalance = undefined;
            if (isolated) {
                marginType = 'isolated';
                walletBalance = this.safeString (position, 'isolatedWallet');
                collateralString = Precise.stringAdd (walletBalance, unrealizedPnlString);
            } else {
                marginType = 'cross';
                walletBalance = this.safeString (position, 'crossWalletBalance');
                collateralString = this.safeString (position, 'crossMargin');
            }
            const collateral = this.parseNumber (collateralString);
            let marginRatio = undefined;
            let side = undefined;
            let percentage = undefined;
            let liquidationPriceStringRaw = undefined;
            let liquidationPrice = undefined;
            if (notionalFloat === 0.0) {
                entryPrice = undefined;
            } else {
                side = (notionalFloat < 0) ? 'short' : 'long';
                marginRatio = this.parseNumber (Precise.stringDiv (maintenanceMarginString, collateralString, 4));
                percentage = this.parseNumber (Precise.stringMul (Precise.stringDiv (unrealizedPnlString, initialMarginString, 4), '100'));
                if (usdm) {
                    // calculate liquidation price
                    //
                    // liquidationPrice = (walletBalance / (contracts * (±1 + mmp))) (±entryPrice / (±1 + mmp))
                    //
                    // mmp = maintenanceMarginPercentage
                    // where ± is negative for long and positive for short
                    // TODO: calculate liquidation price for coinm contracts
                    let onePlusMaintenanceMarginPercentageString = undefined;
                    let entryPriceSignString = entryPriceString;
                    if (side === 'short') {
                        onePlusMaintenanceMarginPercentageString = Precise.stringAdd ('1', maintenanceMarginPercentageString);
                    } else {
                        onePlusMaintenanceMarginPercentageString = Precise.stringAdd ('-1', maintenanceMarginPercentageString);
                        entryPriceSignString = Precise.stringMul ('-1', entryPriceSignString);
                    }
                    const leftSide = Precise.stringDiv (walletBalance, Precise.stringMul (contractsStringAbs, onePlusMaintenanceMarginPercentageString));
                    const rightSide = Precise.stringDiv (entryPriceSignString, onePlusMaintenanceMarginPercentageString);
                    liquidationPriceStringRaw = Precise.stringAdd (leftSide, rightSide);
                } else {
                    // calculate liquidation price
                    //
                    // liquidationPrice = (contracts * contractSize(±1 - mmp)) / (±1/entryPrice * contracts * contractSize - walletBalance)
                    //
                    let onePlusMaintenanceMarginPercentageString = undefined;
                    let entryPriceSignString = entryPriceString;
                    if (side === 'short') {
                        onePlusMaintenanceMarginPercentageString = Precise.stringSub ('1', maintenanceMarginPercentageString);
                    } else {
                        onePlusMaintenanceMarginPercentageString = Precise.stringSub ('-1', maintenanceMarginPercentageString);
                        entryPriceSignString = Precise.stringMul ('-1', entryPriceSignString);
                    }
                    const size = Precise.stringMul (contractsStringAbs, market['contractSize']);
                    const leftSide = Precise.stringMul (size, onePlusMaintenanceMarginPercentageString);
                    const rightSide = Precise.stringSub (Precise.stringMul (Precise.stringDiv ('1', entryPriceSignString), size), walletBalance);
                    liquidationPriceStringRaw = Precise.stringDiv (leftSide, rightSide);
                }
                const pricePrecision = market['precision']['price'];
                const pricePrecisionPlusOne = pricePrecision + 1;
                const pricePrecisionPlusOneString = pricePrecisionPlusOne.toString ();
                // round half up
                const rounder = new Precise ('5e-' + pricePrecisionPlusOneString);
                const rounderString = rounder.toString ();
                const liquidationPriceRoundedString = Precise.stringAdd (rounderString, liquidationPriceStringRaw);
                let truncatedLiquidationPrice = Precise.stringDiv (liquidationPriceRoundedString, '1', pricePrecision);
                if (truncatedLiquidationPrice[0] === '-') {
                    // user cannot be liquidated
                    // since he has more collateral than the size of the position
                    truncatedLiquidationPrice = undefined;
                }
                liquidationPrice = this.parseNumber (truncatedLiquidationPrice);
            }
            return {
                'info': position,
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'initialMargin': initialMargin,
                'initialMarginPercentage': this.parseNumber (initialMarginPercentageString),
                'maintenanceMargin': maintenanceMargin,
                'maintenanceMarginPercentage': maintenanceMarginPercentage,
                'entryPrice': entryPrice,
                'notional': notional,
                'leverage': leverage,
                'unrealizedPnl': unrealizedPnl,
                'contracts': contracts,
                'contractSize': this.parseNumber (market['contractSize']),
                'marginRatio': marginRatio,
                'liquidationPrice': liquidationPrice,
                'markPrice': undefined,
                'collateral': collateral,
                'marginType': marginType,
                'side': side,
                'percentage': percentage,
            };
        }
    
        parsePositionRisk (position, market = undefined) {
            //
            // usdm
            //     {
            //       "symbol": "BTCUSDT",
            //       "positionAmt": "0.001",
            //       "entryPrice": "43578.07000",
            //       "markPrice": "43532.30000000",
            //       "unRealizedProfit": "-0.04577000",
            //       "liquidationPrice": "21841.24993976",
            //       "leverage": "2",
            //       "maxNotionalValue": "300000000",
            //       "marginType": "isolated",
            //       "isolatedMargin": "21.77841506",
            //       "isAutoAddMargin": "false",
            //       "positionSide": "BOTH",
            //       "notional": "43.53230000",
            //       "isolatedWallet": "21.82418506",
            //       "updateTime": "1621358023886"
            //     }
            //
            // coinm
            //     {
            //       "symbol": "BTCUSD_PERP",
            //       "positionAmt": "2",
            //       "entryPrice": "37643.10000021",
            //       "markPrice": "38103.05510455",
            //       "unRealizedProfit": "0.00006413",
            //       "liquidationPrice": "25119.97445760",
            //       "leverage": "2",
            //       "maxQty": "1500",
            //       "marginType": "isolated",
            //       "isolatedMargin": "0.00274471",
            //       "isAutoAddMargin": "false",
            //       "positionSide": "BOTH",
            //       "notionalValue": "0.00524892",
            //       "isolatedWallet": "0.00268058"
            //     }
            //
            const marketId = this.safeString (position, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = market['symbol'];
            const leverageBrackets = this.safeValue (this.options, 'leverageBrackets', {});
            const leverageBracket = this.safeValue (leverageBrackets, symbol, []);
            const notionalString = this.safeString2 (position, 'notional', 'notionalValue');
            const notionalStringAbs = Precise.stringAbs (notionalString);
            const notionalFloatAbs = parseFloat (notionalStringAbs);
            const notionalFloat = parseFloat (notionalString);
            let maintenanceMarginPercentageString = undefined;
            for (let i = 0; i < leverageBracket.length; i++) {
                const bracket = leverageBracket[i];
                if (notionalFloatAbs < bracket[0]) {
                    break;
                }
                maintenanceMarginPercentageString = bracket[1];
            }
            const notional = this.parseNumber (notionalStringAbs);
            const contractsAbs = Precise.stringAbs (this.safeString (position, 'positionAmt'));
            const contracts = this.parseNumber (contractsAbs);
            const unrealizedPnlString = this.safeString (position, 'unRealizedProfit');
            const unrealizedPnl = this.parseNumber (unrealizedPnlString);
            const leverageString = this.safeString (position, 'leverage');
            const leverage = parseInt (leverageString);
            let liquidationPrice = this.safeNumber (position, 'liquidationPrice');
            const collateralString = this.safeString (position, 'isolatedMargin');
            const collateralFloat = parseFloat (collateralString);
            const collateral = this.parseNumber (collateralString);
            const markPriceString = this.safeString (position, 'markPrice');
            const markPriceFloat = parseFloat (markPriceString);
            let markPrice = undefined;
            if (markPriceFloat !== 0.0) {
                markPrice = this.parseNumber (markPriceString);
            }
            const entryPrice = this.safeNumber (position, 'entryPrice');
            const timestamp = this.safeInteger (position, 'updateTime');
            const maintenanceMarginPercentage = this.parseNumber (maintenanceMarginPercentageString);
            const maintenanceMarginString = Precise.stringMul (maintenanceMarginPercentageString, notionalStringAbs);
            const maintenanceMargin = this.parseNumber (maintenanceMarginString);
            let initialMarginPercentageString = Precise.stringDiv ('1', leverageString, 8);
            const rational = (1000 % leverage) === 0;
            if (!rational) {
                initialMarginPercentageString = Precise.stringAdd (initialMarginPercentageString, '1e-8');
            }
            const initialMarginString = Precise.stringDiv (Precise.stringMul (notionalStringAbs, initialMarginPercentageString), '1', 8);
            const initialMargin = this.parseNumber (initialMarginString);
            let marginRatio = undefined;
            let side = undefined;
            let percentage = undefined;
            if (collateralFloat === 0.0) {
                liquidationPrice = undefined;
            } else {
                marginRatio = this.parseNumber (Precise.stringDiv (maintenanceMarginString, collateralString, 4));
                side = (notionalFloat < 0) ? 'short' : 'long';
                percentage = this.parseNumber (Precise.stringMul (Precise.stringDiv (unrealizedPnlString, initialMarginString, 4), '100'));
            }
            const marginType = this.safeString (position, 'marginType');
            if (marginType === 'cross') {
                liquidationPrice = undefined;
            }
            return {
                'info': position,
                'symbol': symbol,
                'contracts': contracts,
                'unrealizedPnl': unrealizedPnl,
                'leverage': leverage,
                'liquidationPrice': liquidationPrice,
                'collateral': collateral,
                'notional': notional,
                'markPrice': markPrice,
                'entryPrice': entryPrice,
                'timestamp': timestamp,
                'initialMargin': initialMargin,
                'initialMarginPercentage': this.parseNumber (initialMarginPercentageString),
                'maintenanceMargin': maintenanceMargin,
                'maintenanceMarginPercentage': maintenanceMarginPercentage,
                'marginRatio': marginRatio,
                'datetime': this.iso8601 (timestamp),
                'marginType': marginType,
                'side': side,
                'percentage': percentage,
            };
        }
    
        async loadLeverageBrackets (reload = false, params = {}) {
            await this.loadMarkets ();
            // by default cache the leverage bracket
            // it contains useful stuff like the maintenance margin and initial margin for positions
            const leverageBrackets = this.safeValue (this.options, 'leverageBrackets');
            if ((leverageBrackets === undefined) || (reload)) {
                let method = undefined;
                const defaultType = this.safeString2 (this.options, 'fetchPositions', 'defaultType', 'future');
                const type = this.safeString (params, 'type', defaultType);
                const query = this.omit (params, 'type');
                if (type === 'future') {
                    method = 'fapiPrivateGetLeverageBracket';
                } else if (type === 'delivery') {
                    method = 'dapiPrivateV2GetLeverageBracket';
                } else {
                    throw new NotSupported (this.id + ' loadLeverageBrackets() supports linear and inverse contracts only');
                }
                const response = await this[method] (query);
                this.options['leverageBrackets'] = {};
                for (let i = 0; i < response.length; i++) {
                    const entry = response[i];
                    const marketId = this.safeString (entry, 'symbol');
                    const symbol = this.safeSymbol (marketId);
                    const brackets = this.safeValue (entry, 'brackets');
                    const result = [];
                    for (let j = 0; j < brackets.length; j++) {
                        const bracket = brackets[j];
                        // we use floats here internally on purpose
                        const floorValue = this.safeFloat2 (bracket, 'notionalFloor', 'qtyFloor');
                        const maintenanceMarginPercentage = this.safeString (bracket, 'maintMarginRatio');
                        result.push ([ floorValue, maintenanceMarginPercentage ]);
                    }
                    this.options['leverageBrackets'][symbol] = result;
                }
            }
            return this.options['leverageBrackets'];
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadLeverageBrackets ();
            let method = undefined;
            const defaultType = this.safeString2 (this.options, 'fetchPositions', 'defaultType', 'future');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            if (type === 'future') {
                method = 'fapiPrivateGetAccount';
            } else if (type === 'delivery') {
                method = 'dapiPrivateGetAccount';
            } else {
                throw new NotSupported (this.id + ' fetchPositions() supports linear and inverse contracts only');
            }
            const account = await this[method] (query);
            const result = this.parseAccountPositions (account);
            return this.filterByArray (result, 'symbol', symbols, false);
        }
    
        async fetchIsolatedPositions (symbol = undefined, params = {}) {
            // only supported in usdm futures
            await this.loadMarkets ();
            await this.loadLeverageBrackets ();
            const request = {};
            let market = undefined;
            let method = undefined;
            let defaultType = 'future';
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                if (market['linear']) {
                    defaultType = 'future';
                } else if (market['inverse']) {
                    defaultType = 'delivery';
                } else {
                    throw NotSupported (this.id + ' fetchIsolatedPositions() supports linear and inverse contracts only');
                }
            }
            defaultType = this.safeString2 (this.options, 'fetchIsolatedPositions', 'defaultType', defaultType);
            const type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            if ((type === 'future') || (type === 'linear')) {
                method = 'fapiPrivateGetPositionRisk';
            } else if ((type === 'delivery') || (type === 'inverse')) {
                method = 'dapiPrivateGetPositionRisk';
            } else {
                throw NotSupported (this.id + ' fetchIsolatedPositions() supports linear and inverse contracts only');
            }
            const response = await this[method] (this.extend (request, params));
            if (symbol === undefined) {
                const result = [];
                for (let i = 0; i < response.length; i++) {
                    const parsed = this.parsePositionRisk (response[i], market);
                    if (parsed['marginType'] === 'isolated') {
                        result.push (parsed);
                    }
                }
                return result;
            } else {
                return this.parsePositionRisk (this.safeValue (response, 0), market);
            }
        }
    
        async fetchFundingHistory (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            let method = undefined;
            let defaultType = 'future';
            const request = {
                'incomeType': 'FUNDING_FEE', // "TRANSFER"，"WELCOME_BONUS", "REALIZED_PNL"，"FUNDING_FEE", "COMMISSION" and "INSURANCE_CLEAR"
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                if (market['linear']) {
                    defaultType = 'future';
                } else if (market['inverse']) {
                    defaultType = 'delivery';
                } else {
                    throw NotSupported (this.id + ' fetchFundingHistory() supports linear and inverse contracts only');
                }
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            defaultType = this.safeString2 (this.options, 'fetchFundingHistory', 'defaultType', defaultType);
            const type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            if ((type === 'future') || (type === 'linear')) {
                method = 'fapiPrivateGetIncome';
            } else if ((type === 'delivery') || (type === 'inverse')) {
                method = 'dapiPrivateGetIncome';
            } else {
                throw NotSupported (this.id + ' fetchFundingHistory() supports linear and inverse contracts only');
            }
            const response = await this[method] (this.extend (request, params));
            return this.parseIncomes (response, market, since, limit);
        }
    
        async setLeverage (leverage, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' setLeverage() requires a symbol argument');
            }
            // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
            // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
            if ((leverage < 1) || (leverage > 125)) {
                throw new BadRequest (this.id + ' leverage should be between 1 and 125');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            let method = undefined;
            if (market['linear']) {
                method = 'fapiPrivatePostLeverage';
            } else if (market['inverse']) {
                method = 'dapiPrivatePostLeverage';
            } else {
                throw NotSupported (this.id + ' setLeverage() supports linear and inverse contracts only');
            }
            const request = {
                'symbol': market['id'],
                'leverage': leverage,
            };
            return await this[method] (this.extend (request, params));
        }
    
        async setMarginMode (symbol, marginType, params = {}) {
            //
            // { "code": -4048 , "msg": "Margin type cannot be changed if there exists position." }
            //
            // or
            //
            // { "code": 200, "msg": "success" }
            //
            marginType = marginType.toUpperCase ();
            if ((marginType !== 'ISOLATED') && (marginType !== 'CROSSED')) {
                throw new BadRequest (this.id + ' marginType must be either isolated or crossed');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            let method = undefined;
            if (market['linear']) {
                method = 'fapiPrivatePostMarginType';
            } else if (market['inverse']) {
                method = 'dapiPrivatePostMarginType';
            } else {
                throw NotSupported (this.id + ' setMarginMode() supports linear and inverse contracts only');
            }
            const request = {
                'symbol': market['id'],
                'marginType': marginType,
            };
            return await this[method] (this.extend (request, params));
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            if (!(api in this.urls['api'])) {
                throw new NotSupported (this.id + ' does not have a testnet/sandbox URL for ' + api + ' endpoints');
            }
            let url = this.urls['api'][api];
            url += '/' + path;
            if (api === 'wapi') {
                url += '.html';
            }
            if (path === 'historicalTrades') {
                if (this.apiKey) {
                    headers = {
                        'X-MBX-APIKEY': this.apiKey,
                    };
                } else {
                    throw new AuthenticationError (this.id + ' historicalTrades endpoint requires `apiKey` credential');
                }
            }
            const userDataStream = (path === 'userDataStream') || (path === 'listenKey');
            if (userDataStream) {
                if (this.apiKey) {
                    // v1 special case for userDataStream
                    headers = {
                        'X-MBX-APIKEY': this.apiKey,
                        'Content-Type': 'application/x-www-form-urlencoded',
                    };
                    if (method !== 'GET') {
                        body = this.urlencode (params);
                    }
                } else {
                    throw new AuthenticationError (this.id + ' userDataStream endpoint requires `apiKey` credential');
                }
            } else if ((api === 'private') || (api === 'sapi') || (api === 'wapi' && path !== 'systemStatus') || (api === 'dapiPrivate') || (api === 'dapiPrivateV2') || (api === 'fapiPrivate') || (api === 'fapiPrivateV2')) {
                this.checkRequiredCredentials ();
                let query = undefined;
                const recvWindow = this.safeInteger (this.options, 'recvWindow', 5000);
                if ((api === 'sapi') && (path === 'asset/dust')) {
                    query = this.urlencodeWithArrayRepeat (this.extend ({
                        'timestamp': this.nonce (),
                        'recvWindow': recvWindow,
                    }, params));
                } else if ((path === 'batchOrders') || (path.indexOf ('sub-account') >= 0)) {
                    query = this.rawencode (this.extend ({
                        'timestamp': this.nonce (),
                        'recvWindow': recvWindow,
                    }, params));
                } else {
                    query = this.urlencode (this.extend ({
                        'timestamp': this.nonce (),
                        'recvWindow': recvWindow,
                    }, params));
                }
                const signature = this.hmac (this.encode (query), this.encode (this.secret));
                query += '&' + 'signature=' + signature;
                headers = {
                    'X-MBX-APIKEY': this.apiKey,
                };
                if ((method === 'GET') || (method === 'DELETE') || (api === 'wapi')) {
                    url += '?' + query;
                } else {
                    body = query;
                    headers['Content-Type'] = 'application/x-www-form-urlencoded';
                }
            } else {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if ((code === 418) || (code === 429)) {
                throw new DDoSProtection (this.id + ' ' + code.toString () + ' ' + reason + ' ' + body);
            }
            // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
            // following block cointains legacy checks against message patterns in "msg" property
            // will switch "code" checks eventually, when we know all of them
            if (code >= 400) {
                if (body.indexOf ('Price * QTY is zero or less') >= 0) {
                    throw new InvalidOrder (this.id + ' order cost = amount * price is zero or less ' + body);
                }
                if (body.indexOf ('LOT_SIZE') >= 0) {
                    throw new InvalidOrder (this.id + ' order amount should be evenly divisible by lot size ' + body);
                }
                if (body.indexOf ('PRICE_FILTER') >= 0) {
                    throw new InvalidOrder (this.id + ' order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) ' + body);
                }
            }
            if (response === undefined) {
                return; // fallback to default error handler
            }
            // check success value for wapi endpoints
            // response in format {'msg': 'The coin does not exist.', 'success': true/false}
            const success = this.safeValue (response, 'success', true);
            if (!success) {
                const message = this.safeString (response, 'msg');
                let parsedMessage = undefined;
                if (message !== undefined) {
                    try {
                        parsedMessage = JSON.parse (message);
                    } catch (e) {
                        // do nothing
                        parsedMessage = undefined;
                    }
                    if (parsedMessage !== undefined) {
                        response = parsedMessage;
                    }
                }
            }
            const message = this.safeString (response, 'msg');
            if (message !== undefined) {
                this.throwExactlyMatchedException (this.exceptions['exact'], message, this.id + ' ' + message);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, this.id + ' ' + message);
            }
            // checks against error codes
            const error = this.safeString (response, 'code');
            if (error !== undefined) {
                // https://github.com/ccxt/ccxt/issues/6501
                // https://github.com/ccxt/ccxt/issues/7742
                if ((error === '200') || Precise.stringEquals (error, '0')) {
                    return;
                }
                // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
                // despite that their message is very confusing, it is raised by Binance
                // on a temporary ban, the API key is valid, but disabled for a while
                if ((error === '-2015') && this.options['hasAlreadyAuthenticatedSuccessfully']) {
                    throw new DDoSProtection (this.id + ' temporary banned: ' + body);
                }
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], error, feedback);
                throw new ExchangeError (feedback);
            }
            if (!success) {
                throw new ExchangeError (this.id + ' ' + body);
            }
        }
    
        calculateRateLimiterCost (api, method, path, params, config = {}, context = {}) {
            if (('noSymbol' in config) && !('symbol' in params)) {
                return config['noSymbol'];
            } else if (('noPoolId' in config) && !('poolId' in params)) {
                return config['noPoolId'];
            } else if (('byLimit' in config) && ('limit' in params)) {
                const limit = params['limit'];
                const byLimit = config['byLimit'];
                for (let i = 0; i < byLimit.length; i++) {
                    const entry = byLimit[i];
                    if (limit <= entry[0]) {
                        return entry[1];
                    }
                }
            }
            return this.safeInteger (config, 'cost', 1);
        }
    
        async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined, config = {}, context = {}) {
            const response = await this.fetch2 (path, api, method, params, headers, body, config, context);
            // a workaround for {"code":-2015,"msg":"Invalid API-key, IP, or permissions for action."}
            if ((api === 'private') || (api === 'wapi')) {
                this.options['hasAlreadyAuthenticatedSuccessfully'] = true;
            }
            return response;
        }
    
        async modifyMarginHelper (symbol, amount, addOrReduce, params = {}) {
            // used to modify isolated positions
            let defaultType = this.safeString (this.options, 'defaultType', 'future');
            if (defaultType === 'spot') {
                defaultType = 'future';
            }
            const type = this.safeString (params, 'type', defaultType);
            if ((type === 'margin') || (type === 'spot')) {
                throw new NotSupported (this.id + ' add / reduce margin only supported with type future or delivery');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'type': addOrReduce,
                'symbol': market['id'],
                'amount': amount,
            };
            let method = undefined;
            let code = undefined;
            if (type === 'future') {
                method = 'fapiPrivatePostPositionMargin';
                code = market['quote'];
            } else {
                method = 'dapiPrivatePostPositionMargin';
                code = market['base'];
            }
            const response = await this[method] (this.extend (request, params));
            const rawType = this.safeInteger (response, 'type');
            const resultType = (rawType === 1) ? 'add' : 'reduce';
            const resultAmount = this.safeNumber (response, 'amount');
            const errorCode = this.safeString (response, 'code');
            const status = (errorCode === '200') ? 'ok' : 'failed';
            return {
                'info': response,
                'type': resultType,
                'amount': resultAmount,
                'code': code,
                'symbol': market['symbol'],
                'status': status,
            };
        }
    
        async reduceMargin (symbol, amount, params = {}) {
            return await this.modifyMarginHelper (symbol, amount, 2, params);
        }
    
        async addMargin (symbol, amount, params = {}) {
            return await this.modifyMarginHelper (symbol, amount, 1, params);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],25:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const binance = require ('./binance.js');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class binancecoinm extends binance {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'binancecoinm',
                'name': 'Binance COIN-M',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg',
                    'doc': [
                        'https://binance-docs.github.io/apidocs/delivery/en/',
                        'https://binance-docs.github.io/apidocs/spot/en',
                    ],
                },
                'options': {
                    'defaultType': 'delivery',
                    'leverageBrackets': undefined,
                },
            });
        }
    
        async transferIn (code, amount, params = {}) {
            // transfer from spot wallet to coinm futures wallet
            return await this.futuresTransfer (code, amount, 3, params);
        }
    
        async transferOut (code, amount, params = {}) {
            // transfer from coinm futures wallet to spot wallet
            return await this.futuresTransfer (code, amount, 4, params);
        }
    };
    
    },{"./binance.js":24}],26:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const binance = require ('./binance.js');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class binanceus extends binance {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'binanceus',
                'name': 'Binance US',
                'countries': [ 'US' ], // US
                'certified': false,
                'pro': true,
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/65177307-217b7c80-da5f-11e9-876e-0b748ba0a358.jpg',
                    'api': {
                        'web': 'https://www.binance.us',
                        'sapi': 'https://api.binance.us/sapi/v1',
                        'wapi': 'https://api.binance.us/wapi/v3',
                        'public': 'https://api.binance.us/api/v1',
                        'private': 'https://api.binance.us/api/v3',
                        'v3': 'https://api.binance.us/api/v3',
                        'v1': 'https://api.binance.us/api/v1',
                    },
                    'www': 'https://www.binance.us',
                    'referral': 'https://www.binance.us/?ref=35005074',
                    'doc': 'https://github.com/binance-us/binance-official-api-docs',
                    'fees': 'https://www.binance.us/en/fee/schedule',
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': this.parseNumber ('0.001'), // 0.1% trading fee, zero fees for all trading pairs before November 1
                        'maker': this.parseNumber ('0.001'), // 0.1% trading fee, zero fees for all trading pairs before November 1
                    },
                },
                'options': {
                    'quoteOrderQty': false,
                },
            });
        }
    
        async fetchCurrencies (params = {}) {
            return undefined;
        }
    };
    
    
    },{"./binance.js":24}],27:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const binance = require ('./binance.js');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class binanceusdm extends binance {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'binanceusdm',
                'name': 'Binance USDⓈ-M',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/117738721-668c8d80-b205-11eb-8c49-3fad84c4a07f.jpg',
                    'doc': [
                        'https://binance-docs.github.io/apidocs/futures/en/',
                        'https://binance-docs.github.io/apidocs/spot/en',
                    ],
                },
                'options': {
                    'defaultType': 'future',
                    // https://www.binance.com/en/support/faq/360033162192
                    // tier amount, maintenance margin, initial margin
                    'leverageBrackets': undefined,
                    'marginTypes': {},
                },
            });
        }
    
        async transferIn (code, amount, params = {}) {
            // transfer from spot wallet to usdm futures wallet
            return await this.futuresTransfer (code, amount, 1, params);
        }
    
        async transferOut (code, amount, params = {}) {
            // transfer from usdm futures wallet to spot wallet
            return await this.futuresTransfer (code, amount, 2, params);
        }
    };
    
    },{"./binance.js":24}],28:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ArgumentsRequired, ExchangeError, InvalidNonce, AuthenticationError, PermissionDenied } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bit2c extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bit2c',
                'name': 'Bit2C',
                'countries': [ 'IL' ], // Israel
                'rateLimit': 3000,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766119-3593220e-5ece-11e7-8b3a-5a041f6bcc3f.jpg',
                    'api': 'https://bit2c.co.il',
                    'www': 'https://www.bit2c.co.il',
                    'referral': 'https://bit2c.co.il/Aff/63bfed10-e359-420c-ab5a-ad368dab0baf',
                    'doc': [
                        'https://www.bit2c.co.il/home/api',
                        'https://github.com/OferE/bit2c',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            'Exchanges/{pair}/Ticker',
                            'Exchanges/{pair}/orderbook',
                            'Exchanges/{pair}/trades',
                            'Exchanges/{pair}/lasttrades',
                        ],
                    },
                    'private': {
                        'post': [
                            'Merchant/CreateCheckout',
                            'Order/AddCoinFundsRequest',
                            'Order/AddFund',
                            'Order/AddOrder',
                            'Order/AddOrderMarketPriceBuy',
                            'Order/AddOrderMarketPriceSell',
                            'Order/CancelOrder',
                            'Order/AddCoinFundsRequest',
                            'Order/AddStopOrder',
                            'Payment/GetMyId',
                            'Payment/Send',
                            'Payment/Pay',
                        ],
                        'get': [
                            'Account/Balance',
                            'Account/Balance/v2',
                            'Order/MyOrders',
                            'Order/GetById',
                            'Order/AccountHistory',
                            'Order/OrderHistory',
                        ],
                    },
                },
                'markets': {
                    'BTC/NIS': { 'id': 'BtcNis', 'symbol': 'BTC/NIS', 'base': 'BTC', 'quote': 'NIS', 'baseId': 'Btc', 'quoteId': 'Nis' },
                    'ETH/NIS': { 'id': 'EthNis', 'symbol': 'ETH/NIS', 'base': 'ETH', 'quote': 'NIS', 'baseId': 'Eth', 'quoteId': 'Nis' },
                    'BCH/NIS': { 'id': 'BchabcNis', 'symbol': 'BCH/NIS', 'base': 'BCH', 'quote': 'NIS', 'baseId': 'Bchabc', 'quoteId': 'Nis' },
                    'LTC/NIS': { 'id': 'LtcNis', 'symbol': 'LTC/NIS', 'base': 'LTC', 'quote': 'NIS', 'baseId': 'Ltc', 'quoteId': 'Nis' },
                    'ETC/NIS': { 'id': 'EtcNis', 'symbol': 'ETC/NIS', 'base': 'ETC', 'quote': 'NIS', 'baseId': 'Etc', 'quoteId': 'Nis' },
                    'BTG/NIS': { 'id': 'BtgNis', 'symbol': 'BTG/NIS', 'base': 'BTG', 'quote': 'NIS', 'baseId': 'Btg', 'quoteId': 'Nis' },
                    'BSV/NIS': { 'id': 'BchsvNis', 'symbol': 'BSV/NIS', 'base': 'BSV', 'quote': 'NIS', 'baseId': 'Bchsv', 'quoteId': 'Nis' },
                    'GRIN/NIS': { 'id': 'GrinNis', 'symbol': 'GRIN/NIS', 'base': 'GRIN', 'quote': 'NIS', 'baseId': 'Grin', 'quoteId': 'Nis' },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.005'),
                        'taker': this.parseNumber ('0.005'),
                    },
                },
                'options': {
                    'fetchTradesMethod': 'public_get_exchanges_pair_trades',
                },
                'exceptions': {
                    'exact': {
                        'Please provide valid APIkey': AuthenticationError, // { "error" : "Please provide valid APIkey" }
                    },
                    'broad': {
                        // { "error": "Please provide valid nonce in Request Nonce (1598218490) is not bigger than last nonce (1598218490)."}
                        // { "error": "Please provide valid nonce in Request UInt64.TryParse failed for nonce :" }
                        'Please provide valid nonce': InvalidNonce,
                        'please approve new terms of use on site': PermissionDenied, // { "error" : "please approve new terms of use on site." }
                    },
                },
            });
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const balance = await this.privateGetAccountBalanceV2 (params);
            //
            //     {
            //         "AVAILABLE_NIS": 0.0,
            //         "NIS": 0.0,
            //         "LOCKED_NIS": 0.0,
            //         "AVAILABLE_BTC": 0.0,
            //         "BTC": 0.0,
            //         "LOCKED_BTC": 0.0,
            //         "AVAILABLE_ETH": 0.0,
            //         "ETH": 0.0,
            //         "LOCKED_ETH": 0.0,
            //         "AVAILABLE_BCHSV": 0.0,
            //         "BCHSV": 0.0,
            //         "LOCKED_BCHSV": 0.0,
            //         "AVAILABLE_BCHABC": 0.0,
            //         "BCHABC": 0.0,
            //         "LOCKED_BCHABC": 0.0,
            //         "AVAILABLE_LTC": 0.0,
            //         "LTC": 0.0,
            //         "LOCKED_LTC": 0.0,
            //         "AVAILABLE_ETC": 0.0,
            //         "ETC": 0.0,
            //         "LOCKED_ETC": 0.0,
            //         "AVAILABLE_BTG": 0.0,
            //         "BTG": 0.0,
            //         "LOCKED_BTG": 0.0,
            //         "AVAILABLE_GRIN": 0.0,
            //         "GRIN": 0.0,
            //         "LOCKED_GRIN": 0.0,
            //         "Fees": {
            //             "BtcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "EthNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "BchabcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "LtcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "EtcNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "BtgNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "LtcBtc": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "BchsvNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 },
            //             "GrinNis": { "FeeMaker": 1.0, "FeeTaker": 1.0 }
            //         }
            //     }
            //
            const result = {
                'info': balance,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const codes = Object.keys (this.currencies);
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const account = this.account ();
                const currency = this.currency (code);
                const uppercase = currency['id'].toUpperCase ();
                if (uppercase in balance) {
                    account['free'] = this.safeString (balance, 'AVAILABLE_' + uppercase);
                    account['total'] = this.safeString (balance, uppercase);
                }
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
            };
            const orderbook = await this.publicGetExchangesPairOrderbook (this.extend (request, params));
            return this.parseOrderBook (orderbook, symbol);
        }
    
        parseTicker (ticker, market = undefined) {
            const symbol = this.safeSymbol (undefined, market);
            const timestamp = this.milliseconds ();
            const averagePrice = this.safeNumber (ticker, 'av');
            const baseVolume = this.safeNumber (ticker, 'a');
            let quoteVolume = undefined;
            if (baseVolume !== undefined && averagePrice !== undefined) {
                quoteVolume = baseVolume * averagePrice;
            }
            const last = this.safeNumber (ticker, 'll');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': undefined,
                'low': undefined,
                'bid': this.safeNumber (ticker, 'h'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'l'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': averagePrice,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetExchangesPairTicker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const method = this.options['fetchTradesMethod'];
            const request = {
                'pair': market['id'],
            };
            if (since !== undefined) {
                request['date'] = parseInt (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit; // max 100000
            }
            const response = await this[method] (this.extend (request, params));
            if (typeof response === 'string') {
                throw new ExchangeError (response);
            }
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            let method = 'privatePostOrderAddOrder';
            const request = {
                'Amount': amount,
                'Pair': this.marketId (symbol),
            };
            if (type === 'market') {
                method += 'MarketPrice' + this.capitalize (side);
            } else {
                request['Price'] = price;
                request['Total'] = amount * price;
                request['IsBid'] = (side === 'buy');
            }
            const response = await this[method] (this.extend (request, params));
            return {
                'info': response,
                'id': response['NewOrder']['id'],
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const request = {
                'id': id,
            };
            return await this.privatePostOrderCancelOrder (this.extend (request, params));
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.privateGetOrderMyOrders (this.extend (request, params));
            const orders = this.safeValue (response, market['id'], {});
            const asks = this.safeValue (orders, 'ask', []);
            const bids = this.safeValue (orders, 'bid', []);
            return this.parseOrders (this.arrayConcat (asks, bids), market, since, limit);
        }
    
        parseOrder (order, market = undefined) {
            const timestamp = this.safeInteger (order, 'created');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            let side = this.safeValue (order, 'type');
            if (side === 0) {
                side = 'buy';
            } else if (side === 1) {
                side = 'sell';
            }
            const id = this.safeString (order, 'id');
            const status = this.safeString (order, 'status');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': undefined,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'filled': undefined,
                'remaining': undefined,
                'cost': undefined,
                'trades': undefined,
                'fee': undefined,
                'info': order,
                'average': undefined,
            });
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (limit !== undefined) {
                request['take'] = limit;
            }
            request['take'] = limit;
            if (since !== undefined) {
                request['toTime'] = this.ymd (this.milliseconds (), '.');
                request['fromTime'] = this.ymd (since, '.');
            }
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
            }
            const response = await this.privateGetOrderOrderHistory (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            let timestamp = undefined;
            let id = undefined;
            let priceString = undefined;
            let amountString = undefined;
            let orderId = undefined;
            let feeCost = undefined;
            let side = undefined;
            const reference = this.safeString (trade, 'reference');
            if (reference !== undefined) {
                timestamp = this.safeTimestamp (trade, 'ticks');
                priceString = this.safeString (trade, 'price');
                amountString = this.safeString (trade, 'firstAmount');
                const reference_parts = reference.split ('|'); // reference contains 'pair|orderId|tradeId'
                if (market === undefined) {
                    const marketId = this.safeString (trade, 'pair');
                    if (marketId in this.markets_by_id[marketId]) {
                        market = this.markets_by_id[marketId];
                    } else if (reference_parts[0] in this.markets_by_id) {
                        market = this.markets_by_id[reference_parts[0]];
                    }
                }
                orderId = reference_parts[1];
                id = reference_parts[2];
                side = this.safeInteger (trade, 'action');
                if (side === 0) {
                    side = 'buy';
                } else if (side === 1) {
                    side = 'sell';
                }
                feeCost = this.safeNumber (trade, 'feeAmount');
            } else {
                timestamp = this.safeTimestamp (trade, 'date');
                id = this.safeString (trade, 'tid');
                priceString = this.safeString (trade, 'price');
                amountString = this.safeString (trade, 'amount');
                side = this.safeValue (trade, 'isBid');
                if (side !== undefined) {
                    if (side) {
                        side = 'buy';
                    } else {
                        side = 'sell';
                    }
                }
            }
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            return {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': {
                    'cost': feeCost,
                    'currency': 'NIS',
                    'rate': undefined,
                },
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.implodeParams (path, params);
            if (api === 'public') {
                url += '.json';
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                const query = this.extend ({
                    'nonce': nonce,
                }, params);
                const auth = this.urlencode (query);
                if (method === 'GET') {
                    if (Object.keys (query).length) {
                        url += '?' + auth;
                    }
                } else {
                    body = auth;
                }
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha512', 'base64');
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'key': this.apiKey,
                    'sign': signature,
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     { "error" : "please approve new terms of use on site." }
            //     { "error": "Please provide valid nonce in Request Nonce (1598218490) is not bigger than last nonce (1598218490)."}
            //
            const error = this.safeString (response, 'error');
            if (error !== undefined) {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], error, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], error, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],29:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AuthenticationError, InvalidNonce, InsufficientFunds, InvalidOrder, OrderNotFound, PermissionDenied } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitbank extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitbank',
                'name': 'bitbank',
                'countries': [ 'JP' ],
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchDepositAddress': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '1hour',
                    '4h': '4hour',
                    '8h': '8hour',
                    '12h': '12hour',
                    '1d': '1day',
                    '1w': '1week',
                },
                'hostname': 'bitbank.cc',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/37808081-b87f2d9c-2e59-11e8-894d-c1900b7584fe.jpg',
                    'api': {
                        'public': 'https://public.{hostname}',
                        'private': 'https://api.{hostname}',
                        'markets': 'https://api.{hostname}',
                    },
                    'www': 'https://bitbank.cc/',
                    'doc': 'https://docs.bitbank.cc/',
                    'fees': 'https://bitbank.cc/docs/fees/',
                },
                'api': {
                    'public': {
                        'get': [
                            '{pair}/ticker',
                            '{pair}/depth',
                            '{pair}/transactions',
                            '{pair}/transactions/{yyyymmdd}',
                            '{pair}/candlestick/{candletype}/{yyyymmdd}',
                        ],
                    },
                    'private': {
                        'get': [
                            'user/assets',
                            'user/spot/order',
                            'user/spot/active_orders',
                            'user/spot/trade_history',
                            'user/withdrawal_account',
                        ],
                        'post': [
                            'user/spot/order',
                            'user/spot/cancel_order',
                            'user/spot/cancel_orders',
                            'user/spot/orders_info',
                            'user/request_withdrawal',
                        ],
                    },
                    'markets': {
                        'get': [
                            'spot/pairs',
                        ],
                    },
                },
                'exceptions': {
                    '20001': AuthenticationError,
                    '20002': AuthenticationError,
                    '20003': AuthenticationError,
                    '20005': AuthenticationError,
                    '20004': InvalidNonce,
                    '40020': InvalidOrder,
                    '40021': InvalidOrder,
                    '40025': ExchangeError,
                    '40013': OrderNotFound,
                    '40014': OrderNotFound,
                    '50008': PermissionDenied,
                    '50009': OrderNotFound,
                    '50010': OrderNotFound,
                    '60001': InsufficientFunds,
                    '60005': InvalidOrder,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.marketsGetSpotPairs (params);
            //
            //     {
            //       "success": 1,
            //       "data": {
            //         "pairs": [
            //           {
            //             "name": "btc_jpy",
            //             "base_asset": "btc",
            //             "quote_asset": "jpy",
            //             "maker_fee_rate_base": "0",
            //             "taker_fee_rate_base": "0",
            //             "maker_fee_rate_quote": "-0.0002",
            //             "taker_fee_rate_quote": "0.0012",
            //             "unit_amount": "0.0001",
            //             "limit_max_amount": "1000",
            //             "market_max_amount": "10",
            //             "market_allowance_rate": "0.2",
            //             "price_digits": 0,
            //             "amount_digits": 4,
            //             "is_enabled": true,
            //             "stop_order": false,
            //             "stop_order_and_cancel": false
            //           }
            //         ]
            //       }
            //     }
            //
            const data = this.safeValue (response, 'data');
            const pairs = this.safeValue (data, 'pairs', []);
            const result = [];
            for (let i = 0; i < pairs.length; i++) {
                const entry = pairs[i];
                const id = this.safeString (entry, 'name');
                const baseId = this.safeString (entry, 'base_asset');
                const quoteId = this.safeString (entry, 'quote_asset');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const maker = this.safeNumber (entry, 'maker_fee_rate_quote');
                const taker = this.safeNumber (entry, 'taker_fee_rate_quote');
                const pricePrecisionString = this.safeString (entry, 'price_digits');
                const priceLimit = this.parsePrecision (pricePrecisionString);
                const precision = {
                    'price': parseInt (pricePrecisionString),
                    'amount': this.safeInteger (entry, 'amount_digits'),
                };
                const active = this.safeValue (entry, 'is_enabled');
                const minAmountString = this.safeString (entry, 'unit_amount');
                const minCost = Precise.stringMul (minAmountString, priceLimit);
                const limits = {
                    'amount': {
                        'min': this.safeNumber (entry, 'unit_amount'),
                        'max': this.safeNumber (entry, 'limit_max_amount'),
                    },
                    'price': {
                        'min': this.parseNumber (priceLimit),
                        'max': undefined,
                    },
                    'cost': {
                        'min': this.parseNumber (minCost),
                        'max': undefined,
                    },
                };
                result.push ({
                    'info': entry,
                    'id': id,
                    'symbol': symbol,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'base': base,
                    'quote': quote,
                    'precision': precision,
                    'limits': limits,
                    'active': active,
                    'maker': maker,
                    'taker': taker,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            const symbol = this.safeSymbol (undefined, market);
            const timestamp = this.safeInteger (ticker, 'timestamp');
            const last = this.safeNumber (ticker, 'last');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': undefined,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetPairTicker (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            return this.parseTicker (data, market);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
            };
            const response = await this.publicGetPairDepth (this.extend (request, params));
            const orderbook = this.safeValue (response, 'data', {});
            const timestamp = this.safeInteger (orderbook, 'timestamp');
            return this.parseOrderBook (orderbook, symbol, timestamp);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeInteger (trade, 'executed_at');
            let symbol = undefined;
            let feeCurrency = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
                feeCurrency = market['quote'];
            }
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const id = this.safeString2 (trade, 'transaction_id', 'trade_id');
            const takerOrMaker = this.safeString (trade, 'maker_taker');
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee_amount_quote');
            if (feeCost !== undefined) {
                fee = {
                    'currency': feeCurrency,
                    'cost': feeCost,
                };
            }
            const orderId = this.safeString (trade, 'order_id');
            const type = this.safeString (trade, 'type');
            const side = this.safeString (trade, 'side');
            return {
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': type,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
                'info': trade,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetPairTransactions (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            const trades = this.safeValue (data, 'transactions', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         "0.02501786",
            //         "0.02501786",
            //         "0.02501786",
            //         "0.02501786",
            //         "0.0000",
            //         1591488000000
            //     ]
            //
            return [
                this.safeInteger (ohlcv, 5),
                this.safeNumber (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '5m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let date = this.milliseconds ();
            date = this.ymd (date);
            date = date.split ('-');
            const request = {
                'pair': market['id'],
                'candletype': this.timeframes[timeframe],
                'yyyymmdd': date.join (''),
            };
            const response = await this.publicGetPairCandlestickCandletypeYyyymmdd (this.extend (request, params));
            //
            //     {
            //         "success":1,
            //         "data":{
            //             "candlestick":[
            //                 {
            //                     "type":"5min",
            //                     "ohlcv":[
            //                         ["0.02501786","0.02501786","0.02501786","0.02501786","0.0000",1591488000000],
            //                         ["0.02501747","0.02501953","0.02501747","0.02501953","0.3017",1591488300000],
            //                         ["0.02501762","0.02501762","0.02500392","0.02500392","0.1500",1591488600000],
            //                     ]
            //                 }
            //             ],
            //             "timestamp":1591508668190
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const candlestick = this.safeValue (data, 'candlestick', []);
            const first = this.safeValue (candlestick, 0, {});
            const ohlcv = this.safeValue (first, 'ohlcv', []);
            return this.parseOHLCVs (ohlcv, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetUserAssets (params);
            //
            //     {
            //       "success": "1",
            //       "data": {
            //         "assets": [
            //           {
            //             "asset": "jpy",
            //             "amount_precision": "4",
            //             "onhand_amount": "0.0000",
            //             "locked_amount": "0.0000",
            //             "free_amount": "0.0000",
            //             "stop_deposit": false,
            //             "stop_withdrawal": false,
            //             "withdrawal_fee": {
            //               "threshold": "30000.0000",
            //               "under": "550.0000",
            //               "over": "770.0000"
            //             }
            //           },
            //           {
            //             "asset": "btc",
            //             "amount_precision": "8",
            //             "onhand_amount": "0.00000000",
            //             "locked_amount": "0.00000000",
            //             "free_amount": "0.00000000",
            //             "stop_deposit": false,
            //             "stop_withdrawal": false,
            //             "withdrawal_fee": "0.00060000"
            //           },
            //         ]
            //       }
            //     }
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const data = this.safeValue (response, 'data', {});
            const assets = this.safeValue (data, 'assets', []);
            for (let i = 0; i < assets.length; i++) {
                const balance = assets[i];
                const currencyId = this.safeString (balance, 'asset');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'free_amount');
                account['used'] = this.safeString (balance, 'locked_amount');
                account['total'] = this.safeString (balance, 'onhand_amount');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'UNFILLED': 'open',
                'PARTIALLY_FILLED': 'open',
                'FULLY_FILLED': 'closed',
                'CANCELED_UNFILLED': 'canceled',
                'CANCELED_PARTIALLY_FILLED': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            const id = this.safeString (order, 'order_id');
            const marketId = this.safeString (order, 'pair');
            let symbol = undefined;
            if (marketId && !market && (marketId in this.markets_by_id)) {
                market = this.markets_by_id[marketId];
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const timestamp = this.safeInteger (order, 'ordered_at');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'start_amount');
            const filled = this.safeNumber (order, 'executed_amount');
            const remaining = this.safeNumber (order, 'remaining_amount');
            const average = this.safeNumber (order, 'average_price');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const type = this.safeStringLower (order, 'type');
            const side = this.safeStringLower (order, 'side');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'average': average,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'trades': undefined,
                'fee': undefined,
                'info': order,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'amount': this.amountToPrecision (symbol, amount),
                'side': side,
                'type': type,
            };
            if (type === 'limit') {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePostUserSpotOrder (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'order_id': id,
                'pair': market['id'],
            };
            const response = await this.privatePostUserSpotCancelOrder (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return data;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'order_id': id,
                'pair': market['id'],
            };
            const response = await this.privateGetUserSpotOrder (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            if (limit !== undefined) {
                request['count'] = limit;
            }
            if (since !== undefined) {
                request['since'] = parseInt (since / 1000);
            }
            const response = await this.privateGetUserSpotActiveOrders (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            const orders = this.safeValue (data, 'orders', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const request = {};
            if (market !== undefined) {
                request['pair'] = market['id'];
            }
            if (limit !== undefined) {
                request['count'] = limit;
            }
            if (since !== undefined) {
                request['since'] = parseInt (since / 1000);
            }
            const response = await this.privateGetUserSpotTradeHistory (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            const trades = this.safeValue (data, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset': currency['id'],
            };
            const response = await this.privateGetUserWithdrawalAccount (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            // Not sure about this if there could be more than one account...
            const accounts = this.safeValue (data, 'accounts', []);
            const firstAccount = this.safeValue (accounts, 0, {});
            const address = this.safeString (firstAccount, 'address');
            return {
                'currency': currency,
                'address': address,
                'tag': undefined,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            if (!('uuid' in params)) {
                throw new ExchangeError (this.id + ' uuid is required for withdrawal');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset': currency['id'],
                'amount': amount,
            };
            const response = await this.privatePostUserRequestWithdrawal (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            const txid = this.safeString (data, 'txid');
            return {
                'info': response,
                'id': txid,
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let query = this.omit (params, this.extractParams (path));
            let url = this.implodeHostname (this.urls['api'][api]) + '/';
            if ((api === 'public') || (api === 'markets')) {
                url += this.implodeParams (path, params);
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                let auth = nonce;
                url += this.version + '/' + this.implodeParams (path, params);
                if (method === 'POST') {
                    body = this.json (query);
                    auth += body;
                } else {
                    auth += '/' + this.version + '/' + path;
                    if (Object.keys (query).length) {
                        query = this.urlencode (query);
                        url += '?' + query;
                        auth += '?' + query;
                    }
                }
                headers = {
                    'Content-Type': 'application/json',
                    'ACCESS-KEY': this.apiKey,
                    'ACCESS-NONCE': nonce,
                    'ACCESS-SIGNATURE': this.hmac (this.encode (auth), this.encode (this.secret)),
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const success = this.safeInteger (response, 'success');
            const data = this.safeValue (response, 'data');
            if (!success || !data) {
                const errorMessages = {
                    '10000': 'URL does not exist',
                    '10001': 'A system error occurred. Please contact support',
                    '10002': 'Invalid JSON format. Please check the contents of transmission',
                    '10003': 'A system error occurred. Please contact support',
                    '10005': 'A timeout error occurred. Please wait for a while and try again',
                    '20001': 'API authentication failed',
                    '20002': 'Illegal API key',
                    '20003': 'API key does not exist',
                    '20004': 'API Nonce does not exist',
                    '20005': 'API signature does not exist',
                    '20011': 'Two-step verification failed',
                    '20014': 'SMS authentication failed',
                    '30001': 'Please specify the order quantity',
                    '30006': 'Please specify the order ID',
                    '30007': 'Please specify the order ID array',
                    '30009': 'Please specify the stock',
                    '30012': 'Please specify the order price',
                    '30013': 'Trade Please specify either',
                    '30015': 'Please specify the order type',
                    '30016': 'Please specify asset name',
                    '30019': 'Please specify uuid',
                    '30039': 'Please specify the amount to be withdrawn',
                    '40001': 'The order quantity is invalid',
                    '40006': 'Count value is invalid',
                    '40007': 'End time is invalid',
                    '40008': 'end_id Value is invalid',
                    '40009': 'The from_id value is invalid',
                    '40013': 'The order ID is invalid',
                    '40014': 'The order ID array is invalid',
                    '40015': 'Too many specified orders',
                    '40017': 'Incorrect issue name',
                    '40020': 'The order price is invalid',
                    '40021': 'The trading classification is invalid',
                    '40022': 'Start date is invalid',
                    '40024': 'The order type is invalid',
                    '40025': 'Incorrect asset name',
                    '40028': 'uuid is invalid',
                    '40048': 'The amount of withdrawal is illegal',
                    '50003': 'Currently, this account is in a state where you can not perform the operation you specified. Please contact support',
                    '50004': 'Currently, this account is temporarily registered. Please try again after registering your account',
                    '50005': 'Currently, this account is locked. Please contact support',
                    '50006': 'Currently, this account is locked. Please contact support',
                    '50008': 'User identification has not been completed',
                    '50009': 'Your order does not exist',
                    '50010': 'Can not cancel specified order',
                    '50011': 'API not found',
                    '60001': 'The number of possessions is insufficient',
                    '60002': 'It exceeds the quantity upper limit of the tender buying order',
                    '60003': 'The specified quantity exceeds the limit',
                    '60004': 'The specified quantity is below the threshold',
                    '60005': 'The specified price is above the limit',
                    '60006': 'The specified price is below the lower limit',
                    '70001': 'A system error occurred. Please contact support',
                    '70002': 'A system error occurred. Please contact support',
                    '70003': 'A system error occurred. Please contact support',
                    '70004': 'We are unable to accept orders as the transaction is currently suspended',
                    '70005': 'Order can not be accepted because purchase order is currently suspended',
                    '70006': 'We can not accept orders because we are currently unsubscribed ',
                    '70009': 'We are currently temporarily restricting orders to be carried out. Please use the limit order.',
                    '70010': 'We are temporarily raising the minimum order quantity as the system load is now rising.',
                };
                const errorClasses = this.exceptions;
                const code = this.safeString (data, 'code');
                const message = this.safeString (errorMessages, code, 'Error');
                const ErrorClass = this.safeValue (errorClasses, code);
                if (ErrorClass !== undefined) {
                    throw new ErrorClass (message);
                } else {
                    throw new ExchangeError (this.id + ' ' + this.json (response));
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],30:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { InvalidNonce, InsufficientFunds, AuthenticationError, InvalidOrder, ExchangeError, OrderNotFound, AccountSuspended, BadSymbol, OrderImmediatelyFillable, RateLimitExceeded, OnMaintenance, PermissionDenied } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitbay extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitbay',
                'name': 'BitBay',
                'countries': [ 'MT', 'EU' ], // Malta
                'rateLimit': 1000,
                'has': {
                    'cancelOrder': true,
                    'CORS': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchLedger': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '60',
                    '3m': '180',
                    '5m': '300',
                    '15m': '900',
                    '30m': '1800',
                    '1h': '3600',
                    '2h': '7200',
                    '4h': '14400',
                    '6h': '21600',
                    '12h': '43200',
                    '1d': '86400',
                    '3d': '259200',
                    '1w': '604800',
                },
                'hostname': 'bitbay.net',
                'urls': {
                    'referral': 'https://auth.bitbay.net/ref/jHlbB4mIkdS1',
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766132-978a7bd8-5ece-11e7-9540-bc96d1e9bbb8.jpg',
                    'www': 'https://bitbay.net',
                    'api': {
                        'public': 'https://{hostname}/API/Public',
                        'private': 'https://{hostname}/API/Trading/tradingApi.php',
                        'v1_01Public': 'https://api.{hostname}/rest',
                        'v1_01Private': 'https://api.{hostname}/rest',
                    },
                    'doc': [
                        'https://bitbay.net/public-api',
                        'https://bitbay.net/en/private-api',
                        'https://bitbay.net/account/tab-api',
                        'https://github.com/BitBayNet/API',
                        'https://docs.bitbay.net/v1.0.1-en/reference',
                    ],
                    'support': 'https://support.bitbay.net',
                    'fees': 'https://bitbay.net/en/fees',
                },
                'api': {
                    'public': {
                        'get': [
                            '{id}/all',
                            '{id}/market',
                            '{id}/orderbook',
                            '{id}/ticker',
                            '{id}/trades',
                        ],
                    },
                    'private': {
                        'post': [
                            'info',
                            'trade',
                            'cancel',
                            'orderbook',
                            'orders',
                            'transfer',
                            'withdraw',
                            'history',
                            'transactions',
                        ],
                    },
                    'v1_01Public': {
                        'get': [
                            'trading/ticker',
                            'trading/ticker/{symbol}',
                            'trading/stats',
                            'trading/orderbook/{symbol}',
                            'trading/transactions/{symbol}',
                            'trading/candle/history/{symbol}/{resolution}',
                        ],
                    },
                    'v1_01Private': {
                        'get': [
                            'payments/withdrawal/{detailId}',
                            'payments/deposit/{detailId}',
                            'trading/offer',
                            'trading/config/{symbol}',
                            'trading/history/transactions',
                            'balances/BITBAY/history',
                            'balances/BITBAY/balance',
                            'fiat_cantor/rate/{baseId}/{quoteId}',
                            'fiat_cantor/history',
                        ],
                        'post': [
                            'trading/offer/{symbol}',
                            'trading/config/{symbol}',
                            'balances/BITBAY/balance',
                            'balances/BITBAY/balance/transfer/{source}/{destination}',
                            'fiat_cantor/exchange',
                        ],
                        'delete': [
                            'trading/offer/{symbol}/{id}/{side}/{price}',
                        ],
                        'put': [
                            'balances/BITBAY/balance/{id}',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.0'),
                        'taker': this.parseNumber ('0.001'),
                        'percentage': true,
                        'tierBased': false,
                    },
                    'fiat': {
                        'maker': 0.30 / 100,
                        'taker': 0.43 / 100,
                        'percentage': true,
                        'tierBased': true,
                        'tiers': {
                            'taker': [
                                [ 0.0043, 0 ],
                                [ 0.0042, 1250 ],
                                [ 0.0041, 3750 ],
                                [ 0.0040, 7500 ],
                                [ 0.0039, 10000 ],
                                [ 0.0038, 15000 ],
                                [ 0.0037, 20000 ],
                                [ 0.0036, 25000 ],
                                [ 0.0035, 37500 ],
                                [ 0.0034, 50000 ],
                                [ 0.0033, 75000 ],
                                [ 0.0032, 100000 ],
                                [ 0.0031, 150000 ],
                                [ 0.0030, 200000 ],
                                [ 0.0029, 250000 ],
                                [ 0.0028, 375000 ],
                                [ 0.0027, 500000 ],
                                [ 0.0026, 625000 ],
                                [ 0.0025, 875000 ],
                            ],
                            'maker': [
                                [ 0.0030, 0 ],
                                [ 0.0029, 1250 ],
                                [ 0.0028, 3750 ],
                                [ 0.0028, 7500 ],
                                [ 0.0027, 10000 ],
                                [ 0.0026, 15000 ],
                                [ 0.0025, 20000 ],
                                [ 0.0025, 25000 ],
                                [ 0.0024, 37500 ],
                                [ 0.0023, 50000 ],
                                [ 0.0023, 75000 ],
                                [ 0.0022, 100000 ],
                                [ 0.0021, 150000 ],
                                [ 0.0021, 200000 ],
                                [ 0.0020, 250000 ],
                                [ 0.0019, 375000 ],
                                [ 0.0018, 500000 ],
                                [ 0.0018, 625000 ],
                                [ 0.0017, 875000 ],
                            ],
                        },
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'options': {
                    'fiatCurrencies': [ 'EUR', 'USD', 'GBP', 'PLN' ],
                },
                'exceptions': {
                    '400': ExchangeError, // At least one parameter wasn't set
                    '401': InvalidOrder, // Invalid order type
                    '402': InvalidOrder, // No orders with specified currencies
                    '403': InvalidOrder, // Invalid payment currency name
                    '404': InvalidOrder, // Error. Wrong transaction type
                    '405': InvalidOrder, // Order with this id doesn't exist
                    '406': InsufficientFunds, // No enough money or crypto
                    // code 407 not specified are not specified in their docs
                    '408': InvalidOrder, // Invalid currency name
                    '501': AuthenticationError, // Invalid public key
                    '502': AuthenticationError, // Invalid sign
                    '503': InvalidNonce, // Invalid moment parameter. Request time doesn't match current server time
                    '504': ExchangeError, // Invalid method
                    '505': AuthenticationError, // Key has no permission for this action
                    '506': AccountSuspended, // Account locked. Please contact with customer service
                    // codes 507 and 508 are not specified in their docs
                    '509': ExchangeError, // The BIC/SWIFT is required for this currency
                    '510': BadSymbol, // Invalid market name
                    'FUNDS_NOT_SUFFICIENT': InsufficientFunds,
                    'OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS': InvalidOrder,
                    'OFFER_NOT_FOUND': OrderNotFound,
                    'OFFER_WOULD_HAVE_BEEN_PARTIALLY_FILLED': OrderImmediatelyFillable,
                    'ACTION_LIMIT_EXCEEDED': RateLimitExceeded,
                    'UNDER_MAINTENANCE': OnMaintenance,
                    'REQUEST_TIMESTAMP_TOO_OLD': InvalidNonce,
                    'PERMISSIONS_NOT_SUFFICIENT': PermissionDenied,
                },
                'commonCurrencies': {
                    'GGC': 'Global Game Coin',
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.v1_01PublicGetTradingTicker (params);
            const fiatCurrencies = this.safeValue (this.options, 'fiatCurrencies', []);
            //
            //     {
            //         status: 'Ok',
            //         items: {
            //             'BSV-USD': {
            //                 market: {
            //                     code: 'BSV-USD',
            //                     first: { currency: 'BSV', minOffer: '0.00035', scale: 8 },
            //                     second: { currency: 'USD', minOffer: '5', scale: 2 }
            //                 },
            //                 time: '1557569762154',
            //                 highestBid: '52.31',
            //                 lowestAsk: '62.99',
            //                 rate: '63',
            //                 previousRate: '51.21',
            //             },
            //         },
            //     }
            //
            const result = [];
            const items = this.safeValue (response, 'items');
            const keys = Object.keys (items);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const item = items[key];
                const market = this.safeValue (item, 'market', {});
                const first = this.safeValue (market, 'first', {});
                const second = this.safeValue (market, 'second', {});
                const baseId = this.safeString (first, 'currency');
                const quoteId = this.safeString (second, 'currency');
                const id = baseId + quoteId;
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeInteger (first, 'scale'),
                    'price': this.safeInteger (second, 'scale'),
                };
                let fees = this.safeValue (this.fees, 'trading', {});
                if (this.inArray (base, fiatCurrencies) || this.inArray (quote, fiatCurrencies)) {
                    fees = this.safeValue (this.fees, 'fiat', {});
                }
                const maker = this.safeNumber (fees, 'maker');
                const taker = this.safeNumber (fees, 'taker');
                // todo: check that the limits have ben interpreted correctly
                // todo: parse the fees page
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'precision': precision,
                    'active': undefined,
                    'maker': maker,
                    'taker': taker,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (first, 'minOffer'),
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.safeNumber (second, 'minOffer'),
                            'max': undefined,
                        },
                    },
                    'info': item,
                });
            }
            return result;
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const response = await this.v1_01PrivateGetTradingOffer (this.extend (request, params));
            const items = this.safeValue (response, 'items', []);
            return this.parseOrders (items, undefined, since, limit, { 'status': 'open' });
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         market: 'ETH-EUR',
            //         offerType: 'Sell',
            //         id: '93d3657b-d616-11e9-9248-0242ac110005',
            //         currentAmount: '0.04',
            //         lockedAmount: '0.04',
            //         rate: '280',
            //         startAmount: '0.04',
            //         time: '1568372806924',
            //         postOnly: false,
            //         hidden: false,
            //         mode: 'limit',
            //         receivedAmount: '0.0',
            //         firstBalanceId: '5b816c3e-437c-4e43-9bef-47814ae7ebfc',
            //         secondBalanceId: 'ab43023b-4079-414c-b340-056e3430a3af'
            //     }
            //
            const marketId = this.safeString (order, 'market');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = this.safeInteger (order, 'time');
            const amount = this.safeNumber (order, 'startAmount');
            const remaining = this.safeNumber (order, 'currentAmount');
            const postOnly = this.safeValue (order, 'postOnly');
            return this.safeOrder ({
                'id': this.safeString (order, 'id'),
                'clientOrderId': undefined,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': undefined,
                'symbol': symbol,
                'type': this.safeString (order, 'mode'),
                'timeInForce': undefined,
                'postOnly': postOnly,
                'side': this.safeStringLower (order, 'offerType'),
                'price': this.safeNumber (order, 'rate'),
                'stopPrice': undefined,
                'amount': amount,
                'cost': undefined,
                'filled': undefined,
                'remaining': remaining,
                'average': undefined,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbol) {
                const markets = [ this.marketId (symbol) ];
                request['markets'] = markets;
            }
            const query = { 'query': this.json (this.extend (request, params)) };
            const response = await this.v1_01PrivateGetTradingHistoryTransactions (query);
            //
            //     {
            //         status: 'Ok',
            //         totalRows: '67',
            //         items: [
            //             {
            //                 id: 'b54659a0-51b5-42a0-80eb-2ac5357ccee2',
            //                 market: 'BTC-EUR',
            //                 time: '1541697096247',
            //                 amount: '0.00003',
            //                 rate: '4341.44',
            //                 initializedBy: 'Sell',
            //                 wasTaker: false,
            //                 userAction: 'Buy',
            //                 offerId: 'bd19804a-6f89-4a69-adb8-eb078900d006',
            //                 commissionValue: null
            //             },
            //         ]
            //     }
            //
            const items = this.safeValue (response, 'items');
            const result = this.parseTrades (items, undefined, since, limit);
            if (symbol === undefined) {
                return result;
            }
            return this.filterBySymbol (result, symbol);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.v1_01PrivateGetBalancesBITBAYBalance (params);
            const balances = this.safeValue (response, 'balances');
            if (balances === undefined) {
                throw new ExchangeError (this.id + ' empty balance response ' + this.json (response));
            }
            const result = { 'info': response };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['used'] = this.safeString (balance, 'lockedFunds');
                account['free'] = this.safeString (balance, 'availableFunds');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': this.marketId (symbol),
            };
            const orderbook = await this.publicGetIdOrderbook (this.extend (request, params));
            return this.parseOrderBook (orderbook, symbol);
        }
    
        parseTicker (ticker, market = undefined) {
            const symbol = this.safeSymbol (undefined, market);
            const timestamp = this.milliseconds ();
            const baseVolume = this.safeNumber (ticker, 'volume');
            const vwap = this.safeNumber (ticker, 'vwap');
            let quoteVolume = undefined;
            if (baseVolume !== undefined && vwap !== undefined) {
                quoteVolume = baseVolume * vwap;
            }
            const last = this.safeNumber (ticker, 'last');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'max'),
                'low': this.safeNumber (ticker, 'min'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': this.safeNumber (ticker, 'average'),
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'],
            };
            const response = await this.publicGetIdTicker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            const balanceCurrencies = [];
            if (code !== undefined) {
                const currency = this.currency (code);
                balanceCurrencies.push (currency['id']);
            }
            let request = {
                'balanceCurrencies': balanceCurrencies,
            };
            if (since !== undefined) {
                request['fromTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            request = this.extend (request, params);
            const response = await this.v1_01PrivateGetBalancesBITBAYHistory ({ 'query': this.json (request) });
            const items = response['items'];
            return this.parseLedger (items, undefined, since, limit);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //    FUNDS_MIGRATION
            //    {
            //      "historyId": "84ea7a29-7da5-4de5-b0c0-871e83cad765",
            //      "balance": {
            //        "id": "821ec166-cb88-4521-916c-f4eb44db98df",
            //        "currency": "LTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "LTC"
            //      },
            //      "detailId": null,
            //      "time": 1506128252968,
            //      "type": "FUNDS_MIGRATION",
            //      "value": 0.0009957,
            //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
            //      "fundsAfter": { "total": 0.0009957, "available": 0.0009957, "locked": 0 },
            //      "change": { "total": 0.0009957, "available": 0.0009957, "locked": 0 }
            //    }
            //
            //    CREATE_BALANCE
            //    {
            //      "historyId": "d0fabd8d-9107-4b5e-b9a6-3cab8af70d49",
            //      "balance": {
            //        "id": "653ffcf2-3037-4ebe-8e13-d5ea1a01d60d",
            //        "currency": "BTG",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTG"
            //      },
            //      "detailId": null,
            //      "time": 1508895244751,
            //      "type": "CREATE_BALANCE",
            //      "value": 0,
            //      "fundsBefore": { "total": null, "available": null, "locked": null },
            //      "fundsAfter": { "total": 0, "available": 0, "locked": 0 },
            //      "change": { "total": 0, "available": 0, "locked": 0 }
            //    }
            //
            //    BITCOIN_GOLD_FORK
            //    {
            //      "historyId": "2b4d52d3-611c-473d-b92c-8a8d87a24e41",
            //      "balance": {
            //        "id": "653ffcf2-3037-4ebe-8e13-d5ea1a01d60d",
            //        "currency": "BTG",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTG"
            //      },
            //      "detailId": null,
            //      "time": 1508895244778,
            //      "type": "BITCOIN_GOLD_FORK",
            //      "value": 0.00453512,
            //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
            //      "fundsAfter": { "total": 0.00453512, "available": 0.00453512, "locked": 0 },
            //      "change": { "total": 0.00453512, "available": 0.00453512, "locked": 0 }
            //    }
            //
            //    ADD_FUNDS
            //    {
            //      "historyId": "3158236d-dae5-4a5d-81af-c1fa4af340fb",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": "8e83a960-e737-4380-b8bb-259d6e236faa",
            //      "time": 1520631178816,
            //      "type": "ADD_FUNDS",
            //      "value": 0.628405,
            //      "fundsBefore": { "total": 0.00453512, "available": 0.00453512, "locked": 0 },
            //      "fundsAfter": { "total": 0.63294012, "available": 0.63294012, "locked": 0 },
            //      "change": { "total": 0.628405, "available": 0.628405, "locked": 0 }
            //    }
            //
            //    TRANSACTION_PRE_LOCKING
            //    {
            //      "historyId": "e7d19e0f-03b3-46a8-bc72-dde72cc24ead",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": null,
            //      "time": 1520706403868,
            //      "type": "TRANSACTION_PRE_LOCKING",
            //      "value": -0.1,
            //      "fundsBefore": { "total": 0.63294012, "available": 0.63294012, "locked": 0 },
            //      "fundsAfter": { "total": 0.63294012, "available": 0.53294012, "locked": 0.1 },
            //      "change": { "total": 0, "available": -0.1, "locked": 0.1 }
            //    }
            //
            //    TRANSACTION_POST_OUTCOME
            //    {
            //      "historyId": "c4010825-231d-4a9c-8e46-37cde1f7b63c",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": "bf2876bc-b545-4503-96c8-ef4de8233876",
            //      "time": 1520706404032,
            //      "type": "TRANSACTION_POST_OUTCOME",
            //      "value": -0.01771415,
            //      "fundsBefore": { "total": 0.63294012, "available": 0.53294012, "locked": 0.1 },
            //      "fundsAfter": { "total": 0.61522597, "available": 0.53294012, "locked": 0.08228585 },
            //      "change": { "total": -0.01771415, "available": 0, "locked": -0.01771415 }
            //    }
            //
            //    TRANSACTION_POST_INCOME
            //    {
            //      "historyId": "7f18b7af-b676-4125-84fd-042e683046f6",
            //      "balance": {
            //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
            //        "currency": "EUR",
            //        "type": "FIAT",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "EUR"
            //      },
            //      "detailId": "f5fcb274-0cc7-4385-b2d3-bae2756e701f",
            //      "time": 1520706404035,
            //      "type": "TRANSACTION_POST_INCOME",
            //      "value": 628.78,
            //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
            //      "fundsAfter": { "total": 628.78, "available": 628.78, "locked": 0 },
            //      "change": { "total": 628.78, "available": 628.78, "locked": 0 }
            //    }
            //
            //    TRANSACTION_COMMISSION_OUTCOME
            //    {
            //      "historyId": "843177fa-61bc-4cbf-8be5-b029d856c93b",
            //      "balance": {
            //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
            //        "currency": "EUR",
            //        "type": "FIAT",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "EUR"
            //      },
            //      "detailId": "f5fcb274-0cc7-4385-b2d3-bae2756e701f",
            //      "time": 1520706404050,
            //      "type": "TRANSACTION_COMMISSION_OUTCOME",
            //      "value": -2.71,
            //      "fundsBefore": { "total": 766.06, "available": 766.06, "locked": 0 },
            //      "fundsAfter": { "total": 763.35,"available": 763.35, "locked": 0 },
            //      "change": { "total": -2.71, "available": -2.71, "locked": 0 }
            //    }
            //
            //    TRANSACTION_OFFER_COMPLETED_RETURN
            //    {
            //      "historyId": "cac69b04-c518-4dc5-9d86-e76e91f2e1d2",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": null,
            //      "time": 1520714886425,
            //      "type": "TRANSACTION_OFFER_COMPLETED_RETURN",
            //      "value": 0.00000196,
            //      "fundsBefore": { "total": 0.00941208, "available": 0.00941012, "locked": 0.00000196 },
            //      "fundsAfter": { "total": 0.00941208, "available": 0.00941208, "locked": 0 },
            //      "change": { "total": 0, "available": 0.00000196, "locked": -0.00000196 }
            //    }
            //
            //    WITHDRAWAL_LOCK_FUNDS
            //    {
            //      "historyId": "03de2271-66ab-4960-a786-87ab9551fc14",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": "6ad3dc72-1d6d-4ec2-8436-ca43f85a38a6",
            //      "time": 1522245654481,
            //      "type": "WITHDRAWAL_LOCK_FUNDS",
            //      "value": -0.8,
            //      "fundsBefore": { "total": 0.8, "available": 0.8, "locked": 0 },
            //      "fundsAfter": { "total": 0.8, "available": 0, "locked": 0.8 },
            //      "change": { "total": 0, "available": -0.8, "locked": 0.8 }
            //    }
            //
            //    WITHDRAWAL_SUBTRACT_FUNDS
            //    {
            //      "historyId": "b0308c89-5288-438d-a306-c6448b1a266d",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": "6ad3dc72-1d6d-4ec2-8436-ca43f85a38a6",
            //      "time": 1522246526186,
            //      "type": "WITHDRAWAL_SUBTRACT_FUNDS",
            //      "value": -0.8,
            //      "fundsBefore": { "total": 0.8, "available": 0, "locked": 0.8 },
            //      "fundsAfter": { "total": 0, "available": 0, "locked": 0 },
            //      "change": { "total": -0.8, "available": 0, "locked": -0.8 }
            //    }
            //
            //    TRANSACTION_OFFER_ABORTED_RETURN
            //    {
            //      "historyId": "b1a3c075-d403-4e05-8f32-40512cdd88c0",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": null,
            //      "time": 1522512298662,
            //      "type": "TRANSACTION_OFFER_ABORTED_RETURN",
            //      "value": 0.0564931,
            //      "fundsBefore": { "total": 0.44951311, "available": 0.39302001, "locked": 0.0564931 },
            //      "fundsAfter": { "total": 0.44951311, "available": 0.44951311, "locked": 0 },
            //      "change": { "total": 0, "available": 0.0564931, "locked": -0.0564931 }
            //    }
            //
            //    WITHDRAWAL_UNLOCK_FUNDS
            //    {
            //      "historyId": "0ed569a2-c330-482e-bb89-4cb553fb5b11",
            //      "balance": {
            //        "id": "3a7e7a1e-0324-49d5-8f59-298505ebd6c7",
            //        "currency": "BTC",
            //        "type": "CRYPTO",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "BTC"
            //      },
            //      "detailId": "0c7be256-c336-4111-bee7-4eb22e339700",
            //      "time": 1527866360785,
            //      "type": "WITHDRAWAL_UNLOCK_FUNDS",
            //      "value": 0.05045,
            //      "fundsBefore": { "total": 0.86001578, "available": 0.80956578, "locked": 0.05045 },
            //      "fundsAfter": { "total": 0.86001578, "available": 0.86001578, "locked": 0 },
            //      "change": { "total": 0, "available": 0.05045, "locked": -0.05045 }
            //    }
            //
            //    TRANSACTION_COMMISSION_RETURN
            //    {
            //      "historyId": "07c89c27-46f1-4d7a-8518-b73798bf168a",
            //      "balance": {
            //        "id": "ab43023b-4079-414c-b340-056e3430a3af",
            //        "currency": "EUR",
            //        "type": "FIAT",
            //        "userId": "a34d361d-7bad-49c1-888e-62473b75d877",
            //        "name": "EUR"
            //      },
            //      "detailId": null,
            //      "time": 1528304043063,
            //      "type": "TRANSACTION_COMMISSION_RETURN",
            //      "value": 0.6,
            //      "fundsBefore": { "total": 0, "available": 0, "locked": 0 },
            //      "fundsAfter": { "total": 0.6, "available": 0.6, "locked": 0 },
            //      "change": { "total": 0.6, "available": 0.6, "locked": 0 }
            //    }
            //
            const timestamp = this.safeInteger (item, 'time');
            const balance = this.safeValue (item, 'balance', {});
            const currencyId = this.safeString (balance, 'currency');
            const code = this.safeCurrencyCode (currencyId);
            const change = this.safeValue (item, 'change', {});
            let amount = this.safeNumber (change, 'total');
            let direction = 'in';
            if (amount < 0) {
                direction = 'out';
                amount = -amount;
            }
            const id = this.safeString (item, 'historyId');
            // there are 2 undocumented api calls: (v1_01PrivateGetPaymentsDepositDetailId and v1_01PrivateGetPaymentsWithdrawalDetailId)
            // that can be used to enrich the transfers with txid, address etc (you need to use info.detailId as a parameter)
            const referenceId = this.safeString (item, 'detailId');
            const type = this.parseLedgerEntryType (this.safeString (item, 'type'));
            const fundsBefore = this.safeValue (item, 'fundsBefore', {});
            const before = this.safeNumber (fundsBefore, 'total');
            const fundsAfter = this.safeValue (item, 'fundsAfter', {});
            const after = this.safeNumber (fundsAfter, 'total');
            return {
                'info': item,
                'id': id,
                'direction': direction,
                'account': undefined,
                'referenceId': referenceId,
                'referenceAccount': undefined,
                'type': type,
                'currency': code,
                'amount': amount,
                'before': before,
                'after': after,
                'status': 'ok',
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': undefined,
            };
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'ADD_FUNDS': 'transaction',
                'BITCOIN_GOLD_FORK': 'transaction',
                'CREATE_BALANCE': 'transaction',
                'FUNDS_MIGRATION': 'transaction',
                'WITHDRAWAL_LOCK_FUNDS': 'transaction',
                'WITHDRAWAL_SUBTRACT_FUNDS': 'transaction',
                'WITHDRAWAL_UNLOCK_FUNDS': 'transaction',
                'TRANSACTION_COMMISSION_OUTCOME': 'fee',
                'TRANSACTION_COMMISSION_RETURN': 'fee',
                'TRANSACTION_OFFER_ABORTED_RETURN': 'trade',
                'TRANSACTION_OFFER_COMPLETED_RETURN': 'trade',
                'TRANSACTION_POST_INCOME': 'trade',
                'TRANSACTION_POST_OUTCOME': 'trade',
                'TRANSACTION_PRE_LOCKING': 'trade',
            };
            return this.safeString (types, type, type);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         '1582399800000',
            //         {
            //             o: '0.0001428',
            //             c: '0.0001428',
            //             h: '0.0001428',
            //             l: '0.0001428',
            //             v: '4',
            //             co: '1'
            //         }
            //     ]
            //
            const first = this.safeValue (ohlcv, 1, {});
            return [
                this.safeInteger (ohlcv, 0),
                this.safeNumber (first, 'o'),
                this.safeNumber (first, 'h'),
                this.safeNumber (first, 'l'),
                this.safeNumber (first, 'c'),
                this.safeNumber (first, 'v'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const tradingSymbol = market['baseId'] + '-' + market['quoteId'];
            const request = {
                'symbol': tradingSymbol,
                'resolution': this.timeframes[timeframe],
                // 'from': 1574709092000, // unix timestamp in milliseconds, required
                // 'to': 1574709092000, // unix timestamp in milliseconds, required
            };
            if (limit === undefined) {
                limit = 100;
            }
            const duration = this.parseTimeframe (timeframe);
            const timerange = limit * duration * 1000;
            if (since === undefined) {
                request['to'] = this.milliseconds ();
                request['from'] = request['to'] - timerange;
            } else {
                request['from'] = parseInt (since);
                request['to'] = this.sum (request['from'], timerange);
            }
            const response = await this.v1_01PublicGetTradingCandleHistorySymbolResolution (this.extend (request, params));
            //
            //     {
            //         "status":"Ok",
            //         "items":[
            //             ["1591503060000",{"o":"0.02509572","c":"0.02509438","h":"0.02509664","l":"0.02509438","v":"0.02082165","co":"17"}],
            //             ["1591503120000",{"o":"0.02509606","c":"0.02509515","h":"0.02509606","l":"0.02509487","v":"0.04971703","co":"13"}],
            //             ["1591503180000",{"o":"0.02509532","c":"0.02509589","h":"0.02509589","l":"0.02509454","v":"0.01332236","co":"7"}],
            //         ]
            //     }
            //
            const items = this.safeValue (response, 'items', []);
            return this.parseOHLCVs (items, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // createOrder trades
            //
            //     {
            //         "rate": "0.02195928",
            //         "amount": "0.00167952"
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         amount: "0.29285199",
            //         commissionValue: "0.00125927",
            //         id: "11c8203a-a267-11e9-b698-0242ac110007",
            //         initializedBy: "Buy",
            //         market: "ETH-EUR",
            //         offerId: "11c82038-a267-11e9-b698-0242ac110007",
            //         rate: "277",
            //         time: "1562689917517",
            //         userAction: "Buy",
            //         wasTaker: true,
            //     }
            //
            // fetchTrades (public)
            //
            //     {
            //          id: 'df00b0da-e5e0-11e9-8c19-0242ac11000a',
            //          t: '1570108958831',
            //          a: '0.04776653',
            //          r: '0.02145854',
            //          ty: 'Sell'
            //     }
            //
            const timestamp = this.safeInteger2 (trade, 'time', 't');
            const side = this.safeStringLower2 (trade, 'userAction', 'ty');
            const wasTaker = this.safeValue (trade, 'wasTaker');
            let takerOrMaker = undefined;
            if (wasTaker !== undefined) {
                takerOrMaker = wasTaker ? 'taker' : 'maker';
            }
            const priceString = this.safeString2 (trade, 'rate', 'r');
            const amountString = this.safeString2 (trade, 'amount', 'a');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const feeCost = this.safeNumber (trade, 'commissionValue');
            const marketId = this.safeString (trade, 'market');
            market = this.safeMarket (marketId, market, '-');
            const symbol = market['symbol'];
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCcy = (side === 'buy') ? market['base'] : market['quote'];
                fee = {
                    'currency': feeCcy,
                    'cost': feeCost,
                };
            }
            const order = this.safeString (trade, 'offerId');
            // todo: check this logic
            let type = undefined;
            if (order !== undefined) {
                type = order ? 'limit' : 'market';
            }
            return {
                'id': this.safeString (trade, 'id'),
                'order': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'takerOrMaker': takerOrMaker,
                'fee': fee,
                'info': trade,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const tradingSymbol = market['baseId'] + '-' + market['quoteId'];
            const request = {
                'symbol': tradingSymbol,
            };
            if (since !== undefined) {
                request['fromTime'] = since - 1; // result does not include exactly `since` time therefore decrease by 1
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default - 10, max - 300
            }
            const response = await this.v1_01PublicGetTradingTransactionsSymbol (this.extend (request, params));
            const items = this.safeValue (response, 'items');
            return this.parseTrades (items, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const tradingSymbol = market['baseId'] + '-' + market['quoteId'];
            const request = {
                'symbol': tradingSymbol,
                'offerType': side,
                'amount': amount,
                'mode': type,
            };
            if (type === 'limit') {
                request['rate'] = price;
                price = parseFloat (price);
            }
            amount = parseFloat (amount);
            const response = await this.v1_01PrivatePostTradingOfferSymbol (this.extend (request, params));
            //
            // unfilled (open order)
            //
            //     {
            //         status: 'Ok',
            //         completed: false, // can deduce status from here
            //         offerId: 'ce9cc72e-d61c-11e9-9248-0242ac110005',
            //         transactions: [], // can deduce order info from here
            //     }
            //
            // filled (closed order)
            //
            //     {
            //         "status": "Ok",
            //         "offerId": "942a4a3e-e922-11e9-8c19-0242ac11000a",
            //         "completed": true,
            //         "transactions": [
            //           {
            //             "rate": "0.02195928",
            //             "amount": "0.00167952"
            //           },
            //           {
            //             "rate": "0.02195928",
            //             "amount": "0.00167952"
            //           },
            //           {
            //             "rate": "0.02196207",
            //             "amount": "0.27704177"
            //           }
            //         ]
            //     }
            //
            // partially-filled (open order)
            //
            //     {
            //         "status": "Ok",
            //         "offerId": "d0ebefab-f4d7-11e9-8c19-0242ac11000a",
            //         "completed": false,
            //         "transactions": [
            //           {
            //             "rate": "0.02106404",
            //             "amount": "0.0019625"
            //           },
            //           {
            //             "rate": "0.02106404",
            //             "amount": "0.0019625"
            //           },
            //           {
            //             "rate": "0.02105901",
            //             "amount": "0.00975256"
            //           }
            //         ]
            //     }
            //
            const timestamp = this.milliseconds (); // the real timestamp is missing in the response
            const id = this.safeString (response, 'offerId');
            const completed = this.safeValue (response, 'completed', false);
            const status = completed ? 'closed' : 'open';
            let filled = 0;
            let cost = undefined;
            const transactions = this.safeValue (response, 'transactions');
            let trades = undefined;
            if (transactions !== undefined) {
                trades = this.parseTrades (transactions, market, undefined, undefined, {
                    'timestamp': timestamp,
                    'datetime': this.iso8601 (timestamp),
                    'symbol': symbol,
                    'side': side,
                    'type': type,
                    'orderId': id,
                });
                cost = 0;
                for (let i = 0; i < trades.length; i++) {
                    filled = this.sum (filled, trades[i]['amount']);
                    cost = this.sum (cost, trades[i]['cost']);
                }
            }
            const remaining = amount - filled;
            return {
                'id': id,
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'filled': filled,
                'remaining': remaining,
                'average': undefined,
                'fee': undefined,
                'trades': trades,
                'clientOrderId': undefined,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const side = this.safeString (params, 'side');
            if (side === undefined) {
                throw new ExchangeError (this.id + ' cancelOrder() requires a `side` parameter ("buy" or "sell")');
            }
            const price = this.safeValue (params, 'price');
            if (price === undefined) {
                throw new ExchangeError (this.id + ' cancelOrder() requires a `price` parameter (float or string)');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const tradingSymbol = market['baseId'] + '-' + market['quoteId'];
            const request = {
                'symbol': tradingSymbol,
                'id': id,
                'side': side,
                'price': price,
            };
            // { status: 'Fail', errors: [ 'NOT_RECOGNIZED_OFFER_TYPE' ] }  -- if required params are missing
            // { status: 'Ok', errors: [] }
            return this.v1_01PrivateDeleteTradingOfferSymbolIdSidePrice (this.extend (request, params));
        }
    
        isFiat (currency) {
            const fiatCurrencies = {
                'USD': true,
                'EUR': true,
                'PLN': true,
            };
            return this.safeValue (fiatCurrencies, currency, false);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            let method = undefined;
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'quantity': amount,
            };
            if (this.isFiat (code)) {
                method = 'privatePostWithdraw';
                // request['account'] = params['account']; // they demand an account number
                // request['express'] = params['express']; // whatever it means, they don't explain
                // request['bic'] = '';
            } else {
                method = 'privatePostTransfer';
                if (tag !== undefined) {
                    address += '?dt=' + tag.toString ();
                }
                request['address'] = address;
            }
            const response = await this[method] (this.extend (request, params));
            return {
                'info': response,
                'id': undefined,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.implodeHostname (this.urls['api'][api]);
            if (api === 'public') {
                const query = this.omit (params, this.extractParams (path));
                url += '/' + this.implodeParams (path, params) + '.json';
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else if (api === 'v1_01Public') {
                const query = this.omit (params, this.extractParams (path));
                url += '/' + this.implodeParams (path, params);
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else if (api === 'v1_01Private') {
                this.checkRequiredCredentials ();
                const query = this.omit (params, this.extractParams (path));
                url += '/' + this.implodeParams (path, params);
                const nonce = this.milliseconds ().toString ();
                let payload = undefined;
                if (method !== 'POST') {
                    if (Object.keys (query).length) {
                        url += '?' + this.urlencode (query);
                    }
                    payload = this.apiKey + nonce;
                } else if (body === undefined) {
                    body = this.json (query);
                    payload = this.apiKey + nonce + body;
                }
                headers = {
                    'Request-Timestamp': nonce,
                    'Operation-Id': this.uuid (),
                    'API-Key': this.apiKey,
                    'API-Hash': this.hmac (this.encode (payload), this.encode (this.secret), 'sha512'),
                    'Content-Type': 'application/json',
                };
            } else {
                this.checkRequiredCredentials ();
                body = this.urlencode (this.extend ({
                    'method': path,
                    'moment': this.nonce (),
                }, params));
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'API-Key': this.apiKey,
                    'API-Hash': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if ('code' in response) {
                //
                // bitbay returns the integer 'success': 1 key from their private API
                // or an integer 'code' value from 0 to 510 and an error message
                //
                //      { 'success': 1, ... }
                //      { 'code': 502, 'message': 'Invalid sign' }
                //      { 'code': 0, 'message': 'offer funds not exceeding minimums' }
                //
                //      400 At least one parameter wasn't set
                //      401 Invalid order type
                //      402 No orders with specified currencies
                //      403 Invalid payment currency name
                //      404 Error. Wrong transaction type
                //      405 Order with this id doesn't exist
                //      406 No enough money or crypto
                //      408 Invalid currency name
                //      501 Invalid public key
                //      502 Invalid sign
                //      503 Invalid moment parameter. Request time doesn't match current server time
                //      504 Invalid method
                //      505 Key has no permission for this action
                //      506 Account locked. Please contact with customer service
                //      509 The BIC/SWIFT is required for this currency
                //      510 Invalid market name
                //
                const code = this.safeString (response, 'code'); // always an integer
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions, code, feedback);
                throw new ExchangeError (feedback);
            } else if ('status' in response) {
                //
                //      {"status":"Fail","errors":["OFFER_FUNDS_NOT_EXCEEDING_MINIMUMS"]}
                //
                const status = this.safeString (response, 'status');
                if (status === 'Fail') {
                    const errors = this.safeValue (response, 'errors');
                    const feedback = this.id + ' ' + body;
                    for (let i = 0; i < errors.length; i++) {
                        const error = errors[i];
                        this.throwExactlyMatchedException (this.exceptions, error, feedback);
                    }
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],31:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, InsufficientFunds, OrderNotFound, BadRequest, BadSymbol } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitbns extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitbns',
                'name': 'Bitbns',
                'countries': [ 'IN' ], // India
                'rateLimit': 1000,
                'certified': false,
                'pro': false,
                // new metainfo interface
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': false,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchStatus': true,
                    'fetchTicker': 'emulated',
                    'fetchTickers': true,
                    'fetchTrades': false,
                    'fetchWithdrawals': true,
                },
                'timeframes': {
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/117201933-e7a6e780-adf5-11eb-9d80-98fc2a21c3d6.jpg',
                    'api': {
                        'ccxt': 'https://bitbns.com/order',
                        'v1': 'https://api.bitbns.com/api/trade/v1',
                        'v2': 'https://api.bitbns.com/api/trade/v2',
                    },
                    'www': 'https://bitbns.com',
                    'referral': 'https://ref.bitbns.com/1090961',
                    'doc': [
                        'https://bitbns.com/trade/#/api-trading/',
                    ],
                    'fees': 'https://bitbns.com/fees',
                },
                'api': {
                    'ccxt': {
                        'get': [
                            'fetchMarkets',
                            'fetchTickers',
                            'fetchOrderbook',
                        ],
                    },
                    'v1': {
                        'get': [
                            'platform/status',
                            'tickers',
                            'orderbook/sell/{symbol}',
                            'orderbook/buy/{symbol}',
                        ],
                        'post': [
                            'currentCoinBalance/EVERYTHING',
                            'getApiUsageStatus/USAGE',
                            'getOrderSocketToken/USAGE',
                            'currentCoinBalance/{symbol}',
                            'orderStatus/{symbol}',
                            'depositHistory/{symbol}',
                            'withdrawHistory/{symbol}',
                            'listOpenOrders/{symbol}',
                            'listOpenStopOrders/{symbol}',
                            'getCoinAddress/{symbol}',
                            'placeSellOrder/{symbol}',
                            'placeBuyOrder/{symbol}',
                            'buyStopLoss/{symbol}',
                            'placeSellOrder/{symbol}',
                            'cancelOrder/{symbol}',
                            'cancelStopLossOrder/{symbol}',
                            'listExecutedOrders/{symbol}',
                        ],
                    },
                    'v2': {
                        'post': [
                            'orders',
                            'cancel',
                            'getordersnew',
                            'marginOrders',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'quote',
                        'tierBased': false,
                        'percentage': true,
                        'taker': this.parseNumber ('0.0025'),
                        'maker': this.parseNumber ('0.0025'),
                    },
                },
                'exceptions': {
                    'exact': {
                        '400': BadRequest, // {"msg":"Invalid Request","status":-1,"code":400}
                        '409': BadSymbol, // {"data":"","status":0,"error":"coin name not supplied or not yet supported","code":409}
                        '416': InsufficientFunds, // {"data":"Oops ! Not sufficient currency to sell","status":0,"error":null,"code":416}
                        '417': OrderNotFound, // {"data":[],"status":0,"error":"Nothing to show","code":417}
                    },
                    'broad': {},
                },
            });
        }
    
        async fetchStatus (params = {}) {
            const response = await this.v1GetPlatformStatus (params);
            //
            //     {
            //         "data":{
            //             "BTC":{"status":1},
            //             "ETH":{"status":1},
            //             "XRP":{"status":1},
            //         },
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            let status = this.safeString (response, 'status');
            if (status !== undefined) {
                status = (status === '1') ? 'ok' : 'maintenance';
                this.status = this.extend (this.status, {
                    'status': status,
                    'updated': this.milliseconds (),
                });
            }
            return this.status;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.ccxtGetFetchMarkets (params);
            //
            //     [
            //         {
            //             "id":"BTC",
            //             "symbol":"BTC/INR",
            //             "base":"BTC",
            //             "quote":"INR",
            //             "baseId":"BTC",
            //             "quoteId":"",
            //             "active":true,
            //             "limits":{
            //                 "amount":{"min":"0.00017376","max":20},
            //                 "price":{"min":2762353.2359999996,"max":6445490.883999999},
            //                 "cost":{"min":800,"max":128909817.67999998}
            //             },
            //             "precision":{
            //                 "amount":8,
            //                 "price":2
            //             },
            //             "info":{}
            //         },
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'id');
                const baseId = this.safeString (market, 'base');
                const quoteId = this.safeString (market, 'quote');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const marketPrecision = this.safeValue (market, 'precision', {});
                const precision = {
                    'amount': this.safeInteger (marketPrecision, 'amount'),
                    'price': this.safeInteger (marketPrecision, 'price'),
                };
                const marketLimits = this.safeValue (market, 'limits', {});
                const amountLimits = this.safeValue (marketLimits, 'amount', {});
                const priceLimits = this.safeValue (marketLimits, 'price', {});
                const costLimits = this.safeValue (marketLimits, 'cost', {});
                const usdt = (quoteId === 'USDT');
                // INR markets don't need a _INR prefix
                const uppercaseId = usdt ? (baseId + '_' + quoteId) : baseId;
                result.push ({
                    'id': id,
                    'uppercaseId': uppercaseId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                    'active': undefined,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (amountLimits, 'min'),
                            'max': this.safeNumber (amountLimits, 'max'),
                        },
                        'price': {
                            'min': this.safeNumber (priceLimits, 'min'),
                            'max': this.safeNumber (priceLimits, 'max'),
                        },
                        'cost': {
                            'min': this.safeNumber (costLimits, 'min'),
                            'max': this.safeNumber (costLimits, 'max'),
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 100, max 5000, see https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md#order-book
            }
            const response = await this.ccxtGetFetchOrderbook (this.extend (request, params));
            //
            //     {
            //         "bids":[
            //             [49352.04,0.843948],
            //             [49352.03,0.742048],
            //             [49349.78,0.686239],
            //         ],
            //         "asks":[
            //             [49443.59,0.065137],
            //             [49444.63,0.098211],
            //             [49449.01,0.066309],
            //         ],
            //         "timestamp":1619172786577,
            //         "datetime":"2021-04-23T10:13:06.577Z",
            //         "nonce":""
            //     }
            //
            const timestamp = this.safeInteger (response, 'timestamp');
            return this.parseOrderBook (response, timestamp);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         "symbol":"BTC/INR",
            //         "info":{
            //             "highest_buy_bid":4368494.31,
            //             "lowest_sell_bid":4374835.09,
            //             "last_traded_price":4374835.09,
            //             "yes_price":4531016.27,
            //             "volume":{"max":"4569119.23","min":"4254552.13","volume":62.17722344}
            //         },
            //         "timestamp":1619100020845,
            //         "datetime":1619100020845,
            //         "high":"4569119.23",
            //         "low":"4254552.13",
            //         "bid":4368494.31,
            //         "bidVolume":"",
            //         "ask":4374835.09,
            //         "askVolume":"",
            //         "vwap":"",
            //         "open":4531016.27,
            //         "close":4374835.09,
            //         "last":4374835.09,
            //         "baseVolume":62.17722344,
            //         "quoteVolume":"",
            //         "previousClose":"",
            //         "change":-156181.1799999997,
            //         "percentage":-3.446934874943623,
            //         "average":4452925.68
            //     }
            //
            const timestamp = this.safeInteger (ticker, 'timestamp');
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber (ticker, 'last');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': this.safeNumber (ticker, 'bidVolume'),
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': this.safeNumber (ticker, 'askVolume'),
                'vwap': this.safeNumber (ticker, 'vwap'),
                'open': this.safeNumber (ticker, 'open'),
                'close': last,
                'last': last,
                'previousClose': this.safeNumber (ticker, 'previousClose'), // previous day close
                'change': this.safeNumber (ticker, 'change'),
                'percentage': this.safeNumber (ticker, 'percentage'),
                'average': this.safeNumber (ticker, 'average'),
                'baseVolume': this.safeNumber (ticker, 'baseVolume'),
                'quoteVolume': this.safeNumber (ticker, 'quoteVolume'),
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.ccxtGetFetchTickers (params);
            //
            //     {
            //         "BTC/INR":{
            //             "symbol":"BTC/INR",
            //             "info":{
            //                 "highest_buy_bid":4368494.31,
            //                 "lowest_sell_bid":4374835.09,
            //                 "last_traded_price":4374835.09,
            //                 "yes_price":4531016.27,
            //                 "volume":{"max":"4569119.23","min":"4254552.13","volume":62.17722344}
            //             },
            //             "timestamp":1619100020845,
            //             "datetime":1619100020845,
            //             "high":"4569119.23",
            //             "low":"4254552.13",
            //             "bid":4368494.31,
            //             "bidVolume":"",
            //             "ask":4374835.09,
            //             "askVolume":"",
            //             "vwap":"",
            //             "open":4531016.27,
            //             "close":4374835.09,
            //             "last":4374835.09,
            //             "baseVolume":62.17722344,
            //             "quoteVolume":"",
            //             "previousClose":"",
            //             "change":-156181.1799999997,
            //             "percentage":-3.446934874943623,
            //             "average":4452925.68
            //         }
            //     }
            //
            return this.parseTickers (response, symbols);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.v1PostCurrentCoinBalanceEVERYTHING (params);
            //
            //     {
            //         "data":{
            //             "availableorderMoney":0,
            //             "availableorderBTC":0,
            //             "availableorderXRP":0,
            //             "inorderMoney":0,
            //             "inorderBTC":0,
            //             "inorderXRP":0,
            //             "inorderNEO":0,
            //         },
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            const timestamp = undefined;
            const result = {
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
            };
            const data = this.safeValue (response, 'data', {});
            const keys = Object.keys (data);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const parts = key.split ('availableorder');
                const numParts = parts.length;
                if (numParts > 1) {
                    const currencyId = this.safeString (parts, 1);
                    if (currencyId !== 'Money') {
                        const code = this.safeCurrencyCode (currencyId);
                        const account = this.account ();
                        account['free'] = this.safeString (data, key);
                        account['used'] = this.safeString (data, 'inorder' + currencyId);
                        result[code] = account;
                    }
                }
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '0': 'open',
                // 'PARTIALLY_FILLED': 'open',
                // 'FILLED': 'closed',
                // 'CANCELED': 'canceled',
                // 'PENDING_CANCEL': 'canceling', // currently unused
                // 'REJECTED': 'rejected',
                // 'EXPIRED': 'expired',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "data":"Successfully placed bid to purchase currency",
            //         "status":1,
            //         "error":null,
            //         "id":5424475,
            //         "code":200
            //     }
            //
            // fetchOrder
            //
            //     {
            //         "entry_id":5424475,
            //         "btc":0.01,
            //         "rate":2000,
            //         "time":"2021-04-25T17:05:42.000Z",
            //         "type":0,
            //         "status":0,
            //         "total":0.01,
            //         "avg_cost":null,
            //         "side":"BUY",
            //         "amount":0.01,
            //         "remaining":0.01,
            //         "filled":0,
            //         "cost":null,
            //         "fee":0.05
            //     }
            //
            // fetchOpenOrders
            //
            //     {
            //         "entry_id":5424475,
            //         "btc":0.01,
            //         "rate":2000,
            //         "time":"2021-04-25T17:05:42.000Z",
            //         "type":0,
            //         "status":0
            //     }
            //
            const id = this.safeString2 (order, 'id', 'entry_id');
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.parse8601 (this.safeString (order, 'time'));
            const price = this.safeNumber (order, 'rate');
            const amount = this.safeNumber2 (order, 'amount', 'btc');
            const filled = this.safeNumber (order, 'filled');
            const remaining = this.safeNumber (order, 'remaining');
            const average = this.safeNumber (order, 'avg_cost');
            const cost = this.safeNumber (order, 'cost');
            let type = this.safeStringLower (order, 'type');
            if (type === '0') {
                type = 'limit';
            }
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const side = this.safeStringLower (order, 'side');
            const feeCost = this.safeNumber (order, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyCode = undefined;
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': cost,
                'average': average,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            if (type !== 'limit') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'side': side.toUpperCase (),
                'symbol': market['uppercaseId'],
                'quantity': this.amountToPrecision (symbol, amount),
                'rate': this.priceToPrecision (symbol, price),
                // 'target_rate': this.priceToPrecision (symbol, targetRate),
                // 't_rate': this.priceToPrecision (symbol, stopPrice),
                // 'trail_rate': this.priceToPrecision (symbol, trailRate),
                // To Place Simple Buy or Sell Order use rate
                // To Place Stoploss Buy or Sell Order use rate & t_rate
                // To Place Bracket Buy or Sell Order use rate , t_rate, target_rate & trail_rate
            };
            const response = await this.v2PostOrders (this.extend (request, params));
            //
            //     {
            //         "data":"Successfully placed bid to purchase currency",
            //         "status":1,
            //         "error":null,
            //         "id":5424475,
            //         "code":200
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const quoteSide = (market['quoteId'] === 'USDT') ? 'usdtcancelOrder' : 'cancelOrder';
            const request = {
                'entry_id': id,
                'symbol': market['uppercaseId'],
                'side': quoteSide,
            };
            const response = await this.v2PostCancel (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'entry_id': id,
            };
            const response = await this.v1PostOrderStatusSymbol (this.extend (request, params));
            //
            //     {
            //         "data":[
            //             {
            //                 "entry_id":5424475,
            //                 "btc":0.01,
            //                 "rate":2000,
            //                 "time":"2021-04-25T17:05:42.000Z",
            //                 "type":0,
            //                 "status":0,
            //                 "total":0.01,
            //                 "avg_cost":null,
            //                 "side":"BUY",
            //                 "amount":0.01,
            //                 "remaining":0.01,
            //                 "filled":0,
            //                 "cost":null,
            //                 "fee":0.05
            //             }
            //         ],
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const first = this.safeValue (data, 0);
            return this.parseOrder (first, market);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const quoteSide = (market['quoteId'] === 'USDT') ? 'usdtListOpenOrders' : 'listOpenOrders';
            const request = {
                'symbol': market['uppercaseId'],
                'side': quoteSide,
                'page': 0,
            };
            const response = await this.v2PostGetordersnew (this.extend (request, params));
            //
            //     {
            //         "data":[
            //             {
            //                 "entry_id":5424475,
            //                 "btc":0.01,
            //                 "rate":2000,
            //                 "time":"2021-04-25T17:05:42.000Z",
            //                 "type":0,
            //                 "status":0
            //             }
            //         ],
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchMyTrades
            //
            //     {
            //         "type": "BTC Sell order executed",
            //         "typeI": 6,
            //         "crypto": 5000,
            //         "amount": 35.4,
            //         "rate": 709800,
            //         "date": "2020-05-22T15:05:34.000Z",
            //         "unit": "INR",
            //         "factor": 100000000,
            //         "fee": 0.09,
            //         "delh_btc": -5000,
            //         "delh_inr": 0,
            //         "del_btc": 0,
            //         "del_inr": 35.4,
            //         "id": "2938823"
            //     }
            //
            market = this.safeMarket (undefined, market);
            const orderId = this.safeString (trade, 'id');
            const timestamp = this.parse8601 (this.safeString (trade, 'date'));
            const amountString = this.safeString (trade, 'amount');
            const priceString = this.safeString (trade, 'rate');
            const price = this.parseNumber (priceString);
            const factor = this.safeString (trade, 'factor');
            const amountScaled = Precise.stringDiv (amountString, factor);
            const amount = this.parseNumber (amountScaled);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountScaled));
            const symbol = market['symbol'];
            let side = this.safeStringLower (trade, 'type');
            if (side.indexOf ('sell') >= 0) {
                side = 'sell';
            } else if (side.indexOf ('buy') >= 0) {
                side = 'buy';
            }
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyCode = market['quote'];
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': undefined,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'page': 0,
            };
            if (since !== undefined) {
                request['since'] = this.iso8601 (since);
            }
            const response = await this.v1PostListExecutedOrdersSymbol (this.extend (request, params));
            //
            //     {
            //         "data": [
            //             {
            //                 "type": "BTC Sell order executed",
            //                 "typeI": 6,
            //                 "crypto": 5000,
            //                 "amount": 35.4,
            //                 "rate": 709800,
            //                 "date": "2020-05-22T15:05:34.000Z",
            //                 "unit": "INR",
            //                 "factor": 100000000,
            //                 "fee": 0.09,
            //                 "delh_btc": -5000,
            //                 "delh_inr": 0,
            //                 "del_btc": 0,
            //                 "del_inr": 35.4,
            //                 "id": "2938823"
            //             },
            //             {
            //                 "type": "BTC Sell order executed",
            //                 "typeI": 6,
            //                 "crypto": 195000,
            //                 "amount": 1380.58,
            //                 "rate": 709765.5,
            //                 "date": "2020-05-22T15:05:34.000Z",
            //                 "unit": "INR",
            //                 "factor": 100000000,
            //                 "fee": 3.47,
            //                 "delh_btc": -195000,
            //                 "delh_inr": 0,
            //                 "del_btc": 0,
            //                 "del_inr": 1380.58,
            //                 "id": "2938823"
            //             }
            //         ],
            //         "status": 1,
            //         "error": null,
            //         "code": 200
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchDeposits() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'symbol': currency['id'],
                'page': 0,
            };
            const response = await this.v1PostDepositHistorySymbol (this.extend (request, params));
            //
            //     {
            //         "data":[
            //             {
            //                 "type":"USDT deposited",
            //                 "typeI":1,
            //                 "amount":100,
            //                 "date":"2021-04-24T14:56:04.000Z",
            //                 "unit":"USDT",
            //                 "factor":100,
            //                 "fee":0,
            //                 "delh_btc":0,
            //                 "delh_inr":0,
            //                 "rate":0,
            //                 "del_btc":10000,
            //                 "del_inr":0
            //             }
            //         ],
            //         "status":1,
            //         "error":null,
            //         "code":200
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTransactions (data, currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchWithdrawals() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'symbol': currency['id'],
                'page': 0,
            };
            const response = await this.v1PostWithdrawHistorySymbol (this.extend (request, params));
            //
            //     ...
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTransactions (data, currency, since, limit);
        }
    
        parseTransactionStatusByType (status, type = undefined) {
            const statusesByType = {
                'deposit': {
                    '0': 'pending',
                    '1': 'ok',
                },
                'withdrawal': {
                    '0': 'pending', // Email Sent
                    '1': 'canceled', // Cancelled (different from 1 = ok in deposits)
                    '2': 'pending', // Awaiting Approval
                    '3': 'failed', // Rejected
                    '4': 'pending', // Processing
                    '5': 'failed', // Failure
                    '6': 'ok', // Completed
                },
            };
            const statuses = this.safeValue (statusesByType, type, {});
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         "type":"USDT deposited",
            //         "typeI":1,
            //         "amount":100,
            //         "date":"2021-04-24T14:56:04.000Z",
            //         "unit":"USDT",
            //         "factor":100,
            //         "fee":0,
            //         "delh_btc":0,
            //         "delh_inr":0,
            //         "rate":0,
            //         "del_btc":10000,
            //         "del_inr":0
            //     }
            //
            // fetchWithdrawals
            //
            //     ...
            //
            const currencyId = this.safeString (transaction, 'unit');
            const code = this.safeCurrencyCode (currencyId, currency);
            const timestamp = this.parse8601 (this.safeString (transaction, 'date'));
            let type = this.safeString (transaction, 'type');
            let status = undefined;
            if (type !== undefined) {
                if (type.indexOf ('deposit') >= 0) {
                    type = 'deposit';
                    status = 'ok';
                } else if (type.indexOf ('withdraw') >= 0) {
                    type = 'withdrawal';
                }
            }
            // const status = this.parseTransactionStatusByType (this.safeString (transaction, 'status'), type);
            const amount = this.safeNumber (transaction, 'amount');
            const feeCost = this.safeNumber (transaction, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = { 'currency': code, 'cost': feeCost };
            }
            return {
                'info': transaction,
                'id': undefined,
                'txid': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': undefined,
                'addressTo': undefined,
                'addressFrom': undefined,
                'tag': undefined,
                'tagTo': undefined,
                'tagFrom': undefined,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'internal': undefined,
                'fee': fee,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'symbol': currency['id'],
            };
            const response = await this.v1PostGetCoinAddressSymbol (this.extend (request, params));
            //
            //     {
            //         "data":{
            //             "token":"0x680dee9edfff0c397736e10b017cf6a0aee4ba31",
            //             "expiry":"2022-04-24 22:30:11"
            //         },
            //         "status":1,
            //         "error":null
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const address = this.safeString (data, 'token');
            const tag = this.safeString (data, 'tag');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'v1', method = 'GET', params = {}, headers = undefined, body = undefined) {
            this.checkRequiredCredentials ();
            const baseUrl = this.implodeHostname (this.urls['api'][api]);
            let url = baseUrl + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            const nonce = this.nonce ().toString ();
            headers = {
                'X-BITBNS-APIKEY': this.apiKey,
            };
            if (method === 'GET') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else if (method === 'POST') {
                if (Object.keys (query).length) {
                    body = this.json (query);
                } else {
                    body = '{}';
                }
                const auth = {
                    'timeStamp_nonce': nonce,
                    'body': body,
                };
                const payload = this.stringToBase64 (this.json (auth));
                const signature = this.hmac (payload, this.encode (this.secret), 'sha512');
                headers['X-BITBNS-PAYLOAD'] = this.decode (payload);
                headers['X-BITBNS-SIGNATURE'] = signature;
                headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     {"msg":"Invalid Request","status":-1,"code":400}
            //     {"data":[],"status":0,"error":"Nothing to show","code":417}
            //
            const code = this.safeString (response, 'code');
            const message = this.safeString (response, 'msg');
            const error = (code !== undefined) && (code !== '200');
            if (error || (message !== undefined)) {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],32:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const hitbtc = require ('./hitbtc.js');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitcoincom extends hitbtc {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitcoincom',
                'name': 'bitcoin.com',
                'countries': [ 'KN' ],
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/97296144-514fa300-1861-11eb-952b-3d55d492200b.jpg',
                    'api': {
                        'public': 'https://api.exchange.bitcoin.com',
                        'private': 'https://api.exchange.bitcoin.com',
                    },
                    'www': 'https://exchange.bitcoin.com',
                    'doc': 'https://api.exchange.bitcoin.com/api/2/explore',
                    'fees': 'https://exchange.bitcoin.com/fees-and-limits',
                    'referral': 'https://exchange.bitcoin.com/referral/da948b21d6c92d69',
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.0015'),
                        'taker': this.parseNumber ('0.002'),
                    },
                },
            });
        }
    };
    
    },{"./hitbtc.js":85}],33:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { NotSupported, RateLimitExceeded, AuthenticationError, PermissionDenied, ArgumentsRequired, ExchangeError, ExchangeNotAvailable, InsufficientFunds, InvalidOrder, OrderNotFound, InvalidNonce, BadSymbol } = require ('./base/errors');
    const { SIGNIFICANT_DIGITS, DECIMAL_PLACES, TRUNCATE, ROUND } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitfinex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitfinex',
                'name': 'Bitfinex',
                'countries': [ 'VG' ],
                'version': 'v1',
                'rateLimit': 1500,
                'pro': true,
                // new metainfo interface
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'CORS': false,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'deposit': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': false,
                    'fetchFundingFees': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTradingFee': true,
                    'fetchTradingFees': true,
                    'fetchTransactions': true,
                    'fetchWithdrawals': false,
                    'withdraw': true,
                    'transfer': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '3h': '3h',
                    '4h': '4h',
                    '6h': '6h',
                    '12h': '12h',
                    '1d': '1D',
                    '1w': '7D',
                    '2w': '14D',
                    '1M': '1M',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                    'api': {
                        'v2': 'https://api-pub.bitfinex.com', // https://github.com/ccxt/ccxt/issues/5109
                        'public': 'https://api.bitfinex.com',
                        'private': 'https://api.bitfinex.com',
                    },
                    'www': 'https://www.bitfinex.com',
                    'referral': 'https://www.bitfinex.com/?refcode=P61eYxFL',
                    'doc': [
                        'https://docs.bitfinex.com/v1/docs',
                        'https://github.com/bitfinexcom/bitfinex-api-node',
                    ],
                },
                'api': {
                    // v2 symbol ids require a 't' prefix
                    // just the public part of it (use bitfinex2 for everything else)
                    'v2': {
                        'get': [
                            'platform/status',
                            'tickers',
                            'ticker/{symbol}',
                            'trades/{symbol}/hist',
                            'book/{symbol}/{precision}',
                            'book/{symbol}/P0',
                            'book/{symbol}/P1',
                            'book/{symbol}/P2',
                            'book/{symbol}/P3',
                            'book/{symbol}/R0',
                            'stats1/{key}:{size}:{symbol}:{side}/{section}',
                            'stats1/{key}:{size}:{symbol}/{section}',
                            'stats1/{key}:{size}:{symbol}:long/last',
                            'stats1/{key}:{size}:{symbol}:long/hist',
                            'stats1/{key}:{size}:{symbol}:short/last',
                            'stats1/{key}:{size}:{symbol}:short/hist',
                            'candles/trade:{timeframe}:{symbol}/{section}',
                            'candles/trade:{timeframe}:{symbol}/last',
                            'candles/trade:{timeframe}:{symbol}/hist',
                        ],
                    },
                    'public': {
                        'get': [
                            'book/{symbol}',
                            // 'candles/{symbol}',
                            'lendbook/{currency}',
                            'lends/{currency}',
                            'pubticker/{symbol}',
                            'stats/{symbol}',
                            'symbols',
                            'symbols_details',
                            'tickers',
                            'trades/{symbol}',
                        ],
                    },
                    'private': {
                        'post': [
                            'account_fees',
                            'account_infos',
                            'balances',
                            'basket_manage',
                            'credits',
                            'deposit/new',
                            'funding/close',
                            'history',
                            'history/movements',
                            'key_info',
                            'margin_infos',
                            'mytrades',
                            'mytrades_funding',
                            'offer/cancel',
                            'offer/new',
                            'offer/status',
                            'offers',
                            'offers/hist',
                            'order/cancel',
                            'order/cancel/all',
                            'order/cancel/multi',
                            'order/cancel/replace',
                            'order/new',
                            'order/new/multi',
                            'order/status',
                            'orders',
                            'orders/hist',
                            'position/claim',
                            'position/close',
                            'positions',
                            'summary',
                            'taken_funds',
                            'total_taken_funds',
                            'transfer',
                            'unused_taken_funds',
                            'withdraw',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'tierBased': true,
                        'percentage': true,
                        'maker': this.parseNumber ('0.001'),
                        'taker': this.parseNumber ('0.002'),
                        'tiers': {
                            'taker': [
                                [this.parseNumber ('0'), this.parseNumber ('0.002')],
                                [this.parseNumber ('500000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('1000000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('2500000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('5000000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('7500000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('10000000'), this.parseNumber ('0.0018')],
                                [this.parseNumber ('15000000'), this.parseNumber ('0.0016')],
                                [this.parseNumber ('20000000'), this.parseNumber ('0.0014')],
                                [this.parseNumber ('25000000'), this.parseNumber ('0.0012')],
                                [this.parseNumber ('30000000'), this.parseNumber ('0.001')],
                            ],
                            'maker': [
                                [this.parseNumber ('0'), this.parseNumber ('0.001')],
                                [this.parseNumber ('500000'), this.parseNumber ('0.0008')],
                                [this.parseNumber ('1000000'), this.parseNumber ('0.0006')],
                                [this.parseNumber ('2500000'), this.parseNumber ('0.0004')],
                                [this.parseNumber ('5000000'), this.parseNumber ('0.0002')],
                                [this.parseNumber ('7500000'), this.parseNumber ('0')],
                                [this.parseNumber ('10000000'), this.parseNumber ('0')],
                                [this.parseNumber ('15000000'), this.parseNumber ('0')],
                                [this.parseNumber ('20000000'), this.parseNumber ('0')],
                                [this.parseNumber ('25000000'), this.parseNumber ('0')],
                                [this.parseNumber ('30000000'), this.parseNumber ('0')],
                            ],
                        },
                    },
                    'funding': {
                        'tierBased': false, // true for tier-based/progressive
                        'percentage': false, // fixed commission
                        // Actually deposit fees are free for larger deposits (> $1000 USD equivalent)
                        // these values below are deprecated, we should not hardcode fees and limits anymore
                        // to be reimplemented with bitfinex funding fees from their API or web endpoints
                        'deposit': {},
                        'withdraw': {},
                    },
                },
                // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
                'commonCurrencies': {
                    'ALG': 'ALGO', // https://github.com/ccxt/ccxt/issues/6034
                    'AMP': 'AMPL',
                    'ATO': 'ATOM', // https://github.com/ccxt/ccxt/issues/5118
                    'BCHABC': 'XEC',
                    'BCHN': 'BCH',
                    'DAT': 'DATA',
                    'DOG': 'MDOGE',
                    'DSH': 'DASH',
                    // https://github.com/ccxt/ccxt/issues/7399
                    // https://coinmarketcap.com/currencies/pnetwork/
                    // https://en.cryptonomist.ch/blog/eidoo/the-edo-to-pnt-upgrade-what-you-need-to-know-updated/
                    'EDO': 'PNT',
                    'EUS': 'EURS',
                    'EUT': 'EURT',
                    'IOT': 'IOTA',
                    'IQX': 'IQ',
                    'MNA': 'MANA',
                    'ORS': 'ORS Group', // conflict with Origin Sport #3230
                    'PAS': 'PASS',
                    'QSH': 'QASH',
                    'QTM': 'QTUM',
                    'RBT': 'RBTC',
                    'SNG': 'SNGLS',
                    'STJ': 'STORJ',
                    'TERRAUST': 'UST',
                    'TSD': 'TUSD',
                    'YYW': 'YOYOW',
                    'UDC': 'USDC',
                    'UST': 'USDT',
                    'VSY': 'VSYS',
                    'WAX': 'WAXP',
                    'XCH': 'XCHF',
                    'ZBT': 'ZB',
                },
                'exceptions': {
                    'exact': {
                        'temporarily_unavailable': ExchangeNotAvailable, // Sorry, the service is temporarily unavailable. See https://www.bitfinex.com/ for more info.
                        'Order could not be cancelled.': OrderNotFound, // non-existent order
                        'No such order found.': OrderNotFound, // ?
                        'Order price must be positive.': InvalidOrder, // on price <= 0
                        'Could not find a key matching the given X-BFX-APIKEY.': AuthenticationError,
                        'Key price should be a decimal number, e.g. "123.456"': InvalidOrder, // on isNaN (price)
                        'Key amount should be a decimal number, e.g. "123.456"': InvalidOrder, // on isNaN (amount)
                        'ERR_RATE_LIMIT': RateLimitExceeded,
                        'Ratelimit': RateLimitExceeded,
                        'Nonce is too small.': InvalidNonce,
                        'No summary found.': ExchangeError, // fetchTradingFees (summary) endpoint can give this vague error message
                        'Cannot evaluate your available balance, please try again': ExchangeNotAvailable,
                        'Unknown symbol': BadSymbol,
                        'Cannot complete transfer. Exchange balance insufficient.': InsufficientFunds,
                        'Momentary balance check. Please wait few seconds and try the transfer again.': ExchangeError,
                    },
                    'broad': {
                        'Invalid X-BFX-SIGNATURE': AuthenticationError,
                        'This API key does not have permission': PermissionDenied, // authenticated but not authorized
                        'not enough exchange balance for ': InsufficientFunds, // when buying cost is greater than the available quote currency
                        'minimum size for ': InvalidOrder, // when amount below limits.amount.min
                        'Invalid order': InvalidOrder, // ?
                        'The available balance is only': InsufficientFunds, // {"status":"error","message":"Cannot withdraw 1.0027 ETH from your exchange wallet. The available balance is only 0.0 ETH. If you have limit orders, open positions, unused or active margin funding, this will decrease your available balance. To increase it, you can cancel limit orders or reduce/close your positions.","withdrawal_id":0,"fees":"0.0027"}
                    },
                },
                'precisionMode': SIGNIFICANT_DIGITS,
                'options': {
                    'currencyNames': {
                        'AGI': 'agi',
                        'AID': 'aid',
                        'AIO': 'aio',
                        'ANT': 'ant',
                        'AVT': 'aventus', // #1811
                        'BAT': 'bat',
                        // https://github.com/ccxt/ccxt/issues/5833
                        'BCH': 'bab', // undocumented
                        // 'BCH': 'bcash', // undocumented
                        'BCI': 'bci',
                        'BFT': 'bft',
                        'BSV': 'bsv',
                        'BTC': 'bitcoin',
                        'BTG': 'bgold',
                        'CFI': 'cfi',
                        'COMP': 'comp',
                        'DAI': 'dai',
                        'DADI': 'dad',
                        'DASH': 'dash',
                        'DATA': 'datacoin',
                        'DTH': 'dth',
                        'EDO': 'eidoo', // #1811
                        'ELF': 'elf',
                        'EOS': 'eos',
                        'ETC': 'ethereumc',
                        'ETH': 'ethereum',
                        'ETP': 'metaverse',
                        'FUN': 'fun',
                        'GNT': 'golem',
                        'IOST': 'ios',
                        'IOTA': 'iota',
                        // https://github.com/ccxt/ccxt/issues/5833
                        'LEO': 'let', // ETH chain
                        // 'LEO': 'les', // EOS chain
                        'LINK': 'link',
                        'LRC': 'lrc',
                        'LTC': 'litecoin',
                        'LYM': 'lym',
                        'MANA': 'mna',
                        'MIT': 'mit',
                        'MKR': 'mkr',
                        'MTN': 'mtn',
                        'NEO': 'neo',
                        'ODE': 'ode',
                        'OMG': 'omisego',
                        'OMNI': 'mastercoin',
                        'QASH': 'qash',
                        'QTUM': 'qtum', // #1811
                        'RCN': 'rcn',
                        'RDN': 'rdn',
                        'REP': 'rep',
                        'REQ': 'req',
                        'RLC': 'rlc',
                        'SAN': 'santiment',
                        'SNGLS': 'sng',
                        'SNT': 'status',
                        'SPANK': 'spk',
                        'STORJ': 'stj',
                        'TNB': 'tnb',
                        'TRX': 'trx',
                        'TUSD': 'tsd',
                        'USD': 'wire',
                        'USDC': 'udc', // https://github.com/ccxt/ccxt/issues/5833
                        'UTK': 'utk',
                        'USDT': 'tetheruso', // Tether on Omni
                        // 'USDT': 'tetheruse', // Tether on ERC20
                        // 'USDT': 'tetherusl', // Tether on Liquid
                        // 'USDT': 'tetherusx', // Tether on Tron
                        // 'USDT': 'tetheruss', // Tether on EOS
                        'VEE': 'vee',
                        'WAX': 'wax',
                        'XLM': 'xlm',
                        'XMR': 'monero',
                        'XRP': 'ripple',
                        'XVG': 'xvg',
                        'YOYOW': 'yoyow',
                        'ZEC': 'zcash',
                        'ZRX': 'zrx',
                        'XTZ': 'xtz',
                    },
                    'orderTypes': {
                        'limit': 'exchange limit',
                        'market': 'exchange market',
                    },
                    'accountsByType': {
                        'spot': 'exchange',
                        'margin': 'trading',
                        'funding': 'deposit',
                        'exchange': 'exchange',
                        'trading': 'trading',
                        'deposit': 'deposit',
                        'derivatives': 'trading',
                    },
                },
            });
        }
    
        async fetchFundingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostAccountFees (params);
            const fees = response['withdraw'];
            const withdraw = {};
            const ids = Object.keys (fees);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const code = this.safeCurrencyCode (id);
                withdraw[code] = this.safeNumber (fees, id);
            }
            return {
                'info': response,
                'withdraw': withdraw,
                'deposit': withdraw,  // only for deposits of less than $1000
            };
        }
    
        async fetchTradingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostSummary (params);
            //
            //     {
            //         time: '2019-02-20T15:50:19.152000Z',
            //         trade_vol_30d: [
            //             {
            //                 curr: 'Total (USD)',
            //                 vol: 0,
            //                 vol_maker: 0,
            //                 vol_BFX: 0,
            //                 vol_BFX_maker: 0,
            //                 vol_ETHFX: 0,
            //                 vol_ETHFX_maker: 0
            //             }
            //         ],
            //         fees_funding_30d: {},
            //         fees_funding_total_30d: 0,
            //         fees_trading_30d: {},
            //         fees_trading_total_30d: 0,
            //         maker_fee: 0.001,
            //         taker_fee: 0.002
            //     }
            //
            return {
                'info': response,
                'maker': this.safeNumber (response, 'maker_fee'),
                'taker': this.safeNumber (response, 'taker_fee'),
            };
        }
    
        async fetchMarkets (params = {}) {
            const ids = await this.publicGetSymbols ();
            //
            //     [ "btcusd", "ltcusd", "ltcbtc" ]
            //
            const details = await this.publicGetSymbolsDetails ();
            //
            //     [
            //         {
            //             "pair":"btcusd",
            //             "price_precision":5,
            //             "initial_margin":"10.0",
            //             "minimum_margin":"5.0",
            //             "maximum_order_size":"2000.0",
            //             "minimum_order_size":"0.0002",
            //             "expiration":"NA",
            //             "margin":true
            //         },
            //     ]
            //
            const result = [];
            for (let i = 0; i < details.length; i++) {
                const market = details[i];
                let id = this.safeString (market, 'pair');
                if (!this.inArray (id, ids)) {
                    continue;
                }
                id = id.toUpperCase ();
                let baseId = undefined;
                let quoteId = undefined;
                if (id.indexOf (':') >= 0) {
                    const parts = id.split (':');
                    baseId = parts[0];
                    quoteId = parts[1];
                } else {
                    baseId = id.slice (0, 3);
                    quoteId = id.slice (3, 6);
                }
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'price': this.safeInteger (market, 'price_precision'),
                    // https://docs.bitfinex.com/docs/introduction#amount-precision
                    // The amount field allows up to 8 decimals.
                    // Anything exceeding this will be rounded to the 8th decimal.
                    'amount': 8,
                };
                const minAmountString = this.safeString (market, 'minimum_order_size');
                const maxAmountString = this.safeString (market, 'maximum_order_size');
                const limits = {
                    'amount': {
                        'min': this.parseNumber (minAmountString),
                        'max': this.parseNumber (maxAmountString),
                    },
                    'price': {
                        'min': this.parseNumber ('1e-8'),
                        'max': undefined,
                    },
                };
                limits['cost'] = {
                    'min': undefined,
                    'max': undefined,
                };
                const margin = this.safeValue (market, 'margin');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'type': 'spot',
                    'margin': margin,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                });
            }
            return result;
        }
    
        amountToPrecision (symbol, amount) {
            // https://docs.bitfinex.com/docs/introduction#amount-precision
            // The amount field allows up to 8 decimals.
            // Anything exceeding this will be rounded to the 8th decimal.
            return this.decimalToPrecision (amount, TRUNCATE, this.markets[symbol]['precision']['amount'], DECIMAL_PLACES);
        }
    
        priceToPrecision (symbol, price) {
            price = this.decimalToPrecision (price, ROUND, this.markets[symbol]['precision']['price'], this.precisionMode);
            // https://docs.bitfinex.com/docs/introduction#price-precision
            // The precision level of all trading prices is based on significant figures.
            // All pairs on Bitfinex use up to 5 significant digits and up to 8 decimals (e.g. 1.2345, 123.45, 1234.5, 0.00012345).
            // Prices submit with a precision larger than 5 will be cut by the API.
            return this.decimalToPrecision (price, TRUNCATE, 8, DECIMAL_PLACES);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const accountsByType = this.safeValue (this.options, 'accountsByType', {});
            const requestedType = this.safeString (params, 'type', 'exchange');
            const accountType = this.safeString (accountsByType, requestedType);
            if (accountType === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' fetchBalance type parameter must be one of ' + keys.join (', '));
            }
            const query = this.omit (params, 'type');
            const response = await this.privatePostBalances (query);
            //    [ { type: 'deposit',
            //        currency: 'btc',
            //        amount: '0.00116721',
            //        available: '0.00116721' },
            //      { type: 'exchange',
            //        currency: 'ust',
            //        amount: '0.0000002',
            //        available: '0.0000002' },
            //      { type: 'trading',
            //        currency: 'btc',
            //        amount: '0.0005',
            //        available: '0.0005' } ],
            const result = { 'info': response };
            const isDerivative = requestedType === 'derivatives';
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const type = this.safeString (balance, 'type');
                const currencyId = this.safeStringLower (balance, 'currency', '');
                const start = currencyId.length - 2;
                const isDerivativeCode = currencyId.slice (start) === 'f0';
                // this will only filter the derivative codes if the requestedType is 'derivatives'
                const derivativeCondition = (!isDerivative || isDerivativeCode);
                if ((accountType === type) && derivativeCondition) {
                    const code = this.safeCurrencyCode (currencyId);
                    // bitfinex had BCH previously, now it's BAB, but the old
                    // BCH symbol is kept for backward-compatibility
                    // we need a workaround here so that the old BCH balance
                    // would not override the new BAB balance (BAB is unified to BCH)
                    // https://github.com/ccxt/ccxt/issues/4989
                    if (!(code in result)) {
                        const account = this.account ();
                        account['free'] = this.safeString (balance, 'available');
                        account['total'] = this.safeString (balance, 'amount');
                        result[code] = account;
                    }
                }
            }
            return this.parseBalance (result);
        }
    
        async transfer (code, amount, fromAccount, toAccount, params = {}) {
            // transferring between derivatives wallet and regular wallet is not documented in their API
            // however we support it in CCXT (from just looking at web inspector)
            await this.loadMarkets ();
            const accountsByType = this.safeValue (this.options, 'accountsByType', {});
            const fromId = this.safeString (accountsByType, fromAccount);
            if (fromId === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' transfer fromAccount must be one of ' + keys.join (', '));
            }
            const toId = this.safeString (accountsByType, toAccount);
            if (toId === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' transfer toAccount must be one of ' + keys.join (', '));
            }
            const currency = this.currency (code);
            const fromCurrencyId = this.convertDerivativesId (currency['id'], fromAccount);
            const toCurrencyId = this.convertDerivativesId (currency['id'], toAccount);
            const requestedAmount = this.currencyToPrecision (code, amount);
            const request = {
                'amount': requestedAmount,
                'currency': fromCurrencyId,
                'currency_to': toCurrencyId,
                'walletfrom': fromId,
                'walletto': toId,
            };
            const response = await this.privatePostTransfer (this.extend (request, params));
            // [
            //   {
            //     status: 'success',
            //     message: '0.0001 Bitcoin transfered from Margin to Exchange'
            //   }
            // ]
            const result = this.safeValue (response, 0);
            const status = this.safeString (result, 'status');
            const message = this.safeString (result, 'message');
            if (message === undefined) {
                throw new ExchangeError (this.id + ' transfer failed');
            }
            // [{"status":"error","message":"Momentary balance check. Please wait few seconds and try the transfer again."}]
            if (status === 'error') {
                this.throwExactlyMatchedException (this.exceptions['exact'], message, this.id + ' ' + message);
                throw new ExchangeError (this.id + ' ' + message);
            }
            return {
                'info': response,
                'status': status,
                'amount': requestedAmount,
                'code': code,
                'fromAccount': fromAccount,
                'toAccount': toAccount,
                'timestamp': undefined,
                'datetime': undefined,
            };
        }
    
        convertDerivativesId (currencyId, type) {
            const start = currencyId.length - 2;
            const isDerivativeCode = currencyId.slice (start) === 'F0';
            if ((type !== 'derivatives' && type !== 'trading' && type !== 'margin') && isDerivativeCode) {
                currencyId = currencyId.slice (0, start);
            } else if (type === 'derivatives' && !isDerivativeCode) {
                currencyId = currencyId + 'F0';
            }
            return currencyId;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            if (limit !== undefined) {
                request['limit_bids'] = limit;
                request['limit_asks'] = limit;
            }
            const response = await this.publicGetBookSymbol (this.extend (request, params));
            return this.parseOrderBook (response, symbol, undefined, 'bids', 'asks', 'price', 'amount');
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTickers (params);
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const ticker = this.parseTicker (response[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const ticker = await this.publicGetPubtickerSymbol (this.extend (request, params));
            return this.parseTicker (ticker, market);
        }
    
        parseTicker (ticker, market = undefined) {
            let timestamp = this.safeNumber (ticker, 'timestamp');
            if (timestamp !== undefined) {
                timestamp *= 1000;
            }
            timestamp = parseInt (timestamp);
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            } else if ('pair' in ticker) {
                const marketId = this.safeString (ticker, 'pair');
                if (marketId !== undefined) {
                    if (marketId in this.markets_by_id) {
                        market = this.markets_by_id[marketId];
                        symbol = market['symbol'];
                    } else {
                        const baseId = marketId.slice (0, 3);
                        const quoteId = marketId.slice (3, 6);
                        const base = this.safeCurrencyCode (baseId);
                        const quote = this.safeCurrencyCode (quoteId);
                        symbol = base + '/' + quote;
                    }
                }
            }
            const last = this.safeNumber (ticker, 'last_price');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': this.safeNumber (ticker, 'mid'),
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            }, market);
        }
    
        parseTrade (trade, market) {
            const id = this.safeString (trade, 'tid');
            const timestamp = this.safeTimestamp (trade, 'timestamp');
            const type = undefined;
            const side = this.safeStringLower (trade, 'type');
            const orderId = this.safeString (trade, 'order_id');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let fee = undefined;
            if ('fee_amount' in trade) {
                const feeCost = -this.safeNumber (trade, 'fee_amount');
                const feeCurrencyId = this.safeString (trade, 'fee_currency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': market['symbol'],
                'type': type,
                'order': orderId,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = 50, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'limit_trades': limit,
            };
            if (since !== undefined) {
                request['timestamp'] = parseInt (since / 1000);
            }
            const response = await this.publicGetTradesSymbol (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a `symbol` argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit_trades'] = limit;
            }
            if (since !== undefined) {
                request['timestamp'] = parseInt (since / 1000);
            }
            const response = await this.privatePostMytrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
                'side': side,
                'amount': this.amountToPrecision (symbol, amount),
                'type': this.safeString (this.options['orderTypes'], type, type),
                'ocoorder': false,
                'buy_price_oco': 0,
                'sell_price_oco': 0,
            };
            if (type === 'market') {
                request['price'] = this.nonce ().toString ();
            } else {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePostOrderNew (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async editOrder (id, symbol, type, side, amount = undefined, price = undefined, params = {}) {
            await this.loadMarkets ();
            const order = {
                'order_id': parseInt (id),
            };
            if (price !== undefined) {
                order['price'] = this.priceToPrecision (symbol, price);
            }
            if (amount !== undefined) {
                order['amount'] = this.numberToString (amount);
            }
            if (symbol !== undefined) {
                order['symbol'] = this.marketId (symbol);
            }
            if (side !== undefined) {
                order['side'] = side;
            }
            if (type !== undefined) {
                order['type'] = this.safeString (this.options['orderTypes'], type, type);
            }
            const response = await this.privatePostOrderCancelReplace (this.extend (order, params));
            return this.parseOrder (response);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': parseInt (id),
            };
            return await this.privatePostOrderCancel (this.extend (request, params));
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            return await this.privatePostOrderCancelAll (params);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //           id: 57334010955,
            //           cid: 1611584840966,
            //           cid_date: null,
            //           gid: null,
            //           symbol: 'ltcbtc',
            //           exchange: null,
            //           price: '0.0042125',
            //           avg_execution_price: '0.0042097',
            //           side: 'sell',
            //           type: 'exchange market',
            //           timestamp: '1611584841.0',
            //           is_live: false,
            //           is_cancelled: false,
            //           is_hidden: 0,
            //           oco_order: 0,
            //           was_forced: false,
            //           original_amount: '0.205176',
            //           remaining_amount: '0.0',
            //           executed_amount: '0.205176',
            //           src: 'web'
            //     }
            //
            const side = this.safeString (order, 'side');
            const open = this.safeValue (order, 'is_live');
            const canceled = this.safeValue (order, 'is_cancelled');
            let status = undefined;
            if (open) {
                status = 'open';
            } else if (canceled) {
                status = 'canceled';
            } else {
                status = 'closed';
            }
            const marketId = this.safeStringUpper (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            let orderType = this.safeString (order, 'type', '');
            const exchange = orderType.indexOf ('exchange ') >= 0;
            if (exchange) {
                const parts = order['type'].split (' ');
                orderType = parts[1];
            }
            const timestamp = this.safeTimestamp (order, 'timestamp');
            const id = this.safeString (order, 'id');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': orderType,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': this.safeNumber (order, 'price'),
                'stopPrice': undefined,
                'average': this.safeNumber (order, 'avg_execution_price'),
                'amount': this.safeNumber (order, 'original_amount'),
                'remaining': this.safeNumber (order, 'remaining_amount'),
                'filled': this.safeNumber (order, 'executed_amount'),
                'status': status,
                'fee': undefined,
                'cost': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (symbol !== undefined) {
                if (!(symbol in this.markets)) {
                    throw new ExchangeError (this.id + ' has no symbol ' + symbol);
                }
            }
            const response = await this.privatePostOrders (params);
            let orders = this.parseOrders (response, undefined, since, limit);
            if (symbol !== undefined) {
                orders = this.filterBy (orders, 'symbol', symbol);
            }
            return orders;
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privatePostOrdersHist (this.extend (request, params));
            let orders = this.parseOrders (response, undefined, since, limit);
            if (symbol !== undefined) {
                orders = this.filterBy (orders, 'symbol', symbol);
            }
            orders = this.filterByArray (orders, 'status', [ 'closed', 'canceled' ], false);
            return orders;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': parseInt (id),
            };
            const response = await this.privatePostOrderStatus (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1457539800000,
            //         0.02594,
            //         0.02594,
            //         0.02594,
            //         0.02594,
            //         0.1
            //     ]
            //
            return [
                this.safeInteger (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (limit === undefined) {
                limit = 100;
            }
            const market = this.market (symbol);
            const v2id = 't' + market['id'];
            const request = {
                'symbol': v2id,
                'timeframe': this.timeframes[timeframe],
                'sort': 1,
                'limit': limit,
            };
            if (since !== undefined) {
                request['start'] = since;
            }
            const response = await this.v2GetCandlesTradeTimeframeSymbolHist (this.extend (request, params));
            //
            //     [
            //         [1457539800000,0.02594,0.02594,0.02594,0.02594,0.1],
            //         [1457547300000,0.02577,0.02577,0.02577,0.02577,0.01],
            //         [1457550240000,0.0255,0.0253,0.0255,0.0252,3.2640000000000002],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        getCurrencyName (code) {
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            if (code in this.options['currencyNames']) {
                return this.options['currencyNames'][code];
            }
            throw new NotSupported (this.id + ' ' + code + ' not supported for withdrawal');
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const request = {
                'renew': 1,
            };
            const response = await this.fetchDepositAddress (code, this.extend (request, params));
            return response;
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            const name = this.getCurrencyName (code);
            const request = {
                'method': name,
                'wallet_name': 'exchange',
                'renew': 0, // a value of 1 will generate a new address
            };
            const response = await this.privatePostDepositNew (this.extend (request, params));
            let address = this.safeValue (response, 'address');
            let tag = undefined;
            if ('address_pool' in response) {
                tag = address;
                address = response['address_pool'];
            }
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currencyId = this.safeString (params, 'currency');
            const query = this.omit (params, 'currency');
            let currency = undefined;
            if (currencyId === undefined) {
                if (code === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchTransactions() requires a currency `code` argument or a `currency` parameter');
                } else {
                    currency = this.currency (code);
                    currencyId = currency['id'];
                }
            }
            query['currency'] = currencyId;
            if (since !== undefined) {
                query['since'] = parseInt (since / 1000);
            }
            const response = await this.privatePostHistoryMovements (this.extend (query, params));
            //
            //     [
            //         {
            //             "id":581183,
            //             "txid": 123456,
            //             "currency":"BTC",
            //             "method":"BITCOIN",
            //             "type":"WITHDRAWAL",
            //             "amount":".01",
            //             "description":"3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ, offchain transfer ",
            //             "address":"3QXYWgRGX2BPYBpUDBssGbeWEa5zq6snBZ",
            //             "status":"COMPLETED",
            //             "timestamp":"1443833327.0",
            //             "timestamp_created": "1443833327.1",
            //             "fee": 0.1,
            //         }
            //     ]
            //
            return this.parseTransactions (response, currency, since, limit);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // crypto
            //
            //     {
            //         "id": 12042490,
            //         "fee": "-0.02",
            //         "txid": "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
            //         "type": "DEPOSIT",
            //         "amount": "2099.849999",
            //         "method": "RIPPLE",
            //         "status": "COMPLETED",
            //         "address": "2505189261",
            //         "currency": "XRP",
            //         "timestamp": "1551730524.0",
            //         "description": "EA5B5A66000B66855865EFF2494D7C8D1921FCBE996482157EBD749F2C85E13D",
            //         "timestamp_created": "1551730523.0"
            //     }
            //
            // fiat
            //
            //     {
            //         "id": 12725095,
            //         "fee": "-60.0",
            //         "txid": null,
            //         "type": "WITHDRAWAL",
            //         "amount": "9943.0",
            //         "method": "WIRE",
            //         "status": "SENDING",
            //         "address": null,
            //         "currency": "EUR",
            //         "timestamp": "1561802484.0",
            //         "description": "Name: bob, AccountAddress: some address, Account: someaccountno, Bank: bank address, SWIFT: foo, Country: UK, Details of Payment: withdrawal name, Intermediary Bank Name: , Intermediary Bank Address: , Intermediary Bank City: , Intermediary Bank Country: , Intermediary Bank Account: , Intermediary Bank SWIFT: , Fee: -60.0",
            //         "timestamp_created": "1561716066.0"
            //     }
            //
            const timestamp = this.safeTimestamp (transaction, 'timestamp_created');
            const updated = this.safeTimestamp (transaction, 'timestamp');
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const type = this.safeStringLower (transaction, 'type'); // DEPOSIT or WITHDRAWAL
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            let feeCost = this.safeNumber (transaction, 'fee');
            if (feeCost !== undefined) {
                feeCost = Math.abs (feeCost);
            }
            return {
                'info': transaction,
                'id': this.safeString (transaction, 'id'),
                'txid': this.safeString (transaction, 'txid'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': this.safeString (transaction, 'address'), // todo: this is actually the tag for XRP transfers (the address is missing)
                'tag': undefined, // refix it properly for the tag from description
                'type': type,
                'amount': this.safeNumber (transaction, 'amount'),
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': {
                    'currency': code,
                    'cost': feeCost,
                    'rate': undefined,
                },
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'SENDING': 'pending',
                'CANCELED': 'canceled',
                'ZEROCONFIRMED': 'failed', // ZEROCONFIRMED happens e.g. in a double spend attempt (I had one in my movements!)
                'COMPLETED': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            const name = this.getCurrencyName (code);
            const request = {
                'withdraw_type': name,
                'walletselected': 'exchange',
                'amount': this.numberToString (amount),
                'address': address,
            };
            if (tag !== undefined) {
                request['payment_id'] = tag;
            }
            const responses = await this.privatePostWithdraw (this.extend (request, params));
            const response = responses[0];
            const id = this.safeString (response, 'withdrawal_id');
            const message = this.safeString (response, 'message');
            const errorMessage = this.findBroadlyMatchedKey (this.exceptions['broad'], message);
            if (id === 0) {
                if (errorMessage !== undefined) {
                    const ExceptionClass = this.exceptions['broad'][errorMessage];
                    throw new ExceptionClass (this.id + ' ' + message);
                }
                throw new ExchangeError (this.id + ' withdraw returned an id of zero: ' + this.json (response));
            }
            return {
                'info': response,
                'id': id,
            };
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostPositions (params);
            //
            //     [
            //         {
            //             "id":943715,
            //             "symbol":"btcusd",
            //             "status":"ACTIVE",
            //             "base":"246.94",
            //             "amount":"1.0",
            //             "timestamp":"1444141857.0",
            //             "swap":"0.0",
            //             "pl":"-2.22042"
            //         }
            //     ]
            //
            // todo unify parsePosition/parsePositions
            return response;
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + this.implodeParams (path, params);
            if (api === 'v2') {
                request = '/' + api + request;
            } else {
                request = '/' + this.version + request;
            }
            let query = this.omit (params, this.extractParams (path));
            let url = this.urls['api'][api] + request;
            if ((api === 'public') || (path.indexOf ('/hist') >= 0)) {
                if (Object.keys (query).length) {
                    const suffix = '?' + this.urlencode (query);
                    url += suffix;
                    request += suffix;
                }
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                query = this.extend ({
                    'nonce': nonce.toString (),
                    'request': request,
                }, query);
                body = this.json (query);
                const payload = this.stringToBase64 (body);
                const secret = this.encode (this.secret);
                const signature = this.hmac (payload, secret, 'sha384');
                headers = {
                    'X-BFX-APIKEY': this.apiKey,
                    'X-BFX-PAYLOAD': this.decode (payload),
                    'X-BFX-SIGNATURE': signature,
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            if (code >= 400) {
                if (body[0] === '{') {
                    const feedback = this.id + ' ' + body;
                    const message = this.safeString2 (response, 'message', 'error');
                    this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                    this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                    throw new ExchangeError (feedback); // unknown message
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],34:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const bitfinex = require ('./bitfinex.js');
    const { ExchangeError, InvalidAddress, ArgumentsRequired, InsufficientFunds, AuthenticationError, OrderNotFound, InvalidOrder, BadRequest, InvalidNonce, BadSymbol, OnMaintenance, NotSupported, PermissionDenied, ExchangeNotAvailable } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class bitfinex2 extends bitfinex {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitfinex2',
                'name': 'Bitfinex',
                'countries': [ 'VG' ],
                'version': 'v2',
                'certified': false,
                'pro': false,
                // new metainfo interface
                'has': {
                    'CORS': false,
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createDepositAddress': true,
                    'createLimitOrder': true,
                    'createMarketOrder': true,
                    'createOrder': true,
                    'deposit': false,
                    'editOrder': false,
                    'fetchBalance': true,
                    'fetchClosedOrder': true,
                    'fetchClosedOrders': false,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchFundingFees': false,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrder': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': false,
                    'fetchOrderTrades': true,
                    'fetchStatus': true,
                    'fetchTickers': true,
                    'fetchTradingFee': false,
                    'fetchTradingFees': false,
                    'fetchTransactions': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '3h': '3h',
                    '4h': '4h',
                    '6h': '6h',
                    '12h': '12h',
                    '1d': '1D',
                    '1w': '7D',
                    '2w': '14D',
                    '1M': '1M',
                },
                'rateLimit': 1500,
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766244-e328a50c-5ed2-11e7-947b-041416579bb3.jpg',
                    'api': {
                        'v1': 'https://api.bitfinex.com',
                        'public': 'https://api-pub.bitfinex.com',
                        'private': 'https://api.bitfinex.com',
                    },
                    'www': 'https://www.bitfinex.com',
                    'doc': [
                        'https://docs.bitfinex.com/v2/docs/',
                        'https://github.com/bitfinexcom/bitfinex-api-node',
                    ],
                    'fees': 'https://www.bitfinex.com/fees',
                },
                'api': {
                    'v1': {
                        'get': [
                            'symbols',
                            'symbols_details',
                        ],
                    },
                    'public': {
                        'get': [
                            'conf/{config}',
                            'conf/pub:{action}:{object}',
                            'conf/pub:{action}:{object}:{detail}',
                            'conf/pub:map:{object}',
                            'conf/pub:map:{object}:{detail}',
                            'conf/pub:map:currency:{detail}',
                            'conf/pub:map:currency:sym', // maps symbols to their API symbols, BAB > BCH
                            'conf/pub:map:currency:label', // verbose friendly names, BNT > Bancor
                            'conf/pub:map:currency:unit', // maps symbols to unit of measure where applicable
                            'conf/pub:map:currency:undl', // maps derivatives symbols to their underlying currency
                            'conf/pub:map:currency:pool', // maps symbols to underlying network/protocol they operate on
                            'conf/pub:map:currency:explorer', // maps symbols to their recognised block explorer URLs
                            'conf/pub:map:currency:tx:fee', // maps currencies to their withdrawal fees https://github.com/ccxt/ccxt/issues/7745
                            'conf/pub:map:tx:method',
                            'conf/pub:list:{object}',
                            'conf/pub:list:{object}:{detail}',
                            'conf/pub:list:currency',
                            'conf/pub:list:pair:exchange',
                            'conf/pub:list:pair:margin',
                            'conf/pub:list:pair:futures',
                            'conf/pub:list:competitions',
                            'conf/pub:info:{object}',
                            'conf/pub:info:{object}:{detail}',
                            'conf/pub:info:pair',
                            'conf/pub:info:tx:status', // [ deposit, withdrawal ] statuses 1 = active, 0 = maintenance
                            'conf/pub:fees',
                            'platform/status',
                            'tickers',
                            'ticker/{symbol}',
                            'trades/{symbol}/hist',
                            'book/{symbol}/{precision}',
                            'book/{symbol}/P0',
                            'book/{symbol}/P1',
                            'book/{symbol}/P2',
                            'book/{symbol}/P3',
                            'book/{symbol}/R0',
                            'stats1/{key}:{size}:{symbol}:{side}/{section}',
                            'stats1/{key}:{size}:{symbol}:{side}/last',
                            'stats1/{key}:{size}:{symbol}:{side}/hist',
                            'stats1/{key}:{size}:{symbol}/{section}',
                            'stats1/{key}:{size}:{symbol}/last',
                            'stats1/{key}:{size}:{symbol}/hist',
                            'stats1/{key}:{size}:{symbol}:long/last',
                            'stats1/{key}:{size}:{symbol}:long/hist',
                            'stats1/{key}:{size}:{symbol}:short/last',
                            'stats1/{key}:{size}:{symbol}:short/hist',
                            'candles/trade:{timeframe}:{symbol}:{period}/{section}',
                            'candles/trade:{timeframe}:{symbol}/{section}',
                            'candles/trade:{timeframe}:{symbol}/last',
                            'candles/trade:{timeframe}:{symbol}/hist',
                            'status/{type}',
                            'status/deriv',
                            'liquidations/hist',
                            'rankings/{key}:{timeframe}:{symbol}/{section}',
                            'rankings/{key}:{timeframe}:{symbol}/hist',
                            'pulse/hist',
                            'pulse/profile/{nickname}',
                            'funding/stats/{symbol}/hist',
                        ],
                        'post': [
                            'calc/trade/avg',
                            'calc/fx',
                        ],
                    },
                    'private': {
                        'post': [
                            // 'auth/r/orders/{symbol}/new', // outdated
                            // 'auth/r/stats/perf:{timeframe}/hist', // outdated
                            'auth/r/wallets',
                            'auth/r/wallets/hist',
                            'auth/r/orders',
                            'auth/r/orders/{symbol}',
                            'auth/w/order/submit',
                            'auth/w/order/update',
                            'auth/w/order/cancel',
                            'auth/w/order/multi',
                            'auth/w/order/cancel/multi',
                            'auth/r/orders/{symbol}/hist',
                            'auth/r/orders/hist',
                            'auth/r/order/{symbol}:{id}/trades',
                            'auth/r/trades/{symbol}/hist',
                            'auth/r/trades/hist',
                            'auth/r/ledgers/{currency}/hist',
                            'auth/r/ledgers/hist',
                            'auth/r/info/margin/{key}',
                            'auth/r/info/margin/base',
                            'auth/r/info/margin/sym_all',
                            'auth/r/positions',
                            'auth/w/position/claim',
                            'auth/r/positions/hist',
                            'auth/r/positions/audit',
                            'auth/r/positions/snap',
                            'auth/w/deriv/collateral/set',
                            'auth/w/deriv/collateral/limits',
                            'auth/r/funding/offers',
                            'auth/r/funding/offers/{symbol}',
                            'auth/w/funding/offer/submit',
                            'auth/w/funding/offer/cancel',
                            'auth/w/funding/offer/cancel/all',
                            'auth/w/funding/close',
                            'auth/w/funding/auto',
                            'auth/w/funding/keep',
                            'auth/r/funding/offers/{symbol}/hist',
                            'auth/r/funding/offers/hist',
                            'auth/r/funding/loans',
                            'auth/r/funding/loans/hist',
                            'auth/r/funding/loans/{symbol}',
                            'auth/r/funding/loans/{symbol}/hist',
                            'auth/r/funding/credits',
                            'auth/r/funding/credits/hist',
                            'auth/r/funding/credits/{symbol}',
                            'auth/r/funding/credits/{symbol}/hist',
                            'auth/r/funding/trades/{symbol}/hist',
                            'auth/r/funding/trades/hist',
                            'auth/r/info/funding/{key}',
                            'auth/r/info/user',
                            'auth/r/logins/hist',
                            'auth/w/transfer',
                            'auth/w/deposit/address',
                            'auth/w/deposit/invoice',
                            'auth/w/withdraw',
                            'auth/r/movements/{currency}/hist',
                            'auth/r/movements/hist',
                            'auth/r/alerts',
                            'auth/w/alert/set',
                            'auth/w/alert/price:{symbol}:{price}/del',
                            'auth/w/alert/{type}:{symbol}:{price}/del',
                            'auth/calc/order/avail',
                            'auth/w/settings/set',
                            'auth/r/settings',
                            'auth/w/settings/del',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'percentage': true,
                        'tierBased': true,
                        'maker': this.parseNumber ('0.001'),
                        'taker': this.parseNumber ('0.002'),
                        'tiers': {
                            'taker': [
                                [this.parseNumber ('0'), this.parseNumber ('0.002')],
                                [this.parseNumber ('500000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('1000000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('2500000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('5000000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('7500000'), this.parseNumber ('0.002')],
                                [this.parseNumber ('10000000'), this.parseNumber ('0.0018')],
                                [this.parseNumber ('15000000'), this.parseNumber ('0.0016')],
                                [this.parseNumber ('20000000'), this.parseNumber ('0.0014')],
                                [this.parseNumber ('25000000'), this.parseNumber ('0.0012')],
                                [this.parseNumber ('30000000'), this.parseNumber ('0.001')],
                            ],
                            'maker': [
                                [this.parseNumber ('0'), this.parseNumber ('0.001')],
                                [this.parseNumber ('500000'), this.parseNumber ('0.0008')],
                                [this.parseNumber ('1000000'), this.parseNumber ('0.0006')],
                                [this.parseNumber ('2500000'), this.parseNumber ('0.0004')],
                                [this.parseNumber ('5000000'), this.parseNumber ('0.0002')],
                                [this.parseNumber ('7500000'), this.parseNumber ('0')],
                                [this.parseNumber ('10000000'), this.parseNumber ('0')],
                                [this.parseNumber ('15000000'), this.parseNumber ('0')],
                                [this.parseNumber ('20000000'), this.parseNumber ('0')],
                                [this.parseNumber ('25000000'), this.parseNumber ('0')],
                                [this.parseNumber ('30000000'), this.parseNumber ('0')],
                            ],
                        },
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'options': {
                    'precision': 'R0', // P0, P1, P2, P3, P4, R0
                    // convert 'EXCHANGE MARKET' to lowercase 'market'
                    // convert 'EXCHANGE LIMIT' to lowercase 'limit'
                    // everything else remains uppercase
                    'exchangeTypes': {
                        // 'MARKET': undefined,
                        'EXCHANGE MARKET': 'market',
                        // 'LIMIT': undefined,
                        'EXCHANGE LIMIT': 'limit',
                        // 'STOP': undefined,
                        // 'EXCHANGE STOP': undefined,
                        // 'TRAILING STOP': undefined,
                        // 'EXCHANGE TRAILING STOP': undefined,
                        // 'FOK': undefined,
                        // 'EXCHANGE FOK': undefined,
                        // 'STOP LIMIT': undefined,
                        // 'EXCHANGE STOP LIMIT': undefined,
                        // 'IOC': undefined,
                        // 'EXCHANGE IOC': undefined,
                    },
                    // convert 'market' to 'EXCHANGE MARKET'
                    // convert 'limit' 'EXCHANGE LIMIT'
                    // everything else remains as is
                    'orderTypes': {
                        'market': 'EXCHANGE MARKET',
                        'limit': 'EXCHANGE LIMIT',
                    },
                    'fiat': {
                        'USD': 'USD',
                        'EUR': 'EUR',
                        'JPY': 'JPY',
                        'GBP': 'GBP',
                    },
                    // actually the correct names unlike the v1
                    // we don't want to extend this with accountsByType in v1
                    'v2AccountsByType': {
                        'spot': 'exchange',
                        'exchange': 'exchange',
                        'funding': 'funding',
                        'margin': 'margin',
                        'derivatives': 'margin',
                    },
                },
                'exceptions': {
                    'exact': {
                        '10001': PermissionDenied, // api_key: permission invalid (#10001)
                        '10020': BadRequest,
                        '10100': AuthenticationError,
                        '10114': InvalidNonce,
                        '20060': OnMaintenance,
                        // {"code":503,"error":"temporarily_unavailable","error_description":"Sorry, the service is temporarily unavailable. See https://www.bitfinex.com/ for more info."}
                        'temporarily_unavailable': ExchangeNotAvailable,
                    },
                    'broad': {
                        'address': InvalidAddress,
                        'available balance is only': InsufficientFunds,
                        'not enough exchange balance': InsufficientFunds,
                        'Order not found': OrderNotFound,
                        'symbol: invalid': BadSymbol,
                        'Invalid order': InvalidOrder,
                    },
                },
            });
        }
    
        isFiat (code) {
            return (code in this.options['fiat']);
        }
    
        getCurrencyId (code) {
            return 'f' + code;
        }
    
        async fetchStatus (params = {}) {
            //
            //    [1] // operative
            //    [0] // maintenance
            //
            const response = await this.publicGetPlatformStatus (params);
            const status = this.safeInteger (response, 0);
            const formattedStatus = (status === 1) ? 'ok' : 'maintenance';
            this.status = this.extend (this.status, {
                'status': formattedStatus,
                'updated': this.milliseconds (),
            });
            return this.status;
        }
    
        async fetchMarkets (params = {}) {
            // todo drop v1 in favor of v2 configs
            // pub:list:pair:exchange,pub:list:pair:margin,pub:list:pair:futures,pub:info:pair
            const v2response = await this.publicGetConfPubListPairFutures (params);
            const v1response = await this.v1GetSymbolsDetails (params);
            const futuresMarketIds = this.safeValue (v2response, 0, []);
            const result = [];
            for (let i = 0; i < v1response.length; i++) {
                const market = v1response[i];
                let id = this.safeStringUpper (market, 'pair');
                let spot = true;
                if (this.inArray (id, futuresMarketIds)) {
                    spot = false;
                }
                const futures = !spot;
                const type = spot ? 'spot' : 'futures';
                let baseId = undefined;
                let quoteId = undefined;
                if (id.indexOf (':') >= 0) {
                    const parts = id.split (':');
                    baseId = parts[0];
                    quoteId = parts[1];
                } else {
                    baseId = id.slice (0, 3);
                    quoteId = id.slice (3, 6);
                }
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                id = 't' + id;
                baseId = this.getCurrencyId (baseId);
                quoteId = this.getCurrencyId (quoteId);
                const precision = {
                    'price': this.safeInteger (market, 'price_precision'),
                    'amount': 8, // https://github.com/ccxt/ccxt/issues/7310
                };
                const minOrderSizeString = this.safeString (market, 'minimum_order_size');
                const maxOrderSizeString = this.safeString (market, 'maximum_order_size');
                const limits = {
                    'amount': {
                        'min': this.parseNumber (minOrderSizeString),
                        'max': this.parseNumber (maxOrderSizeString),
                    },
                    'price': {
                        'min': this.parseNumber ('1e-8'),
                        'max': undefined,
                    },
                };
                limits['cost'] = {
                    'min': undefined,
                    'max': undefined,
                };
                const margin = this.safeValue (market, 'margin');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                    'type': type,
                    'swap': false,
                    'spot': spot,
                    'margin': margin,
                    'futures': futures,
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const labels = [
                'pub:list:currency',
                'pub:map:currency:sym', // maps symbols to their API symbols, BAB > BCH
                'pub:map:currency:label', // verbose friendly names, BNT > Bancor
                'pub:map:currency:unit', // maps symbols to unit of measure where applicable
                'pub:map:currency:undl', // maps derivatives symbols to their underlying currency
                'pub:map:currency:pool', // maps symbols to underlying network/protocol they operate on
                'pub:map:currency:explorer', // maps symbols to their recognised block explorer URLs
                'pub:map:currency:tx:fee', // maps currencies to their withdrawal fees https://github.com/ccxt/ccxt/issues/7745
            ];
            const config = labels.join (',');
            const request = {
                'config': config,
            };
            const response = await this.publicGetConfConfig (this.extend (request, params));
            //
            //     [
            //
            //         a list of symbols
            //         ["AAA","ABS","ADA"],
            //
            //         // sym
            //         // maps symbols to their API symbols, BAB > BCH
            //         [
            //             [ 'BAB', 'BCH' ],
            //             [ 'CNHT', 'CNHt' ],
            //             [ 'DSH', 'DASH' ],
            //             [ 'IOT', 'IOTA' ],
            //             [ 'LES', 'LEO-EOS' ],
            //             [ 'LET', 'LEO-ERC20' ],
            //             [ 'STJ', 'STORJ' ],
            //             [ 'TSD', 'TUSD' ],
            //             [ 'UDC', 'USDC' ],
            //             [ 'USK', 'USDK' ],
            //             [ 'UST', 'USDt' ],
            //             [ 'USTF0', 'USDt0' ],
            //             [ 'XCH', 'XCHF' ],
            //             [ 'YYW', 'YOYOW' ],
            //             // ...
            //         ],
            //         // label
            //         // verbose friendly names, BNT > Bancor
            //         [
            //             [ 'BAB', 'Bitcoin Cash' ],
            //             [ 'BCH', 'Bitcoin Cash' ],
            //             [ 'LEO', 'Unus Sed LEO' ],
            //             [ 'LES', 'Unus Sed LEO (EOS)' ],
            //             [ 'LET', 'Unus Sed LEO (ERC20)' ],
            //             // ...
            //         ],
            //         // unit
            //         // maps symbols to unit of measure where applicable
            //         [
            //             [ 'IOT', 'Mi|MegaIOTA' ],
            //         ],
            //         // undl
            //         // maps derivatives symbols to their underlying currency
            //         [
            //             [ 'USTF0', 'UST' ],
            //             [ 'BTCF0', 'BTC' ],
            //             [ 'ETHF0', 'ETH' ],
            //         ],
            //         // pool
            //         // maps symbols to underlying network/protocol they operate on
            //         [
            //             [ 'SAN', 'ETH' ], [ 'OMG', 'ETH' ], [ 'AVT', 'ETH' ], [ 'EDO', 'ETH' ],
            //             [ 'ESS', 'ETH' ], [ 'ATD', 'EOS' ], [ 'ADD', 'EOS' ], [ 'MTO', 'EOS' ],
            //             [ 'PNK', 'ETH' ], [ 'BAB', 'BCH' ], [ 'WLO', 'XLM' ], [ 'VLD', 'ETH' ],
            //             [ 'BTT', 'TRX' ], [ 'IMP', 'ETH' ], [ 'SCR', 'ETH' ], [ 'GNO', 'ETH' ],
            //             // ...
            //         ],
            //         // explorer
            //         // maps symbols to their recognised block explorer URLs
            //         [
            //             [
            //                 'AIO',
            //                 [
            //                     "https://mainnet.aion.network",
            //                     "https://mainnet.aion.network/#/account/VAL",
            //                     "https://mainnet.aion.network/#/transaction/VAL"
            //                 ]
            //             ],
            //             // ...
            //         ],
            //         // fee
            //         // maps currencies to their withdrawal fees
            //         [
            //             ["AAA",[0,0]],
            //             ["ABS",[0,131.3]],
            //             ["ADA",[0,0.3]],
            //         ],
            //     ]
            //
            const indexed = {
                'sym': this.indexBy (this.safeValue (response, 1, []), 0),
                'label': this.indexBy (this.safeValue (response, 2, []), 0),
                'unit': this.indexBy (this.safeValue (response, 3, []), 0),
                'undl': this.indexBy (this.safeValue (response, 4, []), 0),
                'pool': this.indexBy (this.safeValue (response, 5, []), 0),
                'explorer': this.indexBy (this.safeValue (response, 6, []), 0),
                'fees': this.indexBy (this.safeValue (response, 7, []), 0),
            };
            const ids = this.safeValue (response, 0, []);
            const result = {};
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const code = this.safeCurrencyCode (id);
                const label = this.safeValue (indexed['label'], id, []);
                const name = this.safeString (label, 1);
                const pool = this.safeValue (indexed['pool'], id, []);
                const type = this.safeString (pool, 1);
                const feeValues = this.safeValue (indexed['fees'], id, []);
                const fees = this.safeValue (feeValues, 1, []);
                const fee = this.safeNumber (fees, 1);
                const undl = this.safeValue (indexed['undl'], id, []);
                const precision = 8; // default precision, todo: fix "magic constants"
                const fid = 'f' + id;
                result[code] = {
                    'id': fid,
                    'code': code,
                    'info': [ id, label, pool, feeValues, undl ],
                    'type': type,
                    'name': name,
                    'active': true,
                    'fee': fee,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': 1 / Math.pow (10, precision),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': fee,
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            // this api call does not return the 'used' amount - use the v1 version instead (which also returns zero balances)
            // there is a difference between this and the v1 api, namely trading wallet is called margin in v2
            await this.loadMarkets ();
            const accountsByType = this.safeValue (this.options, 'v2AccountsByType', {});
            const requestedType = this.safeString (params, 'type', 'exchange');
            const accountType = this.safeString (accountsByType, requestedType);
            if (accountType === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' fetchBalance type parameter must be one of ' + keys.join (', '));
            }
            const isDerivative = requestedType === 'derivatives';
            const query = this.omit (params, 'type');
            const response = await this.privatePostAuthRWallets (query);
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const type = this.safeString (balance, 0);
                const currencyId = this.safeStringLower (balance, 1, '');
                const start = currencyId.length - 2;
                const isDerivativeCode = currencyId.slice (start) === 'f0';
                // this will only filter the derivative codes if the requestedType is 'derivatives'
                const derivativeCondition = (!isDerivative || isDerivativeCode);
                if ((accountType === type) && derivativeCondition) {
                    const code = this.safeCurrencyCode (currencyId);
                    const account = this.account ();
                    account['total'] = this.safeString (balance, 2);
                    account['free'] = this.safeString (balance, 4);
                    result[code] = account;
                }
            }
            return this.parseBalance (result);
        }
    
        async transfer (code, amount, fromAccount, toAccount, params = {}) {
            // transferring between derivatives wallet and regular wallet is not documented in their API
            // however we support it in CCXT (from just looking at web inspector)
            await this.loadMarkets ();
            const accountsByType = this.safeValue (this.options, 'v2AccountsByType', {});
            const fromId = this.safeString (accountsByType, fromAccount);
            if (fromId === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' transfer fromAccount must be one of ' + keys.join (', '));
            }
            const toId = this.safeString (accountsByType, toAccount);
            if (toId === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' transfer toAccount must be one of ' + keys.join (', '));
            }
            const currency = this.currency (code);
            const fromCurrencyId = this.convertDerivativesId (currency, fromAccount);
            const toCurrencyId = this.convertDerivativesId (currency, toAccount);
            const requestedAmount = this.currencyToPrecision (code, amount);
            // this request is slightly different from v1 fromAccount -> from
            const request = {
                'amount': requestedAmount,
                'currency': fromCurrencyId,
                'currency_to': toCurrencyId,
                'from': fromId,
                'to': toId,
            };
            const response = await this.privatePostAuthWTransfer (this.extend (request, params));
            //  [1616451183763,"acc_tf",null,null,[1616451183763,"exchange","margin",null,"UST","UST",null,1],null,"SUCCESS","1.0 Tether USDt transfered from Exchange to Margin"]
            const timestamp = this.safeInteger (response, 0);
            //  ["error",10001,"Momentary balance check. Please wait few seconds and try the transfer again."]
            const error = this.safeString (response, 0);
            if (error === 'error') {
                const message = this.safeString (response, 2, '');
                // same message as in v1
                this.throwExactlyMatchedException (this.exceptions['exact'], message, this.id + ' ' + message);
                throw new ExchangeError (this.id + ' ' + message);
            }
            const info = this.safeValue (response, 4);
            const fromResponse = this.safeString (info, 1);
            const toResponse = this.safeString (info, 2);
            const toCode = this.safeCurrencyCode (this.safeString (info, 5));
            const success = this.safeString (response, 6);
            const status = (success === 'SUCCESS') ? 'ok' : undefined;
            return {
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'status': status,
                'amount': requestedAmount,
                'code': toCode,
                'fromAccount': fromResponse,
                'toAccount': toResponse,
            };
        }
    
        convertDerivativesId (currency, type) {
            // there is a difference between this and the v1 api, namely trading wallet is called margin in v2
            // {
            //   id: 'fUSTF0',
            //   code: 'USTF0',
            //   info: [ 'USTF0', [], [], [], [ 'USTF0', 'UST' ] ],
            const info = this.safeValue (currency, 'info');
            const transferId = this.safeString (info, 0);
            const underlying = this.safeValue (info, 4, []);
            let currencyId = undefined;
            if (type === 'derivatives') {
                currencyId = this.safeString (underlying, 0, transferId);
                const start = currencyId.length - 2;
                const isDerivativeCode = currencyId.slice (start) === 'F0';
                if (!isDerivativeCode) {
                    currencyId = currencyId + 'F0';
                }
            } else if (type !== 'margin') {
                currencyId = this.safeString (underlying, 1, transferId);
            } else {
                currencyId = transferId;
            }
            return currencyId;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchOrder is not implemented yet');
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const precision = this.safeValue (this.options, 'precision', 'R0');
            const request = {
                'symbol': this.marketId (symbol),
                'precision': precision,
            };
            if (limit !== undefined) {
                request['len'] = limit; // 25 or 100
            }
            const fullRequest = this.extend (request, params);
            const orderbook = await this.publicGetBookSymbolPrecision (fullRequest);
            const timestamp = this.milliseconds ();
            const result = {
                'symbol': symbol,
                'bids': [],
                'asks': [],
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'nonce': undefined,
            };
            const priceIndex = (fullRequest['precision'] === 'R0') ? 1 : 0;
            for (let i = 0; i < orderbook.length; i++) {
                const order = orderbook[i];
                const price = this.safeNumber (order, priceIndex);
                const signedAmount = this.safeNumber (order, 2);
                const amount = Math.abs (signedAmount);
                const side = (signedAmount > 0) ? 'bids' : 'asks';
                result[side].push ([ price, amount ]);
            }
            result['bids'] = this.sortBy (result['bids'], 0, true);
            result['asks'] = this.sortBy (result['asks'], 0);
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.milliseconds ();
            const symbol = this.safeSymbol (undefined, market);
            const length = ticker.length;
            const last = this.safeNumber (ticker, length - 4);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, length - 2),
                'low': this.safeNumber (ticker, length - 1),
                'bid': this.safeNumber (ticker, length - 10),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, length - 8),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': this.safeNumber (ticker, length - 6),
                'percentage': this.safeNumber (ticker, length - 5) * 100,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, length - 3),
                'quoteVolume': undefined,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbols !== undefined) {
                const ids = this.marketIds (symbols);
                request['symbols'] = ids.join (',');
            } else {
                request['symbols'] = 'ALL';
            }
            const tickers = await this.publicGetTickers (this.extend (request, params));
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const ticker = tickers[i];
                const id = ticker[0];
                if (id in this.markets_by_id) {
                    const market = this.markets_by_id[id];
                    const symbol = market['symbol'];
                    result[symbol] = this.parseTicker (ticker, market);
                }
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const ticker = await this.publicGetTickerSymbol (this.extend (request, params));
            return this.parseTicker (ticker, market);
        }
    
        parseSymbol (marketId) {
            if (marketId === undefined) {
                return marketId;
            }
            marketId = marketId.replace ('t', '');
            let baseId = undefined;
            let quoteId = undefined;
            if (marketId.indexOf (':') >= 0) {
                const parts = marketId.split (':');
                baseId = parts[0];
                quoteId = parts[1];
            } else {
                baseId = marketId.slice (0, 3);
                quoteId = marketId.slice (3, 6);
            }
            const base = this.safeCurrencyCode (baseId);
            const quote = this.safeCurrencyCode (quoteId);
            return base + '/' + quote;
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     [
            //         ID,
            //         MTS, // timestamp
            //         AMOUNT,
            //         PRICE
            //     ]
            //
            // fetchMyTrades (private)
            //
            //     [
            //         ID,
            //         PAIR,
            //         MTS_CREATE,
            //         ORDER_ID,
            //         EXEC_AMOUNT,
            //         EXEC_PRICE,
            //         ORDER_TYPE,
            //         ORDER_PRICE,
            //         MAKER,
            //         FEE,
            //         FEE_CURRENCY,
            //         ...
            //     ]
            //
            const tradeLength = trade.length;
            const isPrivate = (tradeLength > 5);
            const id = this.safeString (trade, 0);
            const amountIndex = isPrivate ? 4 : 2;
            let side = undefined;
            let amountString = this.safeString (trade, amountIndex);
            const priceIndex = isPrivate ? 5 : 3;
            const priceString = this.safeString (trade, priceIndex);
            if (amountString[0] === '-') {
                side = 'sell';
                amountString = amountString.slice (1);
            } else {
                side = 'buy';
            }
            const amount = this.parseNumber (amountString);
            const price = this.parseNumber (priceString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let orderId = undefined;
            let takerOrMaker = undefined;
            let type = undefined;
            let fee = undefined;
            let symbol = undefined;
            const timestampIndex = isPrivate ? 2 : 1;
            const timestamp = this.safeInteger (trade, timestampIndex);
            if (isPrivate) {
                const marketId = trade[1];
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                    symbol = market['symbol'];
                } else {
                    symbol = this.parseSymbol (marketId);
                }
                orderId = this.safeString (trade, 3);
                const maker = this.safeInteger (trade, 8);
                takerOrMaker = (maker === 1) ? 'maker' : 'taker';
                let feeCostString = this.safeString (trade, 9);
                feeCostString = Precise.stringNeg (feeCostString);
                const feeCost = this.parseNumber (feeCostString);
                const feeCurrencyId = this.safeString (trade, 10);
                const feeCurrency = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
                const orderType = trade[6];
                type = this.safeString (this.options['exchangeTypes'], orderType);
            }
            if (symbol === undefined) {
                if (market !== undefined) {
                    symbol = market['symbol'];
                }
            }
            return {
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'side': side,
                'type': type,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
                'info': trade,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let sort = '-1';
            const request = {
                'symbol': market['id'],
            };
            if (since !== undefined) {
                request['start'] = since;
                sort = '1';
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 120, max 5000
            }
            request['sort'] = sort;
            const response = await this.publicGetTradesSymbolHist (this.extend (request, params));
            //
            //     [
            //         [
            //             ID,
            //             MTS, // timestamp
            //             AMOUNT,
            //             PRICE
            //         ]
            //     ]
            //
            const trades = this.sortBy (response, 1);
            return this.parseTrades (trades, market, undefined, limit);
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = 100, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (limit === undefined) {
                limit = 100; // default 100, max 5000
            }
            if (since === undefined) {
                const duration = this.parseTimeframe (timeframe);
                since = this.milliseconds () - duration * limit * 1000;
            }
            const request = {
                'symbol': market['id'],
                'timeframe': this.timeframes[timeframe],
                'sort': 1,
                'start': since,
                'limit': limit,
            };
            const response = await this.publicGetCandlesTradeTimeframeSymbolHist (this.extend (request, params));
            //
            //     [
            //         [1591503840000,0.025069,0.025068,0.025069,0.025068,1.97828998],
            //         [1591504500000,0.025065,0.025065,0.025065,0.025065,1.0164],
            //         [1591504620000,0.025062,0.025062,0.025062,0.025062,0.5],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        parseOrderStatus (status) {
            if (status === undefined) {
                return status;
            }
            const parts = status.split (' ');
            const state = this.safeString (parts, 0);
            const statuses = {
                'ACTIVE': 'open',
                'PARTIALLY': 'open',
                'EXECUTED': 'closed',
                'CANCELED': 'canceled',
                'INSUFFICIENT': 'canceled',
                'RSN_DUST': 'rejected',
                'RSN_PAUSE': 'rejected',
            };
            return this.safeString (statuses, state, status);
        }
    
        parseOrder (order, market = undefined) {
            const id = this.safeString (order, 0);
            let symbol = undefined;
            const marketId = this.safeString (order, 3);
            if (marketId in this.markets_by_id) {
                market = this.markets_by_id[marketId];
            } else {
                symbol = this.parseSymbol (marketId);
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            // https://github.com/ccxt/ccxt/issues/6686
            // const timestamp = this.safeTimestamp (order, 5);
            const timestamp = this.safeInteger (order, 5);
            const remaining = Math.abs (this.safeNumber (order, 6));
            const signedAmount = this.safeNumber (order, 7);
            const amount = Math.abs (signedAmount);
            const side = (signedAmount < 0) ? 'sell' : 'buy';
            const orderType = this.safeString (order, 8);
            const type = this.safeString (this.safeValue (this.options, 'exchangeTypes'), orderType);
            let status = undefined;
            const statusString = this.safeString (order, 13);
            if (statusString !== undefined) {
                const parts = statusString.split (' @ ');
                status = this.parseOrderStatus (this.safeString (parts, 0));
            }
            const price = this.safeNumber (order, 16);
            const average = this.safeNumber (order, 17);
            const clientOrderId = this.safeString (order, 2);
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': undefined,
                'remaining': remaining,
                'status': status,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderTypes = this.safeValue (this.options, 'orderTypes', {});
            const orderType = this.safeStringUpper (orderTypes, type, type);
            amount = (side === 'sell') ? -amount : amount;
            const request = {
                'symbol': market['id'],
                'type': orderType,
                'amount': this.numberToString (amount),
            };
            if ((orderType === 'LIMIT') || (orderType === 'EXCHANGE LIMIT')) {
                request['price'] = this.numberToString (price);
            } else if ((orderType === 'STOP') || (orderType === 'EXCHANGE STOP')) {
                const stopPrice = this.safeNumber (params, 'stopPrice', price);
                request['price'] = this.numberToString (stopPrice);
            } else if ((orderType === 'STOP LIMIT') || (orderType === 'EXCHANGE STOP LIMIT')) {
                const priceAuxLimit = this.safeNumber (params, 'price_aux_limit');
                let stopPrice = this.safeNumber (params, 'stopPrice');
                if (priceAuxLimit === undefined) {
                    if (stopPrice === undefined) {
                        throw new ArgumentsRequired (this.id + ' createOrder() requires a stopPrice parameter or a price_aux_limit parameter for a ' + orderType + ' order');
                    } else {
                        request['price_aux_limit'] = this.numberToString (price);
                    }
                } else {
                    request['price_aux_limit'] = this.numberToString (priceAuxLimit);
                    if (stopPrice === undefined) {
                        stopPrice = price;
                    }
                }
                request['price'] = this.numberToString (stopPrice);
            } else if ((orderType === 'TRAILING STOP') || (orderType === 'EXCHANGE TRAILING STOP')) {
                const priceTrailing = this.safeNumber (params, 'price_trailing');
                request['price_trailing'] = this.numberToString (priceTrailing);
                const stopPrice = this.safeNumber (params, 'stopPrice', price);
                request['price'] = this.numberToString (stopPrice);
            } else if ((orderType === 'FOK') || (orderType === 'EXCHANGE FOK') || (orderType === 'IOC') || (orderType === 'EXCHANGE IOC')) {
                request['price'] = this.numberToString (price);
            }
            params = this.omit (params, [ 'stopPrice', 'price_aux_limit', 'price_trailing' ]);
            const clientOrderId = this.safeValue2 (params, 'cid', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['cid'] = clientOrderId;
                params = this.omit (params, [ 'cid', 'clientOrderId' ]);
            }
            const response = await this.privatePostAuthWOrderSubmit (this.extend (request, params));
            //
            //     [
            //         1578784364.748,    // Millisecond Time Stamp of the update
            //         "on-req",          // Purpose of notification ('on-req', 'oc-req', 'uca', 'fon-req', 'foc-req')
            //         null,              // Unique ID of the message
            //         null,              // Ignore
            //         [
            //             [
            //                 37271830598,           // Order ID
            //                 null,                  // Group ID
            //                 1578784364748,         // Client Order ID
            //                 "tBTCUST",             // Pair
            //                 1578784364748,         // Millisecond timestamp of creation
            //                 1578784364748,         // Millisecond timestamp of update
            //                 -0.005,                // Positive means buy, negative means sell
            //                 -0.005,                // Original amount
            //                 "EXCHANGE LIMIT",      // Order type (LIMIT, MARKET, STOP, TRAILING STOP, EXCHANGE MARKET, EXCHANGE LIMIT, EXCHANGE STOP, EXCHANGE TRAILING STOP, FOK, EXCHANGE FOK, IOC, EXCHANGE IOC)
            //                 null,                  // Previous order type
            //                 null,                  // Millisecond timestamp of Time-In-Force: automatic order cancellation
            //                 null,                  // Ignore
            //                 0,                     // Flags (see https://docs.bitfinex.com/docs/flag-values)
            //                 "ACTIVE",              // Order Status
            //                 null,                  // Ignore
            //                 null,                  // Ignore
            //                 20000,                 // Price
            //                 0,                     // Average price
            //                 0,                     // The trailing price
            //                 0,                     // Auxiliary Limit price (for STOP LIMIT)
            //                 null,                  // Ignore
            //                 null,                  // Ignore
            //                 null,                  // Ignore
            //                 0,                     // 1 - hidden order
            //                 null,                  // If another order caused this order to be placed (OCO) this will be that other order's ID
            //                 null,                  // Ignore
            //                 null,                  // Ignore
            //                 null,                  // Ignore
            //                 "API>BFX",             // Origin of action: BFX, ETHFX, API>BFX, API>ETHFX
            //                 null,                  // Ignore
            //                 null,                  // Ignore
            //                 null                   // Meta
            //             ]
            //         ],
            //         null,                  // Error code
            //         "SUCCESS",             // Status (SUCCESS, ERROR, FAILURE, ...)
            //         "Submitting 1 orders." // Text of the notification
            //     ]
            //
            const status = this.safeString (response, 6);
            if (status !== 'SUCCESS') {
                const errorCode = response[5];
                const errorText = response[7];
                throw new ExchangeError (this.id + ' ' + response[6] + ': ' + errorText + ' (#' + errorCode + ')');
            }
            const orders = this.safeValue (response, 4, []);
            const order = this.safeValue (orders, 0);
            return this.parseOrder (order, market);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            const request = {
                'all': 1,
            };
            const response = await this.privatePostAuthWOrderCancelMulti (this.extend (request, params));
            const orders = this.safeValue (response, 4, []);
            return this.parseOrders (orders);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const cid = this.safeValue2 (params, 'cid', 'clientOrderId'); // client order id
            let request = undefined;
            if (cid !== undefined) {
                const cidDate = this.safeValue (params, 'cidDate'); // client order id date
                if (cidDate === undefined) {
                    throw new InvalidOrder (this.id + " canceling an order by clientOrderId ('cid') requires both 'cid' and 'cid_date' ('YYYY-MM-DD')");
                }
                request = {
                    'cid': cid,
                    'cid_date': cidDate,
                };
                params = this.omit (params, [ 'cid', 'clientOrderId' ]);
            } else {
                request = {
                    'id': parseInt (id),
                };
            }
            const response = await this.privatePostAuthWOrderCancel (this.extend (request, params));
            const order = this.safeValue (response, 4);
            return this.parseOrder (order);
        }
    
        async fetchOpenOrder (id, symbol = undefined, params = {}) {
            const request = {
                'id': [ parseInt (id) ],
            };
            const orders = await this.fetchOpenOrders (symbol, undefined, undefined, this.extend (request, params));
            const order = this.safeValue (orders, 0);
            if (order === undefined) {
                throw new OrderNotFound (this.id + ' order ' + id + ' not found');
            }
            return order;
        }
    
        async fetchClosedOrder (id, symbol = undefined, params = {}) {
            const request = {
                'id': [ parseInt (id) ],
            };
            const orders = await this.fetchClosedOrders (symbol, undefined, undefined, this.extend (request, params));
            const order = this.safeValue (orders, 0);
            if (order === undefined) {
                throw new OrderNotFound (this.id + ' order ' + id + ' not found');
            }
            return order;
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            let response = undefined;
            if (symbol === undefined) {
                response = await this.privatePostAuthROrders (this.extend (request, params));
            } else {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                response = await this.privatePostAuthROrdersSymbol (this.extend (request, params));
            }
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // returns the most recent closed or canceled orders up to circa two weeks ago
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            let response = undefined;
            if (symbol === undefined) {
                response = await this.privatePostAuthROrdersHist (this.extend (request, params));
            } else {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                response = await this.privatePostAuthROrdersSymbolHist (this.extend (request, params));
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 25, max 2500
            }
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrderTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderId = parseInt (id);
            const request = {
                'id': orderId,
                'symbol': market['id'],
            };
            // valid for trades upto 10 days old
            const response = await this.privatePostAuthROrderSymbolIdTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                'end': this.milliseconds (),
            };
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 25, max 1000
            }
            let method = 'privatePostAuthRTradesHist';
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                method = 'privatePostAuthRTradesSymbolHist';
            }
            const response = await this[method] (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const request = {
                'op_renew': 1,
            };
            const response = await this.fetchDepositAddress (code, this.extend (request, params));
            return response;
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            const name = this.getCurrencyName (code);
            const request = {
                'method': name,
                'wallet': 'exchange', // 'exchange', 'margin', 'funding' and also old labels 'exchange', 'trading', 'deposit', respectively
                'op_renew': 0, // a value of 1 will generate a new address
            };
            const response = await this.privatePostAuthWDepositAddress (this.extend (request, params));
            //
            //     [
            //         1582269616687, // MTS Millisecond Time Stamp of the update
            //         'acc_dep', // TYPE Purpose of notification 'acc_dep' for account deposit
            //         null, // MESSAGE_ID unique ID of the message
            //         null, // not documented
            //         [
            //             null, // PLACEHOLDER
            //             'BITCOIN', // METHOD Method of deposit
            //             'BTC', // CURRENCY_CODE Currency code of new address
            //             null, // PLACEHOLDER
            //             '1BC9PZqpUmjyEB54uggn8TFKj49zSDYzqG', // ADDRESS
            //             null, // POOL_ADDRESS
            //         ],
            //         null, // CODE null or integer work in progress
            //         'SUCCESS', // STATUS Status of the notification, SUCCESS, ERROR, FAILURE
            //         'success', // TEXT Text of the notification
            //     ]
            //
            const result = this.safeValue (response, 4, []);
            const poolAddress = this.safeString (result, 5);
            const address = (poolAddress === undefined) ? this.safeString (result, 4) : poolAddress;
            const tag = (poolAddress === undefined) ? undefined : this.safeString (result, 4);
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'SUCCESS': 'ok',
                'ERROR': 'failed',
                'FAILURE': 'failed',
                'CANCELED': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // withdraw
            //
            //     [
            //         1582271520931, // MTS Millisecond Time Stamp of the update
            //         "acc_wd-req", // TYPE Purpose of notification 'acc_wd-req' account withdrawal request
            //         null, // MESSAGE_ID unique ID of the message
            //         null, // not documented
            //         [
            //             0, // WITHDRAWAL_ID Unique Withdrawal ID
            //             null, // PLACEHOLDER
            //             "bitcoin", // METHOD Method of withdrawal
            //             null, // PAYMENT_ID Payment ID if relevant
            //             "exchange", // WALLET Sending wallet
            //             1, // AMOUNT Amount of Withdrawal less fee
            //             null, // PLACEHOLDER
            //             null, // PLACEHOLDER
            //             0.0004, // WITHDRAWAL_FEE Fee on withdrawal
            //         ],
            //         null, // CODE null or integer Work in progress
            //         "SUCCESS", // STATUS Status of the notification, it may vary over time SUCCESS, ERROR, FAILURE
            //         "Invalid bitcoin address (abcdef)", // TEXT Text of the notification
            //     ]
            //
            // fetchTransactions
            //
            //     [
            //         13293039, // ID
            //         'ETH', // CURRENCY
            //         'ETHEREUM', // CURRENCY_NAME
            //         null,
            //         null,
            //         1574175052000, // MTS_STARTED
            //         1574181326000, // MTS_UPDATED
            //         null,
            //         null,
            //         'CANCELED', // STATUS
            //         null,
            //         null,
            //         -0.24, // AMOUNT, negative for withdrawals
            //         -0.00135, // FEES
            //         null,
            //         null,
            //         'DESTINATION_ADDRESS',
            //         null,
            //         null,
            //         null,
            //         'TRANSACTION_ID',
            //         "Purchase of 100 pizzas", // WITHDRAW_TRANSACTION_NOTE
            //     ]
            //
            const transactionLength = transaction.length;
            let timestamp = undefined;
            let updated = undefined;
            let code = undefined;
            let amount = undefined;
            let id = undefined;
            let status = undefined;
            let tag = undefined;
            let type = undefined;
            let feeCost = undefined;
            let txid = undefined;
            let addressTo = undefined;
            if (transactionLength < 9) {
                const data = this.safeValue (transaction, 4, []);
                timestamp = this.safeInteger (transaction, 0);
                if (currency !== undefined) {
                    code = currency['code'];
                }
                feeCost = this.safeNumber (data, 8);
                if (feeCost !== undefined) {
                    feeCost = -feeCost;
                }
                amount = this.safeNumber (data, 5);
                id = this.safeValue (data, 0);
                status = 'ok';
                if (id === 0) {
                    id = undefined;
                    status = 'failed';
                }
                tag = this.safeString (data, 3);
                type = 'withdrawal';
            } else {
                id = this.safeString (transaction, 0);
                timestamp = this.safeInteger (transaction, 5);
                updated = this.safeInteger (transaction, 6);
                status = this.parseTransactionStatus (this.safeString (transaction, 9));
                amount = this.safeNumber (transaction, 12);
                if (amount !== undefined) {
                    if (amount < 0) {
                        type = 'withdrawal';
                    } else {
                        type = 'deposit';
                    }
                }
                feeCost = this.safeNumber (transaction, 13);
                if (feeCost !== undefined) {
                    feeCost = -feeCost;
                }
                addressTo = this.safeString (transaction, 16);
                txid = this.safeString (transaction, 20);
            }
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': undefined,
                'address': addressTo, // this is actually the tag for XRP transfers (the address is missing)
                'addressTo': addressTo,
                'tagFrom': undefined,
                'tag': tag, // refix it properly for the tag from description
                'tagTo': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': {
                    'currency': code,
                    'cost': feeCost,
                    'rate': undefined,
                },
            };
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {};
            let method = 'privatePostAuthRMovementsHist';
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
                method = 'privatePostAuthRMovementsCurrencyHist';
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // max 1000
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     [
            //         [
            //             13293039, // ID
            //             'ETH', // CURRENCY
            //             'ETHEREUM', // CURRENCY_NAME
            //             null,
            //             null,
            //             1574175052000, // MTS_STARTED
            //             1574181326000, // MTS_UPDATED
            //             null,
            //             null,
            //             'CANCELED', // STATUS
            //             null,
            //             null,
            //             -0.24, // AMOUNT, negative for withdrawals
            //             -0.00135, // FEES
            //             null,
            //             null,
            //             'DESTINATION_ADDRESS',
            //             null,
            //             null,
            //             null,
            //             'TRANSACTION_ID',
            //             "Purchase of 100 pizzas", // WITHDRAW_TRANSACTION_NOTE
            //         ]
            //     ]
            //
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            // todo rewrite for https://api-pub.bitfinex.com//v2/conf/pub:map:tx:method
            const name = this.getCurrencyName (code);
            const request = {
                'method': name,
                'wallet': 'exchange', // 'exchange', 'margin', 'funding' and also old labels 'exchange', 'trading', 'deposit', respectively
                'amount': this.numberToString (amount),
                'address': address,
            };
            if (tag !== undefined) {
                request['payment_id'] = tag;
            }
            const response = await this.privatePostAuthWWithdraw (this.extend (request, params));
            //
            //     [
            //         1582271520931, // MTS Millisecond Time Stamp of the update
            //         "acc_wd-req", // TYPE Purpose of notification 'acc_wd-req' account withdrawal request
            //         null, // MESSAGE_ID unique ID of the message
            //         null, // not documented
            //         [
            //             0, // WITHDRAWAL_ID Unique Withdrawal ID
            //             null, // PLACEHOLDER
            //             "bitcoin", // METHOD Method of withdrawal
            //             null, // PAYMENT_ID Payment ID if relevant
            //             "exchange", // WALLET Sending wallet
            //             1, // AMOUNT Amount of Withdrawal less fee
            //             null, // PLACEHOLDER
            //             null, // PLACEHOLDER
            //             0.0004, // WITHDRAWAL_FEE Fee on withdrawal
            //         ],
            //         null, // CODE null or integer Work in progress
            //         "SUCCESS", // STATUS Status of the notification, it may vary over time SUCCESS, ERROR, FAILURE
            //         "Invalid bitcoin address (abcdef)", // TEXT Text of the notification
            //     ]
            //
            const text = this.safeString (response, 7);
            if (text !== 'success') {
                this.throwBroadlyMatchedException (this.exceptions['broad'], text, text);
            }
            const transaction = this.parseTransaction (response, currency);
            return this.extend (transaction, {
                'address': address,
            });
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostPositions (params);
            //
            //     [
            //         [
            //             "tBTCUSD", // SYMBOL
            //             "ACTIVE", // STATUS
            //             0.0195, // AMOUNT
            //             8565.0267019, // BASE_PRICE
            //             0, // MARGIN_FUNDING
            //             0, // MARGIN_FUNDING_TYPE
            //             -0.33455568705000516, // PL
            //             -0.0003117550117425625, // PL_PERC
            //             7045.876419249083, // PRICE_LIQ
            //             3.0673001895895604, // LEVERAGE
            //             null, // _PLACEHOLDER
            //             142355652, // POSITION_ID
            //             1574002216000, // MTS_CREATE
            //             1574002216000, // MTS_UPDATE
            //             null, // _PLACEHOLDER
            //             0, // TYPE
            //             null, // _PLACEHOLDER
            //             0, // COLLATERAL
            //             0, // COLLATERAL_MIN
            //             // META
            //             {
            //                 "reason":"TRADE",
            //                 "order_id":34271018124,
            //                 "liq_stage":null,
            //                 "trade_price":"8565.0267019",
            //                 "trade_amount":"0.0195",
            //                 "order_id_oppo":34277498022
            //             }
            //         ]
            //     ]
            //
            // todo unify parsePosition/parsePositions
            return response;
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'v1') {
                request = api + request;
            } else {
                request = this.version + request;
            }
            let url = this.urls['api'][api] + '/' + request;
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                body = this.json (query);
                const auth = '/api/' + request + nonce + body;
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha384');
                headers = {
                    'bfx-nonce': nonce,
                    'bfx-apikey': this.apiKey,
                    'bfx-signature': signature,
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (statusCode, statusText, url, method, responseHeaders, responseBody, response, requestHeaders, requestBody) {
            if (response !== undefined) {
                if (!Array.isArray (response)) {
                    const message = this.safeString2 (response, 'message', 'error');
                    const feedback = this.id + ' ' + responseBody;
                    this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                    this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                    throw new ExchangeError (this.id + ' ' + responseBody);
                }
            } else if (response === '') {
                throw new ExchangeError (this.id + ' returned empty response');
            }
            if (statusCode === 500) {
                // See https://docs.bitfinex.com/docs/abbreviations-glossary#section-errorinfo-codes
                const errorCode = this.numberToString (response[1]);
                const errorText = response[2];
                const feedback = this.id + ' ' + errorText;
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                this.throwExactlyMatchedException (this.exceptions['exact'], errorText, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], errorText, feedback);
                throw new ExchangeError (this.id + ' ' + errorText + ' (#' + errorCode + ')');
            }
            return response;
        }
    };
    
    },{"./base/Precise":7,"./base/errors":9,"./bitfinex.js":33}],35:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, OrderNotFound } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitflyer extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitflyer',
                'name': 'bitFlyer',
                'countries': [ 'JP' ],
                'version': 'v1',
                'rateLimit': 1000, // their nonce-timestamp is in seconds...
                'hostname': 'bitflyer.com', // or bitflyer.com
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': 'emulated',
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': 'emulated',
                    'fetchOrder': 'emulated',
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'withdraw': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/28051642-56154182-660e-11e7-9b0d-6042d1e6edd8.jpg',
                    'api': 'https://api.{hostname}',
                    'www': 'https://bitflyer.com',
                    'doc': 'https://lightning.bitflyer.com/docs?lang=en',
                },
                'api': {
                    'public': {
                        'get': [
                            'getmarkets/usa', // new (wip)
                            'getmarkets/eu',  // new (wip)
                            'getmarkets',     // or 'markets'
                            'getboard',       // ...
                            'getticker',
                            'getexecutions',
                            'gethealth',
                            'getboardstate',
                            'getchats',
                        ],
                    },
                    'private': {
                        'get': [
                            'getpermissions',
                            'getbalance',
                            'getbalancehistory',
                            'getcollateral',
                            'getcollateralhistory',
                            'getcollateralaccounts',
                            'getaddresses',
                            'getcoinins',
                            'getcoinouts',
                            'getbankaccounts',
                            'getdeposits',
                            'getwithdrawals',
                            'getchildorders',
                            'getparentorders',
                            'getparentorder',
                            'getexecutions',
                            'getpositions',
                            'gettradingcommission',
                        ],
                        'post': [
                            'sendcoin',
                            'withdraw',
                            'sendchildorder',
                            'cancelchildorder',
                            'sendparentorder',
                            'cancelparentorder',
                            'cancelallchildorders',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.002'),
                        'taker': this.parseNumber ('0.002'),
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const jp_markets = await this.publicGetGetmarkets (params);
            const us_markets = await this.publicGetGetmarketsUsa (params);
            const eu_markets = await this.publicGetGetmarketsEu (params);
            let markets = this.arrayConcat (jp_markets, us_markets);
            markets = this.arrayConcat (markets, eu_markets);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'product_code');
                const currencies = id.split ('_');
                let baseId = undefined;
                let quoteId = undefined;
                let base = undefined;
                let quote = undefined;
                const numCurrencies = currencies.length;
                if (numCurrencies === 1) {
                    baseId = id.slice (0, 3);
                    quoteId = id.slice (3, 6);
                } else if (numCurrencies === 2) {
                    baseId = currencies[0];
                    quoteId = currencies[1];
                } else {
                    baseId = currencies[1];
                    quoteId = currencies[2];
                }
                base = this.safeCurrencyCode (baseId);
                quote = this.safeCurrencyCode (quoteId);
                const symbol = (numCurrencies === 2) ? (base + '/' + quote) : id;
                const fees = this.safeValue (this.fees, symbol, this.fees['trading']);
                let maker = this.safeValue (fees, 'maker', this.fees['trading']['maker']);
                let taker = this.safeValue (fees, 'taker', this.fees['trading']['taker']);
                let spot = true;
                let future = false;
                let type = 'spot';
                if (('alias' in market) || (currencies[0] === 'FX')) {
                    type = 'future';
                    future = true;
                    spot = false;
                    maker = 0.0;
                    taker = 0.0;
                }
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'maker': maker,
                    'taker': taker,
                    'type': type,
                    'spot': spot,
                    'future': future,
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetGetbalance (params);
            //
            //     [
            //         {
            //             "currency_code": "JPY",
            //             "amount": 1024078,
            //             "available": 508000
            //         },
            //         {
            //             "currency_code": "BTC",
            //             "amount": 10.24,
            //             "available": 4.12
            //         },
            //         {
            //             "currency_code": "ETH",
            //             "amount": 20.48,
            //             "available": 16.38
            //         }
            //     ]
            //
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'currency_code');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['total'] = this.safeString (balance, 'amount');
                account['free'] = this.safeString (balance, 'available');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'product_code': this.marketId (symbol),
            };
            const orderbook = await this.publicGetGetboard (this.extend (request, params));
            return this.parseOrderBook (orderbook, symbol, undefined, 'bids', 'asks', 'price', 'size');
        }
    
        parseTicker (ticker, market = undefined) {
            const symbol = this.safeSymbol (undefined, market);
            const timestamp = this.parse8601 (this.safeString (ticker, 'timestamp'));
            const last = this.safeNumber (ticker, 'ltp');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': undefined,
                'low': undefined,
                'bid': this.safeNumber (ticker, 'best_bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'best_ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume_by_product'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_code': market['id'],
            };
            const response = await this.publicGetGetticker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            let side = this.safeStringLower (trade, 'side');
            if (side !== undefined) {
                if (side.length < 1) {
                    side = undefined;
                }
            }
            let order = undefined;
            if (side !== undefined) {
                const id = side + '_child_order_acceptance_id';
                if (id in trade) {
                    order = trade[id];
                }
            }
            if (order === undefined) {
                order = this.safeString (trade, 'child_order_acceptance_id');
            }
            const timestamp = this.parse8601 (this.safeString (trade, 'exec_date'));
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'size');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const id = this.safeString (trade, 'id');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': order,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_code': market['id'],
            };
            const response = await this.publicGetGetexecutions (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'product_code': this.marketId (symbol),
                'child_order_type': type.toUpperCase (),
                'side': side.toUpperCase (),
                'price': price,
                'size': amount,
            };
            const result = await this.privatePostSendchildorder (this.extend (request, params));
            // { "status": - 200, "error_message": "Insufficient funds", "data": null }
            const id = this.safeString (result, 'child_order_acceptance_id');
            return {
                'info': result,
                'id': id,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a `symbol` argument');
            }
            await this.loadMarkets ();
            const request = {
                'product_code': this.marketId (symbol),
                'child_order_acceptance_id': id,
            };
            return await this.privatePostCancelchildorder (this.extend (request, params));
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'ACTIVE': 'open',
                'COMPLETED': 'closed',
                'CANCELED': 'canceled',
                'EXPIRED': 'canceled',
                'REJECTED': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            const timestamp = this.parse8601 (this.safeString (order, 'child_order_date'));
            const amount = this.safeNumber (order, 'size');
            const remaining = this.safeNumber (order, 'outstanding_size');
            const filled = this.safeNumber (order, 'executed_size');
            const price = this.safeNumber (order, 'price');
            const status = this.parseOrderStatus (this.safeString (order, 'child_order_state'));
            const type = this.safeStringLower (order, 'child_order_type');
            const side = this.safeStringLower (order, 'side');
            const marketId = this.safeString (order, 'product_code');
            const symbol = this.safeSymbol (marketId, market);
            let fee = undefined;
            const feeCost = this.safeNumber (order, 'total_commission');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': undefined,
                    'rate': undefined,
                };
            }
            const id = this.safeString (order, 'child_order_acceptance_id');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'fee': fee,
                'average': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = 100, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a `symbol` argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_code': market['id'],
                'count': limit,
            };
            const response = await this.privateGetGetchildorders (this.extend (request, params));
            let orders = this.parseOrders (response, market, since, limit);
            if (symbol !== undefined) {
                orders = this.filterBy (orders, 'symbol', symbol);
            }
            return orders;
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = 100, params = {}) {
            const request = {
                'child_order_state': 'ACTIVE',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = 100, params = {}) {
            const request = {
                'child_order_state': 'COMPLETED',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a `symbol` argument');
            }
            const orders = await this.fetchOrders (symbol);
            const ordersById = this.indexBy (orders, 'id');
            if (id in ordersById) {
                return ordersById[id];
            }
            throw new OrderNotFound (this.id + ' No order found with id ' + id);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a `symbol` argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_code': market['id'],
            };
            if (limit !== undefined) {
                request['count'] = limit;
            }
            const response = await this.privateGetGetexecutions (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            if (symbols === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchPositions() requires a `symbols` argument, exactly one symbol in an array');
            }
            await this.loadMarkets ();
            const request = {
                'product_code': this.marketIds (symbols),
            };
            const response = await this.privateGetpositions (this.extend (request, params));
            //
            //     [
            //         {
            //             "product_code": "FX_BTC_JPY",
            //             "side": "BUY",
            //             "price": 36000,
            //             "size": 10,
            //             "commission": 0,
            //             "swap_point_accumulate": -35,
            //             "require_collateral": 120000,
            //             "open_date": "2015-11-03T10:04:45.011",
            //             "leverage": 3,
            //             "pnl": 965,
            //             "sfd": -0.5
            //         }
            //     ]
            //
            // todo unify parsePosition/parsePositions
            return response;
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            if (code !== 'JPY' && code !== 'USD' && code !== 'EUR') {
                throw new ExchangeError (this.id + ' allows withdrawing JPY, USD, EUR only, ' + code + ' is not supported');
            }
            const currency = this.currency (code);
            const request = {
                'currency_code': currency['id'],
                'amount': amount,
                // 'bank_account_id': 1234,
            };
            const response = await this.privatePostWithdraw (this.extend (request, params));
            const id = this.safeString (response, 'message_id');
            return {
                'info': response,
                'id': id,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + this.version + '/';
            if (api === 'private') {
                request += 'me/';
            }
            request += path;
            if (method === 'GET') {
                if (Object.keys (params).length) {
                    request += '?' + this.urlencode (params);
                }
            }
            const baseUrl = this.implodeHostname (this.urls['api']);
            const url = baseUrl + request;
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                let auth = [ nonce, method, request ].join ('');
                if (Object.keys (params).length) {
                    if (method !== 'GET') {
                        body = this.json (params);
                        auth += body;
                    }
                }
                headers = {
                    'ACCESS-KEY': this.apiKey,
                    'ACCESS-TIMESTAMP': nonce,
                    'ACCESS-SIGN': this.hmac (this.encode (auth), this.encode (this.secret)),
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],36:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AuthenticationError, OrderNotFound, InsufficientFunds, DDoSProtection, PermissionDenied, BadSymbol, InvalidOrder } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitforex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitforex',
                'name': 'Bitforex',
                'countries': [ 'CN' ],
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': false,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': false,
                    'fetchTicker': true,
                    'fetchTickers': false,
                    'fetchTrades': true,
                },
                'timeframes': {
                    '1m': '1min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '1hour',
                    '2h': '2hour',
                    '4h': '4hour',
                    '12h': '12hour',
                    '1d': '1day',
                    '1w': '1week',
                    '1M': '1month',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87295553-1160ec00-c50e-11ea-8ea0-df79276a9646.jpg',
                    'api': 'https://api.bitforex.com',
                    'www': 'https://www.bitforex.com',
                    'doc': 'https://github.com/githubdev2020/API_Doc_en/wiki',
                    'fees': 'https://help.bitforex.com/en_us/?cat=13',
                    'referral': 'https://www.bitforex.com/en/invitationRegister?inviterId=1867438',
                },
                'api': {
                    'public': {
                        'get': [
                            'api/v1/market/symbols',
                            'api/v1/market/ticker',
                            'api/v1/market/depth',
                            'api/v1/market/trades',
                            'api/v1/market/kline',
                        ],
                    },
                    'private': {
                        'post': [
                            'api/v1/fund/mainAccount',
                            'api/v1/fund/allAccount',
                            'api/v1/trade/placeOrder',
                            'api/v1/trade/placeMultiOrder',
                            'api/v1/trade/cancelOrder',
                            'api/v1/trade/cancelMultiOrder',
                            'api/v1/trade/cancelAllOrder',
                            'api/v1/trade/orderInfo',
                            'api/v1/trade/multiOrderInfo',
                            'api/v1/trade/orderInfos',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': this.parseNumber ('0.001'),
                        'taker': this.parseNumber ('0.001'),
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': true,
                        'deposit': {},
                        'withdraw': {},
                    },
                },
                'commonCurrencies': {
                    'ACE': 'ACE Entertainment',
                    'BDP': 'BidiPass',
                    'CAPP': 'Crypto Application Token',
                    'CREDIT': 'TerraCredit',
                    'CTC': 'Culture Ticket Chain',
                    'GOT': 'GoNetwork',
                    'HBC': 'Hybrid Bank Cash',
                    'IQ': 'IQ.Cash',
                    'MIR': 'MIR COIN',
                    'UOS': 'UOS Network',
                },
                'exceptions': {
                    '1003': BadSymbol, // {"success":false,"code":"1003","message":"Param Invalid:param invalid -symbol:symbol error"}
                    '1013': AuthenticationError,
                    '1016': AuthenticationError,
                    '1017': PermissionDenied, // {"code":"1017","success":false,"time":1602670594367,"message":"IP not allow"}
                    '1019': BadSymbol, // {"code":"1019","success":false,"time":1607087743778,"message":"Symbol Invalid"}
                    '3002': InsufficientFunds,
                    '4002': InvalidOrder, // {"success":false,"code":"4002","message":"Price unreasonable"}
                    '4003': InvalidOrder, // {"success":false,"code":"4003","message":"amount too small"}
                    '4004': OrderNotFound,
                    '10204': DDoSProtection,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetApiV1MarketSymbols (params);
            const data = response['data'];
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const market = data[i];
                const id = this.safeString (market, 'symbol');
                const symbolParts = id.split ('-');
                const baseId = symbolParts[2];
                const quoteId = symbolParts[1];
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const active = true;
                const precision = {
                    'amount': this.safeInteger (market, 'amountPrecision'),
                    'price': this.safeInteger (market, 'pricePrecision'),
                };
                const limits = {
                    'amount': {
                        'min': this.safeNumber (market, 'minOrderAmount'),
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                });
            }
            return result;
        }
    
        parseTrade (trade, market = undefined) {
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const timestamp = this.safeInteger (trade, 'time');
            const id = this.safeString (trade, 'tid');
            const orderId = undefined;
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const sideId = this.safeInteger (trade, 'direction');
            const side = this.parseSide (sideId);
            return {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'order': orderId,
                'fee': undefined,
                'takerOrMaker': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            if (limit !== undefined) {
                request['size'] = limit;
            }
            const market = this.market (symbol);
            const response = await this.publicGetApiV1MarketTrades (this.extend (request, params));
            return this.parseTrades (response['data'], market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostApiV1FundAllAccount (params);
            const data = response['data'];
            const result = { 'info': response };
            for (let i = 0; i < data.length; i++) {
                const balance = data[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['used'] = this.safeString (balance, 'frozen');
                account['free'] = this.safeString (balance, 'active');
                account['total'] = this.safeString (balance, 'fix');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.markets[symbol];
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetApiV1MarketTicker (this.extend (request, params));
            const data = response['data'];
            const timestamp = this.safeInteger (data, 'date');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (data, 'high'),
                'low': this.safeNumber (data, 'low'),
                'bid': this.safeNumber (data, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (data, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': this.safeNumber (data, 'last'),
                'last': this.safeNumber (data, 'last'),
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (data, 'vol'),
                'quoteVolume': undefined,
                'info': response,
            };
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "close":0.02505143,
            //         "currencyVol":0,
            //         "high":0.02506422,
            //         "low":0.02505143,
            //         "open":0.02506095,
            //         "time":1591508940000,
            //         "vol":51.1869
            //     }
            //
            return [
                this.safeInteger (ohlcv, 'time'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'vol'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'ktype': this.timeframes[timeframe],
            };
            if (limit !== undefined) {
                request['size'] = limit; // default 1, max 600
            }
            const response = await this.publicGetApiV1MarketKline (this.extend (request, params));
            //
            //     {
            //         "data":[
            //             {"close":0.02505143,"currencyVol":0,"high":0.02506422,"low":0.02505143,"open":0.02506095,"time":1591508940000,"vol":51.1869},
            //             {"close":0.02503914,"currencyVol":0,"high":0.02506687,"low":0.02503914,"open":0.02505358,"time":1591509000000,"vol":9.1082},
            //             {"close":0.02505172,"currencyVol":0,"high":0.02507466,"low":0.02503895,"open":0.02506371,"time":1591509060000,"vol":63.7431},
            //         ],
            //         "success":true,
            //         "time":1591509427131
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const marketId = this.marketId (symbol);
            const request = {
                'symbol': marketId,
            };
            if (limit !== undefined) {
                request['size'] = limit;
            }
            const response = await this.publicGetApiV1MarketDepth (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            const timestamp = this.safeInteger (response, 'time');
            return this.parseOrderBook (data, symbol, timestamp, 'bids', 'asks', 'price', 'amount');
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '0': 'open',
                '1': 'open',
                '2': 'closed',
                '3': 'canceled',
                '4': 'canceled',
            };
            return (status in statuses) ? statuses[status] : status;
        }
    
        parseSide (sideId) {
            if (sideId === 1) {
                return 'buy';
            } else if (sideId === 2) {
                return 'sell';
            } else {
                return undefined;
            }
        }
    
        parseOrder (order, market = undefined) {
            const id = this.safeString (order, 'orderId');
            const timestamp = this.safeNumber (order, 'createTime');
            const lastTradeTimestamp = this.safeNumber (order, 'lastTime');
            const symbol = market['symbol'];
            const sideId = this.safeInteger (order, 'tradeType');
            const side = this.parseSide (sideId);
            const type = undefined;
            const price = this.safeNumber (order, 'orderPrice');
            const average = this.safeNumber (order, 'avgPrice');
            const amount = this.safeNumber (order, 'orderAmount');
            const filled = this.safeNumber (order, 'dealAmount');
            const status = this.parseOrderStatus (this.safeString (order, 'orderState'));
            const feeSide = (side === 'buy') ? 'base' : 'quote';
            const feeCurrency = market[feeSide];
            const fee = {
                'cost': this.safeNumber (order, 'tradeFee'),
                'currency': feeCurrency,
            };
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'average': average,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': this.marketId (symbol),
                'orderId': id,
            };
            const response = await this.privatePostApiV1TradeOrderInfo (this.extend (request, params));
            const order = this.parseOrder (response['data'], market);
            return order;
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': this.marketId (symbol),
                'state': 0,
            };
            const response = await this.privatePostApiV1TradeOrderInfos (this.extend (request, params));
            return this.parseOrders (response['data'], market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': this.marketId (symbol),
                'state': 1,
            };
            const response = await this.privatePostApiV1TradeOrderInfos (this.extend (request, params));
            return this.parseOrders (response['data'], market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            let sideId = undefined;
            if (side === 'buy') {
                sideId = 1;
            } else if (side === 'sell') {
                sideId = 2;
            }
            const request = {
                'symbol': this.marketId (symbol),
                'price': price,
                'amount': amount,
                'tradeType': sideId,
            };
            const response = await this.privatePostApiV1TradePlaceOrder (this.extend (request, params));
            const data = response['data'];
            return {
                'info': response,
                'id': this.safeString (data, 'orderId'),
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderId': id,
            };
            if (symbol !== undefined) {
                request['symbol'] = this.marketId (symbol);
            }
            const results = await this.privatePostApiV1TradeCancelOrder (this.extend (request, params));
            const success = results['success'];
            const returnVal = { 'info': results, 'success': success };
            return returnVal;
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                let payload = this.urlencode ({ 'accessKey': this.apiKey });
                query['nonce'] = this.milliseconds ();
                if (Object.keys (query).length) {
                    payload += '&' + this.urlencode (this.keysort (query));
                }
                // let message = '/' + 'api/' + this.version + '/' + path + '?' + payload;
                const message = '/' + path + '?' + payload;
                const signature = this.hmac (this.encode (message), this.encode (this.secret));
                body = payload + '&signData=' + signature;
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (typeof body !== 'string') {
                return; // fallback to default error handler
            }
            if ((body[0] === '{') || (body[0] === '[')) {
                const feedback = this.id + ' ' + body;
                const success = this.safeValue (response, 'success');
                if (success !== undefined) {
                    if (!success) {
                        const code = this.safeString (response, 'code');
                        this.throwExactlyMatchedException (this.exceptions, code, feedback);
                        throw new ExchangeError (feedback);
                    }
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],37:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ExchangeNotAvailable, OnMaintenance, ArgumentsRequired, BadRequest, AccountSuspended, InvalidAddress, PermissionDenied, DDoSProtection, InsufficientFunds, InvalidNonce, CancelPending, InvalidOrder, OrderNotFound, AuthenticationError, RequestTimeout, NotSupported, BadSymbol, RateLimitExceeded } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitget extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitget',
                'name': 'Bitget',
                'countries': [ 'SG' ],
                'version': 'v3',
                'rateLimit': 1000, // up to 3000 requests per 5 minutes ≈ 600 requests per minute ≈ 10 requests per second ≈ 100 ms
                'has': {
                    'cancelOrder': true,
                    'cancelOrders': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchAccounts': true,
                    'fetchBalance': true,
                    'fetchCurrencies': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOpenOrders': true,
                    'fetchClosedOrders': true,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '2h': '2h',
                    '4h': '4h',
                    '6h': '6h',
                    '12h': '12h',
                    '1d': '1d',
                    '1w': '1w',
                },
                'hostname': 'bitget.com',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/88317935-a8a21c80-cd22-11ea-8e2b-4b9fac5975eb.jpg',
                    'api': {
                        'data': 'https://api.{hostname}',
                        'api': 'https://api.{hostname}',
                        'capi': 'https://capi.{hostname}',
                        'swap': 'https://capi.{hostname}',
                    },
                    'www': 'https://www.bitget.com',
                    'doc': [
                        'https://bitgetlimited.github.io/apidoc/en/swap',
                        'https://bitgetlimited.github.io/apidoc/en/spot',
                    ],
                    'fees': 'https://www.bitget.cc/zh-CN/rate?tab=1',
                    'test': {
                        'rest': 'https://testnet.bitget.com',
                    },
                    'referral': 'https://www.bitget.com/expressly?languageType=0&channelCode=ccxt&vipCode=tg9j',
                },
                'api': {
                    'data': {
                        'get': [
                            'market/history/kline', // Kline data
                            'market/detail/merged', // Get aggregated ticker
                            'market/tickers', // Get all trading tickers
                            'market/allticker', // Get all trading market method 2
                            'market/depth', // Get Market Depth Data
                            'market/trade', // Get Trade Detail Data
                            'market/history/trade', // Get record of trading
                            'market/detail', // Get Market Detail 24h Volume
                            'common/symbols', // Query all trading pairs and accuracy supported in the station
                            'common/currencys', // Query all currencies supported in the station
                            'common/timestamp', // Query system current time
                        ],
                    },
                    'api': {
                        'get': [
                            'account/accounts', // Get all accounts of current user(即account_id)。
                            'accounts/{account_id}/balance', // Get the balance of the specified account
                            'order/orders', // Query order, deprecated
                            'order/orders/openOrders',
                            'order/orders/history',
                            'order/deposit_withdraw', // Query assets history
                        ],
                        'post': [
                            'order/orders/place', // Place order
                            'order/orders/{order_id}/submitcancel', // Request to cancel an order request
                            'order/orders/batchcancel', // Bulk order cancellation
                            'order/orders/{order_id}', // Query an order details
                            'order/orders/{order_id}/matchresults', // Query the transaction details of an order
                            'order/matchresults', // Query current order, order history
                        ],
                    },
                    'capi': {
                        'get': [
                            'market/time',
                            'market/contracts',
                            'market/depth',
                            'market/tickers',
                            'market/ticker',
                            'market/trades',
                            'market/candles',
                            'market/index',
                            'market/open_count',
                            'market/open_interest',
                            'market/price_limit',
                            'market/funding_time',
                            'market/mark_price',
                            'market/open_count',
                            'market/historyFundRate',
                        ],
                    },
                    'swap': {
                        'get': [
                            'account/accounts',
                            'account/account',
                            'account/settings',
                            'position/allPosition',
                            'position/singlePosition',
                            'position/holds',
                            'order/detail',
                            'order/orders',
                            'order/fills',
                            'order/current',
                            'order/currentPlan', // conditional
                            'order/history',
                            'order/historyPlan', // conditional
                            'trace/closeTrack',
                            'trace/currentTrack',
                            'trace/historyTrack',
                            'trace/summary',
                            'trace/profitSettleTokenIdGroup',
                            'trace/profitDateGroupList',
                            'trace/profitDateList',
                            'trace/waitProfitDateList',
                        ],
                        'post': [
                            'account/leverage',
                            'account/adjustMargin',
                            'account/modifyAutoAppendMargin',
                            'order/placeOrder',
                            'order/batchOrders',
                            'order/cancel_order',
                            'order/cancel_batch_orders',
                            'order/plan_order',
                            'order/cancel_plan',
                            'position/changeHoldModel',
                            'trace/closeTrackOrder',
                        ],
                    },
                },
                'fees': {
                    'spot': {
                        'taker': this.parseNumber ('0.002'),
                        'maker': this.parseNumber ('0.002'),
                    },
                    'swap': {
                        'taker': this.parseNumber ('0.0006'),
                        'maker': this.parseNumber ('0.0004'),
                    },
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'password': true,
                },
                'exceptions': {
                    // http error codes
                    // 400 Bad Request — Invalid request format
                    // 401 Unauthorized — Invalid API Key
                    // 403 Forbidden — You do not have access to the requested resource
                    // 404 Not Found
                    // 500 Internal Server Error — We had a problem with our server
                    'exact': {
                        '1': ExchangeError, // { "code": 1, "message": "System error" }
                        // undocumented
                        'failure to get a peer from the ring-balancer': ExchangeNotAvailable, // { "message": "failure to get a peer from the ring-balancer" }
                        '4010': PermissionDenied, // { "code": 4010, "message": "For the security of your funds, withdrawals are not permitted within 24 hours after changing fund password  / mobile number / Google Authenticator settings " }
                        // common
                        // '0': ExchangeError, // 200 successful,when the order placement / cancellation / operation is successful
                        '4001': ExchangeError, // no data received in 30s
                        '4002': ExchangeError, // Buffer full. cannot write data
                        // --------------------------------------------------------
                        '30001': AuthenticationError, // { "code": 30001, "message": 'request header "OK_ACCESS_KEY" cannot be blank'}
                        '30002': AuthenticationError, // { "code": 30002, "message": 'request header "OK_ACCESS_SIGN" cannot be blank'}
                        '30003': AuthenticationError, // { "code": 30003, "message": 'request header "OK_ACCESS_TIMESTAMP" cannot be blank'}
                        '30004': AuthenticationError, // { "code": 30004, "message": 'request header "OK_ACCESS_PASSPHRASE" cannot be blank'}
                        '30005': InvalidNonce, // { "code": 30005, "message": "invalid OK_ACCESS_TIMESTAMP" }
                        '30006': AuthenticationError, // { "code": 30006, "message": "invalid OK_ACCESS_KEY" }
                        '30007': BadRequest, // { "code": 30007, "message": 'invalid Content_Type, please use "application/json" format'}
                        '30008': RequestTimeout, // { "code": 30008, "message": "timestamp request expired" }
                        '30009': ExchangeError, // { "code": 30009, "message": "system error" }
                        '30010': AuthenticationError, // { "code": 30010, "message": "API validation failed" }
                        '30011': PermissionDenied, // { "code": 30011, "message": "invalid IP" }
                        '30012': AuthenticationError, // { "code": 30012, "message": "invalid authorization" }
                        '30013': AuthenticationError, // { "code": 30013, "message": "invalid sign" }
                        '30014': DDoSProtection, // { "code": 30014, "message": "request too frequent" }
                        '30015': AuthenticationError, // { "code": 30015, "message": 'request header "OK_ACCESS_PASSPHRASE" incorrect'}
                        '30016': ExchangeError, // { "code": 30015, "message": "you are using v1 apiKey, please use v1 endpoint. If you would like to use v3 endpoint, please subscribe to v3 apiKey" }
                        '30017': ExchangeError, // { "code": 30017, "message": "apikey's broker id does not match" }
                        '30018': ExchangeError, // { "code": 30018, "message": "apikey's domain does not match" }
                        '30019': ExchangeNotAvailable, // { "code": 30019, "message": "Api is offline or unavailable" }
                        '30020': BadRequest, // { "code": 30020, "message": "body cannot be blank" }
                        '30021': BadRequest, // { "code": 30021, "message": "Json data format error" }, { "code": 30021, "message": "json data format error" }
                        '30022': PermissionDenied, // { "code": 30022, "message": "Api has been frozen" }
                        '30023': BadRequest, // { "code": 30023, "message": "{0} parameter cannot be blank" }
                        '30024': BadSymbol, // {"code":30024,"message":"\"instrument_id\" is an invalid parameter"}
                        '30025': BadRequest, // { "code": 30025, "message": "{0} parameter category error" }
                        '30026': DDoSProtection, // { "code": 30026, "message": "requested too frequent" }
                        '30027': AuthenticationError, // { "code": 30027, "message": "login failure" }
                        '30028': PermissionDenied, // { "code": 30028, "message": "unauthorized execution" }
                        '30029': AccountSuspended, // { "code": 30029, "message": "account suspended" }
                        '30030': ExchangeError, // { "code": 30030, "message": "endpoint request failed. Please try again" }
                        '30031': BadRequest, // { "code": 30031, "message": "token does not exist" }
                        '30032': BadSymbol, // { "code": 30032, "message": "pair does not exist" }
                        '30033': BadRequest, // { "code": 30033, "message": "exchange domain does not exist" }
                        '30034': ExchangeError, // { "code": 30034, "message": "exchange ID does not exist" }
                        '30035': ExchangeError, // { "code": 30035, "message": "trading is not supported in this website" }
                        '30036': ExchangeError, // { "code": 30036, "message": "no relevant data" }
                        '30037': ExchangeNotAvailable, // { "code": 30037, "message": "endpoint is offline or unavailable" }
                        // '30038': AuthenticationError, // { "code": 30038, "message": "user does not exist" }
                        '30038': OnMaintenance, // {"client_oid":"","code":"30038","error_code":"30038","error_message":"Matching engine is being upgraded. Please try in about 1 minute.","message":"Matching engine is being upgraded. Please try in about 1 minute.","order_id":"-1","result":false}
                        // futures
                        '32001': AccountSuspended, // { "code": 32001, "message": "futures account suspended" }
                        '32002': PermissionDenied, // { "code": 32002, "message": "futures account does not exist" }
                        '32003': CancelPending, // { "code": 32003, "message": "canceling, please wait" }
                        '32004': ExchangeError, // { "code": 32004, "message": "you have no unfilled orders" }
                        '32005': InvalidOrder, // { "code": 32005, "message": "max order quantity" }
                        '32006': InvalidOrder, // { "code": 32006, "message": "the order price or trigger price exceeds USD 1 million" }
                        '32007': InvalidOrder, // { "code": 32007, "message": "leverage level must be the same for orders on the same side of the contract" }
                        '32008': InvalidOrder, // { "code": 32008, "message": "Max. positions to open (cross margin)" }
                        '32009': InvalidOrder, // { "code": 32009, "message": "Max. positions to open (fixed margin)" }
                        '32010': ExchangeError, // { "code": 32010, "message": "leverage cannot be changed with open positions" }
                        '32011': ExchangeError, // { "code": 32011, "message": "futures status error" }
                        '32012': ExchangeError, // { "code": 32012, "message": "futures order update error" }
                        '32013': ExchangeError, // { "code": 32013, "message": "token type is blank" }
                        '32014': ExchangeError, // { "code": 32014, "message": "your number of contracts closing is larger than the number of contracts available" }
                        '32015': ExchangeError, // { "code": 32015, "message": "margin ratio is lower than 100% before opening positions" }
                        '32016': ExchangeError, // { "code": 32016, "message": "margin ratio is lower than 100% after opening position" }
                        '32017': ExchangeError, // { "code": 32017, "message": "no BBO" }
                        '32018': ExchangeError, // { "code": 32018, "message": "the order quantity is less than 1, please try again" }
                        '32019': ExchangeError, // { "code": 32019, "message": "the order price deviates from the price of the previous minute by more than 3%" }
                        '32020': ExchangeError, // { "code": 32020, "message": "the price is not in the range of the price limit" }
                        '32021': ExchangeError, // { "code": 32021, "message": "leverage error" }
                        '32022': ExchangeError, // { "code": 32022, "message": "this function is not supported in your country or region according to the regulations" }
                        '32023': ExchangeError, // { "code": 32023, "message": "this account has outstanding loan" }
                        '32024': ExchangeError, // { "code": 32024, "message": "order cannot be placed during delivery" }
                        '32025': ExchangeError, // { "code": 32025, "message": "order cannot be placed during settlement" }
                        '32026': ExchangeError, // { "code": 32026, "message": "your account is restricted from opening positions" }
                        '32027': ExchangeError, // { "code": 32027, "message": "cancelled over 20 orders" }
                        '32028': AccountSuspended, // { "code": 32028, "message": "account is suspended and liquidated" }
                        '32029': ExchangeError, // { "code": 32029, "message": "order info does not exist" }
                        '32030': InvalidOrder, // The order cannot be cancelled
                        '32031': ArgumentsRequired, // client_oid or order_id is required.
                        '32038': AuthenticationError, // User does not exist
                        '32040': ExchangeError, // User have open contract orders or position
                        '32044': ExchangeError, // { "code": 32044, "message": "The margin ratio after submitting this order is lower than the minimum requirement ({0}) for your tier." }
                        '32045': ExchangeError, // String of commission over 1 million
                        '32046': ExchangeError, // Each user can hold up to 10 trade plans at the same time
                        '32047': ExchangeError, // system error
                        '32048': InvalidOrder, // Order strategy track range error
                        '32049': ExchangeError, // Each user can hold up to 10 track plans at the same time
                        '32050': InvalidOrder, // Order strategy rang error
                        '32051': InvalidOrder, // Order strategy ice depth error
                        '32052': ExchangeError, // String of commission over 100 thousand
                        '32053': ExchangeError, // Each user can hold up to 6 ice plans at the same time
                        '32057': ExchangeError, // The order price is zero. Market-close-all function cannot be executed
                        '32054': ExchangeError, // Trade not allow
                        '32055': InvalidOrder, // cancel order error
                        '32056': ExchangeError, // iceberg per order average should between {0}-{1} contracts
                        '32058': ExchangeError, // Each user can hold up to 6 initiative plans at the same time
                        '32059': InvalidOrder, // Total amount should exceed per order amount
                        '32060': InvalidOrder, // Order strategy type error
                        '32061': InvalidOrder, // Order strategy initiative limit error
                        '32062': InvalidOrder, // Order strategy initiative range error
                        '32063': InvalidOrder, // Order strategy initiative rate error
                        '32064': ExchangeError, // Time Stringerval of orders should set between 5-120s
                        '32065': ExchangeError, // Close amount exceeds the limit of Market-close-all (999 for BTC, and 9999 for the rest tokens)
                        '32066': ExchangeError, // You have open orders. Please cancel all open orders before changing your leverage level.
                        '32067': ExchangeError, // Account equity < required margin in this setting. Please adjust your leverage level again.
                        '32068': ExchangeError, // The margin for this position will fall short of the required margin in this setting. Please adjust your leverage level or increase your margin to proceed.
                        '32069': ExchangeError, // Target leverage level too low. Your account balance is insufficient to cover the margin required. Please adjust the leverage level again.
                        '32070': ExchangeError, // Please check open position or unfilled order
                        '32071': ExchangeError, // Your current liquidation mode does not support this action.
                        '32072': ExchangeError, // The highest available margin for your order’s tier is {0}. Please edit your margin and place a new order.
                        '32073': ExchangeError, // The action does not apply to the token
                        '32074': ExchangeError, // The number of contracts of your position, open orders, and the current order has exceeded the maximum order limit of this asset.
                        '32075': ExchangeError, // Account risk rate breach
                        '32076': ExchangeError, // Liquidation of the holding position(s) at market price will require cancellation of all pending close orders of the contracts.
                        '32077': ExchangeError, // Your margin for this asset in futures account is insufficient and the position has been taken over for liquidation. (You will not be able to place orders, close positions, transfer funds, or add margin during this period of time. Your account will be restored after the liquidation is complete.)
                        '32078': ExchangeError, // Please cancel all open orders before switching the liquidation mode(Please cancel all open orders before switching the liquidation mode)
                        '32079': ExchangeError, // Your open positions are at high risk.(Please add margin or reduce positions before switching the mode)
                        '32080': ExchangeError, // Funds cannot be transferred out within 30 minutes after futures settlement
                        '32083': ExchangeError, // The number of contracts should be a positive multiple of %%. Please place your order again
                        // token and margin trading
                        '33001': PermissionDenied, // { "code": 33001, "message": "margin account for this pair is not enabled yet" }
                        '33002': AccountSuspended, // { "code": 33002, "message": "margin account for this pair is suspended" }
                        '33003': InsufficientFunds, // { "code": 33003, "message": "no loan balance" }
                        '33004': ExchangeError, // { "code": 33004, "message": "loan amount cannot be smaller than the minimum limit" }
                        '33005': ExchangeError, // { "code": 33005, "message": "repayment amount must exceed 0" }
                        '33006': ExchangeError, // { "code": 33006, "message": "loan order not found" }
                        '33007': ExchangeError, // { "code": 33007, "message": "status not found" }
                        '33008': InsufficientFunds, // { "code": 33008, "message": "loan amount cannot exceed the maximum limit" }
                        '33009': ExchangeError, // { "code": 33009, "message": "user ID is blank" }
                        '33010': ExchangeError, // { "code": 33010, "message": "you cannot cancel an order during session 2 of call auction" }
                        '33011': ExchangeError, // { "code": 33011, "message": "no new market data" }
                        '33012': ExchangeError, // { "code": 33012, "message": "order cancellation failed" }
                        '33013': InvalidOrder, // { "code": 33013, "message": "order placement failed" }
                        '33014': OrderNotFound, // { "code": 33014, "message": "order does not exist" }
                        '33015': InvalidOrder, // { "code": 33015, "message": "exceeded maximum limit" }
                        '33016': ExchangeError, // { "code": 33016, "message": "margin trading is not open for this token" }
                        '33017': InsufficientFunds, // { "code": 33017, "message": "insufficient balance" }
                        '33018': ExchangeError, // { "code": 33018, "message": "this parameter must be smaller than 1" }
                        '33020': ExchangeError, // { "code": 33020, "message": "request not supported" }
                        '33021': BadRequest, // { "code": 33021, "message": "token and the pair do not match" }
                        '33022': InvalidOrder, // { "code": 33022, "message": "pair and the order do not match" }
                        '33023': ExchangeError, // { "code": 33023, "message": "you can only place market orders during call auction" }
                        '33024': InvalidOrder, // { "code": 33024, "message": "trading amount too small" }
                        '33025': InvalidOrder, // { "code": 33025, "message": "base token amount is blank" }
                        '33026': ExchangeError, // { "code": 33026, "message": "transaction completed" }
                        '33027': InvalidOrder, // { "code": 33027, "message": "cancelled order or order cancelling" }
                        '33028': InvalidOrder, // { "code": 33028, "message": "the decimal places of the trading price exceeded the limit" }
                        '33029': InvalidOrder, // { "code": 33029, "message": "the decimal places of the trading size exceeded the limit" }
                        '33034': ExchangeError, // { "code": 33034, "message": "You can only place limit order after Call Auction has started" }
                        '33035': ExchangeError, // This type of order cannot be canceled(This type of order cannot be canceled)
                        '33036': ExchangeError, // Exceeding the limit of entrust order
                        '33037': ExchangeError, // The buy order price should be lower than 130% of the trigger price
                        '33038': ExchangeError, // The sell order price should be higher than 70% of the trigger price
                        '33039': ExchangeError, // The limit of callback rate is 0 < x <= 5%
                        '33040': ExchangeError, // The trigger price of a buy order should be lower than the latest transaction price
                        '33041': ExchangeError, // The trigger price of a sell order should be higher than the latest transaction price
                        '33042': ExchangeError, // The limit of price variance is 0 < x <= 1%
                        '33043': ExchangeError, // The total amount must be larger than 0
                        '33044': ExchangeError, // The average amount should be 1/1000 * total amount <= x <= total amount
                        '33045': ExchangeError, // The price should not be 0, including trigger price, order price, and price limit
                        '33046': ExchangeError, // Price variance should be 0 < x <= 1%
                        '33047': ExchangeError, // Sweep ratio should be 0 < x <= 100%
                        '33048': ExchangeError, // Per order limit: Total amount/1000 < x <= Total amount
                        '33049': ExchangeError, // Total amount should be X > 0
                        '33050': ExchangeError, // Time interval should be 5 <= x <= 120s
                        '33051': ExchangeError, // cancel order number not higher limit: plan and track entrust no more than 10, ice and time entrust no more than 6
                        '33059': BadRequest, // { "code": 33059, "message": "client_oid or order_id is required" }
                        '33060': BadRequest, // { "code": 33060, "message": "Only fill in either parameter client_oid or order_id" }
                        '33061': ExchangeError, // Value of a single market price order cannot exceed 100,000 USD
                        '33062': ExchangeError, // The leverage ratio is too high. The borrowed position has exceeded the maximum position of this leverage ratio. Please readjust the leverage ratio
                        '33063': ExchangeError, // Leverage multiple is too low, there is insufficient margin in the account, please readjust the leverage ratio
                        '33064': ExchangeError, // The setting of the leverage ratio cannot be less than 2, please readjust the leverage ratio
                        '33065': ExchangeError, // Leverage ratio exceeds maximum leverage ratio, please readjust leverage ratio
                        // account
                        '21009': ExchangeError, // Funds cannot be transferred out within 30 minutes after swap settlement(Funds cannot be transferred out within 30 minutes after swap settlement)
                        '34001': PermissionDenied, // { "code": 34001, "message": "withdrawal suspended" }
                        '34002': InvalidAddress, // { "code": 34002, "message": "please add a withdrawal address" }
                        '34003': ExchangeError, // { "code": 34003, "message": "sorry, this token cannot be withdrawn to xx at the moment" }
                        '34004': ExchangeError, // { "code": 34004, "message": "withdrawal fee is smaller than minimum limit" }
                        '34005': ExchangeError, // { "code": 34005, "message": "withdrawal fee exceeds the maximum limit" }
                        '34006': ExchangeError, // { "code": 34006, "message": "withdrawal amount is lower than the minimum limit" }
                        '34007': ExchangeError, // { "code": 34007, "message": "withdrawal amount exceeds the maximum limit" }
                        '34008': InsufficientFunds, // { "code": 34008, "message": "insufficient balance" }
                        '34009': ExchangeError, // { "code": 34009, "message": "your withdrawal amount exceeds the daily limit" }
                        '34010': ExchangeError, // { "code": 34010, "message": "transfer amount must be larger than 0" }
                        '34011': ExchangeError, // { "code": 34011, "message": "conditions not met" }
                        '34012': ExchangeError, // { "code": 34012, "message": "the minimum withdrawal amount for NEO is 1, and the amount must be an integer" }
                        '34013': ExchangeError, // { "code": 34013, "message": "please transfer" }
                        '34014': ExchangeError, // { "code": 34014, "message": "transfer limited" }
                        '34015': ExchangeError, // { "code": 34015, "message": "subaccount does not exist" }
                        '34016': PermissionDenied, // { "code": 34016, "message": "transfer suspended" }
                        '34017': AccountSuspended, // { "code": 34017, "message": "account suspended" }
                        '34018': AuthenticationError, // { "code": 34018, "message": "incorrect trades password" }
                        '34019': PermissionDenied, // { "code": 34019, "message": "please bind your email before withdrawal" }
                        '34020': PermissionDenied, // { "code": 34020, "message": "please bind your funds password before withdrawal" }
                        '34021': InvalidAddress, // { "code": 34021, "message": "Not verified address" }
                        '34022': ExchangeError, // { "code": 34022, "message": "Withdrawals are not available for sub accounts" }
                        '34023': PermissionDenied, // { "code": 34023, "message": "Please enable futures trading before transferring your funds" }
                        '34026': ExchangeError, // transfer too frequently(transfer too frequently)
                        '34036': ExchangeError, // Parameter is incorrect, please refer to API documentation
                        '34037': ExchangeError, // Get the sub-account balance interface, account type is not supported
                        '34038': ExchangeError, // Since your C2C transaction is unusual, you are restricted from fund transfer. Please contact our customer support to cancel the restriction
                        '34039': ExchangeError, // You are now restricted from transferring out your funds due to abnormal trades on C2C Market. Please transfer your fund on our website or app instead to verify your identity
                        // swap
                        '35001': ExchangeError, // { "code": 35001, "message": "Contract does not exist" }
                        '35002': ExchangeError, // { "code": 35002, "message": "Contract settling" }
                        '35003': ExchangeError, // { "code": 35003, "message": "Contract paused" }
                        '35004': ExchangeError, // { "code": 35004, "message": "Contract pending settlement" }
                        '35005': AuthenticationError, // { "code": 35005, "message": "User does not exist" }
                        '35008': InvalidOrder, // { "code": 35008, "message": "Risk ratio too high" }
                        '35010': InvalidOrder, // { "code": 35010, "message": "Position closing too large" }
                        '35012': InvalidOrder, // { "code": 35012, "message": "Incorrect order size" }
                        '35014': InvalidOrder, // { "code": 35014, "message": "Order price is not within limit" }
                        '35015': InvalidOrder, // { "code": 35015, "message": "Invalid leverage level" }
                        '35017': ExchangeError, // { "code": 35017, "message": "Open orders exist" }
                        '35019': InvalidOrder, // { "code": 35019, "message": "Order size too large" }
                        '35020': InvalidOrder, // { "code": 35020, "message": "Order price too high" }
                        '35021': InvalidOrder, // { "code": 35021, "message": "Order size exceeded current tier limit" }
                        '35022': ExchangeError, // { "code": 35022, "message": "Contract status error" }
                        '35024': ExchangeError, // { "code": 35024, "message": "Contract not initialized" }
                        '35025': InsufficientFunds, // { "code": 35025, "message": "No account balance" }
                        '35026': ExchangeError, // { "code": 35026, "message": "Contract settings not initialized" }
                        '35029': OrderNotFound, // { "code": 35029, "message": "Order does not exist" }
                        '35030': InvalidOrder, // { "code": 35030, "message": "Order size too large" }
                        '35031': InvalidOrder, // { "code": 35031, "message": "Cancel order size too large" }
                        '35032': ExchangeError, // { "code": 35032, "message": "Invalid user status" }
                        '35037': ExchangeError, // No last traded price in cache
                        '35039': ExchangeError, // { "code": 35039, "message": "Open order quantity exceeds limit" }
                        '35040': InvalidOrder, // {"error_message":"Invalid order type","result":"true","error_code":"35040","order_id":"-1"}
                        '35044': ExchangeError, // { "code": 35044, "message": "Invalid order status" }
                        '35046': InsufficientFunds, // { "code": 35046, "message": "Negative account balance" }
                        '35047': InsufficientFunds, // { "code": 35047, "message": "Insufficient account balance" }
                        '35048': ExchangeError, // { "code": 35048, "message": "User contract is frozen and liquidating" }
                        '35049': InvalidOrder, // { "code": 35049, "message": "Invalid order type" }
                        '35050': InvalidOrder, // { "code": 35050, "message": "Position settings are blank" }
                        '35052': InsufficientFunds, // { "code": 35052, "message": "Insufficient cross margin" }
                        '35053': ExchangeError, // { "code": 35053, "message": "Account risk too high" }
                        '35055': InsufficientFunds, // { "code": 35055, "message": "Insufficient account balance" }
                        '35057': ExchangeError, // { "code": 35057, "message": "No last traded price" }
                        '35058': ExchangeError, // { "code": 35058, "message": "No limit" }
                        '35059': BadRequest, // { "code": 35059, "message": "client_oid or order_id is required" }
                        '35060': BadRequest, // { "code": 35060, "message": "Only fill in either parameter client_oid or order_id" }
                        '35061': BadRequest, // { "code": 35061, "message": "Invalid instrument_id" }
                        '35062': InvalidOrder, // { "code": 35062, "message": "Invalid match_price" }
                        '35063': InvalidOrder, // { "code": 35063, "message": "Invalid order_size" }
                        '35064': InvalidOrder, // { "code": 35064, "message": "Invalid client_oid" }
                        '35066': InvalidOrder, // Order interval error
                        '35067': InvalidOrder, // Time-weighted order ratio error
                        '35068': InvalidOrder, // Time-weighted order range error
                        '35069': InvalidOrder, // Time-weighted single transaction limit error
                        '35070': InvalidOrder, // Algo order type error
                        '35071': InvalidOrder, // Order total must be larger than single order limit
                        '35072': InvalidOrder, // Maximum 6 unfulfilled time-weighted orders can be held at the same time
                        '35073': InvalidOrder, // Order price is 0. Market-close-all not available
                        '35074': InvalidOrder, // Iceberg order single transaction average error
                        '35075': InvalidOrder, // Failed to cancel order
                        '35076': InvalidOrder, // LTC 20x leverage. Not allowed to open position
                        '35077': InvalidOrder, // Maximum 6 unfulfilled iceberg orders can be held at the same time
                        '35078': InvalidOrder, // Order amount exceeded 100,000
                        '35079': InvalidOrder, // Iceberg order price variance error
                        '35080': InvalidOrder, // Callback rate error
                        '35081': InvalidOrder, // Maximum 10 unfulfilled trail orders can be held at the same time
                        '35082': InvalidOrder, // Trail order callback rate error
                        '35083': InvalidOrder, // Each user can only hold a maximum of 10 unfulfilled stop-limit orders at the same time
                        '35084': InvalidOrder, // Order amount exceeded 1 million
                        '35085': InvalidOrder, // Order amount is not in the correct range
                        '35086': InvalidOrder, // Price exceeds 100 thousand
                        '35087': InvalidOrder, // Price exceeds 100 thousand
                        '35088': InvalidOrder, // Average amount error
                        '35089': InvalidOrder, // Price exceeds 100 thousand
                        '35090': ExchangeError, // No stop-limit orders available for cancelation
                        '35091': ExchangeError, // No trail orders available for cancellation
                        '35092': ExchangeError, // No iceberg orders available for cancellation
                        '35093': ExchangeError, // No trail orders available for cancellation
                        '35094': ExchangeError, // Stop-limit order last traded price error
                        '35095': BadRequest, // Instrument_id error
                        '35096': ExchangeError, // Algo order status error
                        '35097': ExchangeError, // Order status and order ID cannot exist at the same time
                        '35098': ExchangeError, // An order status or order ID must exist
                        '35099': ExchangeError, // Algo order ID error
                        // option
                        '36001': BadRequest, // Invalid underlying index.
                        '36002': BadRequest, // Instrument does not exist.
                        '36005': ExchangeError, // Instrument status is invalid.
                        '36101': AuthenticationError, // Account does not exist.
                        '36102': PermissionDenied, // Account status is invalid.
                        '36103': AccountSuspended, // Account is suspended due to ongoing liquidation.
                        '36104': PermissionDenied, // Account is not enabled for options trading.
                        '36105': PermissionDenied, // Please enable the account for option contract.
                        '36106': AccountSuspended, // Funds cannot be transferred in or out, as account is suspended.
                        '36107': PermissionDenied, // Funds cannot be transferred out within 30 minutes after option exercising or settlement.
                        '36108': InsufficientFunds, // Funds cannot be transferred in or out, as equity of the account is less than zero.
                        '36109': PermissionDenied, // Funds cannot be transferred in or out during option exercising or settlement.
                        '36201': PermissionDenied, // New order function is blocked.
                        '36202': PermissionDenied, // Account does not have permission to short option.
                        '36203': InvalidOrder, // Invalid format for client_oid.
                        '36204': ExchangeError, // Invalid format for request_id.
                        '36205': BadRequest, // Instrument id does not match underlying index.
                        '36206': BadRequest, // Order_id and client_oid can not be used at the same time.
                        '36207': InvalidOrder, // Either order price or fartouch price must be present.
                        '36208': InvalidOrder, // Either order price or size must be present.
                        '36209': InvalidOrder, // Either order_id or client_oid must be present.
                        '36210': InvalidOrder, // Either order_ids or client_oids must be present.
                        '36211': InvalidOrder, // Exceeding max batch size for order submission.
                        '36212': InvalidOrder, // Exceeding max batch size for oder cancellation.
                        '36213': InvalidOrder, // Exceeding max batch size for order amendment.
                        '36214': ExchangeError, // Instrument does not have valid bid/ask quote.
                        '36216': OrderNotFound, // Order does not exist.
                        '36217': InvalidOrder, // Order submission failed.
                        '36218': InvalidOrder, // Order cancellation failed.
                        '36219': InvalidOrder, // Order amendment failed.
                        '36220': InvalidOrder, // Order is pending cancel.
                        '36221': InvalidOrder, // Order qty is not valid multiple of lot size.
                        '36222': InvalidOrder, // Order price is breaching highest buy limit.
                        '36223': InvalidOrder, // Order price is breaching lowest sell limit.
                        '36224': InvalidOrder, // Exceeding max order size.
                        '36225': InvalidOrder, // Exceeding max open order count for instrument.
                        '36226': InvalidOrder, // Exceeding max open order count for underlying.
                        '36227': InvalidOrder, // Exceeding max open size across all orders for underlying
                        '36228': InvalidOrder, // Exceeding max available qty for instrument.
                        '36229': InvalidOrder, // Exceeding max available qty for underlying.
                        '36230': InvalidOrder, // Exceeding max position limit for underlying.
                        // --------------------------------------------------------
                        // swap
                        '400': BadRequest, // Bad Request
                        '401': AuthenticationError, // Unauthorized access
                        '403': PermissionDenied, // Access prohibited
                        '404': BadRequest, // Request address does not exist
                        '405': BadRequest, // The HTTP Method is not supported
                        '415': BadRequest, // The current media type is not supported
                        '429': DDoSProtection, // Too many requests
                        '500': ExchangeNotAvailable, // System busy
                        '1001': RateLimitExceeded, // The request is too frequent and has been throttled
                        '1002': ExchangeError, // {0} verifications within 24 hours
                        '1003': ExchangeError, // You failed more than {0} times today, the current operation is locked, please try again in 24 hours
                        // '00000': ExchangeError, // success
                        '40001': AuthenticationError, // ACCESS_KEY cannot be empty
                        '40002': AuthenticationError, // SECRET_KEY cannot be empty
                        '40003': AuthenticationError, // Signature cannot be empty
                        '40004': InvalidNonce, // Request timestamp expired
                        '40005': InvalidNonce, // Invalid ACCESS_TIMESTAMP
                        '40006': AuthenticationError, // Invalid ACCESS_KEY
                        '40007': BadRequest, // Invalid Content_Type
                        '40008': InvalidNonce, // Request timestamp expired
                        '40009': AuthenticationError, // sign signature error
                        '40010': AuthenticationError, // sign signature error
                        '40011': AuthenticationError, // ACCESS_PASSPHRASE cannot be empty
                        '40012': AuthenticationError, // apikey/password is incorrect
                        '40013': ExchangeError, // User status is abnormal
                        '40014': PermissionDenied, // Incorrect permissions
                        '40015': ExchangeError, // System is abnormal, please try again later
                        '40016': PermissionDenied, // The user must bind the phone or Google
                        '40017': ExchangeError, // Parameter verification failed
                        '40018': PermissionDenied, // Invalid IP
                        '40102': BadRequest, // Contract configuration does not exist, please check the parameters
                        '40103': BadRequest, // Request method cannot be empty
                        '40104': ExchangeError, // Lever adjustment failure
                        '40105': ExchangeError, // Abnormal access to current price limit data
                        '40106': ExchangeError, // Abnormal get next settlement time
                        '40107': ExchangeError, // Abnormal access to index price data
                        '40108': InvalidOrder, // Wrong order quantity
                        '40109': OrderNotFound, // The data of the order cannot be found, please confirm the order number
                        '40200': OnMaintenance, // Server upgrade, please try again later
                        '40201': InvalidOrder, // Order number cannot be empty
                        '40202': ExchangeError, // User information cannot be empty
                        '40203': BadRequest, // The amount of adjustment margin cannot be empty or negative
                        '40204': BadRequest, // Adjustment margin type cannot be empty
                        '40205': BadRequest, // Adjusted margin type data is wrong
                        '40206': BadRequest, // The direction of the adjustment margin cannot be empty
                        '40207': BadRequest, // The adjustment margin data is wrong
                        '40208': BadRequest, // The accuracy of the adjustment margin amount is incorrect
                        '40209': BadRequest, // The current page number is wrong, please confirm
                        '40300': ExchangeError, // User does not exist
                        '40301': PermissionDenied, // Permission has not been obtained yet. If you need to use it, please contact customer service
                        '40302': BadRequest, // Parameter abnormality
                        '40303': BadRequest, // Can only query up to 20,000 data
                        '40304': BadRequest, // Parameter type is abnormal
                        '40305': BadRequest, // Client_oid length is not greater than 50, and cannot be Martian characters
                        '40306': ExchangeError, // Batch processing orders can only process up to 20
                        '40308': OnMaintenance, // The contract is being temporarily maintained
                        '40309': BadSymbol, // The contract has been removed
                        '40400': ExchangeError, // Status check abnormal
                        '40401': ExchangeError, // The operation cannot be performed
                        '40402': BadRequest, // The opening direction cannot be empty
                        '40403': BadRequest, // Wrong opening direction format
                        '40404': BadRequest, // Whether to enable automatic margin call parameters cannot be empty
                        '40405': BadRequest, // Whether to enable the automatic margin call parameter type is wrong
                        '40406': BadRequest, // Whether to enable automatic margin call parameters is of unknown type
                        '40407': ExchangeError, // The query direction is not the direction entrusted by the plan
                        '40408': ExchangeError, // Wrong time range
                        '40409': ExchangeError, // Time format error
                        '40500': InvalidOrder, // Client_oid check error
                        '40501': ExchangeError, // Channel name error
                        '40502': ExchangeError, // If it is a copy user, you must pass the copy to whom
                        '40503': ExchangeError, // With the single type
                        '40504': ExchangeError, // Platform code must pass
                        '40505': ExchangeError, // Not the same as single type
                        '40506': AuthenticationError, // Platform signature error
                        '40507': AuthenticationError, // Api signature error
                        '40508': ExchangeError, // KOL is not authorized
                        '40509': ExchangeError, // Abnormal copy end
                        '40600': ExchangeError, // Copy function suspended
                        '40601': ExchangeError, // Followers cannot be KOL
                        '40602': ExchangeError, // The number of copies has reached the limit and cannot process the request
                        '40603': ExchangeError, // Abnormal copy end
                        '40604': ExchangeNotAvailable, // Server is busy, please try again later
                        '40605': ExchangeError, // Copy type, the copy number must be passed
                        '40606': ExchangeError, // The type of document number is wrong
                        '40607': ExchangeError, // Document number must be passed
                        '40608': ExchangeError, // No documented products currently supported
                        '40609': ExchangeError, // The contract product does not support copying
                        '40700': BadRequest, // Cursor parameters are incorrect
                        '40701': ExchangeError, // KOL is not authorized
                        '40702': ExchangeError, // Unauthorized copying user
                        '40703': ExchangeError, // Bill inquiry start and end time cannot be empty
                        '40704': ExchangeError, // Can only check the data of the last three months
                        '40705': BadRequest, // The start and end time cannot exceed 90 days
                        '40706': InvalidOrder, // Wrong order price
                        '40707': BadRequest, // Start time is greater than end time
                        '40708': BadRequest, // Parameter verification is abnormal
                        '40709': ExchangeError, // There is no position in this position, and no automatic margin call can be set
                        '40710': ExchangeError, // Abnormal account status
                        '40711': InsufficientFunds, // Insufficient contract account balance
                        '40712': InsufficientFunds, // Insufficient margin
                        '40713': ExchangeError, // Cannot exceed the maximum transferable margin amount
                        '40714': ExchangeError, // No direct margin call is allowed
                        // spot
                        'invalid sign': AuthenticationError,
                        'invalid currency': BadSymbol, // invalid trading pair
                        'invalid symbol': BadSymbol,
                        'invalid period': BadRequest, // invalid Kline type
                        'invalid user': ExchangeError,
                        'invalid amount': InvalidOrder,
                        'invalid type': InvalidOrder, // {"status":"error","ts":1595700344504,"err_code":"invalid-parameter","err_msg":"invalid type"}
                        'invalid orderId': InvalidOrder,
                        'invalid record': ExchangeError,
                        'invalid accountId': BadRequest,
                        'invalid address': BadRequest,
                        'accesskey not null': AuthenticationError, // {"status":"error","ts":1595704360508,"err_code":"invalid-parameter","err_msg":"accesskey not null"}
                        'illegal accesskey': AuthenticationError,
                        'sign not null': AuthenticationError,
                        'req_time is too much difference from server time': InvalidNonce,
                        'permissions not right': PermissionDenied, // {"status":"error","ts":1595704490084,"err_code":"invalid-parameter","err_msg":"permissions not right"}
                        'illegal sign invalid': AuthenticationError, // {"status":"error","ts":1595684716042,"err_code":"invalid-parameter","err_msg":"illegal sign invalid"}
                        'user locked': AccountSuspended,
                        'Request Frequency Is Too High': RateLimitExceeded,
                        'more than a daily rate of cash': BadRequest,
                        'more than the maximum daily withdrawal amount': BadRequest,
                        'need to bind email or mobile': ExchangeError,
                        'user forbid': PermissionDenied,
                        'User Prohibited Cash Withdrawal': PermissionDenied,
                        'Cash Withdrawal Is Less Than The Minimum Value': BadRequest,
                        'Cash Withdrawal Is More Than The Maximum Value': BadRequest,
                        'the account with in 24 hours ban coin': PermissionDenied,
                        'order cancel fail': BadRequest, // {"status":"error","ts":1595703343035,"err_code":"bad-request","err_msg":"order cancel fail"}
                        'base symbol error': BadSymbol,
                        'base date error': ExchangeError,
                        'api signature not valid': AuthenticationError,
                        'gateway internal error': ExchangeError,
                        'audit failed': ExchangeError,
                        'order queryorder invalid': BadRequest,
                        'market no need price': InvalidOrder,
                        'limit need price': InvalidOrder,
                        'userid not equal to account_id': ExchangeError,
                        'your balance is low': InsufficientFunds, // {"status":"error","ts":1595594160149,"err_code":"invalid-parameter","err_msg":"invalid size, valid range: [1,2000]"}
                        'address invalid cointype': ExchangeError,
                        'system exception': ExchangeError, // {"status":"error","ts":1595711862763,"err_code":"system exception","err_msg":"system exception"}
                        '50003': ExchangeError, // No record
                        '50004': BadSymbol, // The transaction pair is currently not supported or has been suspended
                        '50006': PermissionDenied, // The account is forbidden to withdraw. If you have any questions, please contact customer service.
                        '50007': PermissionDenied, // The account is forbidden to withdraw within 24 hours. If you have any questions, please contact customer service.
                        '50008': RequestTimeout, // network timeout
                        '50009': RateLimitExceeded, // The operation is too frequent, please try again later
                        '50010': ExchangeError, // The account is abnormally frozen. If you have any questions, please contact customer service.
                        '50014': InvalidOrder, // The transaction amount under minimum limits
                        '50015': InvalidOrder, // The transaction amount exceed maximum limits
                        '50016': InvalidOrder, // The price can't be higher than the current price
                        '50017': InvalidOrder, // Price under minimum limits
                        '50018': InvalidOrder, // The price exceed maximum limits
                        '50019': InvalidOrder, // The amount under minimum limits
                        '50020': InsufficientFunds, // Insufficient balance
                        '50021': InvalidOrder, // Price is under minimum limits
                        '50026': InvalidOrder, // Market price parameter error
                        'invalid order query time': ExchangeError, // start time is greater than end time; or the time interval between start time and end time is greater than 48 hours
                        'invalid start time': BadRequest, // start time is a date 30 days ago; or start time is a date in the future
                        'invalid end time': BadRequest, // end time is a date 30 days ago; or end time is a date in the future
                        '20003': ExchangeError, // operation failed, {"status":"error","ts":1595730308979,"err_code":"bad-request","err_msg":"20003"}
                        '01001': ExchangeError, // order failed, {"status":"fail","err_code":"01001","err_msg":"系统异常，请稍后重试"}
                    },
                    'broad': {
                        'invalid size, valid range': ExchangeError,
                    },
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    'createMarketBuyOrderRequiresPrice': true,
                    'fetchMarkets': [
                        'spot',
                        'swap',
                    ],
                    'parseOHLCV': {
                        'volume': {
                            'spot': 'amount',
                            'swap': 5,
                        },
                    },
                    'defaultType': 'spot', // 'spot', 'swap'
                    'accountId': undefined, // '1012838157',
                    'timeframes': {
                        'spot': {
                            '1m': '1min',
                            '5m': '5min',
                            '15m': '15min',
                            '30m': '30min',
                            '1h': '60min',
                            '2h': '120min',
                            '4h': '240min',
                            '6h': '360min',
                            '12h': '720min',
                            '1d': '1day',
                            '1w': '1week',
                        },
                        'swap': {
                            '1m': '60',
                            '5m': '300',
                            '15m': '900',
                            '30m': '1800',
                            '1h': '3600',
                            '2h': '7200',
                            '4h': '14400',
                            '6h': '21600',
                            '12h': '43200',
                            '1d': '86400',
                            '1w': '604800',
                        },
                    },
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.dataGetCommonTimestamp (params);
            //
            //     {
            //         "status":"ok",
            //         "data":"1595525139400"
            //     }
            //
            return this.safeInteger (response, 'data');
        }
    
        async fetchMarkets (params = {}) {
            let types = this.safeValue (this.options, 'fetchMarkets');
            if (!types.length) {
                types = [
                    this.options['defaultType'],
                ];
            }
            let result = [];
            for (let i = 0; i < types.length; i++) {
                const markets = await this.fetchMarketsByType (types[i], params);
                result = this.arrayConcat (result, markets);
            }
            return result;
        }
    
        parseMarkets (markets) {
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                result.push (this.parseMarket (markets[i]));
            }
            return result;
        }
    
        parseMarket (market) {
            //
            // spot
            //
            //     {
            //         "base_currency":"btc",
            //         "quote_currency":"usdt",
            //         "symbol":"btc_usdt",
            //         "tick_size":"2",
            //         "size_increment":"4",
            //         "status":"1",
            //         "base_asset_precision":"8"
            //     }
            //
            //
            // swap
            //
            //     {
            //         "symbol":"btcusd",
            //         "underlying_index":"BTC",
            //         "quote_currency":"USD",
            //         "coin":"BTC",
            //         "contract_val":"1",
            //         "listing":null,
            //         "delivery":["07:00:00","15:00:00","23:00:00"],
            //         "size_increment":"0",
            //         "tick_size":"1",
            //         "forwardContractFlag":false,
            //         "priceEndStep":5
            //     }
            //
            const id = this.safeString (market, 'symbol');
            let marketType = 'spot';
            let spot = true;
            let swap = false;
            const baseId = this.safeString2 (market, 'base_currency', 'coin');
            const quoteId = this.safeString (market, 'quote_currency');
            const contractVal = this.safeNumber (market, 'contract_val');
            if (contractVal !== undefined) {
                marketType = 'swap';
                spot = false;
                swap = true;
            }
            const base = this.safeCurrencyCode (baseId);
            const quote = this.safeCurrencyCode (quoteId);
            let symbol = id.toUpperCase ();
            if (spot) {
                symbol = base + '/' + quote;
            }
            const tickSize = this.safeString (market, 'tick_size');
            const sizeIncrement = this.safeString (market, 'size_increment');
            const precision = {
                'amount': this.parseNumber (this.parsePrecision (sizeIncrement)),
                'price': this.parseNumber (this.parsePrecision (tickSize)),
            };
            const minAmount = this.safeNumber2 (market, 'min_size', 'base_min_size');
            const status = this.safeString (market, 'status');
            let active = undefined;
            if (status !== undefined) {
                active = (status === '1');
            }
            const fees = this.safeValue2 (this.fees, marketType, 'trading', {});
            return this.extend (fees, {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'info': market,
                'type': marketType,
                'spot': spot,
                'swap': swap,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': minAmount,
                        'max': undefined,
                    },
                    'price': {
                        'min': precision['price'],
                        'max': undefined,
                    },
                    'cost': {
                        'min': precision['price'],
                        'max': undefined,
                    },
                },
            });
        }
    
        async fetchMarketsByType (type, params = {}) {
            if (type === 'spot') {
                const response = await this.dataGetCommonSymbols (params);
                //
                //     {
                //         "status":"ok",
                //         "ts":1595526622408,
                //         "data":[
                //             {
                //                 "base_currency":"btc",
                //                 "quote_currency":"usdt",
                //                 "symbol":"btc_usdt",
                //                 "tick_size":"2",
                //                 "size_increment":"4",
                //                 "status":"1",
                //                 "base_asset_precision":"8"
                //             },
                //         ]
                //     }
                //
                const data = this.safeValue (response, 'data', []);
                return this.parseMarkets (data);
            } else if (type === 'swap') {
                const response = await this.capiGetMarketContracts (params);
                //
                //     {
                //         "data":{
                //             "contractApis":[
                //                 {
                //                     "instrument_id":"btcusd",
                //                     "underlying_index":"BTC",
                //                     "quote_currency":"USD",
                //                     "coin":"BTC",
                //                     "contract_val":"1",
                //                     "delivery":["07:00:00","15:00:00","23:00:00"],
                //                     "size_increment":"0",
                //                     "tick_size":"1",
                //                     "forwardContractFlag":false,
                //                     "priceEndStep":"5"
                //                 },
                //             ]
                //         },
                //         "status":"ok",
                //         "err_code":"00000"
                //     }
                //
                return this.parseMarkets (response);
            } else {
                throw new NotSupported (this.id + ' fetchMarketsByType does not support market type ' + type);
            }
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.dataGetCommonCurrencys (params);
            //
            //     {
            //         "status":"ok",
            //         "ts":1595537740466,
            //         "data":[
            //             "btc",
            //             "bft",
            //             "usdt",
            //             "usdt-omni",
            //             "usdt-erc20"
            //         ]
            //     }
            //
            const result = {};
            const data = this.safeValue (response, 'data', []);
            for (let i = 0; i < data.length; i++) {
                const id = data[i];
                const code = this.safeCurrencyCode (id);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': id,
                    'type': undefined,
                    'name': undefined,
                    'active': undefined,
                    'fee': undefined,
                    'precision': undefined,
                    'limits': {
                        'amount': { 'min': undefined, 'max': undefined },
                        'withdraw': { 'min': undefined, 'max': undefined },
                    },
                };
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            if (market['spot']) {
                method = 'dataGetMarketDepth';
                request['type'] = 'step0'; // step0, step1, step2, step3, step4, step5, do not merge depth if step0
            } else if (market['swap']) {
                method = 'capiGetMarketDepth';
                request['limit'] = (limit === undefined) ? 100 : limit; // max 100
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ch":"market.btc_usdt.depth.step0",
            //         "ts":1595607628197,
            //         "data":{
            //             "id":"1595607628197",
            //             "ts":"1595607628197",
            //             "bids":[
            //                 ["9534.99","15.36160000000000000000"],
            //                 ["9534.85","0.14580000000000000000"],
            //                 ["9534.73","0.02100000000000000000"],
            //             ],
            //             "asks":[
            //                 ["9535.02","7.37160000000000000000"],
            //                 ["9535.03","0.09040000000000000000"],
            //                 ["9535.05","0.02180000000000000000"],
            //             ]
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "asks":[
            //             ["9579.0","119865",1],
            //             ["9579.5","90069",1],
            //             ["9580.0","256673",1],
            //         ],
            //         "bids":[
            //             ["9578.5","2417",1],
            //             ["9577.5","3024",1],
            //             ["9577.0","21548",1],
            //         ],
            //         "timestamp":"1595664767349"
            //     }
            //
            const data = this.safeValue (response, 'data', response);
            const timestamp = this.safeInteger2 (data, 'timestamp', 'ts');
            const nonce = this.safeInteger (data, 'id');
            const orderbook = this.parseOrderBook (data, symbol, timestamp);
            orderbook['nonce'] = nonce;
            return orderbook;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // spot
            //
            //     fetchTicker
            //
            //     {
            //         "id":"1595538241113",
            //         "bid":["0.028474000000","1.139400000000"],
            //         "ask":["0.028482000000","0.353100000000"],
            //         "amount":"2850.6649",
            //         "count":"818",
            //         "open":"0.02821",
            //         "close":"0.028474",
            //         "low":"0.02821",
            //         "high":"0.029091",
            //         "vol":"79.4548693404"
            //     }
            //
            //     fetchTickers
            //
            //     {
            //         "amount":"30086.8095",
            //         "count":"22450",
            //         "open":"9525.11",
            //         "close":"9591.81",
            //         "low":"9510.68",
            //         "high":"9659.7",
            //         "vol":"286239092.250461",
            //         "symbol":"btc_usdt"
            //     }
            //
            // swap
            //
            //     {
            //         "instrument_id":"btcusd",
            //         "last":"9574.5",
            //         "best_ask":"9575.0",
            //         "best_bid":"9574.0",
            //         "high_24h":"9672",
            //         "low_24h":"9512",
            //         "volume_24h":"567697050",
            //         "timestamp":"1595538450096"
            //     }
            //
            const timestamp = this.safeInteger2 (ticker, 'timestamp', 'id');
            let symbol = undefined;
            const marketId = this.safeString2 (ticker, 'instrument_id', 'symbol');
            if (marketId in this.markets_by_id) {
                market = this.markets_by_id[marketId];
                symbol = market['symbol'];
            } else if (marketId !== undefined) {
                const parts = marketId.split ('_');
                const numParts = parts.length;
                if (numParts === 2) {
                    const [ baseId, quoteId ] = parts;
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                } else {
                    symbol = marketId;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const last = this.safeNumber2 (ticker, 'last', 'close');
            const open = this.safeNumber (ticker, 'open');
            let bidVolume = undefined;
            let askVolume = undefined;
            let bid = this.safeValue (ticker, 'bid');
            if (bid === undefined) {
                bid = this.safeNumber (ticker, 'best_bid');
            } else {
                bidVolume = this.safeNumber (bid, 1);
                bid = this.safeNumber (bid, 0);
            }
            let ask = this.safeValue (ticker, 'ask');
            if (ask === undefined) {
                ask = this.safeNumber (ticker, 'best_ask');
            } else {
                askVolume = this.safeNumber (ask, 1);
                ask = this.safeNumber (ask, 0);
            }
            const baseVolume = this.safeNumber2 (ticker, 'amount', 'volume_24h');
            const quoteVolume = this.safeNumber (ticker, 'vol');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber2 (ticker, 'high', 'high_24h'),
                'low': this.safeNumber2 (ticker, 'low', 'low_24h'),
                'bid': bid,
                'bidVolume': bidVolume,
                'ask': ask,
                'askVolume': askVolume,
                'vwap': vwap,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let method = undefined;
            if (market['spot']) {
                method = 'dataGetMarketDetailMerged';
            } else if (market['swap']) {
                method = 'capiGetMarketTicker';
            }
            const request = {
                'symbol': market['id'],
            };
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ch":"market.eth_btc.detail.merged",
            //         "ts":1595538241474,
            //         "data":{
            //             "id":"1595538241113",
            //             "bid":["0.028474000000","1.139400000000"],
            //             "ask":["0.028482000000","0.353100000000"],
            //             "amount":"2850.6649",
            //             "count":"818",
            //             "open":"0.02821",
            //             "close":"0.028474",
            //             "low":"0.02821",
            //             "high":"0.029091",
            //             "vol":"79.4548693404"
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "symbol":"btcusd",
            //         "last":"9575.5",
            //         "best_ask":"9576.0",
            //         "best_bid":"9575.0",
            //         "high_24h":"9646",
            //         "low_24h":"9516",
            //         "volume_24h":"516656839",
            //         "timestamp":"1595664217405"
            //     }
            //
            const data = this.safeValue (response, 'data', response);
            return this.parseTicker (data, market);
        }
    
        async fetchTickersByType (type, symbols = undefined, params = {}) {
            await this.loadMarkets ();
            let method = undefined;
            if (type === 'spot') {
                method = 'dataGetMarketTickers';
            } else if (type === 'swap') {
                method = 'capiGetMarketTickers';
            }
            const response = await this[method] (params);
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ts":1595542893250,
            //         "data":[
            //             {
            //                 "amount":"30086.8095",
            //                 "count":"22450",
            //                 "open":"9525.11",
            //                 "close":"9591.81",
            //                 "low":"9510.68",
            //                 "high":"9659.7",
            //                 "vol":"286239092.250461",
            //                 "symbol":"btc_usdt"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //     [
            //         {
            //             "symbol":"btcusd",
            //             "last":"9572",
            //             "best_ask":"9571.5",
            //             "best_bid":"9570.5",
            //             "high_24h":"9646",
            //             "low_24h":"9516",
            //             "volume_24h":"515401635",
            //             "timestamp":"1595664479952"
            //         }
            //     ]
            //
            const data = this.safeValue (response, 'data', response);
            let timestamp = undefined;
            if (!Array.isArray (response)) {
                timestamp = this.safeInteger (response, 'ts');
            }
            const result = {};
            for (let i = 0; i < data.length; i++) {
                const ticker = this.parseTicker (this.extend ({
                    'timestamp': timestamp,
                }, data[i]));
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            const defaultType = this.safeString2 (this.options, 'fetchTickers', 'defaultType');
            const type = this.safeString (params, 'type', defaultType);
            return await this.fetchTickersByType (type, symbols, this.omit (params, 'type'));
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     spot
            //
            //     {
            //         "id":"1",
            //         "price":"9533.81",
            //         "amount":"0.7326",
            //         "direction":"sell",
            //         "ts":"1595604964000"
            //     }
            //
            //     swap
            //
            //     {
            //         "trade_id":"670581881367954915",
            //         "price":"9553.00",
            //         "size":"20",
            //         "side":"sell",
            //         "timestamp":"1595605100004",
            //         "symbol":"btcusd"
            //     }
            //
            // spot fetchMyTrades (private)
            //
            //     {
            //         "id": 29555,
            //         "order_id": 59378,
            //         "match_id": 59335,
            //         "symbol": "eth_usdt",
            //         "type": "buy-limit",
            //         "source": "api",
            //         "price": "100.1000000000",
            //         "filled_amount": "0.9845000000",
            //         "filled_fees": "0.0019690000",
            //         "created_at": 1494901400487
            //     }
            //
            // fetchOrderTrades (private)
            //
            //     spot
            //
            //     {
            //         "id":"614164775",
            //         "created_at":"1596298860602",
            //         "filled_amount":"0.0417000000000000",
            //         "filled_fees":"0.0000834000000000",
            //         "match_id":"673491702661292033",
            //         "order_id":"673491720340279296",
            //         "price":"359.240000000000",
            //         "source":"接口",
            //         "symbol":"eth_usdt",
            //         "type":"buy-market"
            //     }
            //
            //     swap
            //
            //     {
            //         "trade_id":"6667390",
            //         "symbol":"cmt_btcusdt",
            //         "order_id":"525946425993854915",
            //         "price":"9839.00",
            //         "order_qty":"3466",
            //         "fee":"-0.0000528407360000",
            //         "timestamp":"1561121514442",
            //         "exec_type":"M",
            //         "side":"3"
            //     }
            //
            let symbol = undefined;
            const marketId = this.safeString (trade, 'symbol');
            let base = undefined;
            let quote = undefined;
            if (marketId in this.markets_by_id) {
                market = this.markets_by_id[marketId];
                symbol = market['symbol'];
                base = market['base'];
                quote = market['quote'];
            } else if (marketId !== undefined) {
                const parts = marketId.split ('_');
                const numParts = parts.length;
                if (numParts === 2) {
                    const [ baseId, quoteId ] = parts;
                    base = this.safeCurrencyCode (baseId);
                    quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                } else {
                    symbol = marketId.toUpperCase ();
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
                base = market['base'];
                quote = market['quote'];
            }
            let timestamp = this.safeInteger (trade, 'created_at');
            timestamp = this.safeInteger2 (trade, 'timestamp', 'ts', timestamp);
            const priceString = this.safeString (trade, 'price');
            let amountString = this.safeString2 (trade, 'filled_amount', 'order_qty');
            amountString = this.safeString2 (trade, 'size', 'amount', amountString);
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let takerOrMaker = this.safeString2 (trade, 'exec_type', 'liquidity');
            if (takerOrMaker === 'M') {
                takerOrMaker = 'maker';
            } else if (takerOrMaker === 'T') {
                takerOrMaker = 'taker';
            }
            const orderType = this.safeString (trade, 'type');
            let side = undefined;
            let type = undefined;
            if (orderType !== undefined) {
                side = this.safeString (trade, 'type');
                type = this.parseOrderType (side);
                side = this.parseOrderSide (side);
            } else {
                side = this.safeString2 (trade, 'side', 'direction');
                type = this.parseOrderType (side);
                side = this.parseOrderSide (side);
            }
            let feeCostString = this.safeString (trade, 'fee');
            if (feeCostString === undefined) {
                feeCostString = this.safeString (trade, 'filled_fees');
            } else {
                feeCostString = Precise.stringNeg (feeCostString);
            }
            const feeCost = this.parseNumber (feeCostString);
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrency = (side === 'buy') ? base : quote;
                fee = {
                    // fee is either a positive number (invitation rebate)
                    // or a negative number (transaction fee deduction)
                    // therefore we need to invert the fee
                    // more about it https://github.com/ccxt/ccxt/issues/5909
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
            }
            const orderId = this.safeString (trade, 'order_id');
            const id = this.safeString2 (trade, 'trade_id', 'id');
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': type,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, limit = undefined, since = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            if (market['spot']) {
                method = 'dataGetMarketHistoryTrade';
            } else if (market['swap']) {
                method = 'capiGetMarketTrades';
            }
            if (market['spot']) {
                if (limit !== undefined) {
                    request['size'] = limit; // default 1, max 2000
                }
            } else if (market['swap']) {
                if (limit === undefined) {
                    limit = 100; // default 20, max 100
                }
                request['limit'] = limit;
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ch":"market.btc_usdt.trade.detail",
            //         "ts":1595604968430,
            //         "data":{
            //             "ts":"1595604964000",
            //             "data":[
            //                 {"id":"1","price":"9533.81","amount":"0.7326","direction":"sell","ts":"1595604964000"},
            //                 {"id":"2","price":"9533.67","amount":"1.1591","direction":"buy","ts":"1595604961000"},
            //                 {"id":"3","price":"9533.67","amount":"1.5022","direction":"sell","ts":"1595604959000"},
            //             ]
            //         }
            //     }
            //
            // swap
            //
            //     [
            //         {"trade_id":"670833198971748613","price":"9578.50","size":"5412","side":"sell","timestamp":"1595665018790","symbol":"btcusd"},
            //         {"trade_id":"670833194240574915","price":"9579.00","size":"3972","side":"buy","timestamp":"1595665017662","symbol":"btcusd"},
            //         {"trade_id":"670833194240573915","price":"9579.00","size":"1227","side":"buy","timestamp":"1595665017662","symbol":"btcusd"},
            //     ]
            //
            let trades = undefined;
            if (Array.isArray (response)) {
                trades = response;
            } else {
                const data = this.safeValue (response, 'data', {});
                trades = this.safeValue2 (data, 'data', []);
            }
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined, timeframe = '1m') {
            //
            // spot
            //
            //     {
            //         "id":"1594694700000",
            //         "amount":"283.6811",
            //         "count":"234",
            //         "open":"9230.00",
            //         "close":"9227.15",
            //         "low":"9206.66",
            //         "high":"9232.33",
            //         "vol":"2618015.032504000000"
            //     }
            //
            // swap
            //
            //     [
            //         "1594693800000",
            //         "9240",
            //         "9241",
            //         "9222",
            //         "9228.5",
            //         "3913370",
            //         "424.003616350563"
            //     ]
            //
            const options = this.safeValue (this.options, 'parseOHLCV', {});
            const volume = this.safeValue (options, 'volume', {});
            if (Array.isArray (ohlcv)) {
                const volumeIndex = this.safeString (volume, market['type'], 'amount');
                return [
                    this.safeInteger (ohlcv, 0),         // timestamp
                    this.safeNumber (ohlcv, 1),           // Open
                    this.safeNumber (ohlcv, 2),           // High
                    this.safeNumber (ohlcv, 3),           // Low
                    this.safeNumber (ohlcv, 4),           // Close
                    // this.safeNumber (ohlcv, 5),        // Quote Volume
                    // this.safeNumber (ohlcv, 6),        // Base Volume
                    this.safeNumber (ohlcv, volumeIndex), // Volume, bitget will return base volume in the 7th element for future markets
                ];
            } else {
                const volumeIndex = this.safeValue (volume, market['type'], 6);
                return [
                    this.safeInteger (ohlcv, 'id'),
                    this.safeNumber (ohlcv, 'open'),      // Open
                    this.safeNumber (ohlcv, 'high'),      // High
                    this.safeNumber (ohlcv, 'low'),       // Low
                    this.safeNumber (ohlcv, 'close'),     // Close
                    this.safeNumber (ohlcv, volumeIndex), // Base Volume
                ];
            }
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            const type = market['type'];
            const options = this.safeValue (this.options, 'timeframes', {});
            const intervals = this.safeValue (options, type, {});
            const interval = this.safeValue (intervals, this.timeframes[timeframe]);
            if (market['spot']) {
                method = 'dataGetMarketHistoryKline';
                request['period'] = interval;
                if (limit !== undefined) {
                    request['size'] = limit; // default 150, max 1000
                }
            } else if (market['swap']) {
                const duration = this.parseTimeframe (timeframe);
                method = 'capiGetMarketCandles';
                request['granularity'] = interval;
                const now = this.milliseconds ();
                if (since === undefined) {
                    if (limit === undefined) {
                        limit = 1000;
                    }
                    request['start'] = this.iso8601 (now - limit * duration * 1000);
                    request['end'] = this.iso8601 (now);
                } else {
                    request['start'] = this.iso8601 (since);
                    if (limit === undefined) {
                        request['end'] = this.iso8601 (now);
                    } else {
                        request['end'] = this.iso8601 (this.sum (since, limit * duration * 1000));
                    }
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ch":"market.btc_usdt.kline.15min",
            //         "ts":1595594183874,
            //         "data":[
            //             {"id":"1594694700000","amount":"283.6811","count":"234","open":"9230.00","close":"9227.15","low":"9206.66","high":"9232.33","vol":"2618015.032504000000"},
            //             {"id":"1594695600000","amount":"457.2904","count":"238","open":"9227.15","close":"9229.46","low":"9223.80","high":"9235.14","vol":"4220734.684570000000"},
            //             {"id":"1594696500000","amount":"501.2353","count":"255","open":"9229.46","close":"9227.78","low":"9222.69","high":"9230.74","vol":"4625779.185006000000"},
            //         ]
            //     }
            //
            // swap
            //
            //     [
            //         ["1594764900000","9255.5","9261","9251","9255.5","3958946","427.742307964305"],
            //         ["1594765800000","9255.5","9264","9252","9258","3609496","389.832756058107"],
            //         ["1594766700000","9258","9260","9244.5","9250.5","3738600","403.97870345085"],
            //     ]
            //
            let candles = response;
            if (!Array.isArray (response)) {
                candles = this.safeValue (response, 'data', []);
            }
            return this.parseOHLCVs (candles, market, timeframe, since, limit);
        }
    
        parseSpotBalance (response) {
            //
            //     {
            //         "status":"ok",
            //         "ts":1595681450932,
            //         "data":{
            //             "list":[
            //                 {"balance":"0.0000000000000000","currency":"BTC","type":"trade"},
            //                 {"balance":"0.0000000000000000","currency":"BTC","type":"frozen"},
            //                 {"balance":"0.0000000000000000","currency":"BTC","type":"lock"},
            //             ],
            //             "id":"7420922606",
            //             "type":"spot",
            //             "state":"working"
            //         }
            //     }
            //
            const result = { 'info': response };
            const data = this.safeValue (response, 'data');
            const balances = this.safeValue (data, 'list');
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                if (!(code in result)) {
                    const account = this.account ();
                    result[code] = account;
                }
                const type = this.safeValue (balance, 'type');
                if (type === 'trade') {
                    result[code]['free'] = this.safeString (balance, 'balance');
                } else if ((type === 'frozen') || (type === 'lock')) {
                    const used = this.safeString (result[code], 'used');
                    result[code]['used'] = Precise.stringAdd (used, this.safeString (balance, 'balance'));
                }
            }
            return this.parseBalance (result);
        }
    
        parseSwapBalance (response) {
            //
            // swap
            //
            //     [
            //         {"equity":"0","fixed_balance":"0","total_avail_balance":"0","margin":"0","realized_pnl":"0","unrealized_pnl":"0","symbol":"bchusd","margin_frozen":"0","timestamp":"1595673431547","margin_mode":"fixed","forwardContractFlag":false},
            //         {"equity":"0","fixed_balance":"0","total_avail_balance":"0","margin":"0","realized_pnl":"0","unrealized_pnl":"0","symbol":"ethusd","margin_frozen":"0","timestamp":"1595673431573","margin_mode":"fixed","forwardContractFlag":false},
            //         {"equity":"0","fixed_balance":"0","total_avail_balance":"0","margin":"0","realized_pnl":"0","unrealized_pnl":"0","symbol":"cmt_btcsusdt","margin_frozen":"0","timestamp":"1595673431577","margin_mode":"fixed","forwardContractFlag":true},
            //     ]
            //
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const marketId = this.safeString (balance, 'symbol');
                let symbol = marketId;
                if (marketId in this.markets_by_id) {
                    symbol = this.markets_by_id[marketId]['symbol'];
                }
                const account = this.account ();
                // it may be incorrect to use total, free and used for swap accounts
                account['total'] = this.safeString (balance, 'equity');
                account['free'] = this.safeString (balance, 'total_avail_balance');
                result[symbol] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchAccounts (params = {}) {
            const request = {
                'method': 'accounts',
            };
            const response = await this.apiGetAccountAccounts (this.extend (request, params));
            //
            //     {
            //         "status":"ok",
            //         "ts":1595679591824,
            //         "data":[
            //             {"id":"7420922606","type":"spot","state":"working"}
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const account = data[i];
                const accountId = this.safeString (account, 'id');
                const type = this.safeStringLower (account, 'type');
                result.push ({
                    'id': accountId,
                    'type': type,
                    'currency': undefined,
                    'info': account,
                });
            }
            return result;
        }
    
        async findAccountByType (type) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const accountsByType = this.groupBy (this.accounts, 'type');
            const accounts = this.safeValue (accountsByType, type);
            if (accounts === undefined) {
                throw new ExchangeError (this.id + " findAccountByType() could not find an accountId with type '" + type + "', specify the 'accountId' parameter instead"); // eslint-disable-line quotes
            }
            const numAccounts = accounts.length;
            if (numAccounts > 1) {
                throw new ExchangeError (this.id + " findAccountByType() found more than one accountId with type '" + type + "', specify the 'accountId' parameter instead"); // eslint-disable-line quotes
            }
            return accounts[0];
        }
    
        async getAccountId (params) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const defaultAccountId = this.safeString (this.options, 'accountId');
            const accountId = this.safeString (params, 'accountId', defaultAccountId);
            if (accountId !== undefined) {
                return accountId;
            }
            const defaultType = this.safeString (this.options, 'defaultType', 'margin');
            const type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            if (type === undefined) {
                throw new ArgumentsRequired (this.id + " getAccountId() requires an 'accountId' parameter");
            }
            const account = await this.findAccountByType (type);
            return account['id'];
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const defaultType = this.safeString2 (this.options, 'fetchBalance', 'defaultType');
            const type = this.safeString (params, 'type', defaultType);
            if (type === undefined) {
                throw new ArgumentsRequired (this.id + " fetchBalance() requires a 'type' parameter, one of 'spot', 'swap'");
            }
            let method = undefined;
            const query = this.omit (params, 'type');
            if (type === 'spot') {
                const accountId = await this.getAccountId (params);
                method = 'apiGetAccountsAccountIdBalance';
                query['account_id'] = accountId;
                query['method'] = 'balance';
            } else if (type === 'swap') {
                method = 'swapGetAccountAccounts';
            }
            const response = await this[method] (query);
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ts":1595681450932,
            //         "data":{
            //             "list":[
            //                 {"balance":"0.0000000000000000","currency":"BTC","type":"trade"},
            //                 {"balance":"0.0000000000000000","currency":"BTC","type":"frozen"},
            //                 {"balance":"0.0000000000000000","currency":"BTC","type":"lock"},
            //             ],
            //             "id":"7420922606",
            //             "type":"spot",
            //             "state":"working"
            //         }
            //     }
            //
            // swap
            //
            //     [
            //         {"equity":"0","fixed_balance":"0","total_avail_balance":"0","margin":"0","realized_pnl":"0","unrealized_pnl":"0","symbol":"bchusd","margin_frozen":"0","timestamp":"1595673431547","margin_mode":"fixed","forwardContractFlag":false},
            //         {"equity":"0","fixed_balance":"0","total_avail_balance":"0","margin":"0","realized_pnl":"0","unrealized_pnl":"0","symbol":"ethusd","margin_frozen":"0","timestamp":"1595673431573","margin_mode":"fixed","forwardContractFlag":false},
            //         {"equity":"0","fixed_balance":"0","total_avail_balance":"0","margin":"0","realized_pnl":"0","unrealized_pnl":"0","symbol":"cmt_btcsusdt","margin_frozen":"0","timestamp":"1595673431577","margin_mode":"fixed","forwardContractFlag":true},
            //     ]
            //
            return this.parseBalanceByType (type, response);
        }
    
        parseBalanceByType (type, response) {
            if (type === 'spot') {
                return this.parseSpotBalance (response);
            } else if (type === 'swap') {
                return this.parseSwapBalance (response);
            }
            throw new NotSupported (this.id + " fetchBalance does not support the '" + type + "' type (the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')");
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'submitted': 'open',
                'partial-filled': 'open',
                'partial-canceled': 'canceled',
                'filled': 'closed',
                'canceled': 'canceled',
                '-2': 'failed',
                '-1': 'canceled',
                '0': 'open',
                '1': 'open',
                '2': 'closed',
                '3': 'open',
                '4': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrderSide (side) {
            const sides = {
                'buy-market': 'buy',
                'sell-market': 'sell',
                'buy-limit': 'buy',
                'sell-limit': 'sell',
                '1': 'long', // open long
                '2': 'short', // open short
                '3': 'long', // close long
                '4': 'short', // close short
            };
            return this.safeString (sides, side, side);
        }
    
        parseOrderType (type) {
            const types = {
                'buy-market': 'market',
                'sell-market': 'market',
                'buy-limit': 'limit',
                'sell-limit': 'limit',
                '1': 'open', // open long
                '2': 'open', // open short
                '3': 'close', // close long
                '4': 'close', // close short
            };
            return this.safeString (types, type, type);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     spot
            //
            //     {
            //         "status":"ok",
            //         "ts":1595792596056,
            //         "data":671368296142774272
            //     }
            //
            //     swap
            //
            //     {
            //         "client_oid":"58775e54-0592-491c-97e8-e2369025f2d1",
            //         "order_id":"671757564085534713"
            //     }
            //
            // cancelOrder
            //
            //     spot
            //
            //     {
            //         "status": "ok",
            //         "ts": 1595818631279,
            //         "data": 671368296142774272
            //     }
            //
            //     swap
            //
            //     {
            //         "order_id":"671757564085534713",
            //         "client_oid":"58775e54-0592-491c-97e8-e2369025f2d1",
            //         "symbol":"cmt_ethusdt",
            //         "result":true,
            //         "err_code":null,
            //         "err_msg":null
            //     }
            //
            // fetchOpenOrders, fetchClosedOrders, fetchOrder
            //
            //     spot
            //
            //     {
            //         "account_id":"7420922606",
            //         "amount":"0.1000000000000000",
            //         "canceled_at":"1595872129618",
            //         "created_at":"1595872089525",
            //         "filled_amount":"0.000000000000",
            //         "filled_cash_amount":"0.000000000000",
            //         "filled_fees":"0.000000000000",
            //         "finished_at":"1595872129618",
            //         "id":"671701716584665088",
            //         "price":"150.000000000000",
            //         "source":"接口",
            //         "state":"canceled",
            //         "symbol":"eth_usdt",
            //         "type":"buy-limit"
            //     }
            //
            //     swap
            //
            //     {
            //         "symbol":"cmt_ethusdt",
            //         "size":"1",
            //         "timestamp":"1595885546770",
            //         "client_oid":"f3aa81d6-9a4c-4eab-bebe-ebc19da21cf2",
            //         "createTime":"1595885521200",
            //         "filled_qty":"0",
            //         "fee":"0.00000000",
            //         "order_id":"671758053112020913",
            //         "price":"150.00",
            //         "price_avg":"0.00",
            //         "status":"0",
            //         "type":"1",
            //         "order_type":"0",
            //         "totalProfits":null
            //     }
            //
            let id = this.safeString (order, 'order_id');
            id = this.safeString2 (order, 'id', 'data', id);
            const timestamp = this.safeInteger2 (order, 'created_at', 'createTime');
            let type = this.safeString (order, 'type');
            const side = this.parseOrderSide (type);
            type = this.parseOrderType (type);
            // if ((side !== 'buy') && (side !== 'sell')) {
            //     side = this.parseOrderSide (type);
            // }
            // if ((type !== 'limit') && (type !== 'market')) {
            //     if ('pnl' in order) {
            //         type = 'futures';
            //     } else {
            //         type = 'swap';
            //     }
            // }
            let symbol = undefined;
            const marketId = this.safeString (order, 'symbol');
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    symbol = marketId.toUpperCase ();
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const amount = this.safeNumber2 (order, 'amount', 'size');
            const filled = this.safeNumber2 (order, 'filled_amount', 'filled_qty');
            const cost = this.safeNumber (order, 'filled_cash_amount');
            const price = this.safeNumber (order, 'price');
            const average = this.safeNumber (order, 'price_avg');
            const status = this.parseOrderStatus (this.safeString2 (order, 'state', 'status'));
            const feeCost = this.safeNumber2 (order, 'filled_fees', 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrency = undefined;
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
            }
            const clientOrderId = this.safeString (order, 'client_oid');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'average': average,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const market = this.market (symbol);
            //
            // spot
            //
            //     account_id true string Account ID, obtained using the accounts method. Currency transactions use the accountid of the'spot' account; for loan asset transactions, please use the accountid of the'margin' account
            //     amount true string A limit order indicates the quantity of the order, when a market price buy order indicates how much money to buy, and when a market price sell order indicates how much currency to sell
            //     price false string Order price, market order does not pass this parameter
            //     source false string Order source api
            //     symbol true string Trading pair  btc_usdt, eth_btc ...
            //     type true string Order Type  buy-market: buy at market price, sell-market: sell at market price, buy-limit: buy at limit price, sell-limit: sell at limit price
            //
            // swap
            //
            //     symbol String Yes Contract ID
            //     client_oid String Yes customize order IDs to identify your orders. (Less than 50 characters without special characters,
            //     size String Yes Quantity to buy or sell (value not equal to 0 or negative)
            //     type String Yes 1 Open long 2Open short 3 Close long 4 Close short
            //     order_type String Yes 0: Normal order (Unfilled and 0 imply normal limit order) 1: Post only 2: Fill or Kill 3: Immediate Or Cancel
            //     match_price String Yes 0 Limit price 1 market price
            //     price String No Price of each contract
            //
            const request = {
                'symbol': market['id'],
            };
            const clientOrderId = this.safeString2 (params, 'client_oid', 'clientOrderId', this.uuid ());
            params = this.omit (params, [ 'client_oid', 'clientOrderId' ]);
            let method = undefined;
            if (market['spot']) {
                const accountId = await this.getAccountId ({
                    'type': market['type'],
                });
                method = 'apiPostOrderOrdersPlace';
                request['account_id'] = accountId;
                request['method'] = 'place';
                request['type'] = side + '-' + type;
                if (type === 'limit') {
                    request['amount'] = this.amountToPrecision (symbol, amount);
                    request['price'] = this.priceToPrecision (symbol, price);
                } else if (type === 'market') {
                    // for market buy it requires the amount of quote currency to spend
                    if (side === 'buy') {
                        let cost = this.safeNumber (params, 'amount');
                        const createMarketBuyOrderRequiresPrice = this.safeValue (this.options, 'createMarketBuyOrderRequiresPrice', true);
                        if (createMarketBuyOrderRequiresPrice) {
                            if (price !== undefined) {
                                if (cost === undefined) {
                                    cost = amount * price;
                                }
                            } else if (cost === undefined) {
                                throw new InvalidOrder (this.id + " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'amount' extra parameter (the exchange-specific behaviour)");
                            }
                        } else {
                            cost = (cost === undefined) ? amount : cost;
                        }
                        request['amount'] = this.costToPrecision (symbol, cost);
                    } else if (side === 'sell') {
                        request['amount'] = this.amountToPrecision (symbol, amount);
                    }
                }
                // ...
            } else if (market['swap']) {
                request['order_type'] = '0'; // '0' = Normal order, undefined and 0 imply a normal limit order, '1' = Post only, '2' = Fill or Kill, '3' = Immediate Or Cancel
                request['client_oid'] = clientOrderId;
                const orderType = this.safeString (params, 'type');
                if (orderType === undefined) {
                    throw new ArgumentsRequired (this.id + " createOrder() requires a type parameter, '1' = open long, '2' = open short, '3' = close long, '4' = close short for " + market['type'] + ' orders');
                }
                request['size'] = this.amountToPrecision (symbol, amount);
                request['type'] = orderType;
                // if match_price is set to '1', the price parameter will be ignored for market orders
                if (type === 'limit') {
                    request['match_price'] = '0';
                    request['price'] = this.priceToPrecision (symbol, price);
                } else if (type === 'market') {
                    request['match_price'] = '1';
                }
                method = 'swapPostOrderPlaceOrder';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ts":1595792596056,
            //         "data":"671368296142774272"
            //     }
            //
            // swap
            //
            //     {
            //         "client_oid":"58775e54-0592-491c-97e8-e2369025f2d1",
            //         "order_id":"671757564085534713"
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            let type = undefined;
            if (symbol === undefined) {
                const defaultType = this.safeString2 (this.options, 'cancelOrder', 'defaultType');
                const type = this.safeString (params, 'type', defaultType);
                if (type === 'spot') {
                    if (symbol === undefined) {
                        throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument for spot orders');
                    }
                }
            } else {
                market = this.market (symbol);
                type = market['type'];
            }
            const query = this.omit (params, 'type');
            let method = undefined;
            const request = {};
            if (type === 'spot') {
                method = 'apiPostOrderOrdersOrderIdSubmitcancel';
                request['order_id'] = id;
                request['method'] = 'submitcancel';
            } else if (type === 'swap') {
                method = 'swapPostOrderCancelOrder';
                request['orderId'] = id;
                request['symbol'] = market['id'];
            }
            const response = await this[method] (this.extend (request, query));
            //
            // spot
            //
            //     { "status": "ok", "ts": 1595818631279, "data": 671368296142774272 }
            //
            // swap
            //
            //     {
            //         "order_id":"671757564085534713",
            //         "client_oid":"58775e54-0592-491c-97e8-e2369025f2d1",
            //         "symbol":"cmt_ethusdt",
            //         "result":true,
            //         "err_code":null,
            //         "err_msg":null
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrders (ids, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const type = this.safeString (params, 'type', market['type']);
            if (type === undefined) {
                throw new ArgumentsRequired (this.id + " cancelOrders() requires a type parameter (one of 'spot', 'swap').");
            }
            params = this.omit (params, 'type');
            const request = {};
            let method = undefined;
            if (type === 'spot') {
                method = 'apiPostOrderOrdersBatchcancel';
                request['method'] = 'batchcancel';
                const jsonIds = this.json (ids);
                const parts = jsonIds.split ('"');
                request['order_ids'] = parts.join ('');
            } else if (type === 'swap') {
                method = 'swapPostOrderCancelBatchOrders';
                request['symbol'] = market['id'];
                request['ids'] = ids;
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     spot
            //
            //     {
            //         "status": "ok",
            //         "data": {
            //             "success": [
            //                 "673451224205135872",
            //             ],
            //             "failed": [
            //                 {
            //                 "err-msg": "invalid record",
            //                 "order-id": "673451224205135873",
            //                 "err-code": "base record invalid"
            //                 }
            //             ]
            //         }
            //     }
            //
            //     swap
            //
            //     {
            //         "result":true,
            //         "symbol":"cmt_btcusdt",
            //         "order_ids":[
            //             "258414711",
            //             "478585558"
            //         ],
            //         "fail_infos":[
            //             {
            //                 "order_id":"258414711",
            //                 "err_code":"401",
            //                 "err_msg":""
            //             }
            //         ]
            //     }
            //
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const type = this.safeString (params, 'type', market['type']);
            if (type === undefined) {
                throw new ArgumentsRequired (this.id + " fetchOrder() requires a type parameter (one of 'spot', 'swap').");
            }
            let method = undefined;
            const request = {};
            if (type === 'spot') {
                const clientOid = this.safeString (params, 'client_oid');
                if (clientOid !== undefined) {
                    method = 'apiPostOrderOrdersClientOid';
                    request['client_oid'] = clientOid;
                } else {
                    method = 'apiPostOrderOrdersOrderId';
                    request['order_id'] = id;
                }
                request['method'] = 'getOrder';
            } else if (type === 'swap') {
                method = 'swapGetOrderDetail';
                request['symbol'] = market['id'];
                request['orderId'] = id;
            }
            const query = this.omit (params, 'type');
            const response = await this[method] (this.extend (request, query));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ts":1595897886717,
            //         "data":{
            //             "account_id":"7420922606",
            //             "amount":"0.1000000000000000",
            //             "canceled_at":"1595818631541",
            //             "created_at":"1595792595897",
            //             "filled_amount":"0.000000000000",
            //             "filled_cash_amount":"0.000000000000",
            //             "filled_fees":"0.000000000000",
            //             "finished_at":"1595818631541",
            //             "id":"671368296142774272",
            //             "price":"150.000000000000",
            //             "source":"接口",
            //             "state":"canceled",
            //             "symbol":"eth_usdt",
            //             "type":"buy-limit"
            //         }
            //     }
            //
            //
            // swap
            //
            //     {
            //         "symbol":"cmt_ethusdt",
            //         "size":"1",
            //         "timestamp":"1595896459890",
            //         "client_oid":"58775e54-0592-491c-97e8-e2369025f2d1",
            //         "createTime":"1595885404607",
            //         "filled_qty":"0",
            //         "fee":"0",
            //         "order_id":"671757564085534713",
            //         "price":"150",
            //         "price_avg":"0",
            //         "status":"-1",
            //         "type":"1",
            //         "order_type":"0",
            //         "totalProfits":"0"
            //     }
            //
            const data = this.safeValue (response, 'data', response);
            return this.parseOrder (data, market);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const type = this.safeString (params, 'type', market['type']);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            if (type === 'spot') {
                method = 'apiGetOrderOrdersOpenOrders';
                // request['from'] = this.safeString (params, 'from'); // order id
                // request['direct'] = 'next'; // or 'prev'
                request['method'] = 'openOrders';
                if (limit === undefined) {
                    request['size'] = limit; // default 100, max 1000
                }
            } else if (type === 'swap') {
                method = 'swapGetOrderOrders';
                request['status'] = '3'; // 0 Failed, 1 Partially Filled, 2 Fully Filled 3 = Open + Partially Filled, 4 Canceling
                request['from'] = '1';
                request['to'] = '1';
                if (limit === undefined) {
                    request['limit'] = 100; // default 100, max 100
                }
            }
            const query = this.omit (params, 'type');
            const response = await this[method] (this.extend (request, query));
            //
            //  spot
            //
            //
            //     {
            //         "status":"ok",
            //         "ts":1595875165865,
            //         "data":[
            //             {
            //                 "account_id":"7420922606",
            //                 "amount":"0.1000000000000000",
            //                 "canceled_at":"1595872129618",
            //                 "created_at":"1595872089525",
            //                 "filled_amount":"0.000000000000",
            //                 "filled_cash_amount":"0.000000000000",
            //                 "filled_fees":"0.000000000000",
            //                 "finished_at":"1595872129618",
            //                 "id":"671701716584665088",
            //                 "price":"150.000000000000",
            //                 "source":"接口",
            //                 "state":"canceled",
            //                 "symbol":"eth_usdt",
            //                 "type":"buy-limit"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //     [
            //         {
            //             "symbol":"cmt_ethusdt",
            //             "size":"1",
            //             "timestamp":"1595885546770",
            //             "client_oid":"f3aa81d6-9a4c-4eab-bebe-ebc19da21cf2",
            //             "createTime":"1595885521200",
            //             "filled_qty":"0",
            //             "fee":"0.00000000",
            //             "order_id":"671758053112020913",
            //             "price":"150.00",
            //             "price_avg":"0.00",
            //             "status":"0",
            //             "type":"1",
            //             "order_type":"0",
            //             "totalProfits":null
            //         }
            //     ]
            //
            let data = response;
            if (!Array.isArray (response)) {
                data = this.safeValue (response, 'data', []);
            }
            return this.parseOrders (data, market, undefined, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchClosedOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const type = this.safeString (params, 'type', market['type']);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            if (type === 'spot') {
                method = 'apiGetOrderOrdersHistory';
                // Value range [((end_time) – 48h), (end_time)]
                // the query window is 48 hours at most
                // the window shift range is the last 30 days
                if (since !== undefined) {
                    request['start_time'] = since;
                }
                // request['end_time'] = this.safeInteger (params, 'end_time');
                // request['from'] = this.safeString (params, 'from'); // order id
                // request['direct'] = 'next'; // or 'prev'
                request['method'] = 'openOrders';
                if (limit === undefined) {
                    request['size'] = limit; // default 100, max 1000
                }
            } else if (type === 'swap') {
                method = 'swapGetOrderOrders';
                request['status'] = '2'; // 0 Failed, 1 Partially Filled, 2 Fully Filled 3 = Open + Partially Filled, 4 Canceling
                request['from'] = '1';
                request['to'] = '1';
                if (limit === undefined) {
                    request['limit'] = 100; // default 100, max 100
                }
            }
            const query = this.omit (params, 'type');
            const response = await this[method] (this.extend (request, query));
            //
            //  spot
            //
            //
            //     {
            //         "status":"ok",
            //         "ts":1595875165865,
            //         "data":[
            //             {
            //                 "account_id":"7420922606",
            //                 "amount":"0.1000000000000000",
            //                 "canceled_at":"1595872129618",
            //                 "created_at":"1595872089525",
            //                 "filled_amount":"0.000000000000",
            //                 "filled_cash_amount":"0.000000000000",
            //                 "filled_fees":"0.000000000000",
            //                 "finished_at":"1595872129618",
            //                 "id":"671701716584665088",
            //                 "price":"150.000000000000",
            //                 "source":"接口",
            //                 "state":"canceled",
            //                 "symbol":"eth_usdt",
            //                 "type":"buy-limit"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //     [
            //         {
            //             "symbol":"cmt_ethusdt",
            //             "size":"1",
            //             "timestamp":"1595885546770",
            //             "client_oid":"f3aa81d6-9a4c-4eab-bebe-ebc19da21cf2",
            //             "createTime":"1595885521200",
            //             "filled_qty":"0",
            //             "fee":"0.00000000",
            //             "order_id":"671758053112020913",
            //             "price":"150.00",
            //             "price_avg":"0.00",
            //             "status":"0",
            //             "type":"1",
            //             "order_type":"0",
            //             "totalProfits":null
            //         }
            //     ]
            //
            let data = response;
            if (!Array.isArray (response)) {
                data = this.safeValue (response, 'data', []);
            }
            return this.parseOrders (data, market, undefined, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchDeposits() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'method': 'deposit_withdraw',
                'type': 'deposit',
                'size': 12,
            };
            const response = await this.apiGetOrderDepositWithdraw (this.extend (request, params));
            //
            //     {
            //         "status": "ok",
            //         "data": [
            //             {
            //                 "id": 1171,
            //                 "type": "deposit",
            //                 "currency": "usdt",
            //                 "tx_hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
            //                 "amount": 7.457467,
            //                 "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
            //                 "address_tag": "100040",
            //                 "fee": 0,
            //                 "state": "safe",
            //                 "created_at": 1510912472199,
            //                 "updated_at": 1511145876575
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTransactions (data, currency, since, limit, params);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchWithdrawals() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'method': 'deposit_withdraw',
                'type': 'withdraw',
                'size': 12,
            };
            const response = await this.apiGetOrderDepositWithdraw (this.extend (request, params));
            //
            //     {
            //         "status": "ok",
            //         "data": [
            //             {
            //                 "id": 1171,
            //                 "type": "withdraw",
            //                 "currency": "usdt",
            //                 "tx_hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
            //                 "amount": 7.457467,
            //                 "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
            //                 "address_tag": "100040",
            //                 "fee": 0,
            //                 "state": "safe",
            //                 "created_at": 1510912472199,
            //                 "updated_at": 1511145876575
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTransactions (data, currency, since, limit, params);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                // withdrawals
                'WaitForOperation': 'pending', // 等待提现
                'OperationLock': 'pending', // 初审锁定成功
                'OperationSuccess': 'ok', // 提现成功
                'Cancel': 'canceled', // 用户撤销
                'Sure': 'ok', // 复审锁定成功
                'Fail': 'failed', // 出币异常
                'WaitForChainSure': 'ok', // 等待链上确认
                // deposits
                'WAIT_0': 'pending', // 待确认
                'WAIT_1': 'pending', // 待确认
                'DATA_CHANGE': 'pending', // 待确认中
                'SUCCESS': 'ok', // 充值成功
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits, fetchWithdrawals
            //
            //     {
            //         "id": 1171,
            //         "type": "withdraw",
            //         "currency": "usdt",
            //         "tx_hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
            //         "amount": 7.457467,
            //         "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
            //         "address_tag": "100040",
            //         "fee": 0,
            //         "state": "safe",
            //         "created_at": 1510912472199,
            //         "updated_at": 1511145876575
            //     }
            //
            const id = this.safeString (transaction, 'id');
            const address = this.safeString (transaction, 'address');
            const tag = this.safeString (transaction, 'address_tag');
            const tagFrom = undefined;
            const tagTo = tag;
            const addressFrom = undefined;
            const addressTo = address;
            let type = this.safeString (transaction, 'type');
            if (type === 'withdraw') {
                type = 'withdrawal';
            } else if (type === 'deposit') {
                type = 'deposit';
            }
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId);
            const amount = this.safeNumber (transaction, 'amount');
            const status = this.parseTransactionStatus (this.safeString (transaction, 'state'));
            const txid = this.safeString (transaction, 'tx_hash');
            const timestamp = this.safeInteger (transaction, 'created_at');
            const updated = this.safeInteger (transaction, 'updated_at');
            const feeCost = this.safeNumber (transaction, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = {
                    'currency': code,
                    'cost': feeCost,
                };
            }
            return {
                'info': transaction,
                'id': id,
                'currency': code,
                'amount': amount,
                'addressFrom': addressFrom,
                'addressTo': addressTo,
                'address': address,
                'tagFrom': tagFrom,
                'tagTo': tagTo,
                'tag': tag,
                'status': status,
                'type': type,
                'updated': updated,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': fee,
            };
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const type = this.safeString (params, 'type', market['type']);
            const query = this.omit (params, 'type');
            if (type === 'swap') {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() is not supported for ' + type + ' type');
            }
            //
            // spot
            //
            //     POST /api/v1/order/matchresults Query current order, order history
            //     symbol true string trading pair  btc_usdt, eth_btc ...
            //     types false string Query order type combination  buy-market, sell-market, buy-limit, sell-limit
            //     start_date false string Query start date, date format yyyy-mm-dd -61 days [-61day, end-date]
            //     end_date false string Query end date, date format yyyy-mm-dd Now [start-date, now]
            //     from false string Query start ID order record id
            //     direct false string Query direction ‘next’ is default , the transaction record ID is sorted from large to small prev，next
            //     size false string Query record size 100 <=100
            //
            const request = {
                'symbol': market['id'],
                'method': 'matchresults',
                // 'types': 'buy-market,sell-market,buy-limit,sell-limit',
                // 'start_date': this.ymd (since),
                // 'end_date': this.ymd (this.milliseconds ()),
                // 'size': 100,
                // 'direct': 'next',
            };
            if (since !== undefined) {
                request['start_date'] = this.ymd (since);
                const end = this.sum (since, 2 * 24 * 60 * 60 * 1000);
                request['end_date'] = this.ymd (end);
            }
            if (limit !== undefined) {
                request['size'] = limit; // default 100, max 100
            }
            const response = await this.apiPostOrderMatchresults (this.extend (request, query));
            //
            //     {
            //         "status": "ok",
            //         "data": [
            //             {
            //                 "id": 29555,
            //                 "order_id": 59378,
            //                 "match_id": 59335,
            //                 "symbol": "eth_usdt",
            //                 "type": "buy-limit",
            //                 "source": "api",
            //                 "price": "100.1000000000",
            //                 "filled_amount": "0.9845000000",
            //                 "filled_fees": "0.0019690000",
            //                 "created_at": 1494901400487
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrderTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const type = this.safeString (params, 'type', market['type']);
            params = this.omit (params, 'type');
            let method = undefined;
            const request = {};
            if (type === 'spot') {
                request['order_id'] = id;
                request['method'] = 'matchresults';
                method = 'apiPostOrderOrdersOrderIdMatchresults';
            } else if (type === 'swap') {
                request['orderId'] = id;
                request['symbol'] = market['id'];
                method = 'swapGetOrderFills';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "status":"ok",
            //         "ts":1596298917277,
            //         "data":[
            //             {
            //                 "id":"614164775",
            //                 "created_at":"1596298860602",
            //                 "filled_amount":"0.0417000000000000",
            //                 "filled_fees":"0.0000834000000000",
            //                 "match_id":"673491702661292033",
            //                 "order_id":"673491720340279296",
            //                 "price":"359.240000000000",
            //                 "source":"接口",
            //                 "symbol":"eth_usdt",
            //                 "type":"buy-market"
            //             }
            //         ]
            //     }
            //
            // swap
            //
            //
            //     [
            //         {
            //             "trade_id":"6667390",
            //             "symbol":"cmt_btcusdt",
            //             "order_id":"525946425993854915",
            //             "price":"9839.00",
            //             "order_qty":"3466",
            //             "fee":"-0.0000528407360000",
            //             "timestamp":"1561121514442",
            //             "exec_type":"M",
            //             "side":"3"
            //         }
            //     ]
            //
            let data = response;
            if (!Array.isArray (data)) {
                data = this.safeValue (response, 'data', []);
            }
            return await this.parseTrades (data, market, since, limit);
        }
    
        async fetchPosition (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.swapGetPositionSinglePosition (this.extend (request, params));
            //
            //     {
            //         "margin_mode":"fixed", // Margin mode: crossed / fixed
            //         "holding":[
            //             {
            //                 "symbol":"cmt_btcusdt", // Contract name
            //                 "liquidation_price":"0.00", // Estimated liquidation price
            //                 "position":"0", // Position Margin, the margin for holding current positions
            //                 "avail_position":"0", // Available position
            //                 "avg_cost":"0.00", // Transaction average price
            //                 "leverage":"2", // Leverage
            //                 "realized_pnl":"0.00000000", // Realized Profit and loss
            //                 "keepMarginRate":"0.005", // Maintenance margin rate
            //                 "side":"1", // Position Direction Long or short, Mark obsolete
            //                 "holdSide":"1", // Position Direction Long or short
            //                 "timestamp":"1557571623963", // System timestamp
            //                 "margin":"0.0000000000000000", // Used margin
            //                 "unrealized_pnl":"0.00000000", // Unrealized profit and loss
            //             }
            //         ]
            //     }
            return response;
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.swapGetPositionAllPosition (params);
            //
            //     [
            //         {
            //             "margin_mode":"fixed",
            //             "holding":[
            //                 {
            //                     "liquidation_price":"0.00",
            //                     "position":"0",
            //                     "avail_position":"0",
            //                     "avg_cost":"0.00",
            //                     "symbol":"btcusd",
            //                     "leverage":"20",
            //                     "keepMarginRate":"0.005",
            //                     "realized_pnl":"0.00000000",
            //                     "unrealized_pnl":"0",
            //                     "side":"long",
            //                     "holdSide":"1",
            //                     "timestamp":"1595698564915",
            //                     "margin":"0.0000000000000000"
            //                 },
            //             ]
            //         },
            //     ]
            //
            // todo unify parsePosition/parsePositions
            return response;
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + this.implodeParams (path, params);
            if ((api === 'capi') || (api === 'swap')) {
                request = '/api/swap/' + this.version + request;
            } else {
                request = '/' + api + '/v1' + request;
            }
            let query = this.omit (params, this.extractParams (path));
            let url = this.implodeHostname (this.urls['api'][api]) + request;
            if ((api === 'data') || (api === 'capi')) {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else if (api === 'swap') {
                this.checkRequiredCredentials ();
                const timestamp = this.milliseconds ().toString ();
                let auth = timestamp + method + request;
                if (method === 'POST') {
                    body = this.json (params);
                    auth += body;
                } else {
                    if (Object.keys (params).length) {
                        const query = this.urlencode (this.keysort (params));
                        url += '?' + query;
                        auth += '?' + query;
                    }
                }
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256', 'base64');
                headers = {
                    'ACCESS-KEY': this.apiKey,
                    'ACCESS-SIGN': signature,
                    'ACCESS-TIMESTAMP': timestamp,
                    'ACCESS-PASSPHRASE': this.password,
                };
                if (method === 'POST') {
                    headers['Content-Type'] = 'application/json';
                }
            } else if (api === 'api') {
                const timestamp = this.milliseconds ().toString ();
                let auth = '';
                query = this.keysort (query);
                auth = this.rawencode (query);
                const hash = this.hash (this.encode (this.secret), 'sha1');
                let signed = auth;
                const signature = this.hmac (this.encode (auth), this.encode (hash), 'md5');
                if (auth.length > 0) {
                    signed += '&';
                }
                signed += 'sign=' + signature + '&req_time=' + timestamp + '&accesskey=' + this.apiKey;
                if (method === 'GET') {
                    if (Object.keys (query).length) {
                        url += '?' + signed;
                    }
                } else if (method === 'POST') {
                    url += '?sign=' + signature + '&req_time=' + timestamp + '&accesskey=' + this.apiKey;
                    body = auth;
                    headers = {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    };
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (!response) {
                return; // fallback to default error handler
            }
            //
            // spot
            //
            //     {"status":"fail","err_code":"01001","err_msg":"系统异常，请稍后重试"}
            //     {"status":"error","ts":1595594160149,"err_code":"invalid-parameter","err_msg":"invalid size, valid range: [1,2000]"}
            //     {"status":"error","ts":1595684716042,"err_code":"invalid-parameter","err_msg":"illegal sign invalid"}
            //     {"status":"error","ts":1595700216275,"err_code":"bad-request","err_msg":"your balance is low!"}
            //     {"status":"error","ts":1595700344504,"err_code":"invalid-parameter","err_msg":"invalid type"}
            //     {"status":"error","ts":1595703343035,"err_code":"bad-request","err_msg":"order cancel fail"}
            //     {"status":"error","ts":1595704360508,"err_code":"invalid-parameter","err_msg":"accesskey not null"}
            //     {"status":"error","ts":1595704490084,"err_code":"invalid-parameter","err_msg":"permissions not right"}
            //     {"status":"error","ts":1595711862763,"err_code":"system exception","err_msg":"system exception"}
            //     {"status":"error","ts":1595730308979,"err_code":"bad-request","err_msg":"20003"}
            //
            // swap
            //
            //     {"code":"40015","msg":"","requestTime":1595698564931,"data":null}
            //     {"code":"40017","msg":"Order id must not be blank","requestTime":1595702477835,"data":null}
            //     {"code":"40017","msg":"Order Type must not be blank","requestTime":1595698516162,"data":null}
            //     {"code":"40301","msg":"","requestTime":1595667662503,"data":null}
            //     {"code":"40017","msg":"Contract code must not be blank","requestTime":1595703151651,"data":null}
            //     {"code":"40108","msg":"","requestTime":1595885064600,"data":null}
            //     {"order_id":"513468410013679613","client_oid":null,"symbol":"ethusd","result":false,"err_code":"order_no_exist_error","err_msg":"订单不存在！"}
            //
            const message = this.safeString (response, 'err_msg');
            const errorCode = this.safeString2 (response, 'code', 'err_code');
            const feedback = this.id + ' ' + body;
            const nonEmptyMessage = ((message !== undefined) && (message !== ''));
            if (nonEmptyMessage) {
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
            }
            const nonZeroErrorCode = (errorCode !== undefined) && (errorCode !== '00000');
            if (nonZeroErrorCode) {
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
            }
            if (nonZeroErrorCode || nonEmptyMessage) {
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],38:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ExchangeNotAvailable, AuthenticationError, BadRequest, PermissionDenied, InvalidAddress, ArgumentsRequired, InvalidOrder } = require ('./base/errors');
    const { DECIMAL_PLACES, SIGNIFICANT_DIGITS, TRUNCATE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bithumb extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bithumb',
                'name': 'Bithumb',
                'countries': [ 'KR' ], // South Korea
                'rateLimit': 500,
                'has': {
                    'cancelOrder': true,
                    'CORS': true,
                    'createMarketOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'withdraw': true,
                },
                'hostname': 'bithumb.com',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/30597177-ea800172-9d5e-11e7-804c-b9d4fa9b56b0.jpg',
                    'api': {
                        'public': 'https://api.{hostname}/public',
                        'private': 'https://api.{hostname}',
                    },
                    'www': 'https://www.bithumb.com',
                    'doc': 'https://apidocs.bithumb.com',
                    'fees': 'https://en.bithumb.com/customer_support/info_fee',
                },
                'api': {
                    'public': {
                        'get': [
                            'ticker/{currency}',
                            'ticker/all',
                            'ticker/ALL_BTC',
                            'ticker/ALL_KRW',
                            'orderbook/{currency}',
                            'orderbook/all',
                            'transaction_history/{currency}',
                            'transaction_history/all',
                            'candlestick/{currency}/{interval}',
                        ],
                    },
                    'private': {
                        'post': [
                            'info/account',
                            'info/balance',
                            'info/wallet_address',
                            'info/ticker',
                            'info/orders',
                            'info/user_transactions',
                            'info/order_detail',
                            'trade/place',
                            'trade/cancel',
                            'trade/btc_withdrawal',
                            'trade/krw_deposit',
                            'trade/krw_withdrawal',
                            'trade/market_buy',
                            'trade/market_sell',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.0025'),
                        'taker': this.parseNumber ('0.0025'),
                    },
                },
                'precisionMode': SIGNIFICANT_DIGITS,
                'exceptions': {
                    'Bad Request(SSL)': BadRequest,
                    'Bad Request(Bad Method)': BadRequest,
                    'Bad Request.(Auth Data)': AuthenticationError, // { "status": "5100", "message": "Bad Request.(Auth Data)" }
                    'Not Member': AuthenticationError,
                    'Invalid Apikey': AuthenticationError, // {"status":"5300","message":"Invalid Apikey"}
                    'Method Not Allowed.(Access IP)': PermissionDenied,
                    'Method Not Allowed.(BTC Adress)': InvalidAddress,
                    'Method Not Allowed.(Access)': PermissionDenied,
                    'Database Fail': ExchangeNotAvailable,
                    'Invalid Parameter': BadRequest,
                    '5600': ExchangeError,
                    'Unknown Error': ExchangeError,
                    'After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions': ExchangeError, // {"status":"5100","message":"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions"}
                },
                'timeframes': {
                    '1m': '1m',
                    '3m': '3m',
                    '5m': '5m',
                    '10m': '10m',
                    '30m': '30m',
                    '1h': '1h',
                    '6h': '6h',
                    '12h': '12h',
                    '1d': '24h',
                },
                'options': {
                    'quoteCurrencies': {
                        'BTC': {
                            'limits': {
                                'cost': {
                                    'min': 0.0002,
                                    'max': 100,
                                },
                            },
                        },
                        'KRW': {
                            'limits': {
                                'cost': {
                                    'min': 500,
                                    'max': 5000000000,
                                },
                            },
                        },
                    },
                },
                'commonCurrencies': {
                    'MIR': 'MIR COIN',
                    'SOC': 'Soda Coin',
                },
            });
        }
    
        amountToPrecision (symbol, amount) {
            return this.decimalToPrecision (amount, TRUNCATE, this.markets[symbol]['precision']['amount'], DECIMAL_PLACES);
        }
    
        async fetchMarkets (params = {}) {
            const result = [];
            const quoteCurrencies = this.safeValue (this.options, 'quoteCurrencies', {});
            const quotes = Object.keys (quoteCurrencies);
            for (let i = 0; i < quotes.length; i++) {
                const quote = quotes[i];
                const extension = this.safeValue (quoteCurrencies, quote, {});
                const method = 'publicGetTickerALL' + quote;
                const response = await this[method] (params);
                const data = this.safeValue (response, 'data');
                const currencyIds = Object.keys (data);
                for (let j = 0; j < currencyIds.length; j++) {
                    const currencyId = currencyIds[j];
                    if (currencyId === 'date') {
                        continue;
                    }
                    const market = data[currencyId];
                    const base = this.safeCurrencyCode (currencyId);
                    const symbol = currencyId + '/' + quote;
                    let active = true;
                    if (Array.isArray (market)) {
                        const numElements = market.length;
                        if (numElements === 0) {
                            active = false;
                        }
                    }
                    const entry = this.deepExtend ({
                        'id': currencyId,
                        'symbol': symbol,
                        'base': base,
                        'quote': quote,
                        'info': market,
                        'active': active,
                        'precision': {
                            'amount': 4,
                            'price': 4,
                        },
                        'limits': {
                            'amount': {
                                'min': undefined,
                                'max': undefined,
                            },
                            'price': {
                                'min': undefined,
                                'max': undefined,
                            },
                            'cost': {}, // set via options
                        },
                        'baseId': undefined,
                        'quoteId': undefined,
                    }, extension);
                    result.push (entry);
                }
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const request = {
                'currency': 'ALL',
            };
            const response = await this.privatePostInfoBalance (this.extend (request, params));
            const result = { 'info': response };
            const balances = this.safeValue (response, 'data');
            const codes = Object.keys (this.currencies);
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const account = this.account ();
                const currency = this.currency (code);
                const lowerCurrencyId = this.safeStringLower (currency, 'id');
                account['total'] = this.safeString (balances, 'total_' + lowerCurrencyId);
                account['used'] = this.safeString (balances, 'in_use_' + lowerCurrencyId);
                account['free'] = this.safeString (balances, 'available_' + lowerCurrencyId);
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['base'] + '_' + market['quote'],
            };
            if (limit !== undefined) {
                request['count'] = limit; // default 30, max 30
            }
            const response = await this.publicGetOrderbookCurrency (this.extend (request, params));
            //
            //     {
            //         "status":"0000",
            //         "data":{
            //             "timestamp":"1587621553942",
            //             "payment_currency":"KRW",
            //             "order_currency":"BTC",
            //             "bids":[
            //                 {"price":"8652000","quantity":"0.0043"},
            //                 {"price":"8651000","quantity":"0.0049"},
            //                 {"price":"8650000","quantity":"8.4791"},
            //             ],
            //             "asks":[
            //                 {"price":"8654000","quantity":"0.119"},
            //                 {"price":"8655000","quantity":"0.254"},
            //                 {"price":"8658000","quantity":"0.119"},
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const timestamp = this.safeInteger (data, 'timestamp');
            return this.parseOrderBook (data, symbol, timestamp, 'bids', 'asks', 'price', 'quantity');
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker, fetchTickers
            //
            //     {
            //         "opening_price":"227100",
            //         "closing_price":"228400",
            //         "min_price":"222300",
            //         "max_price":"230000",
            //         "units_traded":"82618.56075337",
            //         "acc_trade_value":"18767376138.6031",
            //         "prev_closing_price":"227100",
            //         "units_traded_24H":"151871.13484676",
            //         "acc_trade_value_24H":"34247610416.8974",
            //         "fluctate_24H":"8700",
            //         "fluctate_rate_24H":"3.96",
            //         "date":"1587710327264", // fetchTickers inject this
            //     }
            //
            const timestamp = this.safeInteger (ticker, 'date');
            const symbol = this.safeSymbol (undefined, market);
            const open = this.safeNumber (ticker, 'opening_price');
            const close = this.safeNumber (ticker, 'closing_price');
            const baseVolume = this.safeNumber (ticker, 'units_traded_24H');
            const quoteVolume = this.safeNumber (ticker, 'acc_trade_value_24H');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'max_price'),
                'low': this.safeNumber (ticker, 'min_price'),
                'bid': this.safeNumber (ticker, 'buy_price'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell_price'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': open,
                'close': close,
                'last': close,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTickerAll (params);
            //
            //     {
            //         "status":"0000",
            //         "data":{
            //             "BTC":{
            //                 "opening_price":"9045000",
            //                 "closing_price":"9132000",
            //                 "min_price":"8938000",
            //                 "max_price":"9168000",
            //                 "units_traded":"4619.79967497",
            //                 "acc_trade_value":"42021363832.5187",
            //                 "prev_closing_price":"9041000",
            //                 "units_traded_24H":"8793.5045804",
            //                 "acc_trade_value_24H":"78933458515.4962",
            //                 "fluctate_24H":"530000",
            //                 "fluctate_rate_24H":"6.16"
            //             },
            //             "date":"1587710878669"
            //         }
            //     }
            //
            const result = {};
            const data = this.safeValue (response, 'data', {});
            const timestamp = this.safeInteger (data, 'date');
            const tickers = this.omit (data, 'date');
            const ids = Object.keys (tickers);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                let symbol = id;
                let market = undefined;
                if (id in this.markets_by_id) {
                    market = this.markets_by_id[id];
                    symbol = market['symbol'];
                }
                const ticker = tickers[id];
                const isArray = Array.isArray (ticker);
                if (!isArray) {
                    ticker['date'] = timestamp;
                    result[symbol] = this.parseTicker (ticker, market);
                }
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['base'],
            };
            const response = await this.publicGetTickerCurrency (this.extend (request, params));
            //
            //     {
            //         "status":"0000",
            //         "data":{
            //             "opening_price":"227100",
            //             "closing_price":"228400",
            //             "min_price":"222300",
            //             "max_price":"230000",
            //             "units_traded":"82618.56075337",
            //             "acc_trade_value":"18767376138.6031",
            //             "prev_closing_price":"227100",
            //             "units_traded_24H":"151871.13484676",
            //             "acc_trade_value_24H":"34247610416.8974",
            //             "fluctate_24H":"8700",
            //             "fluctate_rate_24H":"3.96",
            //             "date":"1587710327264"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseTicker (data, market);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1576823400000, // 기준 시간
            //         '8284000', // 시가
            //         '8286000', // 종가
            //         '8289000', // 고가
            //         '8276000', // 저가
            //         '15.41503692' // 거래량
            //     ]
            //
            return [
                this.safeInteger (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['base'],
                'interval': this.timeframes[timeframe],
            };
            const response = await this.publicGetCandlestickCurrencyInterval (this.extend (request, params));
            //
            //     {
            //         'status': '0000',
            //         'data': {
            //             [
            //                 1576823400000, // 기준 시간
            //                 '8284000', // 시가
            //                 '8286000', // 종가
            //                 '8289000', // 고가
            //                 '8276000', // 저가
            //                 '15.41503692' // 거래량
            //             ],
            //             [
            //                 1576824000000, // 기준 시간
            //                 '8284000', // 시가
            //                 '8281000', // 종가
            //                 '8289000', // 고가
            //                 '8275000', // 저가
            //                 '6.19584467' // 거래량
            //             ],
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "transaction_date":"2020-04-23 22:21:46",
            //         "type":"ask",
            //         "units_traded":"0.0125",
            //         "price":"8667000",
            //         "total":"108337"
            //     }
            //
            // fetchOrder (private)
            //
            //     {
            //         "transaction_date": "1572497603902030",
            //         "price": "8601000",
            //         "units": "0.005",
            //         "fee_currency": "KRW",
            //         "fee": "107.51",
            //         "total": "43005"
            //     }
            //
            // a workaround for their bug in date format, hours are not 0-padded
            let timestamp = undefined;
            const transactionDatetime = this.safeString (trade, 'transaction_date');
            if (transactionDatetime !== undefined) {
                const parts = transactionDatetime.split (' ');
                const numParts = parts.length;
                if (numParts > 1) {
                    const transactionDate = parts[0];
                    let transactionTime = parts[1];
                    if (transactionTime.length < 8) {
                        transactionTime = '0' + transactionTime;
                    }
                    timestamp = this.parse8601 (transactionDate + ' ' + transactionTime);
                } else {
                    timestamp = this.safeIntegerProduct (trade, 'transaction_date', 0.001);
                }
            }
            if (timestamp !== undefined) {
                timestamp -= 9 * 3600000; // they report UTC + 9 hours, server in Korean timezone
            }
            const type = undefined;
            let side = this.safeString (trade, 'type');
            side = (side === 'ask') ? 'sell' : 'buy';
            const id = this.safeString (trade, 'cont_no');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString2 (trade, 'units_traded', 'units');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            let cost = this.safeNumber (trade, 'total');
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'fee_currency');
                const feeCurrencyCode = this.commonCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': undefined,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['base'],
            };
            if (limit === undefined) {
                request['count'] = limit; // default 20, max 100
            }
            const response = await this.publicGetTransactionHistoryCurrency (this.extend (request, params));
            //
            //     {
            //         "status":"0000",
            //         "data":[
            //             {
            //                 "transaction_date":"2020-04-23 22:21:46",
            //                 "type":"ask",
            //                 "units_traded":"0.0125",
            //                 "price":"8667000",
            //                 "total":"108337"
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'order_currency': market['id'],
                'payment_currency': market['quote'],
                'units': amount,
            };
            let method = 'privatePostTradePlace';
            if (type === 'limit') {
                request['price'] = price;
                request['type'] = (side === 'buy') ? 'bid' : 'ask';
            } else {
                method = 'privatePostTradeMarket' + this.capitalize (side);
            }
            const response = await this[method] (this.extend (request, params));
            const id = this.safeString (response, 'order_id');
            if (id === undefined) {
                throw new InvalidOrder (this.id + ' createOrder() did not return an order id');
            }
            return {
                'info': response,
                'symbol': symbol,
                'type': type,
                'side': side,
                'id': id,
            };
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'order_id': id,
                'count': 1,
                'order_currency': market['base'],
                'payment_currency': market['quote'],
            };
            const response = await this.privatePostInfoOrderDetail (this.extend (request, params));
            //
            //     {
            //         "status": "0000",
            //         "data": {
            //             order_date: '1603161798539254',
            //             type: 'ask',
            //             order_status: 'Cancel',
            //             order_currency: 'BTC',
            //             payment_currency: 'KRW',
            //             watch_price: '0',
            //             order_price: '13344000',
            //             order_qty: '0.0125',
            //             cancel_date: '1603161803809993',
            //             cancel_type: '사용자취소',
            //             contract: [
            //                 {
            //                     transaction_date: '1603161799976383',
            //                     price: '13344000',
            //                     units: '0.0015',
            //                     fee_currency: 'KRW',
            //                     fee: '0',
            //                     total: '20016'
            //                 }
            //             ],
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data');
            return this.parseOrder (this.extend (data, { 'order_id': id }), market);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'Pending': 'open',
                'Completed': 'closed',
                'Cancel': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //
            // fetchOrder
            //
            //     {
            //         "transaction_date": "1572497603668315",
            //         "type": "bid",
            //         "order_status": "Completed",
            //         "order_currency": "BTC",
            //         "payment_currency": "KRW",
            //         "order_price": "8601000",
            //         "order_qty": "0.007",
            //         "cancel_date": "",
            //         "cancel_type": "",
            //         "contract": [
            //             {
            //                 "transaction_date": "1572497603902030",
            //                 "price": "8601000",
            //                 "units": "0.005",
            //                 "fee_currency": "KRW",
            //                 "fee": "107.51",
            //                 "total": "43005"
            //             },
            //         ]
            //     }
            //
            //     {
            //         order_date: '1603161798539254',
            //         type: 'ask',
            //         order_status: 'Cancel',
            //         order_currency: 'BTC',
            //         payment_currency: 'KRW',
            //         watch_price: '0',
            //         order_price: '13344000',
            //         order_qty: '0.0125',
            //         cancel_date: '1603161803809993',
            //         cancel_type: '사용자취소',
            //         contract: [
            //             {
            //                 transaction_date: '1603161799976383',
            //                 price: '13344000',
            //                 units: '0.0015',
            //                 fee_currency: 'KRW',
            //                 fee: '0',
            //                 total: '20016'
            //             }
            //         ],
            //     }
            //
            // fetchOpenOrders
            //
            //     {
            //         "order_currency": "BTC",
            //         "payment_currency": "KRW",
            //         "order_id": "C0101000007408440032",
            //         "order_date": "1571728739360570",
            //         "type": "bid",
            //         "units": "5.0",
            //         "units_remaining": "5.0",
            //         "price": "501000",
            //     }
            //
            const timestamp = this.safeIntegerProduct (order, 'order_date', 0.001);
            const sideProperty = this.safeValue2 (order, 'type', 'side');
            const side = (sideProperty === 'bid') ? 'buy' : 'sell';
            const status = this.parseOrderStatus (this.safeString (order, 'order_status'));
            let price = this.safeNumber2 (order, 'order_price', 'price');
            let type = 'limit';
            if (price === 0) {
                price = undefined;
                type = 'market';
            }
            const amount = this.safeNumber2 (order, 'order_qty', 'units');
            let remaining = this.safeNumber (order, 'units_remaining');
            if (remaining === undefined) {
                if (status === 'closed') {
                    remaining = 0;
                } else if (status !== 'canceled') {
                    remaining = amount;
                }
            }
            let symbol = undefined;
            const baseId = this.safeString (order, 'order_currency');
            const quoteId = this.safeString (order, 'payment_currency');
            const base = this.safeCurrencyCode (baseId);
            const quote = this.safeCurrencyCode (quoteId);
            if ((base !== undefined) && (quote !== undefined)) {
                symbol = base + '/' + quote;
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const id = this.safeString (order, 'order_id');
            const rawTrades = this.safeValue (order, 'contract', []);
            const trades = this.parseTrades (rawTrades, market, undefined, undefined, {
                'side': side,
                'symbol': symbol,
                'order': id,
            });
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': undefined,
                'average': undefined,
                'filled': undefined,
                'remaining': remaining,
                'status': status,
                'fee': undefined,
                'trades': trades,
            });
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (limit === undefined) {
                limit = 100;
            }
            const request = {
                'count': limit,
                'order_currency': market['base'],
                'payment_currency': market['quote'],
            };
            if (since !== undefined) {
                request['after'] = since;
            }
            const response = await this.privatePostInfoOrders (this.extend (request, params));
            //
            //     {
            //         "status": "0000",
            //         "data": [
            //             {
            //                 "order_currency": "BTC",
            //                 "payment_currency": "KRW",
            //                 "order_id": "C0101000007408440032",
            //                 "order_date": "1571728739360570",
            //                 "type": "bid",
            //                 "units": "5.0",
            //                 "units_remaining": "5.0",
            //                 "price": "501000",
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const side_in_params = ('side' in params);
            if (!side_in_params) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a `side` parameter (sell or buy)');
            }
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a `symbol` argument');
            }
            const market = this.market (symbol);
            const side = (params['side'] === 'buy') ? 'bid' : 'ask';
            params = this.omit (params, [ 'side', 'currency' ]);
            // https://github.com/ccxt/ccxt/issues/6771
            const request = {
                'order_id': id,
                'type': side,
                'order_currency': market['base'],
                'payment_currency': market['quote'],
            };
            return await this.privatePostTradeCancel (this.extend (request, params));
        }
    
        cancelUnifiedOrder (order, params = {}) {
            const request = {
                'side': order['side'],
            };
            return this.cancelOrder (order['id'], order['symbol'], this.extend (request, params));
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'units': amount,
                'address': address,
                'currency': currency['id'],
            };
            if (currency === 'XRP' || currency === 'XMR' || currency === 'EOS' || currency === 'STEEM') {
                const destination = this.safeString (params, 'destination');
                if ((tag === undefined) && (destination === undefined)) {
                    throw new ArgumentsRequired (this.id + ' ' + code + ' withdraw() requires a tag argument or an extra destination param');
                } else if (tag !== undefined) {
                    request['destination'] = tag;
                }
            }
            const response = await this.privatePostTradeBtcWithdrawal (this.extend (request, params));
            return {
                'info': response,
                'id': undefined,
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const endpoint = '/' + this.implodeParams (path, params);
            let url = this.implodeHostname (this.urls['api'][api]) + endpoint;
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                body = this.urlencode (this.extend ({
                    'endpoint': endpoint,
                }, query));
                const nonce = this.nonce ().toString ();
                const auth = endpoint + "\0" + body + "\0" + nonce; // eslint-disable-line quotes
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha512');
                const signature64 = this.decode (this.stringToBase64 (signature));
                headers = {
                    'Accept': 'application/json',
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Api-Key': this.apiKey,
                    'Api-Sign': signature64,
                    'Api-Nonce': nonce,
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if ('status' in response) {
                //
                //     {"status":"5100","message":"After May 23th, recent_transactions is no longer, hence users will not be able to connect to recent_transactions"}
                //
                const status = this.safeString (response, 'status');
                const message = this.safeString (response, 'message');
                if (status !== undefined) {
                    if (status === '0000') {
                        return; // no error
                    } else if (message === '거래 진행중인 내역이 존재하지 않습니다') {
                        // https://github.com/ccxt/ccxt/issues/9017
                        return; // no error
                    }
                    const feedback = this.id + ' ' + body;
                    this.throwExactlyMatchedException (this.exceptions, status, feedback);
                    this.throwExactlyMatchedException (this.exceptions, message, feedback);
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],39:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { AuthenticationError, ExchangeNotAvailable, AccountSuspended, PermissionDenied, RateLimitExceeded, InvalidNonce, InvalidAddress, ArgumentsRequired, ExchangeError, InvalidOrder, InsufficientFunds, BadRequest, OrderNotFound, BadSymbol, NotSupported } = require ('./base/errors');
    const { ROUND, TICK_SIZE, TRUNCATE } = require ('./base/functions/number');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitmart extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitmart',
                'name': 'BitMart',
                'countries': [ 'US', 'CN', 'HK', 'KR' ],
                'rateLimit': 1000,
                'version': 'v1',
                'certified': true,
                'pro': true,
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'cancelOrders': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchCanceledOrders': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchStatus': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'fetchFundingFee': true,
                    'withdraw': true,
                },
                'hostname': 'bitmart.com', // bitmart.info, bitmart.news for Hong Kong users
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/129991357-8f47464b-d0f4-41d6-8a82-34122f0d1398.jpg',
                    'api': {
                        'rest': 'https://api-cloud.{hostname}', // bitmart.info for Hong Kong users
                    },
                    'www': 'https://www.bitmart.com/',
                    'doc': 'https://developer-pro.bitmart.com/',
                    'referral': 'http://www.bitmart.com/?r=rQCFLh',
                    'fees': 'https://www.bitmart.com/fee/en',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'uid': true,
                },
                'api': {
                    'public': {
                        'system': {
                            'get': [
                                'time', // https://api-cloud.bitmart.com/system/time
                                'service', // https://api-cloud.bitmart.com/system/service
                            ],
                        },
                        'account': {
                            'get': [
                                'currencies', // https://api-cloud.bitmart.com/account/v1/currencies
                            ],
                        },
                        'spot': {
                            'get': [
                                'currencies',
                                'symbols',
                                'symbols/details',
                                'ticker', // ?symbol=BTC_USDT
                                'steps', // ?symbol=BMX_ETH
                                'symbols/kline', // ?symbol=BMX_ETH&step=15&from=1525760116&to=1525769116
                                'symbols/book', // ?symbol=BMX_ETH&precision=6
                                'symbols/trades', // ?symbol=BMX_ETH
                            ],
                        },
                        'contract': {
                            'get': [
                                'contracts', // https://api-cloud.bitmart.com/contract/v1/ifcontract/contracts
                                'pnls',
                                'indexes',
                                'tickers',
                                'quote',
                                'indexquote',
                                'trades',
                                'depth',
                                'fundingrate',
                            ],
                        },
                    },
                    'private': {
                        'account': {
                            'get': [
                                'wallet', // ?account_type=1
                                'deposit/address', // ?currency=USDT-TRC20
                                'withdraw/charge', // ?currency=BTC
                                'deposit-withdraw/history', // ?limit=10&offset=1&operationType=withdraw
                                'deposit-withdraw/detail', // ?id=1679952
                            ],
                            'post': [
                                'withdraw/apply',
                            ],
                        },
                        'spot': {
                            'get': [
                                'wallet',
                                'order_detail',
                                'orders',
                                'trades',
                            ],
                            'post': [
                                'submit_order', // https://api-cloud.bitmart.com/spot/v1/submit_order
                                'cancel_order', // https://api-cloud.bitmart.com/spot/v2/cancel_order
                                'cancel_orders',
                            ],
                        },
                        'contract': {
                            'get': [
                                'userOrders',
                                'userOrderInfo',
                                'userTrades',
                                'orderTrades',
                                'accounts',
                                'userPositions',
                                'userLiqRecords',
                                'positionFee',
                            ],
                            'post': [
                                'batchOrders',
                                'submitOrder',
                                'cancelOrders',
                                'marginOper',
                            ],
                        },
                    },
                },
                'timeframes': {
                    '1m': 1,
                    '3m': 3,
                    '5m': 5,
                    '15m': 15,
                    '30m': 30,
                    '45m': 45,
                    '1h': 60,
                    '2h': 120,
                    '3h': 180,
                    '4h': 240,
                    '1d': 1440,
                    '1w': 10080,
                    '1M': 43200,
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': this.parseNumber ('0.0025'),
                        'maker': this.parseNumber ('0.0025'),
                        'tiers': {
                            'taker': [
                                [this.parseNumber ('0'), this.parseNumber ('0.0020')],
                                [this.parseNumber ('10'), this.parseNumber ('0.18')],
                                [this.parseNumber ('50'), this.parseNumber ('0.0016')],
                                [this.parseNumber ('250'), this.parseNumber ('0.0014')],
                                [this.parseNumber ('1000'), this.parseNumber ('0.0012')],
                                [this.parseNumber ('5000'), this.parseNumber ('0.0010')],
                                [this.parseNumber ('25000'), this.parseNumber ('0.0008')],
                                [this.parseNumber ('50000'), this.parseNumber ('0.0006')],
                            ],
                            'maker': [
                                [this.parseNumber ('0'), this.parseNumber ('0.001')],
                                [this.parseNumber ('10'), this.parseNumber ('0.0009')],
                                [this.parseNumber ('50'), this.parseNumber ('0.0008')],
                                [this.parseNumber ('250'), this.parseNumber ('0.0007')],
                                [this.parseNumber ('1000'), this.parseNumber ('0.0006')],
                                [this.parseNumber ('5000'), this.parseNumber ('0.0005')],
                                [this.parseNumber ('25000'), this.parseNumber ('0.0004')],
                                [this.parseNumber ('50000'), this.parseNumber ('0.0003')],
                            ],
                        },
                    },
                },
                'precisionMode': TICK_SIZE,
                'exceptions': {
                    'exact': {
                        // general errors
                        '30000': ExchangeError, // 404, Not found
                        '30001': AuthenticationError, // 401, Header X-BM-KEY is empty
                        '30002': AuthenticationError, // 401, Header X-BM-KEY not found
                        '30003': AccountSuspended, // 401, Header X-BM-KEY has frozen
                        '30004': AuthenticationError, // 401, Header X-BM-SIGN is empty
                        '30005': AuthenticationError, // 401, Header X-BM-SIGN is wrong
                        '30006': AuthenticationError, // 401, Header X-BM-TIMESTAMP is empty
                        '30007': AuthenticationError, // 401, Header X-BM-TIMESTAMP range. Within a minute
                        '30008': AuthenticationError, // 401, Header X-BM-TIMESTAMP invalid format
                        '30010': PermissionDenied, // 403, IP is forbidden. We recommend enabling IP whitelist for API trading. After that reauth your account
                        '30011': AuthenticationError, // 403, Header X-BM-KEY over expire time
                        '30012': AuthenticationError, // 403, Header X-BM-KEY is forbidden to request it
                        '30013': RateLimitExceeded, // 429, Request too many requests
                        '30014': ExchangeNotAvailable, // 503, Service unavailable
                        // funding account errors
                        '60000': BadRequest, // 400, Invalid request (maybe the body is empty, or the int parameter passes string data)
                        '60001': BadRequest, // 400, Asset account type does not exist
                        '60002': BadRequest, // 400, currency does not exist
                        '60003': ExchangeError, // 400, Currency has been closed recharge channel, if there is any problem, please consult customer service
                        '60004': ExchangeError, // 400, Currency has been closed withdraw channel, if there is any problem, please consult customer service
                        '60005': ExchangeError, // 400, Minimum amount is %s
                        '60006': ExchangeError, // 400, Maximum withdraw precision is %d
                        '60007': InvalidAddress, // 400, Only withdrawals from added addresses are allowed
                        '60008': InsufficientFunds, // 400, Balance not enough
                        '60009': ExchangeError, // 400, Beyond the limit
                        '60010': ExchangeError, // 400, Withdraw id or deposit id not found
                        '60011': InvalidAddress, // 400, Address is not valid
                        '60012': ExchangeError, // 400, This action is not supported in this currency(If IOTA, HLX recharge and withdraw calls are prohibited)
                        '60020': PermissionDenied, // 403, Your account is not allowed to recharge
                        '60021': PermissionDenied, // 403, Your account is not allowed to withdraw
                        '60022': PermissionDenied, // 403, No withdrawals for 24 hours
                        '60030': BadRequest, // 405, Method Not Allowed
                        '60031': BadRequest, // 415, Unsupported Media Type
                        '60050': ExchangeError, // 500, User account not found
                        '60051': ExchangeError, // 500, Internal Server Error
                        // spot errors
                        '50000': BadRequest, // 400, Bad Request
                        '50001': BadSymbol, // 400, Symbol not found
                        '50002': BadRequest, // 400, From Or To format error
                        '50003': BadRequest, // 400, Step format error
                        '50004': BadRequest, // 400, Kline size over 500
                        '50005': OrderNotFound, // 400, Order Id not found
                        '50006': InvalidOrder, // 400, Minimum size is %s
                        '50007': InvalidOrder, // 400, Maximum size is %s
                        '50008': InvalidOrder, // 400, Minimum price is %s
                        '50009': InvalidOrder, // 400, Minimum count*price is %s
                        '50010': InvalidOrder, // 400, RequestParam size is required
                        '50011': InvalidOrder, // 400, RequestParam price is required
                        '50012': InvalidOrder, // 400, RequestParam notional is required
                        '50013': InvalidOrder, // 400, Maximum limit*offset is %d
                        '50014': BadRequest, // 400, RequestParam limit is required
                        '50015': BadRequest, // 400, Minimum limit is 1
                        '50016': BadRequest, // 400, Maximum limit is %d
                        '50017': BadRequest, // 400, RequestParam offset is required
                        '50018': BadRequest, // 400, Minimum offset is 1
                        '50019': BadRequest, // 400, Maximum price is %s
                        // '50019': ExchangeError, // 400, Invalid status. validate status is [1=Failed, 2=Success, 3=Frozen Failed, 4=Frozen Success, 5=Partially Filled, 6=Fully Fulled, 7=Canceling, 8=Canceled
                        '50020': InsufficientFunds, // 400, Balance not enough
                        '50021': BadRequest, // 400, Invalid %s
                        '50022': ExchangeNotAvailable, // 400, Service unavailable
                        '50023': BadSymbol, // 400, This Symbol can't place order by api
                        '53000': AccountSuspended, // 403, Your account is frozen due to security policies. Please contact customer service
                        '57001': BadRequest, // 405, Method Not Allowed
                        '58001': BadRequest, // 415, Unsupported Media Type
                        '59001': ExchangeError, // 500, User account not found
                        '59002': ExchangeError, // 500, Internal Server Error
                        // contract errors
                        '40001': ExchangeError, // 400, Cloud account not found
                        '40002': ExchangeError, // 400, out_trade_no not found
                        '40003': ExchangeError, // 400, out_trade_no already existed
                        '40004': ExchangeError, // 400, Cloud account count limit
                        '40005': ExchangeError, // 400, Transfer vol precision error
                        '40006': PermissionDenied, // 400, Invalid ip error
                        '40007': BadRequest, // 400, Parse parameter error
                        '40008': InvalidNonce, // 400, Check nonce error
                        '40009': BadRequest, // 400, Check ver error
                        '40010': BadRequest, // 400, Not found func error
                        '40011': BadRequest, // 400, Invalid request
                        '40012': ExchangeError, // 500, System error
                        '40013': ExchangeError, // 400, Access too often" CLIENT_TIME_INVALID, "Please check your system time.
                        '40014': BadSymbol, // 400, This contract is offline
                        '40015': BadSymbol, // 400, This contract's exchange has been paused
                        '40016': InvalidOrder, // 400, This order would trigger user position liquidate
                        '40017': InvalidOrder, // 400, It is not possible to open and close simultaneously in the same position
                        '40018': InvalidOrder, // 400, Your position is closed
                        '40019': ExchangeError, // 400, Your position is in liquidation delegating
                        '40020': InvalidOrder, // 400, Your position volume is not enough
                        '40021': ExchangeError, // 400, The position is not exsit
                        '40022': ExchangeError, // 400, The position is not isolated
                        '40023': ExchangeError, // 400, The position would liquidate when sub margin
                        '40024': ExchangeError, // 400, The position would be warnning of liquidation when sub margin
                        '40025': ExchangeError, // 400, The position’s margin shouldn’t be lower than the base limit
                        '40026': ExchangeError, // 400, You cross margin position is in liquidation delegating
                        '40027': InsufficientFunds, // 400, You contract account available balance not enough
                        '40028': PermissionDenied, // 400, Your plan order's count is more than system maximum limit.
                        '40029': InvalidOrder, // 400, The order's leverage is too large.
                        '40030': InvalidOrder, // 400, The order's leverage is too small.
                        '40031': InvalidOrder, // 400, The deviation between current price and trigger price is too large.
                        '40032': InvalidOrder, // 400, The plan order's life cycle is too long.
                        '40033': InvalidOrder, // 400, The plan order's life cycle is too short.
                        '40034': BadSymbol, // 400, This contract is not found
                    },
                    'broad': {},
                },
                'commonCurrencies': {
                    'COT': 'Community Coin',
                    'CPC': 'CPCoin',
                    'MVP': 'MVP Coin',
                    'ONE': 'Menlo One',
                    'PLA': 'Plair',
                    'TCT': 'TacoCat Token',
                },
                'options': {
                    'defaultType': 'spot', // 'spot', 'swap'
                    'fetchBalance': {
                        'type': 'spot', // 'spot', 'swap', 'contract', 'account'
                    },
                    'createMarketBuyOrderRequiresPrice': true,
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicSystemGetTime (params);
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"c4e5e5b7-fe9f-4191-89f7-53f6c5bf9030",
            //         "data":{
            //             "server_time":1599843709578
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.safeInteger (data, 'server_time');
        }
    
        async fetchStatus (params = {}) {
            const options = this.safeValue (this.options, 'fetchBalance', {});
            const defaultType = this.safeString (this.options, 'defaultType');
            let type = this.safeString (options, 'type', defaultType);
            type = this.safeString (params, 'type', type);
            params = this.omit (params, 'type');
            const response = await this.publicSystemGetService (params);
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "serivce":[
            //                 {
            //                     "title": "Spot API Stop",
            //                     "service_type": "spot",
            //                     "status": "2",
            //                     "start_time": 1527777538000,
            //                     "end_time": 1527777538000
            //                 },
            //                 {
            //                     "title": "Contract API Stop",
            //                     "service_type": "contract",
            //                     "status": "2",
            //                     "start_time": 1527777538000,
            //                     "end_time": 1527777538000
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const services = this.safeValue (data, 'service', []);
            const servicesByType = this.indexBy (services, 'service_type');
            if ((type === 'swap') || (type === 'future')) {
                type = 'contract';
            }
            const service = this.safeValue (servicesByType, type);
            let status = undefined;
            let eta = undefined;
            if (service !== undefined) {
                const statusCode = this.safeInteger (service, 'status');
                if (statusCode === 2) {
                    status = 'ok';
                } else {
                    status = 'maintenance';
                    eta = this.safeInteger (service, 'end_time');
                }
            }
            this.status = this.extend (this.status, {
                'status': status,
                'updated': this.milliseconds (),
                'eta': eta,
            });
            return this.status;
        }
    
        async fetchSpotMarkets (params = {}) {
            const response = await this.publicSpotGetSymbolsDetails (params);
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a67c9146-086d-4d3f-9897-5636a9bb26e1",
            //         "data":{
            //             "symbols":[
            //                 {
            //                     "symbol":"PRQ_BTC",
            //                     "symbol_id":1232,
            //                     "base_currency":"PRQ",
            //                     "quote_currency":"BTC",
            //                     "quote_increment":"1.0000000000",
            //                     "base_min_size":"1.0000000000",
            //                     "base_max_size":"10000000.0000000000",
            //                     "price_min_precision":8,
            //                     "price_max_precision":10,
            //                     "expiration":"NA",
            //                     "min_buy_amount":"0.0001000000",
            //                     "min_sell_amount":"0.0001000000"
            //                 },
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const symbols = this.safeValue (data, 'symbols', []);
            const result = [];
            for (let i = 0; i < symbols.length; i++) {
                const market = symbols[i];
                const id = this.safeString (market, 'symbol');
                const numericId = this.safeInteger (market, 'symbol_id');
                const baseId = this.safeString (market, 'base_currency');
                const quoteId = this.safeString (market, 'quote_currency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                //
                // https://github.com/bitmartexchange/bitmart-official-api-docs/blob/master/rest/public/symbols_details.md#response-details
                // from the above API doc:
                // quote_increment Minimum order price as well as the price increment
                // price_min_precision Minimum price precision (digit) used to query price and kline
                // price_max_precision Maximum price precision (digit) used to query price and kline
                //
                // the docs are wrong: https://github.com/ccxt/ccxt/issues/5612
                //
                const pricePrecision = this.safeInteger (market, 'price_max_precision');
                const precision = {
                    'amount': this.safeNumber (market, 'base_min_size'),
                    'price': this.parseNumber (this.decimalToPrecision (Math.pow (10, -pricePrecision), ROUND, 12)),
                };
                const minBuyCost = this.safeNumber (market, 'min_buy_amount');
                const minSellCost = this.safeNumber (market, 'min_sell_amount');
                const minCost = Math.max (minBuyCost, minSellCost);
                const limits = {
                    'amount': {
                        'min': this.safeNumber (market, 'base_min_size'),
                        'max': this.safeNumber (market, 'base_max_size'),
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': minCost,
                        'max': undefined,
                    },
                };
                result.push ({
                    'id': id,
                    'numericId': numericId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'type': 'spot',
                    'spot': true,
                    'future': false,
                    'swap': false,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                    'active': true,
                });
            }
            return result;
        }
    
        async fetchContractMarkets (params = {}) {
            const response = await this.publicContractGetContracts (params);
            //
            //     {
            //         "errno":"OK",
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"7fcedfb5-a660-4780-8a7a-b36a9e2159f7",
            //         "data":{
            //             "contracts":[
            //                 {
            //                     "contract":{
            //                         "contract_id":1,
            //                         "index_id":1,
            //                         "name":"BTCUSDT",
            //                         "display_name":"BTCUSDT永续合约",
            //                         "display_name_en":"BTCUSDT_SWAP",
            //                         "contract_type":1,
            //                         "base_coin":"BTC",
            //                         "quote_coin":"USDT",
            //                         "price_coin":"BTC",
            //                         "exchange":"*",
            //                         "contract_size":"0.0001",
            //                         "begin_at":"2018-08-17T04:00:00Z",
            //                         "delive_at":"2020-08-15T12:00:00Z",
            //                         "delivery_cycle":28800,
            //                         "min_leverage":"1",
            //                         "max_leverage":"100",
            //                         "price_unit":"0.1",
            //                         "vol_unit":"1",
            //                         "value_unit":"0.0001",
            //                         "min_vol":"1",
            //                         "max_vol":"300000",
            //                         "liquidation_warn_ratio":"0.85",
            //                         "fast_liquidation_ratio":"0.8",
            //                         "settgle_type":1,
            //                         "open_type":3,
            //                         "compensate_type":1,
            //                         "status":3,
            //                         "block":1,
            //                         "rank":1,
            //                         "created_at":"2018-07-12T19:16:57Z",
            //                         "depth_bord":"1.001",
            //                         "base_coin_zh":"比特币",
            //                         "base_coin_en":"Bitcoin",
            //                         "max_rate":"0.00375",
            //                         "min_rate":"-0.00375"
            //                     },
            //                     "risk_limit":{"contract_id":1,"base_limit":"1000000","step":"500000","maintenance_margin":"0.005","initial_margin":"0.01"},
            //                     "fee_config":{"contract_id":1,"maker_fee":"-0.0003","taker_fee":"0.001","settlement_fee":"0","created_at":"2018-07-12T20:47:22Z"},
            //                     "plan_order_config":{"contract_id":0,"min_scope":"0.001","max_scope":"2","max_count":10,"min_life_cycle":24,"max_life_cycle":168}
            //                 },
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const contracts = this.safeValue (data, 'contracts', []);
            const result = [];
            for (let i = 0; i < contracts.length; i++) {
                const market = contracts[i];
                const contract = this.safeValue (market, 'contract', {});
                const id = this.safeString (contract, 'contract_id');
                const numericId = this.safeInteger (contract, 'contract_id');
                const baseId = this.safeString (contract, 'base_coin');
                const quoteId = this.safeString (contract, 'quote_coin');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = this.safeString (contract, 'name');
                //
                // https://github.com/bitmartexchange/bitmart-official-api-docs/blob/master/rest/public/symbols_details.md#response-details
                // from the above API doc:
                // quote_increment Minimum order price as well as the price increment
                // price_min_precision Minimum price precision (digit) used to query price and kline
                // price_max_precision Maximum price precision (digit) used to query price and kline
                //
                // the docs are wrong: https://github.com/ccxt/ccxt/issues/5612
                //
                const amountPrecision = this.safeNumber (contract, 'vol_unit');
                const pricePrecision = this.safeNumber (contract, 'price_unit');
                const precision = {
                    'amount': amountPrecision,
                    'price': pricePrecision,
                };
                const limits = {
                    'amount': {
                        'min': this.safeNumber (contract, 'min_vol'),
                        'max': this.safeNumber (contract, 'max_vol'),
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                const contractType = this.safeValue (contract, 'contract_type');
                let future = false;
                let swap = false;
                let type = 'contract';
                if (contractType === 1) {
                    type = 'swap';
                    swap = true;
                } else if (contractType === 2) {
                    type = 'future';
                    future = true;
                }
                const feeConfig = this.safeValue (market, 'fee_config', {});
                const maker = this.safeNumber (feeConfig, 'maker_fee');
                const taker = this.safeNumber (feeConfig, 'taker_fee');
                result.push ({
                    'id': id,
                    'numericId': numericId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'maker': maker,
                    'taker': taker,
                    'type': type,
                    'spot': false,
                    'future': future,
                    'swap': swap,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                    'active': undefined,
                });
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            return await this.fetchSpotMarkets ();
        }
    
        async fetchFundingFee (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateAccountGetWithdrawCharge (this.extend (request, params));
            //
            //     {
            //         message: 'OK',
            //         code: '1000',
            //         trace: '3ecc0adf-91bd-4de7-aca1-886c1122f54f',
            //         data: {
            //             today_available_withdraw_BTC: '100.0000',
            //             min_withdraw: '0.005',
            //             withdraw_precision: '8',
            //             withdraw_fee: '0.000500000000000000000000000000'
            //         }
            //     }
            //
            const data = response['data'];
            const withdrawFees = {};
            withdrawFees[code] = this.safeNumber (data, 'withdraw_fee');
            return {
                'info': response,
                'withdraw': withdrawFees,
                'deposit': {},
            };
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // spot
            //
            //     {
            //         "symbol":"ETH_BTC",
            //         "last_price":"0.036037",
            //         "quote_volume_24h":"4380.6660000000",
            //         "base_volume_24h":"159.3582006712",
            //         "high_24h":"0.036972",
            //         "low_24h":"0.035524",
            //         "open_24h":"0.036561",
            //         "close_24h":"0.036037",
            //         "best_ask":"0.036077",
            //         "best_ask_size":"9.9500",
            //         "best_bid":"0.035983",
            //         "best_bid_size":"4.2792",
            //         "fluctuation":"-0.0143",
            //         "s_t": "1630981727", // ws only
            //         "url":"https://www.bitmart.com/trade?symbol=ETH_BTC"
            //     }
            //
            // contract
            //
            //     {
            //         "last_price":"422.2",
            //         "open":"430.5",
            //         "close":"422.2",
            //         "low":"421.9",
            //         "high":"436.9",
            //         "avg_price":"430.8569900089815372072",
            //         "volume":"2720",
            //         "total_volume":"18912248",
            //         "timestamp":1597631495,
            //         "rise_fall_rate":"-0.0192799070847851336",
            //         "rise_fall_value":"-8.3",
            //         "contract_id":2,
            //         "position_size":"3067404",
            //         "volume_day":"9557384",
            //         "amount24":"80995537.0919999999999974153",
            //         "base_coin_volume":"189122.48",
            //         "quote_coin_volume":"81484742.475833810590837937856",
            //         "pps":"1274350547",
            //         "index_price":"422.135",
            //         "fair_price":"422.147253318507",
            //         "depth_price":{"bid_price":"421.9","ask_price":"422","mid_price":"421.95"},
            //         "fair_basis":"0.000029027013",
            //         "fair_value":"0.012253318507",
            //         "rate":{"quote_rate":"0.0006","base_rate":"0.0003","interest_rate":"0.000099999999"},
            //         "premium_index":"0.000045851604",
            //         "funding_rate":"0.000158",
            //         "next_funding_rate":"0.000099999999",
            //         "next_funding_at":"2020-08-17T04:00:00Z"
            //     }
            //
            const timestamp = this.safeTimestamp2 (ticker, 'timestamp', 's_t', this.milliseconds ());
            const marketId = this.safeString2 (ticker, 'symbol', 'contract_id');
            const symbol = this.safeSymbol (marketId, market, '_');
            const last = this.safeNumber2 (ticker, 'close_24h', 'last_price');
            let percentage = this.safeNumber2 (ticker, 'fluctuation', 'rise_fall_rate');
            if (percentage !== undefined) {
                percentage *= 100;
            }
            const baseVolume = this.safeNumber2 (ticker, 'base_volume_24h', 'base_coin_volume');
            const quoteVolume = this.safeNumber2 (ticker, 'quote_volume_24h', 'quote_coin_volume');
            const vwap = this.vwap (baseVolume, quoteVolume);
            const open = this.safeNumber2 (ticker, 'open_24h', 'open');
            let average = undefined;
            if ((last !== undefined) && (open !== undefined)) {
                average = this.sum (last, open) / 2;
            }
            average = this.safeNumber (ticker, 'avg_price', average);
            const price = this.safeValue (ticker, 'depth_price', ticker);
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber2 (ticker, 'high', 'high_24h'),
                'low': this.safeNumber2 (ticker, 'low', 'low_24h'),
                'bid': this.safeNumber (price, 'best_bid', 'bid_price'),
                'bidVolume': this.safeNumber (ticker, 'best_bid_size'),
                'ask': this.safeNumber (price, 'best_ask', 'ask_price'),
                'askVolume': this.safeNumber (ticker, 'best_ask_size'),
                'vwap': vwap,
                'open': this.safeNumber (ticker, 'open_24h'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': percentage,
                'average': average,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            let method = undefined;
            if (market['swap'] || market['future']) {
                method = 'publicContractGetTickers';
                request['contractID'] = market['id'];
            } else if (market['spot']) {
                method = 'publicSpotGetTicker';
                request['symbol'] = market['id'];
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"6aa5b923-2f57-46e3-876d-feca190e0b82",
            //         "data":{
            //             "tickers":[
            //                 {
            //                     "symbol":"ETH_BTC",
            //                     "last_price":"0.036037",
            //                     "quote_volume_24h":"4380.6660000000",
            //                     "base_volume_24h":"159.3582006712",
            //                     "high_24h":"0.036972",
            //                     "low_24h":"0.035524",
            //                     "open_24h":"0.036561",
            //                     "close_24h":"0.036037",
            //                     "best_ask":"0.036077",
            //                     "best_ask_size":"9.9500",
            //                     "best_bid":"0.035983",
            //                     "best_bid_size":"4.2792",
            //                     "fluctuation":"-0.0143",
            //                     "url":"https://www.bitmart.com/trade?symbol=ETH_BTC"
            //                 }
            //             ]
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "errno":"OK",
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"d09b57c4-d99b-4a13-91a8-2df98f889909",
            //         "data":{
            //             "tickers":[
            //                 {
            //                     "last_price":"422.2",
            //                     "open":"430.5",
            //                     "close":"422.2",
            //                     "low":"421.9",
            //                     "high":"436.9",
            //                     "avg_price":"430.8569900089815372072",
            //                     "volume":"2720",
            //                     "total_volume":"18912248",
            //                     "timestamp":1597631495,
            //                     "rise_fall_rate":"-0.0192799070847851336",
            //                     "rise_fall_value":"-8.3",
            //                     "contract_id":2,
            //                     "position_size":"3067404",
            //                     "volume_day":"9557384",
            //                     "amount24":"80995537.0919999999999974153",
            //                     "base_coin_volume":"189122.48",
            //                     "quote_coin_volume":"81484742.475833810590837937856",
            //                     "pps":"1274350547",
            //                     "index_price":"422.135",
            //                     "fair_price":"422.147253318507",
            //                     "depth_price":{"bid_price":"421.9","ask_price":"422","mid_price":"421.95"},
            //                     "fair_basis":"0.000029027013",
            //                     "fair_value":"0.012253318507",
            //                     "rate":{"quote_rate":"0.0006","base_rate":"0.0003","interest_rate":"0.000099999999"},
            //                     "premium_index":"0.000045851604",
            //                     "funding_rate":"0.000158",
            //                     "next_funding_rate":"0.000099999999",
            //                     "next_funding_at":"2020-08-17T04:00:00Z"
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const tickers = this.safeValue (data, 'tickers', []);
            const tickersById = this.indexBy (tickers, 'symbol');
            const ticker = this.safeValue (tickersById, market['id']);
            return this.parseTicker (ticker, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            let method = undefined;
            if ((type === 'swap') || (type === 'future')) {
                method = 'publicContractGetTickers';
            } else if (type === 'spot') {
                method = 'publicSpotGetTicker';
            }
            const response = await this[method] (params);
            const data = this.safeValue (response, 'data', {});
            const tickers = this.safeValue (data, 'tickers', []);
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const ticker = this.parseTicker (tickers[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicAccountGetCurrencies (params);
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"8c768b3c-025f-413f-bec5-6d6411d46883",
            //         "data":{
            //             "currencies":[
            //                 {"currency":"MATIC","name":"Matic Network","withdraw_enabled":true,"deposit_enabled":true},
            //                 {"currency":"KTN","name":"Kasoutuuka News","withdraw_enabled":true,"deposit_enabled":false},
            //                 {"currency":"BRT","name":"Berith","withdraw_enabled":true,"deposit_enabled":true},
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const currencies = this.safeValue (data, 'currencies', []);
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                const id = this.safeString (currency, 'currency');
                const code = this.safeCurrencyCode (id);
                const name = this.safeString (currency, 'name');
                const withdrawEnabled = this.safeValue (currency, 'withdraw_enabled');
                const depositEnabled = this.safeValue (currency, 'deposit_enabled');
                const active = withdrawEnabled && depositEnabled;
                result[code] = {
                    'id': id,
                    'code': code,
                    'name': name,
                    'info': currency, // the original payload
                    'active': active,
                    'fee': undefined,
                    'precision': undefined,
                    'limits': {
                        'amount': { 'min': undefined, 'max': undefined },
                        'withdraw': { 'min': undefined, 'max': undefined },
                    },
                };
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            let method = undefined;
            if (market['spot']) {
                method = 'publicSpotGetSymbolsBook';
                request['symbol'] = market['id'];
                // request['precision'] = 4; // optional price precision / depth level whose range is defined in symbol details
            } else if (market['swap'] || market['future']) {
                method = 'publicContractGetDepth';
                request['contractID'] = market['id'];
                if (limit !== undefined) {
                    request['count'] = limit; // returns all records if size is omitted
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"8254f8fc-431d-404f-ad9a-e716339f66c7",
            //         "data":{
            //             "buys":[
            //                 {"amount":"4.7091","total":"4.71","price":"0.034047","count":"1"},
            //                 {"amount":"5.7439","total":"10.45","price":"0.034039","count":"1"},
            //                 {"amount":"2.5249","total":"12.98","price":"0.032937","count":"1"},
            //             ],
            //             "sells":[
            //                 {"amount":"41.4365","total":"41.44","price":"0.034174","count":"1"},
            //                 {"amount":"4.2317","total":"45.67","price":"0.034183","count":"1"},
            //                 {"amount":"0.3000","total":"45.97","price":"0.034240","count":"1"},
            //             ]
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "errno":"OK",
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"c330dfca-ca5b-4f15-b350-9fef3f049b4f",
            //         "data":{
            //             "sells":[
            //                 {"price":"347.6","vol":"6678"},
            //                 {"price":"347.7","vol":"3452"},
            //                 {"price":"347.8","vol":"6331"},
            //             ],
            //             "buys":[
            //                 {"price":"347.5","vol":"6222"},
            //                 {"price":"347.4","vol":"20979"},
            //                 {"price":"347.3","vol":"15179"},
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            if (market['spot']) {
                return this.parseOrderBook (data, symbol, undefined, 'buys', 'sells', 'price', 'amount');
            } else if (market['swap'] || market['future']) {
                return this.parseOrderBook (data, symbol, undefined, 'buys', 'sells', 'price', 'vol');
            }
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades spot
            //
            //     {
            //         "amount":"0.005703",
            //         "order_time":1599652045394,
            //         "price":"0.034029",
            //         "count":"0.1676",
            //         "type":"sell"
            //     }
            //
            // public fetchTrades contract, private fetchMyTrades contract
            //
            //     {
            //         "order_id":109159616160,
            //         "trade_id":109159616197,
            //         "contract_id":2,
            //         "deal_price":"347.6",
            //         "deal_vol":"5623",
            //         "make_fee":"-5.8636644",
            //         "take_fee":"9.772774",
            //         "created_at":"2020-09-09T11:49:50.749170536Z",
            //         "way":1,
            //         "fluctuation":"0"
            //     }
            //
            // private fetchMyTrades spot
            //
            //     {
            //         "detail_id":256348632,
            //         "order_id":2147484350,
            //         "symbol":"BTC_USDT",
            //         "create_time":1590462303000,
            //         "side":"buy",
            //         "fees":"0.00001350",
            //         "fee_coin_name":"BTC",
            //         "notional":"88.00000000",
            //         "price_avg":"8800.00",
            //         "size":"0.01000",
            //         "exec_type":"M"
            //     }
            //
            const id = this.safeString2 (trade, 'trade_id', 'detail_id');
            let timestamp = this.safeInteger2 (trade, 'order_time', 'create_time');
            if (timestamp === undefined) {
                timestamp = this.safeTimestamp (trade, 's_t');
            }
            if (timestamp === undefined) {
                timestamp = this.parse8601 (this.safeString (trade, 'created_at'));
            }
            const type = undefined;
            const way = this.safeInteger (trade, 'way');
            let side = this.safeStringLower2 (trade, 'type', 'side');
            if ((side === undefined) && (way !== undefined)) {
                if (way < 5) {
                    side = 'buy';
                } else {
                    side = 'sell';
                }
            }
            let takerOrMaker = undefined;
            const execType = this.safeString (trade, 'exec_type');
            if (execType !== undefined) {
                takerOrMaker = (execType === 'M') ? 'maker' : 'taker';
            }
            let price = this.safeNumber2 (trade, 'price', 'deal_price');
            price = this.safeNumber (trade, 'price_avg', price);
            let amount = this.safeNumber2 (trade, 'amount', 'deal_vol');
            amount = this.safeNumber (trade, 'size', amount);
            let cost = this.safeNumber2 (trade, 'count', 'notional');
            if ((cost === undefined) && (price !== undefined) && (amount !== undefined)) {
                cost = amount * price;
            }
            const orderId = this.safeInteger (trade, 'order_id');
            const marketId = this.safeString2 (trade, 'contract_id', 'symbol');
            const symbol = this.safeSymbol (marketId, market, '_');
            const feeCost = this.safeNumber (trade, 'fees');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'fee_coin_name');
                let feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                if ((feeCurrencyCode === undefined) && (market !== undefined)) {
                    feeCurrencyCode = (side === 'buy') ? market['base'] : market['quote'];
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'info': trade,
                'id': id,
                'order': orderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'takerOrMaker': takerOrMaker,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            let method = undefined;
            if (market['spot']) {
                request['symbol'] = market['id'];
                method = 'publicSpotGetSymbolsTrades';
            } else if (market['swap'] || market['future']) {
                method = 'publicContractGetTrades';
                request['contractID'] = market['id'];
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"222d74c0-8f6d-49d9-8e1b-98118c50eeba",
            //         "data":{
            //             "trades":[
            //                 {
            //                     "amount":"0.005703",
            //                     "order_time":1599652045394,
            //                     "price":"0.034029",
            //                     "count":"0.1676",
            //                     "type":"sell"
            //                 },
            //             ]
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "errno":"OK",
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"782bc746-b86e-43bf-8d1a-c68b479c9bdd",
            //         "data":{
            //             "trades":[
            //                 {
            //                     "order_id":109159616160,
            //                     "trade_id":109159616197,
            //                     "contract_id":2,
            //                     "deal_price":"347.6",
            //                     "deal_vol":"5623",
            //                     "make_fee":"-5.8636644",
            //                     "take_fee":"9.772774",
            //                     "created_at":"2020-09-09T11:49:50.749170536Z",
            //                     "way":1,
            //                     "fluctuation":"0"
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const trades = this.safeValue (data, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            // spot
            //
            //     {
            //         "last_price":"0.034987",
            //         "timestamp":1598787420,
            //         "volume":"1.0198",
            //         "open":"0.035007",
            //         "close":"0.034987",
            //         "high":"0.035007",
            //         "low":"0.034986"
            //     }
            //
            // contract
            //
            //     {
            //         "low":"404.4",
            //         "high":"404.4",
            //         "open":"404.4",
            //         "close":"404.4",
            //         "last_price":"404.4",
            //         "avg_price":"404.4",
            //         "volume":"7670",
            //         "timestamp":1598758441,
            //         "rise_fall_rate":"0",
            //         "rise_fall_value":"0",
            //         "base_coin_volume":"76.7",
            //         "quote_coin_volume":"31017.48"
            //     }
            //
            // ws
            //
            //     [
            //         1631056350, // timestamp
            //         '46532.83', // oopen
            //         '46555.71', // high
            //         '46511.41', // low
            //         '46555.71', // close
            //         '0.25', // volume
            //     ]
            //
            if (Array.isArray (ohlcv)) {
                return [
                    this.safeTimestamp (ohlcv, 0),
                    this.safeNumber (ohlcv, 1),
                    this.safeNumber (ohlcv, 2),
                    this.safeNumber (ohlcv, 3),
                    this.safeNumber (ohlcv, 4),
                    this.safeNumber (ohlcv, 5),
                ];
            } else {
                return [
                    this.safeTimestamp (ohlcv, 'timestamp'),
                    this.safeNumber (ohlcv, 'open'),
                    this.safeNumber (ohlcv, 'high'),
                    this.safeNumber (ohlcv, 'low'),
                    this.safeNumber (ohlcv, 'close'),
                    this.safeNumber (ohlcv, 'volume'),
                ];
            }
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const type = market['type'];
            let method = undefined;
            const request = {};
            const duration = this.parseTimeframe (timeframe);
            if (type === 'spot') {
                method = 'publicSpotGetSymbolsKline';
                request['symbol'] = market['id'];
                request['step'] = this.timeframes[timeframe];
                // the exchange will return an empty array if more than 500 candles is requested
                const maxLimit = 500;
                if (limit === undefined) {
                    limit = maxLimit;
                }
                limit = Math.min (maxLimit, limit);
                if (since === undefined) {
                    const end = parseInt (this.milliseconds () / 1000);
                    const start = end - limit * duration;
                    request['from'] = start;
                    request['to'] = end;
                } else {
                    const start = parseInt (since / 1000);
                    const end = this.sum (start, limit * duration);
                    request['from'] = start;
                    request['to'] = end;
                }
            } else if ((type === 'swap') || (type === 'future')) {
                method = 'publicContractGetQuote';
                request['contractID'] = market['id'];
                const defaultLimit = 500;
                if (limit === undefined) {
                    limit = defaultLimit;
                }
                if (since === undefined) {
                    const end = parseInt (this.milliseconds () / 1000);
                    const start = end - limit * duration;
                    request['startTime'] = start;
                    request['endTime'] = end;
                } else {
                    const start = parseInt (since / 1000);
                    const end = this.sum (start, limit * duration);
                    request['startTime'] = start;
                    request['endTime'] = end;
                }
                request['unit'] = this.timeframes[timeframe];
                request['resolution'] = 'M';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"80d86378-ab4e-4c70-819e-b42146cf87ad",
            //         "data":{
            //             "klines":[
            //                 {"last_price":"0.034987","timestamp":1598787420,"volume":"1.0198","open":"0.035007","close":"0.034987","high":"0.035007","low":"0.034986"},
            //                 {"last_price":"0.034986","timestamp":1598787480,"volume":"0.3959","open":"0.034982","close":"0.034986","high":"0.034986","low":"0.034980"},
            //                 {"last_price":"0.034978","timestamp":1598787540,"volume":"0.3259","open":"0.034987","close":"0.034978","high":"0.034987","low":"0.034977"},
            //             ]
            //         }
            //     }
            //
            // swap
            //
            //     {
            //         "errno":"OK",
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"32965074-5804-4655-b693-e953e36026a0",
            //         "data":[
            //             {"low":"404.4","high":"404.4","open":"404.4","close":"404.4","last_price":"404.4","avg_price":"404.4","volume":"7670","timestamp":1598758441,"rise_fall_rate":"0","rise_fall_value":"0","base_coin_volume":"76.7","quote_coin_volume":"31017.48"},
            //             {"low":"404.1","high":"404.4","open":"404.4","close":"404.1","last_price":"404.1","avg_price":"404.15881086","volume":"12076","timestamp":1598758501,"rise_fall_rate":"-0.000741839762611276","rise_fall_value":"-0.3","base_coin_volume":"120.76","quote_coin_volume":"48806.2179994536"},
            //             {"low":"404","high":"404.3","open":"404.1","close":"404","last_price":"404","avg_price":"404.08918918","volume":"740","timestamp":1598758561,"rise_fall_rate":"-0.000247463499133878","rise_fall_value":"-0.1","base_coin_volume":"7.4","quote_coin_volume":"2990.259999932"},
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            if (Array.isArray (data)) {
                return this.parseOHLCVs (data, market, timeframe, since, limit);
            } else {
                const klines = this.safeValue (data, 'klines', []);
                return this.parseOHLCVs (klines, market, timeframe, since, limit);
            }
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            let method = undefined;
            const request = {};
            if (market['spot']) {
                request['symbol'] = market['id'];
                request['offset'] = 1; // max offset * limit < 500
                if (limit === undefined) {
                    limit = 100; // max 100
                }
                request['limit'] = limit;
                method = 'privateSpotGetTrades';
            } else if (market['swap'] || market['future']) {
                request['contractID'] = market['id'];
                // request['offset'] = 1;
                if (limit !== undefined) {
                    request['size'] = limit; // max 60
                }
                method = 'privateContractGetUserTrades';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a06a5c53-8e6f-42d6-8082-2ff4718d221c",
            //         "data":{
            //             "current_page":1,
            //             "trades":[
            //                 {
            //                     "detail_id":256348632,
            //                     "order_id":2147484350,
            //                     "symbol":"BTC_USDT",
            //                     "create_time":1590462303000,
            //                     "side":"buy",
            //                     "fees":"0.00001350",
            //                     "fee_coin_name":"BTC",
            //                     "notional":"88.00000000",
            //                     "price_avg":"8800.00",
            //                     "size":"0.01000",
            //                     "exec_type":"M"
            //                 },
            //             ]
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "trades": [
            //                 {
            //                     "order_id": 10116361,
            //                     "trade_id": 10116363,
            //                     "contract_id": 1,
            //                     "deal_price": "16",
            //                     "deal_vol": "10",
            //                     "make_fee": "0.04",
            //                     "take_fee": "0.12",
            //                     "created_at": null,
            //                     "way": 5,
            //                     "fluctuation": "0"
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const trades = this.safeValue (data, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrderTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            let method = undefined;
            const request = {};
            if (market['spot']) {
                request['symbol'] = market['id'];
                request['order_id'] = id;
                method = 'privateSpotGetTrades';
            } else if (market['swap'] || market['future']) {
                request['contractID'] = market['id'];
                request['orderID'] = id;
                method = 'privateContractGetOrderTrades';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a06a5c53-8e6f-42d6-8082-2ff4718d221c",
            //         "data":{
            //             "current_page":1,
            //             "trades":[
            //                 {
            //                     "detail_id":256348632,
            //                     "order_id":2147484350,
            //                     "symbol":"BTC_USDT",
            //                     "create_time":1590462303000,
            //                     "side":"buy",
            //                     "fees":"0.00001350",
            //                     "fee_coin_name":"BTC",
            //                     "notional":"88.00000000",
            //                     "price_avg":"8800.00",
            //                     "size":"0.01000",
            //                     "exec_type":"M"
            //                 },
            //             ]
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "trades": [
            //                 {
            //                     "order_id": 10116361,
            //                     "trade_id": 10116363,
            //                     "contract_id": 1,
            //                     "deal_price": "16",
            //                     "deal_vol": "10",
            //                     "make_fee": "0.04",
            //                     "take_fee": "0.12",
            //                     "created_at": null,
            //                     "way": 5,
            //                     "fluctuation": "0"
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const trades = this.safeValue (data, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            let method = undefined;
            const options = this.safeValue (this.options, 'fetchBalance', {});
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            let type = this.safeString (options, 'type', defaultType);
            type = this.safeString (params, 'type', type);
            params = this.omit (params, 'type');
            if (type === 'spot') {
                method = 'privateSpotGetWallet';
            } else if (type === 'account') {
                method = 'privateAccountGetWallet';
            } else if ((type === 'swap') || (type === 'future') || (type === 'contract')) {
                method = 'privateContractGetAccounts';
            }
            const response = await this[method] (params);
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"39069916-72f9-44c7-acde-2ad5afd21cad",
            //         "data":{
            //             "wallet":[
            //                 {"id":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
            //                 {"id":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"},
            //                 {"id":"BMX","name":"BitMart Token","available":"0.00000000","frozen":"0.00000000"}
            //             ]
            //         }
            //     }
            //
            // account
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"5c3b7fc7-93b2-49ef-bb59-7fdc56915b59",
            //         "data":{
            //             "wallet":[
            //                 {"currency":"BTC","name":"Bitcoin","available":"0.00000062","frozen":"0.00000000"},
            //                 {"currency":"ETH","name":"Ethereum","available":"0.00002277","frozen":"0.00000000"}
            //             ]
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "accounts": [
            //                 {
            //                     "account_id": 10,
            //                     "coin_code": "USDT",
            //                     "freeze_vol": "1201.8",
            //                     "available_vol": "8397.65",
            //                     "cash_vol": "0",
            //                     "realised_vol": "-0.5",
            //                     "unrealised_vol": "-0.5",
            //                     "earnings_vol": "-0.5",
            //                     "created_at": "2018-07-13T16:48:49+08:00",
            //                     "updated_at": "2018-07-13T18:34:45.900387+08:00"
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const wallet = this.safeValue2 (data, 'wallet', 'accounts', []);
            const result = { 'info': response };
            for (let i = 0; i < wallet.length; i++) {
                const balance = wallet[i];
                let currencyId = this.safeString2 (balance, 'id', 'currency');
                currencyId = this.safeString (balance, 'coin_code', currencyId);
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString2 (balance, 'available', 'available_vol');
                account['used'] = this.safeString2 (balance, 'frozen', 'freeze_vol');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "order_id": 2707217580
            //     }
            //
            // cancelOrder
            //
            //     '2707217580' // order id
            //
            // spot fetchOrder, fetchOrdersByStatus, fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "order_id":1736871726781,
            //         "symbol":"BTC_USDT",
            //         "create_time":1591096004000,
            //         "side":"sell",
            //         "type":"market",
            //         "price":"0.00",
            //         "price_avg":"0.00",
            //         "size":"0.02000",
            //         "notional":"0.00000000",
            //         "filled_notional":"0.00000000",
            //         "filled_size":"0.00000",
            //         "status":"8"
            //     }
            //
            // contract fetchOrder, fetchOrdersByStatus, fetchOpenOrders, fetchClosedOrders, fetchOrders
            //
            //     {
            //         "order_id": 10539098,
            //         "contract_id": 1,
            //         "position_id": 10539088,
            //         "account_id": 10,
            //         "price": "16",
            //         "vol": "1",
            //         "done_avg_price": "16",
            //         "done_vol": "1",
            //         "way": 3,
            //         "category": 1,
            //         "open_type": 2,
            //         "make_fee": "0.00025",
            //         "take_fee": "0.012",
            //         "origin": "",
            //         "created_at": "2018-07-23T11:55:56.715305Z",
            //         "finished_at": "2018-07-23T11:55:56.763941Z",
            //         "status": 4,
            //         "errno": 0
            //     }
            //
            let id = undefined;
            if (typeof order === 'string') {
                id = order;
                order = {};
            }
            id = this.safeString (order, 'order_id', id);
            let timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            timestamp = this.safeInteger (order, 'create_time', timestamp);
            const marketId = this.safeString2 (order, 'symbol', 'contract_id');
            const symbol = this.safeSymbol (marketId, market, '_');
            let status = undefined;
            if (market !== undefined) {
                status = this.parseOrderStatusByType (market['type'], this.safeString (order, 'status'));
            }
            let price = this.safeNumber (order, 'price');
            let average = this.safeNumber2 (order, 'price_avg', 'done_avg_price');
            const amount = this.safeNumber2 (order, 'size', 'vol');
            const filled = this.safeNumber2 (order, 'filled_size', 'done_vol');
            let side = this.safeString (order, 'side');
            // 1 = Open long
            // 2 = Close short
            // 3 = Close long
            // 4 = Open short
            side = this.safeString (order, 'way', side);
            const category = this.safeInteger (order, 'category');
            let type = this.safeString (order, 'type');
            if (category === 1) {
                type = 'limit';
            } else if (category === 2) {
                type = 'market';
            }
            if (type === 'market') {
                if (price === 0.0) {
                    price = undefined;
                }
                if (average === 0.0) {
                    average = undefined;
                }
            }
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        parseOrderStatusByType (type, status) {
            const statusesByType = {
                'spot': {
                    '1': 'failed', // Order failure
                    '2': 'open', // Placing order
                    '3': 'failed', // Order failure, Freeze failure
                    '4': 'open', // Order success, Pending for fulfilment
                    '5': 'open', // Partially filled
                    '6': 'closed', // Fully filled
                    '7': 'canceling', // Canceling
                    '8': 'canceled', // Canceled
                },
                'swap': {
                    '1': 'open', // Submitting
                    '2': 'open', // Commissioned
                    '4': 'closed', // Completed
                },
            };
            const statuses = this.safeValue (statusesByType, type, {});
            return this.safeString (statuses, status, status);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            let method = undefined;
            if (market['spot']) {
                request['symbol'] = market['id'];
                request['side'] = side;
                request['type'] = type;
                method = 'privateSpotPostSubmitOrder';
                if (type === 'limit') {
                    request['size'] = this.amountToPrecision (symbol, amount);
                    request['price'] = this.priceToPrecision (symbol, price);
                } else if (type === 'market') {
                    // for market buy it requires the amount of quote currency to spend
                    if (side === 'buy') {
                        let notional = this.safeNumber (params, 'notional');
                        const createMarketBuyOrderRequiresPrice = this.safeValue (this.options, 'createMarketBuyOrderRequiresPrice', true);
                        if (createMarketBuyOrderRequiresPrice) {
                            if (price !== undefined) {
                                if (notional === undefined) {
                                    notional = amount * price;
                                }
                            } else if (notional === undefined) {
                                throw new InvalidOrder (this.id + " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument or in the 'notional' extra parameter (the exchange-specific behaviour)");
                            }
                        } else {
                            notional = (notional === undefined) ? amount : notional;
                        }
                        const precision = market['precision']['price'];
                        request['notional'] = this.decimalToPrecision (notional, TRUNCATE, precision, this.precisionMode);
                    } else if (side === 'sell') {
                        request['size'] = this.amountToPrecision (symbol, amount);
                    }
                }
            } else if (market['swap'] || market['future']) {
                method = 'privateContractPostSubmitOrder';
                request['contractID'] = market['id'];
                if (type === 'limit') {
                    request['category'] = 1;
                } else if (type === 'market') {
                    request['category'] = 2;
                }
                request['way'] = side; // 1 = open long, 2 = close short, 3 = close long, 4 = open short
                request['custom_id'] = this.nonce ();
                request['open_type'] = 1; // 1 = cross margin, 2 = fixed margin
                request['leverage'] = 1; // must meet the effective range of leverage configured in the contract
                request['price'] = this.priceToPrecision (symbol, price);
                request['vol'] = this.amountToPrecision (symbol, amount);
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot and contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "order_id": 2707217580
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            let method = undefined;
            if (market['spot']) {
                method = 'privateSpotPostCancelOrder';
                request['order_id'] = parseInt (id);
                request['symbol'] = market['id'];
            } else if (market['swap'] || market['future']) {
                method = 'privateContractPostCancelOrders';
                request['contractID'] = market['id'];
                request['orders'] = [ parseInt (id) ];
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "result": true
            //         }
            //     }
            //
            // spot alternative
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": true
            //     }
            //
            // contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "succeed": [
            //                 2707219612
            //             ],
            //             "failed": []
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data');
            if (data === true) {
                return this.parseOrder (id, market);
            }
            const succeeded = this.safeValue (data, 'succeed');
            if (succeeded !== undefined) {
                id = this.safeString (succeeded, 0);
                if (id === undefined) {
                    throw new InvalidOrder (this.id + ' cancelOrder() failed to cancel ' + symbol + ' order id ' + id);
                }
            } else {
                const result = this.safeValue (data, 'result');
                if (!result) {
                    throw new InvalidOrder (this.id + ' cancelOrder() ' + symbol + ' order id ' + id + ' is filled or canceled');
                }
            }
            const order = this.parseOrder (id, market);
            return this.extend (order, { 'id': id });
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelAllOrders() requires a symbol argument');
            }
            const side = this.safeString (params, 'side');
            if (side === undefined) {
                throw new ArgumentsRequired (this.id + " cancelAllOrders() requires a `side` parameter ('buy' or 'sell')");
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (!market['spot']) {
                throw new NotSupported (this.id + ' cancelAllOrders() does not support ' + market['type'] + ' orders, only spot orders are accepted');
            }
            const request = {
                'symbol': market['id'],
                'side': side, // 'buy' or 'sell'
            };
            const response = await this.privateSpotPostCancelOrders (this.extend (request, params));
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {}
            //     }
            //
            return response;
        }
    
        async cancelOrders (ids, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' canelOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (!market['spot']) {
                throw new NotSupported (this.id + ' cancelOrders() does not support ' + market['type'] + ' orders, only contract orders are accepted');
            }
            const orders = [];
            for (let i = 0; i < ids.length; i++) {
                orders.push (parseInt (ids[i]));
            }
            const request = {
                'orders': orders,
            };
            const response = await this.privateContractPostCancelOrders (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "result": true
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "succeed": [
            //                 2707219612
            //             ],
            //             "failed": []
            //         }
            //     }
            //
            return response;
        }
    
        async fetchOrdersByStatus (status, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrdersByStatus() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            let method = undefined;
            if (market['spot']) {
                method = 'privateSpotGetOrders';
                request['symbol'] = market['id'];
                request['offset'] = 1; // max offset * limit < 500
                request['limit'] = 100; // max limit is 100
                //  1 = Order failure
                //  2 = Placing order
                //  3 = Order failure, Freeze failure
                //  4 = Order success, Pending for fulfilment
                //  5 = Partially filled
                //  6 = Fully filled
                //  7 = Canceling
                //  8 = Canceled
                //  9 = Outstanding (4 and 5)
                // 10 = 6 and 8
                if (status === 'open') {
                    request['status'] = 9;
                } else if (status === 'closed') {
                    request['status'] = 6;
                } else {
                    request['status'] = status;
                }
            } else if (market['swap'] || market['future']) {
                method = 'privateContractGetUserOrders';
                request['contractID'] = market['id'];
                // request['offset'] = 1;
                if (limit !== undefined) {
                    request['size'] = limit; // max 60
                }
                // 0 = All
                // 1 = Submitting
                // 2 = Commissioned
                // 3 = 1 and 2
                // 4 = Completed
                if (status === 'open') {
                    request['status'] = 3;
                } else if (status === 'closed') {
                    request['status'] = 4;
                } else {
                    request['status'] = status;
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"70e7d427-7436-4fb8-8cdd-97e1f5eadbe9",
            //         "data":{
            //             "current_page":1,
            //             "orders":[
            //                 {
            //                     "order_id":2147601241,
            //                     "symbol":"BTC_USDT",
            //                     "create_time":1591099963000,
            //                     "side":"sell",
            //                     "type":"limit",
            //                     "price":"9000.00",
            //                     "price_avg":"0.00",
            //                     "size":"1.00000",
            //                     "notional":"9000.00000000",
            //                     "filled_notional":"0.00000000",
            //                     "filled_size":"0.00000",
            //                     "status":"4"
            //                 }
            //             ]
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "orders": [
            //                 {
            //                     "order_id": 10284160,
            //                     "contract_id": 1,
            //                     "price": "8",
            //                     "vol": "4",
            //                     "done_avg_price": "0",
            //                     "done_vol": "0",
            //                     "way": 1,
            //                     "category": 1,
            //                     "open_type": 2,
            //                     "make_fee": "0",
            //                     "take_fee": "0",
            //                     "origin": "",
            //                     "created_at": "2018-07-17T07:24:13.410507Z",
            //                     "finished_at": null,
            //                     "status": 2,
            //                     "errno": 0
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const orders = this.safeValue (data, 'orders', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStatus ('open', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStatus ('closed', symbol, since, limit, params);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (!(market['swap'] || market['future'])) {
                throw new NotSupported (this.id + ' fetchOrders does not support ' + market['type'] + ' markets, only contracts are supported');
            }
            return await this.fetchOrdersByStatus (0, symbol, since, limit, params);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const request = {};
            const market = this.market (symbol);
            let method = undefined;
            if (typeof id !== 'string') {
                id = id.toString ();
            }
            if (market['spot']) {
                request['symbol'] = market['id'];
                request['order_id'] = id;
                method = 'privateSpotGetOrderDetail';
            } else if (market['swap'] || market['future']) {
                request['contractID'] = market['id'];
                request['orderID'] = id;
                method = 'privateContractGetUserOrderInfo';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // spot
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"a27c2cb5-ead4-471d-8455-1cfeda054ea6",
            //         "data": {
            //             "order_id":1736871726781,
            //             "symbol":"BTC_USDT",
            //             "create_time":1591096004000,
            //             "side":"sell",
            //             "type":"market",
            //             "price":"0.00",
            //             "price_avg":"0.00",
            //             "size":"0.02000",
            //             "notional":"0.00000000",
            //             "filled_notional":"0.00000000",
            //             "filled_size":"0.00000",
            //             "status":"8"
            //         }
            //     }
            //
            // contract
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "orders": [
            //                 {
            //                     "order_id": 10539098,
            //                     "contract_id": 1,
            //                     "position_id": 10539088,
            //                     "account_id": 10,
            //                     "price": "16",
            //                     "vol": "1",
            //                     "done_avg_price": "16",
            //                     "done_vol": "1",
            //                     "way": 3,
            //                     "category": 1,
            //                     "make_fee": "0.00025",
            //                     "take_fee": "0.012",
            //                     "origin": "",
            //                     "created_at": "2018-07-23T11:55:56.715305Z",
            //                     "finished_at": "2018-07-23T11:55:56.763941Z",
            //                     "status": 4,
            //                     "errno": 0
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data');
            if ('orders' in data) {
                const orders = this.safeValue (data, 'orders', []);
                const firstOrder = this.safeValue (orders, 0);
                if (firstOrder === undefined) {
                    throw new OrderNotFound (this.id + ' fetchOrder() could not find ' + symbol + ' order id ' + id);
                }
                return this.parseOrder (firstOrder, market);
            } else {
                return this.parseOrder (data, market);
            }
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateAccountGetDepositAddress (this.extend (request, params));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"0e6edd79-f77f-4251-abe5-83ba75d06c1a",
            //         "data":{
            //             "currency":"USDT-TRC20",
            //             "chain":"USDT-TRC20",
            //             "address":"TGR3ghy2b5VLbyAYrmiE15jasR6aPHTvC5",
            //             "address_memo":""
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const address = this.safeString (data, 'address');
            const tag = this.safeString (data, 'address_memo');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'amount': amount,
                'destination': 'To Digital Address', // To Digital Address, To Binance, To OKEX
                'address': address,
            };
            if (tag !== undefined) {
                request['address_memo'] = tag;
            }
            const response = await this.privateAccountPostWithdrawApply (this.extend (request, params));
            //
            //     {
            //         "code": 1000,
            //         "trace":"886fb6ae-456b-4654-b4e0-d681ac05cea1",
            //         "message": "OK",
            //         "data": {
            //             "withdraw_id": "121212"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data');
            const transaction = this.parseTransaction (data, currency);
            return this.extend (transaction, {
                'code': code,
                'address': address,
                'tag': tag,
            });
        }
    
        async fetchTransactionsByType (type, code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (limit === undefined) {
                limit = 50; // max 50
            }
            const request = {
                'operation_type': type, // deposit or withdraw
                'offset': 1,
                'limit': limit,
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currenc (code);
                request['currency'] = currency['id'];
            }
            const response = await this.privateAccountGetDepositWithdrawHistory (this.extend (request, params));
            //
            //     {
            //         "message":"OK",
            //         "code":1000,
            //         "trace":"142bf92a-fc50-4689-92b6-590886f90b97",
            //         "data":{
            //             "records":[
            //                 {
            //                     "withdraw_id":"1679952",
            //                     "deposit_id":"",
            //                     "operation_type":"withdraw",
            //                     "currency":"BMX",
            //                     "apply_time":1588867374000,
            //                     "arrival_amount":"59.000000000000",
            //                     "fee":"1.000000000000",
            //                     "status":0,
            //                     "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //                     "address_memo":"",
            //                     "tx_id":""
            //                 },
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const records = this.safeValue (data, 'records', []);
            return this.parseTransactions (records, currency, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsByType ('deposit', code, since, limit, params);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsByType ('withdraw', code, since, limit, params);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                '0': 'pending', // Create
                '1': 'pending', // Submitted, waiting for withdrawal
                '2': 'pending', // Processing
                '3': 'ok', // Success
                '4': 'canceled', // Cancel
                '5': 'failed', // Fail
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // withdraw
            //
            //     {
            //         "withdraw_id": "121212"
            //     }
            //
            // fetchDeposits, fetchWithdrawals
            //
            //     {
            //         "withdraw_id":"1679952",
            //         "deposit_id":"",
            //         "operation_type":"withdraw",
            //         "currency":"BMX",
            //         "apply_time":1588867374000,
            //         "arrival_amount":"59.000000000000",
            //         "fee":"1.000000000000",
            //         "status":0,
            //         "address":"0xe57b69a8776b37860407965B73cdFFBDFe668Bb5",
            //         "address_memo":"",
            //         "tx_id":""
            //     }
            //
            let id = undefined;
            const withdrawId = this.safeString (transaction, 'withdraw_id');
            const depositId = this.safeString (transaction, 'deposit_id');
            let type = undefined;
            if ((withdrawId !== undefined) && (withdrawId !== '')) {
                type = 'withdraw';
                id = withdrawId;
            } else if ((depositId !== undefined) && (depositId !== '')) {
                type = 'deposit';
                id = depositId;
            }
            const amount = this.safeNumber (transaction, 'arrival_amount');
            const timestamp = this.safeInteger (transaction, 'apply_time');
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const feeCost = this.safeNumber (transaction, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': code,
                };
            }
            let txid = this.safeString (transaction, 'tx_id');
            if (txid === '') {
                txid = undefined;
            }
            const address = this.safeString (transaction, 'address');
            const tag = this.safeString (transaction, 'address_memo');
            return {
                'info': transaction,
                'id': id,
                'currency': code,
                'amount': amount,
                'address': address,
                'addressFrom': undefined,
                'addressTo': undefined,
                'tag': tag,
                'tagFrom': undefined,
                'tagTo': undefined,
                'status': status,
                'type': type,
                'updated': undefined,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': fee,
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const access = this.safeString (api, 0);
            const type = this.safeString (api, 1);
            const baseUrl = this.implodeHostname (this.urls['api']['rest']);
            let url = baseUrl + '/' + type;
            if (type !== 'system') {
                url += '/' + this.version;
            }
            if (type === 'contract') {
                url += '/' + 'ifcontract';
            }
            url += '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (type === 'system') {
                if (Object.keys (query).length) {
                    // console.log (query);
                    url += '?' + this.urlencode (query);
                }
            } else if (access === 'public') {
                if (Object.keys (query).length) {
                    // console.log (query);
                    url += '?' + this.urlencode (query);
                }
            } else if (access === 'private') {
                this.checkRequiredCredentials ();
                const timestamp = this.milliseconds ().toString ();
                let queryString = '';
                headers = {
                    'X-BM-KEY': this.apiKey,
                    'X-BM-TIMESTAMP': timestamp,
                };
                if ((method === 'POST') || (method === 'PUT')) {
                    headers['Content-Type'] = 'application/json';
                    body = this.json (query);
                    queryString = body;
                } else {
                    if (Object.keys (query).length) {
                        queryString = this.urlencode (query);
                        url += '?' + queryString;
                    }
                }
                const auth = timestamp + '#' + this.uid + '#' + queryString;
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                headers['X-BM-SIGN'] = signature;
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            //
            // spot
            //
            //     {"message":"Bad Request [to is empty]","code":50000,"trace":"f9d46e1b-4edb-4d07-a06e-4895fb2fc8fc","data":{}}
            //     {"message":"Bad Request [from is empty]","code":50000,"trace":"579986f7-c93a-4559-926b-06ba9fa79d76","data":{}}
            //     {"message":"Kline size over 500","code":50004,"trace":"d625caa8-e8ca-4bd2-b77c-958776965819","data":{}}
            //     {"message":"Balance not enough","code":50020,"trace":"7c709d6a-3292-462c-98c5-32362540aeef","data":{}}
            //
            // contract
            //
            //     {"errno":"OK","message":"INVALID_PARAMETER","code":49998,"trace":"eb5ebb54-23cd-4de2-9064-e090b6c3b2e3","data":null}
            //
            const message = this.safeString (response, 'message');
            const errorCode = this.safeString (response, 'code');
            if (((errorCode !== undefined) && (errorCode !== '1000')) || ((message !== undefined) && (message !== 'OK'))) {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], errorCode, feedback);
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/errors":9,"./base/functions/number":15}],40:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { TICK_SIZE } = require ('./base/functions/number');
    const { AuthenticationError, BadRequest, DDoSProtection, ExchangeError, ExchangeNotAvailable, InsufficientFunds, InvalidOrder, OrderNotFound, PermissionDenied, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitmex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitmex',
                'name': 'BitMEX',
                'countries': [ 'SC' ], // Seychelles
                'version': 'v1',
                'userAgent': undefined,
                'rateLimit': 2000,
                'pro': true,
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchLedger': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTransactions': 'emulated',
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '1h': '1h',
                    '1d': '1d',
                },
                'urls': {
                    'test': {
                        'public': 'https://testnet.bitmex.com',
                        'private': 'https://testnet.bitmex.com',
                    },
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766319-f653c6e6-5ed4-11e7-933d-f0bc3699ae8f.jpg',
                    'api': {
                        'public': 'https://www.bitmex.com',
                        'private': 'https://www.bitmex.com',
                    },
                    'www': 'https://www.bitmex.com',
                    'doc': [
                        'https://www.bitmex.com/app/apiOverview',
                        'https://github.com/BitMEX/api-connectors/tree/master/official-http',
                    ],
                    'fees': 'https://www.bitmex.com/app/fees',
                    'referral': 'https://www.bitmex.com/register/upZpOX',
                },
                'api': {
                    'public': {
                        'get': [
                            'announcement',
                            'announcement/urgent',
                            'funding',
                            'instrument',
                            'instrument/active',
                            'instrument/activeAndIndices',
                            'instrument/activeIntervals',
                            'instrument/compositeIndex',
                            'instrument/indices',
                            'insurance',
                            'leaderboard',
                            'liquidation',
                            'orderBook',
                            'orderBook/L2',
                            'quote',
                            'quote/bucketed',
                            'schema',
                            'schema/websocketHelp',
                            'settlement',
                            'stats',
                            'stats/history',
                            'trade',
                            'trade/bucketed',
                        ],
                    },
                    'private': {
                        'get': [
                            'apiKey',
                            'chat',
                            'chat/channels',
                            'chat/connected',
                            'execution',
                            'execution/tradeHistory',
                            'notification',
                            'order',
                            'position',
                            'user',
                            'user/affiliateStatus',
                            'user/checkReferralCode',
                            'user/commission',
                            'user/depositAddress',
                            'user/executionHistory',
                            'user/margin',
                            'user/minWithdrawalFee',
                            'user/wallet',
                            'user/walletHistory',
                            'user/walletSummary',
                        ],
                        'post': [
                            'apiKey',
                            'apiKey/disable',
                            'apiKey/enable',
                            'chat',
                            'order',
                            'order/bulk',
                            'order/cancelAllAfter',
                            'order/closePosition',
                            'position/isolate',
                            'position/leverage',
                            'position/riskLimit',
                            'position/transferMargin',
                            'user/cancelWithdrawal',
                            'user/confirmEmail',
                            'user/confirmEnableTFA',
                            'user/confirmWithdrawal',
                            'user/disableTFA',
                            'user/logout',
                            'user/logoutAll',
                            'user/preferences',
                            'user/requestEnableTFA',
                            'user/requestWithdrawal',
                        ],
                        'put': [
                            'order',
                            'order/bulk',
                            'user',
                        ],
                        'delete': [
                            'apiKey',
                            'order',
                            'order/all',
                        ],
                    },
                },
                'exceptions': {
                    'exact': {
                        'Invalid API Key.': AuthenticationError,
                        'This key is disabled.': PermissionDenied,
                        'Access Denied': PermissionDenied,
                        'Duplicate clOrdID': InvalidOrder,
                        'orderQty is invalid': InvalidOrder,
                        'Invalid price': InvalidOrder,
                        'Invalid stopPx for ordType': InvalidOrder,
                    },
                    'broad': {
                        'Signature not valid': AuthenticationError,
                        'overloaded': ExchangeNotAvailable,
                        'Account has insufficient Available Balance': InsufficientFunds,
                        'Service unavailable': ExchangeNotAvailable, // {"error":{"message":"Service unavailable","name":"HTTPError"}}
                        'Server Error': ExchangeError, // {"error":{"message":"Server Error","name":"HTTPError"}}
                        'Unable to cancel order due to existing state': InvalidOrder,
                    },
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    // https://blog.bitmex.com/api_announcement/deprecation-of-api-nonce-header/
                    // https://github.com/ccxt/ccxt/issues/4789
                    'api-expires': 5, // in seconds
                    'fetchOHLCVOpenTimestamp': true,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetInstrumentActiveAndIndices (params);
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const active = (market['state'] !== 'Unlisted');
                const id = market['symbol'];
                const baseId = market['underlying'];
                const quoteId = market['quoteCurrency'];
                const basequote = baseId + quoteId;
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const swap = (id === basequote);
                // 'positionCurrency' may be empty ("", as Bitmex currently returns for ETHUSD)
                // so let's take the quote currency first and then adjust if needed
                const positionId = this.safeString2 (market, 'positionCurrency', 'quoteCurrency');
                let type = undefined;
                let future = false;
                let prediction = false;
                const position = this.safeCurrencyCode (positionId);
                let symbol = id;
                if (swap) {
                    type = 'swap';
                    symbol = base + '/' + quote;
                } else if (id.indexOf ('B_') >= 0) {
                    prediction = true;
                    type = 'prediction';
                } else {
                    future = true;
                    type = 'future';
                }
                const precision = {
                    'amount': undefined,
                    'price': undefined,
                };
                const lotSize = this.safeNumber (market, 'lotSize');
                const tickSize = this.safeNumber (market, 'tickSize');
                if (lotSize !== undefined) {
                    precision['amount'] = lotSize;
                }
                if (tickSize !== undefined) {
                    precision['price'] = tickSize;
                }
                const limits = {
                    'amount': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'price': {
                        'min': tickSize,
                        'max': this.safeNumber (market, 'maxPrice'),
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                const limitField = (position === quote) ? 'cost' : 'amount';
                limits[limitField] = {
                    'min': lotSize,
                    'max': this.safeNumber (market, 'maxOrderQty'),
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'precision': precision,
                    'limits': limits,
                    'taker': this.safeNumber (market, 'takerFee'),
                    'maker': this.safeNumber (market, 'makerFee'),
                    'type': type,
                    'spot': false,
                    'swap': swap,
                    'future': future,
                    'prediction': prediction,
                    'info': market,
                });
            }
            return result;
        }
    
        parseBalanceResponse (response) {
            //
            //     [
            //         {
            //             "account":1455728,
            //             "currency":"XBt",
            //             "riskLimit":1000000000000,
            //             "prevState":"",
            //             "state":"",
            //             "action":"",
            //             "amount":263542,
            //             "pendingCredit":0,
            //             "pendingDebit":0,
            //             "confirmedDebit":0,
            //             "prevRealisedPnl":0,
            //             "prevUnrealisedPnl":0,
            //             "grossComm":0,
            //             "grossOpenCost":0,
            //             "grossOpenPremium":0,
            //             "grossExecCost":0,
            //             "grossMarkValue":0,
            //             "riskValue":0,
            //             "taxableMargin":0,
            //             "initMargin":0,
            //             "maintMargin":0,
            //             "sessionMargin":0,
            //             "targetExcessMargin":0,
            //             "varMargin":0,
            //             "realisedPnl":0,
            //             "unrealisedPnl":0,
            //             "indicativeTax":0,
            //             "unrealisedProfit":0,
            //             "syntheticMargin":null,
            //             "walletBalance":263542,
            //             "marginBalance":263542,
            //             "marginBalancePcnt":1,
            //             "marginLeverage":0,
            //             "marginUsedPcnt":0,
            //             "excessMargin":263542,
            //             "excessMarginPcnt":1,
            //             "availableMargin":263542,
            //             "withdrawableMargin":263542,
            //             "timestamp":"2020-08-03T12:01:01.246Z",
            //             "grossLastValue":0,
            //             "commission":null
            //         }
            //     ]
            //
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                let free = this.safeString (balance, 'availableMargin');
                let total = this.safeString (balance, 'marginBalance');
                if (code === 'BTC') {
                    free = Precise.stringDiv (free, '1e8');
                    total = Precise.stringDiv (total, '1e8');
                }
                account['free'] = free;
                account['total'] = total;
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const request = {
                'currency': 'all',
            };
            const response = await this.privateGetUserMargin (this.extend (request, params));
            //
            //     [
            //         {
            //             "account":1455728,
            //             "currency":"XBt",
            //             "riskLimit":1000000000000,
            //             "prevState":"",
            //             "state":"",
            //             "action":"",
            //             "amount":263542,
            //             "pendingCredit":0,
            //             "pendingDebit":0,
            //             "confirmedDebit":0,
            //             "prevRealisedPnl":0,
            //             "prevUnrealisedPnl":0,
            //             "grossComm":0,
            //             "grossOpenCost":0,
            //             "grossOpenPremium":0,
            //             "grossExecCost":0,
            //             "grossMarkValue":0,
            //             "riskValue":0,
            //             "taxableMargin":0,
            //             "initMargin":0,
            //             "maintMargin":0,
            //             "sessionMargin":0,
            //             "targetExcessMargin":0,
            //             "varMargin":0,
            //             "realisedPnl":0,
            //             "unrealisedPnl":0,
            //             "indicativeTax":0,
            //             "unrealisedProfit":0,
            //             "syntheticMargin":null,
            //             "walletBalance":263542,
            //             "marginBalance":263542,
            //             "marginBalancePcnt":1,
            //             "marginLeverage":0,
            //             "marginUsedPcnt":0,
            //             "excessMargin":263542,
            //             "excessMarginPcnt":1,
            //             "availableMargin":263542,
            //             "withdrawableMargin":263542,
            //             "timestamp":"2020-08-03T12:01:01.246Z",
            //             "grossLastValue":0,
            //             "commission":null
            //         }
            //     ]
            //
            return this.parseBalanceResponse (response);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['depth'] = limit;
            }
            const response = await this.publicGetOrderBookL2 (this.extend (request, params));
            const result = {
                'symbol': symbol,
                'bids': [],
                'asks': [],
                'timestamp': undefined,
                'datetime': undefined,
                'nonce': undefined,
            };
            for (let i = 0; i < response.length; i++) {
                const order = response[i];
                const side = (order['side'] === 'Sell') ? 'asks' : 'bids';
                const amount = this.safeNumber (order, 'size');
                const price = this.safeNumber (order, 'price');
                // https://github.com/ccxt/ccxt/issues/4926
                // https://github.com/ccxt/ccxt/issues/4927
                // the exchange sometimes returns null price in the orderbook
                if (price !== undefined) {
                    result[side].push ([ price, amount ]);
                }
            }
            result['bids'] = this.sortBy (result['bids'], 0, true);
            result['asks'] = this.sortBy (result['asks'], 0);
            return result;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            const filter = {
                'filter': {
                    'orderID': id,
                },
            };
            const response = await this.fetchOrders (symbol, undefined, undefined, this.deepExtend (filter, params));
            const numResults = response.length;
            if (numResults === 1) {
                return response[0];
            }
            throw new OrderNotFound (this.id + ': The order ' + id + ' not found.');
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            let request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['startTime'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['count'] = limit;
            }
            request = this.deepExtend (request, params);
            // why the hassle? urlencode in python is kinda broken for nested dicts.
            // E.g. self.urlencode({"filter": {"open": True}}) will return "filter={'open':+True}"
            // Bitmex doesn't like that. Hence resorting to this hack.
            if ('filter' in request) {
                request['filter'] = this.json (request['filter']);
            }
            const response = await this.privateGetOrder (request);
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'filter': {
                    'open': true,
                },
            };
            return await this.fetchOrders (symbol, since, limit, this.deepExtend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // Bitmex barfs if you set 'open': false in the filter...
            const orders = await this.fetchOrders (symbol, since, limit, params);
            return this.filterBy (orders, 'status', 'closed');
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            let request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['startTime'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['count'] = limit;
            }
            request = this.deepExtend (request, params);
            // why the hassle? urlencode in python is kinda broken for nested dicts.
            // E.g. self.urlencode({"filter": {"open": True}}) will return "filter={'open':+True}"
            // Bitmex doesn't like that. Hence resorting to this hack.
            if ('filter' in request) {
                request['filter'] = this.json (request['filter']);
            }
            const response = await this.privateGetExecutionTradeHistory (request);
            //
            //     [
            //         {
            //             "execID": "string",
            //             "orderID": "string",
            //             "clOrdID": "string",
            //             "clOrdLinkID": "string",
            //             "account": 0,
            //             "symbol": "string",
            //             "side": "string",
            //             "lastQty": 0,
            //             "lastPx": 0,
            //             "underlyingLastPx": 0,
            //             "lastMkt": "string",
            //             "lastLiquidityInd": "string",
            //             "simpleOrderQty": 0,
            //             "orderQty": 0,
            //             "price": 0,
            //             "displayQty": 0,
            //             "stopPx": 0,
            //             "pegOffsetValue": 0,
            //             "pegPriceType": "string",
            //             "currency": "string",
            //             "settlCurrency": "string",
            //             "execType": "string",
            //             "ordType": "string",
            //             "timeInForce": "string",
            //             "execInst": "string",
            //             "contingencyType": "string",
            //             "exDestination": "string",
            //             "ordStatus": "string",
            //             "triggered": "string",
            //             "workingIndicator": true,
            //             "ordRejReason": "string",
            //             "simpleLeavesQty": 0,
            //             "leavesQty": 0,
            //             "simpleCumQty": 0,
            //             "cumQty": 0,
            //             "avgPx": 0,
            //             "commission": 0,
            //             "tradePublishIndicator": "string",
            //             "multiLegReportingType": "string",
            //             "text": "string",
            //             "trdMatchID": "string",
            //             "execCost": 0,
            //             "execComm": 0,
            //             "homeNotional": 0,
            //             "foreignNotional": 0,
            //             "transactTime": "2019-03-05T12:47:02.762Z",
            //             "timestamp": "2019-03-05T12:47:02.762Z"
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'Withdrawal': 'transaction',
                'RealisedPNL': 'margin',
                'UnrealisedPNL': 'margin',
                'Deposit': 'transaction',
                'Transfer': 'transfer',
                'AffiliatePayout': 'referral',
            };
            return this.safeString (types, type, type);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //     {
            //         transactID: "69573da3-7744-5467-3207-89fd6efe7a47",
            //         account:  24321,
            //         currency: "XBt",
            //         transactType: "Withdrawal", // "AffiliatePayout", "Transfer", "Deposit", "RealisedPNL", ...
            //         amount:  -1000000,
            //         fee:  300000,
            //         transactStatus: "Completed", // "Canceled", ...
            //         address: "1Ex4fkF4NhQaQdRWNoYpqiPbDBbq18Kdd9",
            //         tx: "3BMEX91ZhhKoWtsH9QRb5dNXnmnGpiEetA",
            //         text: "",
            //         transactTime: "2017-03-21T20:05:14.388Z",
            //         walletBalance:  0, // balance after
            //         marginBalance:  null,
            //         timestamp: "2017-03-22T13:09:23.514Z"
            //     }
            //
            // ButMEX returns the unrealized pnl from the wallet history endpoint.
            // The unrealized pnl transaction has an empty timestamp.
            // It is not related to historical pnl it has status set to "Pending".
            // Therefore it's not a part of the history at all.
            // https://github.com/ccxt/ccxt/issues/6047
            //
            //     {
            //         "transactID":"00000000-0000-0000-0000-000000000000",
            //         "account":121210,
            //         "currency":"XBt",
            //         "transactType":"UnrealisedPNL",
            //         "amount":-5508,
            //         "fee":0,
            //         "transactStatus":"Pending",
            //         "address":"XBTUSD",
            //         "tx":"",
            //         "text":"",
            //         "transactTime":null,  # ←---------------------------- null
            //         "walletBalance":139198767,
            //         "marginBalance":139193259,
            //         "timestamp":null  # ←---------------------------- null
            //     }
            //
            const id = this.safeString (item, 'transactID');
            const account = this.safeString (item, 'account');
            const referenceId = this.safeString (item, 'tx');
            const referenceAccount = undefined;
            const type = this.parseLedgerEntryType (this.safeString (item, 'transactType'));
            const currencyId = this.safeString (item, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            let amount = this.safeNumber (item, 'amount');
            if (amount !== undefined) {
                amount = amount / 100000000;
            }
            let timestamp = this.parse8601 (this.safeString (item, 'transactTime'));
            if (timestamp === undefined) {
                // https://github.com/ccxt/ccxt/issues/6047
                // set the timestamp to zero, 1970 Jan 1 00:00:00
                // for unrealized pnl and other transactions without a timestamp
                timestamp = 0; // see comments above
            }
            let feeCost = this.safeNumber (item, 'fee', 0);
            if (feeCost !== undefined) {
                feeCost = feeCost / 100000000;
            }
            const fee = {
                'cost': feeCost,
                'currency': code,
            };
            let after = this.safeNumber (item, 'walletBalance');
            if (after !== undefined) {
                after = after / 100000000;
            }
            const before = this.sum (after, -amount);
            let direction = undefined;
            if (amount < 0) {
                direction = 'out';
                amount = Math.abs (amount);
            } else {
                direction = 'in';
            }
            const status = this.parseTransactionStatus (this.safeString (item, 'transactStatus'));
            return {
                'id': id,
                'info': item,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'direction': direction,
                'account': account,
                'referenceId': referenceId,
                'referenceAccount': referenceAccount,
                'type': type,
                'currency': code,
                'amount': amount,
                'before': before,
                'after': after,
                'status': status,
                'fee': fee,
            };
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            const request = {
                // 'start': 123,
            };
            //
            //     if (since !== undefined) {
            //         // date-based pagination not supported
            //     }
            //
            if (limit !== undefined) {
                request['count'] = limit;
            }
            const response = await this.privateGetUserWalletHistory (this.extend (request, params));
            //
            //     [
            //         {
            //             transactID: "69573da3-7744-5467-3207-89fd6efe7a47",
            //             account:  24321,
            //             currency: "XBt",
            //             transactType: "Withdrawal", // "AffiliatePayout", "Transfer", "Deposit", "RealisedPNL", ...
            //             amount:  -1000000,
            //             fee:  300000,
            //             transactStatus: "Completed", // "Canceled", ...
            //             address: "1Ex4fkF4NhQaQdRWNoYpqiPbDBbq18Kdd9",
            //             tx: "3BMEX91ZhhKoWtsH9QRb5dNXnmnGpiEetA",
            //             text: "",
            //             transactTime: "2017-03-21T20:05:14.388Z",
            //             walletBalance:  0, // balance after
            //             marginBalance:  null,
            //             timestamp: "2017-03-22T13:09:23.514Z"
            //         }
            //     ]
            //
            return this.parseLedger (response, currency, since, limit);
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'start': 123,
            };
            //
            //     if (since !== undefined) {
            //         // date-based pagination not supported
            //     }
            //
            if (limit !== undefined) {
                request['count'] = limit;
            }
            const response = await this.privateGetUserWalletHistory (this.extend (request, params));
            const transactions = this.filterByArray (response, 'transactType', [ 'Withdrawal', 'Deposit' ], false);
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            return this.parseTransactions (transactions, currency, since, limit);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'Canceled': 'canceled',
                'Completed': 'ok',
                'Pending': 'pending',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            //   {
            //      'transactID': 'ffe699c2-95ee-4c13-91f9-0faf41daec25',
            //      'account': 123456,
            //      'currency': 'XBt',
            //      'transactType': 'Withdrawal',
            //      'amount': -100100000,
            //      'fee': 100000,
            //      'transactStatus': 'Completed',
            //      'address': '385cR5DM96n1HvBDMzLHPYcw89fZAXULJP',
            //      'tx': '3BMEXabcdefghijklmnopqrstuvwxyz123',
            //      'text': '',
            //      'transactTime': '2019-01-02T01:00:00.000Z',
            //      'walletBalance': 99900000,
            //      'marginBalance': None,
            //      'timestamp': '2019-01-02T13:00:00.000Z'
            //   }
            //
            const id = this.safeString (transaction, 'transactID');
            // For deposits, transactTime == timestamp
            // For withdrawals, transactTime is submission, timestamp is processed
            const transactTime = this.parse8601 (this.safeString (transaction, 'transactTime'));
            const timestamp = this.parse8601 (this.safeString (transaction, 'timestamp'));
            const type = this.safeStringLower (transaction, 'transactType');
            // Deposits have no from address or to address, withdrawals have both
            let address = undefined;
            let addressFrom = undefined;
            let addressTo = undefined;
            if (type === 'withdrawal') {
                address = this.safeString (transaction, 'address');
                addressFrom = this.safeString (transaction, 'tx');
                addressTo = address;
            }
            let amountString = this.safeString (transaction, 'amount');
            amountString = Precise.stringDiv (Precise.stringAbs (amountString), '1e8');
            let feeCostString = this.safeString (transaction, 'fee');
            feeCostString = Precise.stringDiv (feeCostString, '1e8');
            const fee = {
                'cost': this.parseNumber (feeCostString),
                'currency': 'BTC',
            };
            let status = this.safeString (transaction, 'transactStatus');
            if (status !== undefined) {
                status = this.parseTransactionStatus (status);
            }
            return {
                'info': transaction,
                'id': id,
                'txid': undefined,
                'timestamp': transactTime,
                'datetime': this.iso8601 (transactTime),
                'addressFrom': addressFrom,
                'address': address,
                'addressTo': addressTo,
                'tagFrom': undefined,
                'tag': undefined,
                'tagTo': undefined,
                'type': type,
                'amount': this.parseNumber (amountString),
                // BTC is the only currency on Bitmex
                'currency': 'BTC',
                'status': status,
                'updated': timestamp,
                'comment': undefined,
                'fee': fee,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (!market['active']) {
                throw new ExchangeError (this.id + ': symbol ' + symbol + ' is delisted');
            }
            const tickers = await this.fetchTickers ([ symbol ], params);
            const ticker = this.safeValue (tickers, symbol);
            if (ticker === undefined) {
                throw new ExchangeError (this.id + ' ticker symbol ' + symbol + ' not found');
            }
            return ticker;
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetInstrumentActiveAndIndices (params);
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const ticker = this.parseTicker (response[i]);
                const symbol = this.safeString (ticker, 'symbol');
                if (symbol !== undefined) {
                    result[symbol] = ticker;
                }
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {                         symbol: "ETHH19",
            //                           rootSymbol: "ETH",
            //                                state: "Open",
            //                                  typ: "FFCCSX",
            //                              listing: "2018-12-17T04:00:00.000Z",
            //                                front: "2019-02-22T12:00:00.000Z",
            //                               expiry: "2019-03-29T12:00:00.000Z",
            //                               settle: "2019-03-29T12:00:00.000Z",
            //                       relistInterval:  null,
            //                           inverseLeg: "",
            //                              sellLeg: "",
            //                               buyLeg: "",
            //                     optionStrikePcnt:  null,
            //                    optionStrikeRound:  null,
            //                    optionStrikePrice:  null,
            //                     optionMultiplier:  null,
            //                     positionCurrency: "ETH",
            //                           underlying: "ETH",
            //                        quoteCurrency: "XBT",
            //                     underlyingSymbol: "ETHXBT=",
            //                            reference: "BMEX",
            //                      referenceSymbol: ".BETHXBT30M",
            //                         calcInterval:  null,
            //                      publishInterval:  null,
            //                          publishTime:  null,
            //                          maxOrderQty:  100000000,
            //                             maxPrice:  10,
            //                              lotSize:  1,
            //                             tickSize:  0.00001,
            //                           multiplier:  100000000,
            //                        settlCurrency: "XBt",
            //       underlyingToPositionMultiplier:  1,
            //         underlyingToSettleMultiplier:  null,
            //              quoteToSettleMultiplier:  100000000,
            //                             isQuanto:  false,
            //                            isInverse:  false,
            //                           initMargin:  0.02,
            //                          maintMargin:  0.01,
            //                            riskLimit:  5000000000,
            //                             riskStep:  5000000000,
            //                                limit:  null,
            //                               capped:  false,
            //                                taxed:  true,
            //                           deleverage:  true,
            //                             makerFee:  -0.0005,
            //                             takerFee:  0.0025,
            //                        settlementFee:  0,
            //                         insuranceFee:  0,
            //                    fundingBaseSymbol: "",
            //                   fundingQuoteSymbol: "",
            //                 fundingPremiumSymbol: "",
            //                     fundingTimestamp:  null,
            //                      fundingInterval:  null,
            //                          fundingRate:  null,
            //                indicativeFundingRate:  null,
            //                   rebalanceTimestamp:  null,
            //                    rebalanceInterval:  null,
            //                     openingTimestamp: "2019-02-13T08:00:00.000Z",
            //                     closingTimestamp: "2019-02-13T09:00:00.000Z",
            //                      sessionInterval: "2000-01-01T01:00:00.000Z",
            //                       prevClosePrice:  0.03347,
            //                       limitDownPrice:  null,
            //                         limitUpPrice:  null,
            //               bankruptLimitDownPrice:  null,
            //                 bankruptLimitUpPrice:  null,
            //                      prevTotalVolume:  1386531,
            //                          totalVolume:  1387062,
            //                               volume:  531,
            //                            volume24h:  17118,
            //                    prevTotalTurnover:  4741294246000,
            //                        totalTurnover:  4743103466000,
            //                             turnover:  1809220000,
            //                          turnover24h:  57919845000,
            //                      homeNotional24h:  17118,
            //                   foreignNotional24h:  579.19845,
            //                         prevPrice24h:  0.03349,
            //                                 vwap:  0.03383564,
            //                            highPrice:  0.03458,
            //                             lowPrice:  0.03329,
            //                            lastPrice:  0.03406,
            //                   lastPriceProtected:  0.03406,
            //                    lastTickDirection: "ZeroMinusTick",
            //                       lastChangePcnt:  0.017,
            //                             bidPrice:  0.03406,
            //                             midPrice:  0.034065,
            //                             askPrice:  0.03407,
            //                       impactBidPrice:  0.03406,
            //                       impactMidPrice:  0.034065,
            //                       impactAskPrice:  0.03407,
            //                         hasLiquidity:  true,
            //                         openInterest:  83679,
            //                            openValue:  285010674000,
            //                           fairMethod: "ImpactMidPrice",
            //                        fairBasisRate:  0,
            //                            fairBasis:  0,
            //                            fairPrice:  0.03406,
            //                           markMethod: "FairPrice",
            //                            markPrice:  0.03406,
            //                    indicativeTaxRate:  0,
            //                indicativeSettlePrice:  0.03406,
            //                optionUnderlyingPrice:  null,
            //                         settledPrice:  null,
            //                            timestamp: "2019-02-13T08:40:30.000Z",
            //     }
            //
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.parse8601 (this.safeString (ticker, 'timestamp'));
            const open = this.safeNumber (ticker, 'prevPrice24h');
            const last = this.safeNumber (ticker, 'lastPrice');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'highPrice'),
                'low': this.safeNumber (ticker, 'lowPrice'),
                'bid': this.safeNumber (ticker, 'bidPrice'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'askPrice'),
                'askVolume': undefined,
                'vwap': this.safeNumber (ticker, 'vwap'),
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'homeNotional24h'),
                'quoteVolume': this.safeNumber (ticker, 'foreignNotional24h'),
                'info': ticker,
            }, market);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "timestamp":"2015-09-25T13:38:00.000Z",
            //         "symbol":"XBTUSD",
            //         "open":237.45,
            //         "high":237.45,
            //         "low":237.45,
            //         "close":237.45,
            //         "trades":0,
            //         "volume":0,
            //         "vwap":null,
            //         "lastSize":null,
            //         "turnover":0,
            //         "homeNotional":0,
            //         "foreignNotional":0
            //     }
            //
            return [
                this.parse8601 (this.safeString (ohlcv, 'timestamp')),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            // send JSON key/value pairs, such as {"key": "value"}
            // filter by individual fields and do advanced queries on timestamps
            // let filter = { 'key': 'value' };
            // send a bare series (e.g. XBU) to nearest expiring contract in that series
            // you can also send a timeframe, e.g. XBU:monthly
            // timeframes: daily, weekly, monthly, quarterly, and biquarterly
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'binSize': this.timeframes[timeframe],
                'partial': true,     // true == include yet-incomplete current bins
                // 'filter': filter, // filter by individual fields and do advanced queries
                // 'columns': [],    // will return all columns if omitted
                // 'start': 0,       // starting point for results (wtf?)
                // 'reverse': false, // true == newest first
                // 'endTime': '',    // ending date filter for results
            };
            if (limit !== undefined) {
                request['count'] = limit; // default 100, max 500
            }
            const duration = this.parseTimeframe (timeframe) * 1000;
            const fetchOHLCVOpenTimestamp = this.safeValue (this.options, 'fetchOHLCVOpenTimestamp', true);
            // if since is not set, they will return candles starting from 2017-01-01
            if (since !== undefined) {
                let timestamp = since;
                if (fetchOHLCVOpenTimestamp) {
                    timestamp = this.sum (timestamp, duration);
                }
                const ymdhms = this.ymdhms (timestamp);
                request['startTime'] = ymdhms; // starting date filter for results
            } else {
                request['reverse'] = true;
            }
            const response = await this.publicGetTradeBucketed (this.extend (request, params));
            //
            //     [
            //         {"timestamp":"2015-09-25T13:38:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0},
            //         {"timestamp":"2015-09-25T13:39:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0},
            //         {"timestamp":"2015-09-25T13:40:00.000Z","symbol":"XBTUSD","open":237.45,"high":237.45,"low":237.45,"close":237.45,"trades":0,"volume":0,"vwap":null,"lastSize":null,"turnover":0,"homeNotional":0,"foreignNotional":0}
            //     ]
            //
            const result = this.parseOHLCVs (response, market, timeframe, since, limit);
            if (fetchOHLCVOpenTimestamp) {
                // bitmex returns the candle's close timestamp - https://github.com/ccxt/ccxt/issues/4446
                // we can emulate the open timestamp by shifting all the timestamps one place
                // so the previous close becomes the current open, and we drop the first candle
                for (let i = 0; i < result.length; i++) {
                    result[i][0] = result[i][0] - duration;
                }
            }
            return result;
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         timestamp: '2018-08-28T00:00:02.735Z',
            //         symbol: 'XBTUSD',
            //         side: 'Buy',
            //         size: 2000,
            //         price: 6906.5,
            //         tickDirection: 'PlusTick',
            //         trdMatchID: 'b9a42432-0a46-6a2f-5ecc-c32e9ca4baf8',
            //         grossValue: 28958000,
            //         homeNotional: 0.28958,
            //         foreignNotional: 2000
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "execID": "string",
            //         "orderID": "string",
            //         "clOrdID": "string",
            //         "clOrdLinkID": "string",
            //         "account": 0,
            //         "symbol": "string",
            //         "side": "string",
            //         "lastQty": 0,
            //         "lastPx": 0,
            //         "underlyingLastPx": 0,
            //         "lastMkt": "string",
            //         "lastLiquidityInd": "string",
            //         "simpleOrderQty": 0,
            //         "orderQty": 0,
            //         "price": 0,
            //         "displayQty": 0,
            //         "stopPx": 0,
            //         "pegOffsetValue": 0,
            //         "pegPriceType": "string",
            //         "currency": "string",
            //         "settlCurrency": "string",
            //         "execType": "string",
            //         "ordType": "string",
            //         "timeInForce": "string",
            //         "execInst": "string",
            //         "contingencyType": "string",
            //         "exDestination": "string",
            //         "ordStatus": "string",
            //         "triggered": "string",
            //         "workingIndicator": true,
            //         "ordRejReason": "string",
            //         "simpleLeavesQty": 0,
            //         "leavesQty": 0,
            //         "simpleCumQty": 0,
            //         "cumQty": 0,
            //         "avgPx": 0,
            //         "commission": 0,
            //         "tradePublishIndicator": "string",
            //         "multiLegReportingType": "string",
            //         "text": "string",
            //         "trdMatchID": "string",
            //         "execCost": 0,
            //         "execComm": 0,
            //         "homeNotional": 0,
            //         "foreignNotional": 0,
            //         "transactTime": "2019-03-05T12:47:02.762Z",
            //         "timestamp": "2019-03-05T12:47:02.762Z"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (trade, 'timestamp'));
            const priceString = this.safeString2 (trade, 'avgPx', 'price');
            const amountString = this.safeString2 (trade, 'size', 'lastQty');
            const id = this.safeString (trade, 'trdMatchID');
            const order = this.safeString (trade, 'orderID');
            const side = this.safeStringLower (trade, 'side');
            // price * amount doesn't work for all symbols (e.g. XBT, ETH)
            let costString = this.safeString (trade, 'execCost');
            costString = Precise.stringDiv (Precise.stringAbs (costString), '1e8');
            let fee = undefined;
            const feeCostString = Precise.stringDiv (this.safeString (trade, 'execComm'), '1e8');
            if (feeCostString !== undefined) {
                const currencyId = this.safeString (trade, 'settlCurrency');
                const feeCurrencyCode = this.safeCurrencyCode (currencyId);
                const feeRateString = this.safeString (trade, 'commission');
                fee = {
                    'cost': this.parseNumber (feeCostString),
                    'currency': feeCurrencyCode,
                    'rate': this.parseNumber (feeRateString),
                };
            }
            // Trade or Funding
            const execType = this.safeString (trade, 'execType');
            let takerOrMaker = undefined;
            if (feeCostString !== undefined && execType === 'Trade') {
                takerOrMaker = Precise.stringLt (feeCostString, '0') ? 'maker' : 'taker';
            }
            const marketId = this.safeString (trade, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const type = this.safeStringLower (trade, 'ordType');
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': order,
                'type': type,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'price': this.parseNumber (priceString),
                'cost': this.parseNumber (costString),
                'amount': this.parseNumber (amountString),
                'fee': fee,
            };
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'New': 'open',
                'PartiallyFilled': 'open',
                'Filled': 'closed',
                'DoneForDay': 'open',
                'Canceled': 'canceled',
                'PendingCancel': 'open',
                'PendingNew': 'open',
                'Rejected': 'rejected',
                'Expired': 'expired',
                'Stopped': 'open',
                'Untriggered': 'open',
                'Triggered': 'open',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTimeInForce (timeInForce) {
            const timeInForces = {
                'Day': 'Day',
                'GoodTillCancel': 'GTC',
                'ImmediateOrCancel': 'IOC',
                'FillOrKill': 'FOK',
            };
            return this.safeString (timeInForces, timeInForce, timeInForce);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "orderID":"56222c7a-9956-413a-82cf-99f4812c214b",
            //         "clOrdID":"",
            //         "clOrdLinkID":"",
            //         "account":1455728,
            //         "symbol":"XBTUSD",
            //         "side":"Sell",
            //         "simpleOrderQty":null,
            //         "orderQty":1,
            //         "price":40000,
            //         "displayQty":null,
            //         "stopPx":null,
            //         "pegOffsetValue":null,
            //         "pegPriceType":"",
            //         "currency":"USD",
            //         "settlCurrency":"XBt",
            //         "ordType":"Limit",
            //         "timeInForce":"GoodTillCancel",
            //         "execInst":"",
            //         "contingencyType":"",
            //         "exDestination":"XBME",
            //         "ordStatus":"New",
            //         "triggered":"",
            //         "workingIndicator":true,
            //         "ordRejReason":"",
            //         "simpleLeavesQty":null,
            //         "leavesQty":1,
            //         "simpleCumQty":null,
            //         "cumQty":0,
            //         "avgPx":null,
            //         "multiLegReportingType":"SingleSecurity",
            //         "text":"Submitted via API.",
            //         "transactTime":"2021-01-02T21:38:49.246Z",
            //         "timestamp":"2021-01-02T21:38:49.246Z"
            //     }
            //
            const status = this.parseOrderStatus (this.safeString (order, 'ordStatus'));
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.parse8601 (this.safeString (order, 'timestamp'));
            const lastTradeTimestamp = this.parse8601 (this.safeString (order, 'transactTime'));
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'orderQty');
            const filled = this.safeNumber (order, 'cumQty', 0.0);
            const average = this.safeNumber (order, 'avgPx');
            const id = this.safeString (order, 'orderID');
            const type = this.safeStringLower (order, 'ordType');
            const side = this.safeStringLower (order, 'side');
            const clientOrderId = this.safeString (order, 'clOrdID');
            const timeInForce = this.parseTimeInForce (this.safeString (order, 'timeInForce'));
            const stopPrice = this.safeNumber (order, 'stopPx');
            const execInst = this.safeString (order, 'execInst');
            const postOnly = (execInst === 'ParticipateDoNotInitiate');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (since !== undefined) {
                request['startTime'] = this.iso8601 (since);
            } else {
                // by default reverse=false, i.e. trades are fetched since the time of market inception (year 2015 for XBTUSD)
                request['reverse'] = true;
            }
            if (limit !== undefined) {
                request['count'] = limit;
            }
            const response = await this.publicGetTrade (this.extend (request, params));
            //
            //     [
            //         {
            //             timestamp: '2018-08-28T00:00:02.735Z',
            //             symbol: 'XBTUSD',
            //             side: 'Buy',
            //             size: 2000,
            //             price: 6906.5,
            //             tickDirection: 'PlusTick',
            //             trdMatchID: 'b9a42432-0a46-6a2f-5ecc-c32e9ca4baf8',
            //             grossValue: 28958000,
            //             homeNotional: 0.28958,
            //             foreignNotional: 2000
            //         },
            //         {
            //             timestamp: '2018-08-28T00:00:03.778Z',
            //             symbol: 'XBTUSD',
            //             side: 'Sell',
            //             size: 1000,
            //             price: 6906,
            //             tickDirection: 'MinusTick',
            //             trdMatchID: '0d4f1682-5270-a800-569b-4a0eb92db97c',
            //             grossValue: 14480000,
            //             homeNotional: 0.1448,
            //             foreignNotional: 1000
            //         },
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderType = this.capitalize (type);
            const request = {
                'symbol': market['id'],
                'side': this.capitalize (side),
                'orderQty': parseFloat (this.amountToPrecision (symbol, amount)),
                'ordType': orderType,
            };
            if ((orderType === 'Stop') || (orderType === 'StopLimit') || (orderType === 'MarketIfTouched') || (orderType === 'LimitIfTouched')) {
                const stopPrice = this.safeNumber2 (params, 'stopPx', 'stopPrice');
                if (stopPrice === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a stopPx or stopPrice parameter for the ' + orderType + ' order type');
                } else {
                    request['stopPx'] = parseFloat (this.priceToPrecision (symbol, stopPrice));
                    params = this.omit (params, [ 'stopPx', 'stopPrice' ]);
                }
            }
            if ((orderType === 'Limit') || (orderType === 'StopLimit') || (orderType === 'LimitIfTouched')) {
                request['price'] = parseFloat (this.priceToPrecision (symbol, price));
            }
            const clientOrderId = this.safeString2 (params, 'clOrdID', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['clOrdID'] = clientOrderId;
                params = this.omit (params, [ 'clOrdID', 'clientOrderId' ]);
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        async editOrder (id, symbol, type, side, amount = undefined, price = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const origClOrdID = this.safeString2 (params, 'origClOrdID', 'clientOrderId');
            if (origClOrdID !== undefined) {
                request['origClOrdID'] = origClOrdID;
                const clientOrderId = this.safeString (params, 'clOrdID', 'clientOrderId');
                if (clientOrderId !== undefined) {
                    request['clOrdID'] = clientOrderId;
                }
                params = this.omit (params, [ 'origClOrdID', 'clOrdID', 'clientOrderId' ]);
            } else {
                request['orderID'] = id;
            }
            if (amount !== undefined) {
                request['orderQty'] = amount;
            }
            if (price !== undefined) {
                request['price'] = price;
            }
            const response = await this.privatePutOrder (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            // https://github.com/ccxt/ccxt/issues/6507
            const clientOrderId = this.safeString2 (params, 'clOrdID', 'clientOrderId');
            const request = {};
            if (clientOrderId === undefined) {
                request['orderID'] = id;
            } else {
                request['clOrdID'] = clientOrderId;
                params = this.omit (params, [ 'clOrdID', 'clientOrderId' ]);
            }
            const response = await this.privateDeleteOrder (this.extend (request, params));
            const order = this.safeValue (response, 0, {});
            const error = this.safeString (order, 'error');
            if (error !== undefined) {
                if (error.indexOf ('Unable to cancel order due to existing state') >= 0) {
                    throw new OrderNotFound (this.id + ' cancelOrder() failed: ' + error);
                }
            }
            return this.parseOrder (order);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const response = await this.privateDeleteOrderAll (this.extend (request, params));
            //
            //     [
            //         {
            //             "orderID": "string",
            //             "clOrdID": "string",
            //             "clOrdLinkID": "string",
            //             "account": 0,
            //             "symbol": "string",
            //             "side": "string",
            //             "simpleOrderQty": 0,
            //             "orderQty": 0,
            //             "price": 0,
            //             "displayQty": 0,
            //             "stopPx": 0,
            //             "pegOffsetValue": 0,
            //             "pegPriceType": "string",
            //             "currency": "string",
            //             "settlCurrency": "string",
            //             "ordType": "string",
            //             "timeInForce": "string",
            //             "execInst": "string",
            //             "contingencyType": "string",
            //             "exDestination": "string",
            //             "ordStatus": "string",
            //             "triggered": "string",
            //             "workingIndicator": true,
            //             "ordRejReason": "string",
            //             "simpleLeavesQty": 0,
            //             "leavesQty": 0,
            //             "simpleCumQty": 0,
            //             "cumQty": 0,
            //             "avgPx": 0,
            //             "multiLegReportingType": "string",
            //             "text": "string",
            //             "transactTime": "2020-06-01T09:36:35.290Z",
            //             "timestamp": "2020-06-01T09:36:35.290Z"
            //         }
            //     ]
            //
            return this.parseOrders (response, market);
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetPosition (params);
            //     [
            //         {
            //             "account": 0,
            //             "symbol": "string",
            //             "currency": "string",
            //             "underlying": "string",
            //             "quoteCurrency": "string",
            //             "commission": 0,
            //             "initMarginReq": 0,
            //             "maintMarginReq": 0,
            //             "riskLimit": 0,
            //             "leverage": 0,
            //             "crossMargin": true,
            //             "deleveragePercentile": 0,
            //             "rebalancedPnl": 0,
            //             "prevRealisedPnl": 0,
            //             "prevUnrealisedPnl": 0,
            //             "prevClosePrice": 0,
            //             "openingTimestamp": "2020-11-09T06:53:59.892Z",
            //             "openingQty": 0,
            //             "openingCost": 0,
            //             "openingComm": 0,
            //             "openOrderBuyQty": 0,
            //             "openOrderBuyCost": 0,
            //             "openOrderBuyPremium": 0,
            //             "openOrderSellQty": 0,
            //             "openOrderSellCost": 0,
            //             "openOrderSellPremium": 0,
            //             "execBuyQty": 0,
            //             "execBuyCost": 0,
            //             "execSellQty": 0,
            //             "execSellCost": 0,
            //             "execQty": 0,
            //             "execCost": 0,
            //             "execComm": 0,
            //             "currentTimestamp": "2020-11-09T06:53:59.893Z",
            //             "currentQty": 0,
            //             "currentCost": 0,
            //             "currentComm": 0,
            //             "realisedCost": 0,
            //             "unrealisedCost": 0,
            //             "grossOpenCost": 0,
            //             "grossOpenPremium": 0,
            //             "grossExecCost": 0,
            //             "isOpen": true,
            //             "markPrice": 0,
            //             "markValue": 0,
            //             "riskValue": 0,
            //             "homeNotional": 0,
            //             "foreignNotional": 0,
            //             "posState": "string",
            //             "posCost": 0,
            //             "posCost2": 0,
            //             "posCross": 0,
            //             "posInit": 0,
            //             "posComm": 0,
            //             "posLoss": 0,
            //             "posMargin": 0,
            //             "posMaint": 0,
            //             "posAllowance": 0,
            //             "taxableMargin": 0,
            //             "initMargin": 0,
            //             "maintMargin": 0,
            //             "sessionMargin": 0,
            //             "targetExcessMargin": 0,
            //             "varMargin": 0,
            //             "realisedGrossPnl": 0,
            //             "realisedTax": 0,
            //             "realisedPnl": 0,
            //             "unrealisedGrossPnl": 0,
            //             "longBankrupt": 0,
            //             "shortBankrupt": 0,
            //             "taxBase": 0,
            //             "indicativeTaxRate": 0,
            //             "indicativeTax": 0,
            //             "unrealisedTax": 0,
            //             "unrealisedPnl": 0,
            //             "unrealisedPnlPcnt": 0,
            //             "unrealisedRoePcnt": 0,
            //             "simpleQty": 0,
            //             "simpleCost": 0,
            //             "simpleValue": 0,
            //             "simplePnl": 0,
            //             "simplePnlPcnt": 0,
            //             "avgCostPrice": 0,
            //             "avgEntryPrice": 0,
            //             "breakEvenPrice": 0,
            //             "marginCallPrice": 0,
            //             "liquidationPrice": 0,
            //             "bankruptPrice": 0,
            //             "timestamp": "2020-11-09T06:53:59.894Z",
            //             "lastPrice": 0,
            //             "lastValue": 0
            //         }
            //     ]
            //
            // todo unify parsePosition/parsePositions
            return response;
        }
    
        isFiat (currency) {
            if (currency === 'EUR') {
                return true;
            }
            if (currency === 'PLN') {
                return true;
            }
            return false;
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            // let currency = this.currency (code);
            if (code !== 'BTC') {
                throw new ExchangeError (this.id + ' supoprts BTC withdrawals only, other currencies coming soon...');
            }
            const request = {
                'currency': 'XBt', // temporarily
                'amount': amount,
                'address': address,
                // 'otpToken': '123456', // requires if two-factor auth (OTP) is enabled
                // 'fee': 0.001, // bitcoin network fee
            };
            const response = await this.privatePostUserRequestWithdrawal (this.extend (request, params));
            return {
                'info': response,
                'id': this.safeString (response, 'transactID'),
            };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            if (code === 429) {
                throw new DDoSProtection (this.id + ' ' + body);
            }
            if (code >= 400) {
                const error = this.safeValue (response, 'error', {});
                const message = this.safeString (error, 'message');
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                if (code === 400) {
                    throw new BadRequest (feedback);
                }
                throw new ExchangeError (feedback); // unknown message
            }
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let query = '/api/' + this.version + '/' + path;
            if (method === 'GET') {
                if (Object.keys (params).length) {
                    query += '?' + this.urlencode (params);
                }
            } else {
                const format = this.safeString (params, '_format');
                if (format !== undefined) {
                    query += '?' + this.urlencode ({ '_format': format });
                    params = this.omit (params, '_format');
                }
            }
            const url = this.urls['api'][api] + query;
            if (this.apiKey && this.secret) {
                let auth = method + query;
                let expires = this.safeInteger (this.options, 'api-expires');
                headers = {
                    'Content-Type': 'application/json',
                    'api-key': this.apiKey,
                };
                expires = this.sum (this.seconds (), expires);
                expires = expires.toString ();
                auth += expires;
                headers['api-expires'] = expires;
                if (method === 'POST' || method === 'PUT' || method === 'DELETE') {
                    if (Object.keys (params).length) {
                        body = this.json (params);
                        auth += body;
                    }
                }
                headers['api-signature'] = this.hmac (this.encode (auth), this.encode (this.secret));
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],41:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { AuthenticationError, ExchangeError, PermissionDenied, BadRequest, ArgumentsRequired, OrderNotFound, InsufficientFunds, ExchangeNotAvailable, DDoSProtection, InvalidAddress, InvalidOrder } = require ('./base/errors');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitpanda extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitpanda',
                'name': 'Bitpanda Pro',
                'countries': [ 'AT' ], // Austria
                'rateLimit': 300,
                'version': 'v1',
                // new metainfo interface
                'has': {
                    'CORS': false,
                    'publicAPI': true,
                    'privateAPI': true,
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'cancelOrders': true,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDeposits': true,
                    'fetchDepositAddress': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrderTrades': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTradingFees': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1/MINUTES',
                    '5m': '5/MINUTES',
                    '15m': '15/MINUTES',
                    '30m': '30/MINUTES',
                    '1h': '1/HOURS',
                    '4h': '4/HOURS',
                    '1d': '1/DAYS',
                    '1w': '1/WEEKS',
                    '1M': '1/MONTHS',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87591171-9a377d80-c6f0-11ea-94ac-97a126eac3bc.jpg',
                    'api': {
                        'public': 'https://api.exchange.bitpanda.com/public',
                        'private': 'https://api.exchange.bitpanda.com/public',
                    },
                    'www': 'https://www.bitpanda.com/en/pro',
                    'doc': [
                        'https://developers.bitpanda.com/exchange/',
                    ],
                    'fees': 'https://www.bitpanda.com/en/pro/fees',
                },
                'api': {
                    'public': {
                        'get': [
                            'currencies',
                            'candlesticks/{instrument_code}',
                            'fees',
                            'instruments',
                            'order-book/{instrument_code}',
                            'market-ticker',
                            'market-ticker/{instrument_code}',
                            'price-ticks/{instrument_code}',
                            'time',
                        ],
                    },
                    'private': {
                        'get': [
                            'account/balances',
                            'account/deposit/crypto/{currency_code}',
                            'account/deposit/fiat/EUR',
                            'account/deposits',
                            'account/deposits/bitpanda',
                            'account/withdrawals',
                            'account/withdrawals/bitpanda',
                            'account/fees',
                            'account/orders',
                            'account/orders/{order_id}',
                            'account/orders/{order_id}/trades',
                            'account/trades',
                            'account/trades/{trade_id}',
                            'account/trading-volume',
                        ],
                        'post': [
                            'account/deposit/crypto',
                            'account/withdraw/crypto',
                            'account/withdraw/fiat',
                            'account/fees',
                            'account/orders',
                        ],
                        'delete': [
                            'account/orders',
                            'account/orders/{order_id}',
                            'account/orders/client/{client_id}',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': this.parseNumber ('0.0015'),
                        'maker': this.parseNumber ('0.001'),
                        'tiers': [
                            // volume in BTC
                            {
                                'taker': [
                                    [this.parseNumber ('0'), this.parseNumber ('0.0015')],
                                    [this.parseNumber ('100'), this.parseNumber ('0.0013')],
                                    [this.parseNumber ('250'), this.parseNumber ('0.0013')],
                                    [this.parseNumber ('1000'), this.parseNumber ('0.001')],
                                    [this.parseNumber ('5000'), this.parseNumber ('0.0009')],
                                    [this.parseNumber ('10000'), this.parseNumber ('0.00075')],
                                    [this.parseNumber ('20000'), this.parseNumber ('0.00065')],
                                ],
                                'maker': [
                                    [this.parseNumber ('0'), this.parseNumber ('0.001')],
                                    [this.parseNumber ('100'), this.parseNumber ('0.001')],
                                    [this.parseNumber ('250'), this.parseNumber ('0.0009')],
                                    [this.parseNumber ('1000'), this.parseNumber ('0.00075')],
                                    [this.parseNumber ('5000'), this.parseNumber ('0.0006')],
                                    [this.parseNumber ('10000'), this.parseNumber ('0.0005')],
                                    [this.parseNumber ('20000'), this.parseNumber ('0.0005')],
                                ],
                            },
                        ],
                    },
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': false,
                },
                'exceptions': {
                    'exact': {
                        'INVALID_CLIENT_UUID': InvalidOrder,
                        'ORDER_NOT_FOUND': OrderNotFound,
                        'ONLY_ONE_ERC20_ADDRESS_ALLOWED': InvalidAddress,
                        'DEPOSIT_ADDRESS_NOT_USED': InvalidAddress,
                        'INVALID_CREDENTIALS': AuthenticationError,
                        'MISSING_CREDENTIALS': AuthenticationError,
                        'INVALID_APIKEY': AuthenticationError,
                        'INVALID_SCOPES': AuthenticationError,
                        'INVALID_SUBJECT': AuthenticationError,
                        'INVALID_ISSUER': AuthenticationError,
                        'INVALID_AUDIENCE': AuthenticationError,
                        'INVALID_DEVICE_ID': AuthenticationError,
                        'INVALID_IP_RESTRICTION': AuthenticationError,
                        'APIKEY_REVOKED': AuthenticationError,
                        'APIKEY_EXPIRED': AuthenticationError,
                        'SYNCHRONIZER_TOKEN_MISMATCH': AuthenticationError,
                        'SESSION_EXPIRED': AuthenticationError,
                        'INTERNAL_ERROR': AuthenticationError,
                        'CLIENT_IP_BLOCKED': PermissionDenied,
                        'MISSING_PERMISSION': PermissionDenied,
                        'ILLEGAL_CHARS': BadRequest,
                        'UNSUPPORTED_MEDIA_TYPE': BadRequest,
                        'ACCOUNT_HISTORY_TIME_RANGE_TOO_BIG': BadRequest,
                        'CANDLESTICKS_TIME_RANGE_TOO_BIG': BadRequest,
                        'INVALID_INSTRUMENT_CODE': BadRequest,
                        'INVALID_ORDER_TYPE': BadRequest,
                        'INVALID_UNIT': BadRequest,
                        'INVALID_PERIOD': BadRequest,
                        'INVALID_TIME': BadRequest,
                        'INVALID_DATE': BadRequest,
                        'INVALID_CURRENCY': BadRequest,
                        'INVALID_AMOUNT': BadRequest,
                        'INVALID_PRICE': BadRequest,
                        'INVALID_LIMIT': BadRequest,
                        'INVALID_QUERY': BadRequest,
                        'INVALID_CURSOR': BadRequest,
                        'INVALID_ACCOUNT_ID': BadRequest,
                        'INVALID_SIDE': InvalidOrder,
                        'INVALID_ACCOUNT_HISTORY_FROM_TIME': BadRequest,
                        'INVALID_ACCOUNT_HISTORY_MAX_PAGE_SIZE': BadRequest,
                        'INVALID_ACCOUNT_HISTORY_TIME_PERIOD': BadRequest,
                        'INVALID_ACCOUNT_HISTORY_TO_TIME': BadRequest,
                        'INVALID_CANDLESTICKS_GRANULARITY': BadRequest,
                        'INVALID_CANDLESTICKS_UNIT': BadRequest,
                        'INVALID_ORDER_BOOK_DEPTH': BadRequest,
                        'INVALID_ORDER_BOOK_LEVEL': BadRequest,
                        'INVALID_PAGE_CURSOR': BadRequest,
                        'INVALID_TIME_RANGE': BadRequest,
                        'INVALID_TRADE_ID': BadRequest,
                        'INVALID_UI_ACCOUNT_SETTINGS': BadRequest,
                        'NEGATIVE_AMOUNT': InvalidOrder,
                        'NEGATIVE_PRICE': InvalidOrder,
                        'MIN_SIZE_NOT_SATISFIED': InvalidOrder,
                        'BAD_AMOUNT_PRECISION': InvalidOrder,
                        'BAD_PRICE_PRECISION': InvalidOrder,
                        'BAD_TRIGGER_PRICE_PRECISION': InvalidOrder,
                        'MAX_OPEN_ORDERS_EXCEEDED': BadRequest,
                        'MISSING_PRICE': InvalidOrder,
                        'MISSING_ORDER_TYPE': InvalidOrder,
                        'MISSING_SIDE': InvalidOrder,
                        'MISSING_CANDLESTICKS_PERIOD_PARAM': ArgumentsRequired,
                        'MISSING_CANDLESTICKS_UNIT_PARAM': ArgumentsRequired,
                        'MISSING_FROM_PARAM': ArgumentsRequired,
                        'MISSING_INSTRUMENT_CODE': ArgumentsRequired,
                        'MISSING_ORDER_ID': InvalidOrder,
                        'MISSING_TO_PARAM': ArgumentsRequired,
                        'MISSING_TRADE_ID': ArgumentsRequired,
                        'INVALID_ORDER_ID': OrderNotFound,
                        'NOT_FOUND': OrderNotFound,
                        'INSUFFICIENT_LIQUIDITY': InsufficientFunds,
                        'INSUFFICIENT_FUNDS': InsufficientFunds,
                        'NO_TRADING': ExchangeNotAvailable,
                        'SERVICE_UNAVAILABLE': ExchangeNotAvailable,
                        'GATEWAY_TIMEOUT': ExchangeNotAvailable,
                        'RATELIMIT': DDoSProtection,
                        'CF_RATELIMIT': DDoSProtection,
                        'INTERNAL_SERVER_ERROR': ExchangeError,
                    },
                    'broad': {
                    },
                },
                'commonCurrencies': {
                    'MIOTA': 'IOTA', // https://github.com/ccxt/ccxt/issues/7487
                },
                // exchange-specific options
                'options': {
                    'fetchTradingFees': {
                        'method': 'fetchPrivateTradingFees', // or 'fetchPublicTradingFees'
                    },
                    'fiat': [ 'EUR', 'CHF' ],
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     {
            //         iso: '2020-07-10T05:17:26.716Z',
            //         epoch_millis: 1594358246716,
            //     }
            //
            return this.safeInteger (response, 'epoch_millis');
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     [
            //         {
            //             "code":"BEST",
            //             "precision":8
            //         }
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'code');
                const code = this.safeCurrencyCode (id);
                result[code] = {
                    'id': id,
                    'code': code,
                    'name': undefined,
                    'info': currency, // the original payload
                    'active': undefined,
                    'fee': undefined,
                    'precision': this.safeInteger (currency, 'precision'),
                    'limits': {
                        'amount': { 'min': undefined, 'max': undefined },
                        'withdraw': { 'min': undefined, 'max': undefined },
                    },
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetInstruments (params);
            //
            //     [
            //         {
            //             state: 'ACTIVE',
            //             base: { code: 'ETH', precision: 8 },
            //             quote: { code: 'CHF', precision: 2 },
            //             amount_precision: 4,
            //             market_precision: 2,
            //             min_size: '10.0'
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const baseAsset = this.safeValue (market, 'base', {});
                const quoteAsset = this.safeValue (market, 'quote', {});
                const baseId = this.safeString (baseAsset, 'code');
                const quoteId = this.safeString (quoteAsset, 'code');
                const id = baseId + '_' + quoteId;
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeInteger (market, 'amount_precision'),
                    'price': this.safeInteger (market, 'market_precision'),
                };
                const limits = {
                    'amount': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': this.safeNumber (market, 'min_size'),
                        'max': undefined,
                    },
                };
                const state = this.safeString (market, 'state');
                const active = (state === 'ACTIVE');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                    'active': active,
                });
            }
            return result;
        }
    
        async fetchTradingFees (params = {}) {
            let method = this.safeString (params, 'method');
            params = this.omit (params, 'method');
            if (method === undefined) {
                const options = this.safeValue (this.options, 'fetchTradingFees', {});
                method = this.safeString (options, 'method', 'fetchPrivateTradingFees');
            }
            return await this[method] (params);
        }
    
        async fetchPublicTradingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetFees (params);
            //
            //     [
            //         {
            //             "fee_group_id":"default",
            //             "display_text":"The standard fee plan.",
            //             "fee_tiers":[
            //                 {"volume":"0.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.15"},
            //                 {"volume":"100.0","fee_group_id":"default","maker_fee":"0.1","taker_fee":"0.13"},
            //                 {"volume":"250.0","fee_group_id":"default","maker_fee":"0.09","taker_fee":"0.13"},
            //                 {"volume":"1000.0","fee_group_id":"default","maker_fee":"0.075","taker_fee":"0.1"},
            //                 {"volume":"5000.0","fee_group_id":"default","maker_fee":"0.06","taker_fee":"0.09"},
            //                 {"volume":"10000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.075"},
            //                 {"volume":"20000.0","fee_group_id":"default","maker_fee":"0.05","taker_fee":"0.065"}
            //             ],
            //             "fee_discount_rate":"25.0",
            //             "minimum_price_value":"0.12"
            //         }
            //     ]
            //
            const feeGroupsById = this.indexBy (response, 'fee_group_id');
            const feeGroupId = this.safeValue (this.options, 'fee_group_id', 'default');
            const feeGroup = this.safeValue (feeGroupsById, feeGroupId, {});
            const feeTiers = this.safeValue (feeGroup, 'fee_tiers');
            const result = {};
            for (let i = 0; i < this.symbols.length; i++) {
                const symbol = this.symbols[i];
                const fee = {
                    'info': feeGroup,
                    'symbol': symbol,
                    'maker': undefined,
                    'taker': undefined,
                    'percentage': true,
                    'tierBased': true,
                };
                const takerFees = [];
                const makerFees = [];
                for (let i = 0; i < feeTiers.length; i++) {
                    const tier = feeTiers[i];
                    const volume = this.safeNumber (tier, 'volume');
                    let taker = this.safeNumber (tier, 'taker_fee');
                    let maker = this.safeNumber (tier, 'maker_fee');
                    taker /= 100;
                    maker /= 100;
                    takerFees.push ([ volume, taker ]);
                    makerFees.push ([ volume, maker ]);
                    if (i === 0) {
                        fee['taker'] = taker;
                        fee['maker'] = maker;
                    }
                }
                const tiers = {
                    'taker': takerFees,
                    'maker': makerFees,
                };
                fee['tiers'] = tiers;
                result[symbol] = fee;
            }
            return result;
        }
    
        async fetchPrivateTradingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccountFees (params);
            //
            //     {
            //         "account_id": "ed524d00-820a-11e9-8f1e-69602df16d85",
            //         "running_trading_volume": "0.0",
            //         "fee_group_id": "default",
            //         "collect_fees_in_best": false,
            //         "fee_discount_rate": "25.0",
            //         "minimum_price_value": "0.12",
            //         "fee_tiers": [
            //             { "volume": "0.0", "fee_group_id": "default", "maker_fee": "0.1", "taker_fee": "0.1" },
            //             { "volume": "100.0", "fee_group_id": "default", "maker_fee": "0.09", "taker_fee": "0.1" },
            //             { "volume": "250.0", "fee_group_id": "default", "maker_fee": "0.08", "taker_fee": "0.1" },
            //             { "volume": "1000.0", "fee_group_id": "default", "maker_fee": "0.07", "taker_fee": "0.09" },
            //             { "volume": "5000.0", "fee_group_id": "default", "maker_fee": "0.06", "taker_fee": "0.08" },
            //             { "volume": "10000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.07" },
            //             { "volume": "20000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.06" },
            //             { "volume": "50000.0", "fee_group_id": "default", "maker_fee": "0.05", "taker_fee": "0.05" }
            //         ],
            //         "active_fee_tier": { "volume": "0.0", "fee_group_id": "default", "maker_fee": "0.1", "taker_fee": "0.1" }
            //     }
            //
            const activeFeeTier = this.safeValue (response, 'active_fee_tier', {});
            const result = {
                'info': response,
                'maker': this.safeNumber (activeFeeTier, 'maker_fee'),
                'taker': this.safeNumber (activeFeeTier, 'taker_fee'),
                'percentage': true,
                'tierBased': true,
            };
            const feeTiers = this.safeValue (response, 'fee_tiers');
            const takerFees = [];
            const makerFees = [];
            for (let i = 0; i < feeTiers.length; i++) {
                const tier = feeTiers[i];
                const volume = this.safeNumber (tier, 'volume');
                let taker = this.safeNumber (tier, 'taker_fee');
                let maker = this.safeNumber (tier, 'maker_fee');
                taker /= 100;
                maker /= 100;
                takerFees.push ([ volume, taker ]);
                makerFees.push ([ volume, maker ]);
            }
            const tiers = {
                'taker': takerFees,
                'maker': makerFees,
            };
            result['tiers'] = tiers;
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker, fetchTickers
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "sequence":602562,
            //         "time":"2020-07-10T06:27:34.951Z",
            //         "state":"ACTIVE",
            //         "is_frozen":0,
            //         "quote_volume":"1695555.1783768",
            //         "base_volume":"205.67436",
            //         "last_price":"8143.91",
            //         "best_bid":"8143.71",
            //         "best_ask":"8156.9",
            //         "price_change":"-147.47",
            //         "price_change_percentage":"-1.78",
            //         "high":"8337.45",
            //         "low":"8110.0"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (ticker, 'time'));
            const marketId = this.safeString (ticker, 'instrument_code');
            const symbol = this.safeSymbol (marketId, market, '_');
            const last = this.safeNumber (ticker, 'last_price');
            const percentage = this.safeNumber (ticker, 'price_change_percentage');
            const change = this.safeNumber (ticker, 'price_change');
            const baseVolume = this.safeNumber (ticker, 'base_volume');
            const quoteVolume = this.safeNumber (ticker, 'quote_volume');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'best_bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'best_ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_code': market['id'],
            };
            const response = await this.publicGetMarketTickerInstrumentCode (this.extend (request, params));
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "sequence":602562,
            //         "time":"2020-07-10T06:27:34.951Z",
            //         "state":"ACTIVE",
            //         "is_frozen":0,
            //         "quote_volume":"1695555.1783768",
            //         "base_volume":"205.67436",
            //         "last_price":"8143.91",
            //         "best_bid":"8143.71",
            //         "best_ask":"8156.9",
            //         "price_change":"-147.47",
            //         "price_change_percentage":"-1.78",
            //         "high":"8337.45",
            //         "low":"8110.0"
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetMarketTicker (params);
            //
            //     [
            //         {
            //             "instrument_code":"BTC_EUR",
            //             "sequence":602562,
            //             "time":"2020-07-10T06:27:34.951Z",
            //             "state":"ACTIVE",
            //             "is_frozen":0,
            //             "quote_volume":"1695555.1783768",
            //             "base_volume":"205.67436",
            //             "last_price":"8143.91",
            //             "best_bid":"8143.71",
            //             "best_ask":"8156.9",
            //             "price_change":"-147.47",
            //             "price_change_percentage":"-1.78",
            //             "high":"8337.45",
            //             "low":"8110.0"
            //         }
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const ticker = this.parseTicker (response[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'instrument_code': this.marketId (symbol),
                // level 1 means only the best bid and ask
                // level 2 is a compiled order book up to market precision
                // level 3 is a full orderbook
                // if you wish to get regular updates about orderbooks please use the Websocket channel
                // heavy usage of this endpoint may result in limited access according to rate limits rules
                // 'level': 3, // default
            };
            if (limit !== undefined) {
                request['depth'] = limit;
            }
            const response = await this.publicGetOrderBookInstrumentCode (this.extend (request, params));
            //
            // level 1
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "time":"2020-07-10T07:39:06.343Z",
            //         "asks":{
            //             "value":{
            //                 "price":"8145.29",
            //                 "amount":"0.96538",
            //                 "number_of_orders":1
            //             }
            //         },
            //         "bids":{
            //             "value":{
            //                 "price":"8134.0",
            //                 "amount":"1.5978",
            //                 "number_of_orders":5
            //             }
            //         }
            //     }
            //
            // level 2
            //
            //     {
            //         "instrument_code":"BTC_EUR","time":"2020-07-10T07:36:43.538Z",
            //         "asks":[
            //             {"price":"8146.59","amount":"0.89691","number_of_orders":1},
            //             {"price":"8146.89","amount":"1.92062","number_of_orders":1},
            //             {"price":"8169.5","amount":"0.0663","number_of_orders":1},
            //         ],
            //         "bids":[
            //             {"price":"8143.49","amount":"0.01329","number_of_orders":1},
            //             {"price":"8137.01","amount":"5.34748","number_of_orders":1},
            //             {"price":"8137.0","amount":"2.0","number_of_orders":1},
            //         ]
            //     }
            //
            // level 3
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "time":"2020-07-10T07:32:31.525Z",
            //         "bids":[
            //             {"price":"8146.79","amount":"0.01537","order_id":"5d717da1-a8f4-422d-afcc-03cb6ab66825"},
            //             {"price":"8139.32","amount":"3.66009","order_id":"d0715c68-f28d-4cf1-a450-d56cf650e11c"},
            //             {"price":"8137.51","amount":"2.61049","order_id":"085fd6f4-e835-4ca5-9449-a8f165772e60"},
            //         ],
            //         "asks":[
            //             {"price":"8153.49","amount":"0.93384","order_id":"755d3aa3-42b5-46fa-903d-98f42e9ae6c4"},
            //             {"price":"8153.79","amount":"1.80456","order_id":"62034cf3-b70d-45ff-b285-ba6307941e7c"},
            //             {"price":"8167.9","amount":"0.0018","order_id":"036354e0-71cd-492f-94f2-01f7d4b66422"},
            //         ]
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (response, 'time'));
            return this.parseOrderBook (response, symbol, timestamp, 'bids', 'asks', 'price', 'amount');
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "granularity":{"unit":"HOURS","period":1},
            //         "high":"9252.65",
            //         "low":"9115.27",
            //         "open":"9250.0",
            //         "close":"9132.35",
            //         "total_amount":"33.85924",
            //         "volume":"311958.9635744",
            //         "time":"2020-05-08T22:59:59.999Z",
            //         "last_sequence":461123
            //     }
            //
            const granularity = this.safeValue (ohlcv, 'granularity');
            const unit = this.safeString (granularity, 'unit');
            const period = this.safeString (granularity, 'period');
            const units = {
                'MINUTES': 'm',
                'HOURS': 'h',
                'DAYS': 'd',
                'WEEKS': 'w',
                'MONTHS': 'M',
            };
            const lowercaseUnit = this.safeString (units, unit);
            const timeframe = period + lowercaseUnit;
            const durationInSeconds = this.parseTimeframe (timeframe);
            const duration = durationInSeconds * 1000;
            const timestamp = this.parse8601 (this.safeString (ohlcv, 'time'));
            const alignedTimestamp = duration * parseInt (timestamp / duration);
            const options = this.safeValue (this.options, 'fetchOHLCV', {});
            const volumeField = this.safeString (options, 'volume', 'total_amount');
            return [
                alignedTimestamp,
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, volumeField),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const periodUnit = this.safeString (this.timeframes, timeframe);
            const [ period, unit ] = periodUnit.split ('/');
            const durationInSeconds = this.parseTimeframe (timeframe);
            const duration = durationInSeconds * 1000;
            if (limit === undefined) {
                limit = 1500;
            }
            const request = {
                'instrument_code': market['id'],
                // 'from': this.iso8601 (since),
                // 'to': this.iso8601 (this.milliseconds ()),
                'period': period,
                'unit': unit,
            };
            if (since === undefined) {
                const now = this.milliseconds ();
                request['to'] = this.iso8601 (now);
                request['from'] = this.iso8601 (now - limit * duration);
            } else {
                request['from'] = this.iso8601 (since);
                request['to'] = this.iso8601 (this.sum (since, limit * duration));
            }
            const response = await this.publicGetCandlesticksInstrumentCode (this.extend (request, params));
            //
            //     [
            //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9252.65","low":"9115.27","open":"9250.0","close":"9132.35","total_amount":"33.85924","volume":"311958.9635744","time":"2020-05-08T22:59:59.999Z","last_sequence":461123},
            //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9162.49","low":"9040.0","open":"9132.53","close":"9083.69","total_amount":"26.19685","volume":"238553.7812365","time":"2020-05-08T23:59:59.999Z","last_sequence":461376},
            //         {"instrument_code":"BTC_EUR","granularity":{"unit":"HOURS","period":1},"high":"9135.7","low":"9002.59","open":"9055.45","close":"9133.98","total_amount":"26.21919","volume":"238278.8724959","time":"2020-05-09T00:59:59.999Z","last_sequence":461521},
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "instrument_code":"BTC_EUR",
            //         "price":"8137.28",
            //         "amount":"0.22269",
            //         "taker_side":"BUY",
            //         "volume":"1812.0908832",
            //         "time":"2020-07-10T14:44:32.299Z",
            //         "trade_timestamp":1594392272299,
            //         "sequence":603047
            //     }
            //
            // fetchMyTrades, fetchOrder, fetchOpenOrders, fetchClosedOrders trades (private)
            //
            //     {
            //         "fee": {
            //             "fee_amount": "0.0014",
            //             "fee_currency": "BTC",
            //             "fee_percentage": "0.1",
            //             "fee_group_id": "default",
            //             "fee_type": "TAKER",
            //             "running_trading_volume": "0.0"
            //         },
            //         "trade": {
            //             "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
            //             "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
            //             "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //             "amount": "1.4",
            //             "side": "BUY",
            //             "instrument_code": "BTC_EUR",
            //             "price": "7341.4",
            //             "time": "2019-09-27T15:05:32.564Z",
            //             "sequence": 48670
            //         }
            //     }
            //
            const feeInfo = this.safeValue (trade, 'fee', {});
            trade = this.safeValue (trade, 'trade', trade);
            let timestamp = this.safeInteger (trade, 'trade_timestamp');
            if (timestamp === undefined) {
                timestamp = this.parse8601 (this.safeString (trade, 'time'));
            }
            const side = this.safeStringLower2 (trade, 'side', 'taker_side');
            const price = this.safeNumber (trade, 'price');
            const amount = this.safeNumber (trade, 'amount');
            let cost = this.safeNumber (trade, 'volume');
            if ((cost === undefined) && (amount !== undefined) && (price !== undefined)) {
                cost = amount * price;
            }
            const marketId = this.safeString (trade, 'instrument_code');
            const symbol = this.safeSymbol (marketId, market, '_');
            const feeCost = this.safeNumber (feeInfo, 'fee_amount');
            let takerOrMaker = undefined;
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (feeInfo, 'fee_currency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                const feeRate = this.safeNumber (feeInfo, 'fee_percentage');
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                    'rate': feeRate,
                };
                takerOrMaker = this.safeStringLower (feeInfo, 'fee_type');
            }
            return {
                'id': this.safeString2 (trade, 'trade_id', 'sequence'),
                'order': this.safeString (trade, 'order_id'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'takerOrMaker': takerOrMaker,
                'fee': fee,
                'info': trade,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_code': market['id'],
                // 'from': this.iso8601 (since),
                // 'to': this.iso8601 (this.milliseconds ()),
            };
            if (since !== undefined) {
                // returns price ticks for a specific market with an interval of maximum of 4 hours
                // sorted by latest first
                request['from'] = this.iso8601 (since);
                request['to'] = this.iso8601 (this.sum (since, 14400000));
            }
            const response = await this.publicGetPriceTicksInstrumentCode (this.extend (request, params));
            //
            //     [
            //         {
            //             "instrument_code":"BTC_EUR",
            //             "price":"8137.28",
            //             "amount":"0.22269",
            //             "taker_side":"BUY",
            //             "volume":"1812.0908832",
            //             "time":"2020-07-10T14:44:32.299Z",
            //             "trade_timestamp":1594392272299,
            //             "sequence":603047
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccountBalances (params);
            //
            //     {
            //         "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
            //         "balances":[
            //             {
            //                 "account_id":"4b95934f-55f1-460c-a525-bd5afc0cf071",
            //                 "currency_code":"BTC",
            //                 "change":"10.0",
            //                 "available":"10.0",
            //                 "locked":"0.0",
            //                 "sequence":142135994,
            //                 "time":"2020-07-01T10:57:32.959Z"
            //             }
            //         ]
            //     }
            //
            const balances = this.safeValue (response, 'balances', []);
            const result = { 'info': response };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency_code');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'locked');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseDepositAddress (depositAddress, currency = undefined) {
            let code = undefined;
            if (currency !== undefined) {
                code = currency['code'];
            }
            const address = this.safeString (depositAddress, 'address');
            const tag = this.safeString (depositAddress, 'destination_tag');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': depositAddress,
            };
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privatePostAccountDepositCrypto (this.extend (request, params));
            //
            //     {
            //         "address":"rBnNhk95FrdNisZtXcStzriFS8vEzz53DM",
            //         "destination_tag":"865690307",
            //         "enabled":true,
            //         "is_smart_contract":false
            //     }
            //
            return this.parseDepositAddress (response, currency);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency_code': currency['id'],
            };
            const response = await this.privateGetAccountDepositCryptoCurrencyCode (this.extend (request, params));
            //
            //     {
            //         "address":"rBnNhk95FrdNisZtXcStzriFS8vEzz53DM",
            //         "destination_tag":"865690307",
            //         "enabled":true,
            //         "is_smart_contract":false,
            //         "can_create_more":false
            //     }
            //
            return this.parseDepositAddress (response, currency);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'cursor': 'string', // pointer specifying the position from which the next pages should be returned
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency_code'] = currency['id'];
            }
            if (limit !== undefined) {
                request['max_page_size'] = limit;
            }
            if (since !== undefined) {
                const to = this.safeString (params, 'to');
                if (to === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchDeposits() requires a "to" iso8601 string param with the since argument is specified');
                }
                request['from'] = this.iso8601 (since);
            }
            const response = await this.privateGetAccountDeposits (this.extend (request, params));
            //
            //     {
            //         "deposit_history": [
            //             {
            //                 "transaction_id": "e5342efcd-d5b7-4a56-8e12-b69ffd68c5ef",
            //                 "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
            //                 "amount": "100",
            //                 "type": "CRYPTO",
            //                 "funds_source": "INTERNAL",
            //                 "time": "2020-04-22T09:57:47Z",
            //                 "currency": "BTC",
            //                 "fee_amount": "0.0",
            //                 "fee_currency": "BTC"
            //             },
            //             {
            //                 "transaction_id": "79793d00-2899-4a4d-95b7-73ae6b31384f",
            //                 "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
            //                 "time": "2020-05-05T11:22:07.925Z",
            //                 "currency": "EUR",
            //                 "funds_source": "EXTERNAL",
            //                 "type": "FIAT",
            //                 "amount": "50.0",
            //                 "fee_amount": "0.01",
            //                 "fee_currency": "EUR"
            //             }
            //         ],
            //         "max_page_size": 2,
            //         "cursor": "eyJhY2NvdW50X2lkIjp7InMiOiJlMzY5YWM4MC00NTc3LTExZTktYWUwOC05YmVkYzQ3OTBiODQiLCJzcyI6W10sIm5zIjpbXSwiYnMiOltdLCJtIjp7fSwibCI6W119LCJpdGVtX2tleSI6eyJzIjoiV0lUSERSQVdBTDo6MmFlMjYwY2ItOTk3MC00YmNiLTgxNmEtZGY4MDVmY2VhZTY1Iiwic3MiOltdLCJucyI6W10sImJzIjpbXSwibSI6e30sImwiOltdfSwiZ2xvYmFsX3dpdGhkcmF3YWxfaW5kZXhfaGFzaF9rZXkiOnsicyI6ImUzNjlhYzgwLTQ1NzctMTFlOS1hZTA4LTliZWRjNDc5MGI4NCIsInNzIjpbXSwibnMiOltdLCJicyI6W10sIm0iOnt9LCJsIjpbXX0sInRpbWVzdGFtcCI6eyJuIjoiMTU4ODA1ODc2Nzk0OCIsInNzIjpbXSwibnMiOltdLCJicyI6W10sIm0iOnt9LCJsIjpbXX19"
            //     }
            //
            const depositHistory = this.safeValue (response, 'deposit_history', []);
            return this.parseTransactions (depositHistory, currency, since, limit, { 'type': 'deposit' });
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'cursor': 'string', // pointer specifying the position from which the next pages should be returned
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency_code'] = currency['id'];
            }
            if (limit !== undefined) {
                request['max_page_size'] = limit;
            }
            if (since !== undefined) {
                const to = this.safeString (params, 'to');
                if (to === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchWithdrawals() requires a "to" iso8601 string param with the since argument is specified');
                }
                request['from'] = this.iso8601 (since);
            }
            const response = await this.privateGetAccountWithdrawals (this.extend (request, params));
            //
            //     {
            //         "withdrawal_history": [
            //             {
            //                 "account_id": "e369ac80-4577-11e9-ae08-9bedc4790b84",
            //                 "amount": "0.1",
            //                 "currency": "BTC",
            //                 "fee_amount": "0.00002",
            //                 "fee_currency": "BTC",
            //                 "funds_source": "EXTERNAL",
            //                 "related_transaction_id": "e298341a-3855-405e-bce3-92db368a3157",
            //                 "time": "2020-05-05T11:11:32.110Z",
            //                 "transaction_id": "6693ff40-bb10-4dcf-ada7-3b287727c882",
            //                 "type": "CRYPTO"
            //             },
            //             {
            //                 "account_id": "e369ac80-4577-11e9-ae08-9bedc4790b84",
            //                 "amount": "0.1",
            //                 "currency": "BTC",
            //                 "fee_amount": "0.0",
            //                 "fee_currency": "BTC",
            //                 "funds_source": "INTERNAL",
            //                 "time": "2020-05-05T10:29:53.464Z",
            //                 "transaction_id": "ec9703b1-954b-4f76-adea-faac66eabc0b",
            //                 "type": "CRYPTO"
            //             }
            //         ],
            //         "cursor": "eyJhY2NvdW50X2lkIjp7InMiOiJlMzY5YWM4MC00NTc3LTExZTktYWUwOC05YmVkYzQ3OTBiODQiLCJzcyI6W10sIm5zIjpbXSwiYnMiOltdLCJtIjp7fSwibCI6W119LCJpdGVtX2tleSI6eyJzIjoiV0lUSERSQVdBTDo6ZWM5NzAzYjEtOTU0Yi00Zjc2LWFkZWEtZmFhYzY2ZWFiYzBiIiwic3MiOltdLCJucyI6W10sImJzIjpbXSwibSI6e30sImwiOltdfSwiZ2xvYmFsX3dpdGhkcmF3YWxfaW5kZXhfaGFzaF9rZXkiOnsicyI6ImUzNjlhYzgwLTQ1NzctMTFlOS1hZTA4LTliZWRjNDc5MGI4NCIsInNzIjpbXSwibnMiOltdLCJicyI6W10sIm0iOnt9LCJsIjpbXX0sInRpbWVzdGFtcCI6eyJuIjoiMTU4ODY3NDU5MzQ2NCIsInNzIjpbXSwibnMiOltdLCJicyI6W10sIm0iOnt9LCJsIjpbXX19",
            //         "max_page_size": 2
            //     }
            //
            const withdrawalHistory = this.safeValue (response, 'withdrawal_history', []);
            return this.parseTransactions (withdrawalHistory, currency, since, limit, { 'type': 'withdrawal' });
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': code,
                'amount': this.currencyToPrecision (code, amount),
                // 'payout_account_id': '66756a10-3e86-48f4-9678-b634c4b135b2', // fiat only
                // 'recipient': { // crypto only
                //     'address': address,
                //     // 'destination_tag': '',
                // },
            };
            const options = this.safeValue (this.options, 'fiat', []);
            const isFiat = this.inArray (code, options);
            const method = isFiat ? 'privatePostAccountWithdrawFiat' : 'privatePostAccountWithdrawCrypto';
            if (isFiat) {
                const payoutAccountId = this.safeString (params, 'payout_account_id');
                if (payoutAccountId === undefined) {
                    throw ArgumentsRequired (this.id + ' withdraw() requires a payout_account_id param for fiat ' + code + ' withdrawals');
                }
            } else {
                const recipient = { 'address': address };
                if (tag !== undefined) {
                    recipient['destination_tag'] = tag;
                }
                request['recipient'] = recipient;
            }
            const response = await this[method] (this.extend (request, params));
            //
            // crypto
            //
            //     {
            //         "amount": "1234.5678",
            //         "fee": "1234.5678",
            //         "recipient": "3NacQ7rzZdhfyAtfJ5a11k8jFPdcMP2Bq7",
            //         "destination_tag": "",
            //         "transaction_id": "d0f8529f-f832-4e6a-9dc5-b8d5797badb2"
            //     }
            //
            // fiat
            //
            //     {
            //         "transaction_id": "54236cd0-4413-11e9-93fb-5fea7e5b5df6"
            //     }
            //
            return this.parseTransaction (response, currency);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits, fetchWithdrawals
            //
            //     {
            //         "transaction_id": "C2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
            //         "type": "FIAT",
            //         "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
            //         "amount": "1234.5678",
            //         "time": "2019-08-24T14:15:22Z",
            //         "funds_source": "INTERNAL",
            //         "currency": "BTC",
            //         "fee_amount": "1234.5678",
            //         "fee_currency": "BTC",
            //         "blockchain_transaction_id": "f4184fc596403b9d638783cf57adfe4c75c605f6356fbc91338530e9831e9e16",
            //         "related_transaction_id": "e298341a-3855-405e-bce3-92db368a3157"
            //     }
            //
            // withdraw
            //
            //
            //     crypto
            //
            //     {
            //         "amount": "1234.5678",
            //         "fee": "1234.5678",
            //         "recipient": "3NacQ7rzZdhfyAtfJ5a11k8jFPdcMP2Bq7",
            //         "destination_tag": "",
            //         "transaction_id": "d0f8529f-f832-4e6a-9dc5-b8d5797badb2"
            //     }
            //
            //     fiat
            //
            //     {
            //         "transaction_id": "54236cd0-4413-11e9-93fb-5fea7e5b5df6"
            //     }
            //
            const id = this.safeString (transaction, 'transaction_id');
            const amount = this.safeNumber (transaction, 'amount');
            const timestamp = this.parse8601 (this.safeString (transaction, 'time'));
            const currencyId = this.safeString (transaction, 'currency');
            currency = this.safeCurrency (currencyId, currency);
            const status = 'ok'; // the exchange returns cleared transactions only
            const feeCost = this.safeNumber2 (transaction, 'fee_amount', 'fee');
            let fee = undefined;
            const addressTo = this.safeString (transaction, 'recipient');
            const tagTo = this.safeString (transaction, 'destination_tag');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (transaction, 'fee_currency', currencyId);
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'info': transaction,
                'id': id,
                'currency': currency['code'],
                'amount': amount,
                'address': addressTo,
                'addressFrom': undefined,
                'addressTo': addressTo,
                'tag': tagTo,
                'tagFrom': undefined,
                'tagTo': tagTo,
                'status': status,
                'type': undefined,
                'updated': undefined,
                'txid': this.safeString (transaction, 'blockchain_transaction_id'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': fee,
            };
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'FILLED': 'open',
                'FILLED_FULLY': 'closed',
                'FILLED_CLOSED': 'canceled',
                'FILLED_REJECTED': 'rejected',
                'OPEN': 'open',
                'REJECTED': 'rejected',
                'CLOSED': 'canceled',
                'FAILED': 'failed',
                'STOP_TRIGGERED': 'triggered',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "order_id": "d5492c24-2995-4c18-993a-5b8bf8fffc0d",
            //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
            //         "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //         "instrument_code": "BTC_EUR",
            //         "time": "2019-08-01T08:00:44.026Z",
            //         "side": "BUY",
            //         "price": "5000",
            //         "amount": "1",
            //         "filled_amount": "0.5",
            //         "type": "LIMIT",
            //         "time_in_force": "GOOD_TILL_CANCELLED"
            //     }
            //
            // fetchOrder, fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "order": {
            //             "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
            //             "account_id": "1eb2ad5d-55f1-40b5-bc92-7dc05869e905",
            //             "instrument_code": "BTC_EUR",
            //             "amount": "1234.5678",
            //             "filled_amount": "1234.5678",
            //             "side": "BUY",
            //             "type": "LIMIT",
            //             "status": "OPEN",
            //             "sequence": 123456789,
            //             "price": "1234.5678",
            //             "average_price": "1234.5678",
            //             "reason": "INSUFFICIENT_FUNDS",
            //             "time": "2019-08-24T14:15:22Z",
            //             "time_in_force": "GOOD_TILL_CANCELLED",
            //             "time_last_updated": "2019-08-24T14:15:22Z",
            //             "expire_after": "2019-08-24T14:15:22Z",
            //             "is_post_only": false,
            //             "time_triggered": "2019-08-24T14:15:22Z",
            //             "trigger_price": "1234.5678"
            //         },
            //         "trades": [
            //             {
            //                 "fee": {
            //                     "fee_amount": "0.0014",
            //                     "fee_currency": "BTC",
            //                     "fee_percentage": "0.1",
            //                     "fee_group_id": "default",
            //                     "fee_type": "TAKER",
            //                     "running_trading_volume": "0.0"
            //                 },
            //                 "trade": {
            //                     "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
            //                     "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
            //                     "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //                     "amount": "1.4",
            //                     "side": "BUY",
            //                     "instrument_code": "BTC_EUR",
            //                     "price": "7341.4",
            //                     "time": "2019-09-27T15:05:32.564Z",
            //                     "sequence": 48670
            //                 }
            //             }
            //         ]
            //     }
            //
            const rawOrder = this.safeValue (order, 'order', order);
            const id = this.safeString (rawOrder, 'order_id');
            const clientOrderId = this.safeString (rawOrder, 'client_id');
            const timestamp = this.parse8601 (this.safeString (rawOrder, 'time'));
            const rawStatus = this.parseOrderStatus (this.safeString (rawOrder, 'status'));
            const status = this.parseOrderStatus (rawStatus);
            const marketId = this.safeString (rawOrder, 'instrument_code');
            const symbol = this.safeSymbol (marketId, market, '_');
            const price = this.safeNumber (rawOrder, 'price');
            const amount = this.safeNumber (rawOrder, 'amount');
            const filledString = this.safeString (rawOrder, 'filled_amount');
            const filled = this.parseNumber (filledString);
            const side = this.safeStringLower (rawOrder, 'side');
            const type = this.safeStringLower (rawOrder, 'type');
            const timeInForce = this.parseTimeInForce (this.safeString (rawOrder, 'time_in_force'));
            const stopPrice = this.safeNumber (rawOrder, 'trigger_price');
            const postOnly = this.safeValue (rawOrder, 'is_post_only');
            const rawTrades = this.safeValue (order, 'trades', []);
            const trades = this.parseTrades (rawTrades, market, undefined, undefined, {
                'type': type,
            });
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': undefined,
                'average': undefined,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                // 'fee': undefined,
                'trades': trades,
            });
        }
    
        parseTimeInForce (timeInForce) {
            const timeInForces = {
                'GOOD_TILL_CANCELLED': 'GTC',
                'GOOD_TILL_TIME': 'GTT',
                'IMMEDIATE_OR_CANCELLED': 'IOC',
                'FILL_OR_KILL': 'FOK',
            };
            return this.safeString (timeInForces, timeInForce, timeInForce);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const uppercaseType = type.toUpperCase ();
            const request = {
                'instrument_code': market['id'],
                'type': uppercaseType, // LIMIT, MARKET, STOP
                'side': side.toUpperCase (), // or SELL
                'amount': this.amountToPrecision (symbol, amount),
                // "price": "1234.5678", // required for LIMIT and STOP orders
                // "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206", // optional
                // "time_in_force": "GOOD_TILL_CANCELLED", // limit orders only, GOOD_TILL_CANCELLED, GOOD_TILL_TIME, IMMEDIATE_OR_CANCELLED and FILL_OR_KILL
                // "expire_after": "2020-07-02T19:40:13Z", // required for GOOD_TILL_TIME
                // "is_post_only": false, // limit orders only, optional
                // "trigger_price": "1234.5678" // required for stop orders
            };
            let priceIsRequired = false;
            if (uppercaseType === 'LIMIT' || uppercaseType === 'STOP') {
                priceIsRequired = true;
            }
            if (uppercaseType === 'STOP') {
                const triggerPrice = this.safeNumber (params, 'trigger_price');
                if (triggerPrice === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a trigger_price param for ' + type + ' orders');
                }
                request['trigger_price'] = this.priceToPrecision (symbol, triggerPrice);
                params = this.omit (params, 'trigger_price');
            }
            if (priceIsRequired) {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client_id');
            if (clientOrderId !== undefined) {
                request['client_id'] = clientOrderId;
                params = this.omit (params, [ 'clientOrderId', 'client_id' ]);
            }
            const response = await this.privatePostAccountOrders (this.extend (request, params));
            //
            //     {
            //         "order_id": "d5492c24-2995-4c18-993a-5b8bf8fffc0d",
            //         "client_id": "d75fb03b-b599-49e9-b926-3f0b6d103206",
            //         "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //         "instrument_code": "BTC_EUR",
            //         "time": "2019-08-01T08:00:44.026Z",
            //         "side": "BUY",
            //         "price": "5000",
            //         "amount": "1",
            //         "filled_amount": "0.5",
            //         "type": "LIMIT",
            //         "time_in_force": "GOOD_TILL_CANCELLED"
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client_id');
            params = this.omit (params, [ 'clientOrderId', 'client_id' ]);
            let method = 'privateDeleteAccountOrdersOrderId';
            const request = {};
            if (clientOrderId !== undefined) {
                method = 'privateDeleteAccountOrdersClientClientId';
                request['client_id'] = clientOrderId;
            } else {
                request['order_id'] = id;
            }
            const response = await this[method] (this.extend (request, params));
            //
            // responds with an empty body
            //
            return response;
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbol !== undefined) {
                const market = this.market (symbol);
                request['instrument_code'] = market['id'];
            }
            const response = await this.privateDeleteAccountOrders (this.extend (request, params));
            //
            //     [
            //         "a10e9bd1-8f72-4cfe-9f1b-7f1c8a9bd8ee"
            //     ]
            //
            return response;
        }
    
        async cancelOrders (ids, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'ids': ids.join (','),
            };
            const response = await this.privateDeleteAccountOrders (this.extend (request, params));
            //
            //     [
            //         "a10e9bd1-8f72-4cfe-9f1b-7f1c8a9bd8ee"
            //     ]
            //
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privateGetAccountOrdersOrderId (this.extend (request, params));
            //
            //     {
            //         "order": {
            //             "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
            //             "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //             "time_last_updated": "2019-09-27T15:05:35.096Z",
            //             "sequence": 48782,
            //             "price": "7349.2",
            //             "filled_amount": "100.0",
            //             "status": "FILLED_FULLY",
            //             "amount": "100.0",
            //             "instrument_code": "BTC_EUR",
            //             "side": "BUY",
            //             "time": "2019-09-27T15:05:32.063Z",
            //             "type": "MARKET"
            //         },
            //         "trades": [
            //             {
            //                 "fee": {
            //                     "fee_amount": "0.0014",
            //                     "fee_currency": "BTC",
            //                     "fee_percentage": "0.1",
            //                     "fee_group_id": "default",
            //                     "fee_type": "TAKER",
            //                     "running_trading_volume": "0.0"
            //                 },
            //                 "trade": {
            //                     "trade_id": "fdff2bcc-37d6-4a2d-92a5-46e09c868664",
            //                     "order_id": "36bb2437-7402-4794-bf26-4bdf03526439",
            //                     "account_id": "a4c699f6-338d-4a26-941f-8f9853bfc4b9",
            //                     "amount": "1.4",
            //                     "side": "BUY",
            //                     "instrument_code": "BTC_EUR",
            //                     "price": "7341.4",
            //                     "time": "2019-09-27T15:05:32.564Z",
            //                     "sequence": 48670
            //                 }
            //             }
            //         ]
            //     }
            //
            return this.parseOrder (response);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'from': this.iso8601 (since),
                // 'to': this.iso8601 (this.milliseconds ()), // max range is 100 days
                // 'instrument_code': market['id'],
                // 'with_cancelled_and_rejected': false, // default is false, orders which have been cancelled by the user before being filled or rejected by the system as invalid, additionally, all inactive filled orders which would return with "with_just_filled_inactive"
                // 'with_just_filled_inactive': false, // orders which have been filled and are no longer open, use of "with_cancelled_and_rejected" extends "with_just_filled_inactive" and in case both are specified the latter is ignored
                // 'with_just_orders': false, // do not return any trades corresponsing to the orders, it may be significanly faster and should be used if user is not interesting in trade information
                // 'max_page_size': 100,
                // 'cursor': 'string', // pointer specifying the position from which the next pages should be returned
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['instrument_code'] = market['id'];
            }
            if (since !== undefined) {
                const to = this.safeString (params, 'to');
                if (to === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchOrders() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');
                }
                request['from'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['max_page_size'] = limit;
            }
            const response = await this.privateGetAccountOrders (this.extend (request, params));
            //
            //     {
            //         "order_history": [
            //             {
            //                 "order": {
            //                     "trigger_price": "12089.88",
            //                     "order_id": "d453ca12-c650-46dd-9dee-66910d96bfc0",
            //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                     "instrument_code": "BTC_USDT",
            //                     "time": "2019-08-23T10:02:31.663Z",
            //                     "side": "SELL",
            //                     "price": "10159.76",
            //                     "average_price": "10159.76",
            //                     "amount": "0.2",
            //                     "filled_amount": "0.2",
            //                     "type": "STOP",
            //                     "sequence": 8,
            //                     "status": "FILLED_FULLY"
            //                 },
            //                 "trades": [
            //                     {
            //                         "fee": {
            //                             "fee_amount": "0.4188869",
            //                             "fee_currency": "USDT",
            //                             "fee_percentage": "0.1",
            //                             "fee_group_id": "default",
            //                             "fee_type": "TAKER",
            //                             "running_trading_volume": "0.0"
            //                         },
            //                         "trade": {
            //                             "trade_id": "ec82896f-fd1b-4cbb-89df-a9da85ccbb4b",
            //                             "order_id": "d453ca12-c650-46dd-9dee-66910d96bfc0",
            //                             "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                             "amount": "0.2",
            //                             "side": "SELL",
            //                             "instrument_code": "BTC_USDT",
            //                             "price": "10159.76",
            //                             "time": "2019-08-23T10:02:32.663Z",
            //                             "sequence": 9
            //                         }
            //                     }
            //                 ]
            //             },
            //             {
            //                 "order": {
            //                     "order_id": "5151a99e-f414-418f-8cf1-2568d0a63ea5",
            //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                     "instrument_code": "BTC_USDT",
            //                     "time": "2019-08-23T10:01:36.773Z",
            //                     "side": "SELL",
            //                     "price": "12289.88",
            //                     "amount": "0.5",
            //                     "filled_amount": "0.0",
            //                     "type": "LIMIT",
            //                     "sequence": 7,
            //                     "status": "OPEN"
            //                 },
            //                 "trades": []
            //             },
            //             {
            //                 "order": {
            //                     "order_id": "ac80d857-75e1-4733-9070-fd4288395fdc",
            //                     "account_id": "ef3a5f4c-cfcd-415e-ba89-5a9abf47b28a",
            //                     "instrument_code": "BTC_USDT",
            //                     "time": "2019-08-23T10:01:25.031Z",
            //                     "side": "SELL",
            //                     "price": "11089.88",
            //                     "amount": "0.1",
            //                     "filled_amount": "0.0",
            //                     "type": "LIMIT",
            //                     "sequence": 6,
            //                     "status": "OPEN"
            //                 },
            //                 "trades": []
            //             }
            //         ],
            //         "max_page_size": 100
            //     }
            //
            const orderHistory = this.safeValue (response, 'order_history', []);
            return this.parseOrders (orderHistory, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'with_cancelled_and_rejected': true, // default is false, orders which have been cancelled by the user before being filled or rejected by the system as invalid, additionally, all inactive filled orders which would return with "with_just_filled_inactive"
            };
            return await this.fetchOpenOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
                // 'max_page_size': 100,
                // 'cursor': 'string', // pointer specifying the position from which the next pages should be returned
            };
            if (limit !== undefined) {
                request['max_page_size'] = limit;
            }
            const response = await this.privateGetAccountOrdersOrderIdTrades (this.extend (request, params));
            //
            //     {
            //         "trade_history": [
            //             {
            //                 "trade": {
            //                     "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
            //                     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
            //                     "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
            //                     "amount": "1234.5678",
            //                     "side": "BUY",
            //                     "instrument_code": "BTC_EUR",
            //                     "price": "1234.5678",
            //                     "time": "2019-08-24T14:15:22Z",
            //                     "price_tick_sequence": 0,
            //                     "sequence": 123456789
            //                 },
            //                 "fee": {
            //                     "fee_amount": "1234.5678",
            //                     "fee_percentage": "1234.5678",
            //                     "fee_group_id": "default",
            //                     "running_trading_volume": "1234.5678",
            //                     "fee_currency": "BTC",
            //                     "fee_type": "TAKER"
            //                 }
            //             }
            //         ],
            //         "max_page_size": 0,
            //         "cursor": "string"
            //     }
            //
            const tradeHistory = this.safeValue (response, 'trade_history', []);
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            return this.parseTrades (tradeHistory, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'from': this.iso8601 (since),
                // 'to': this.iso8601 (this.milliseconds ()), // max range is 100 days
                // 'instrument_code': market['id'],
                // 'max_page_size': 100,
                // 'cursor': 'string', // pointer specifying the position from which the next pages should be returned
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['instrument_code'] = market['id'];
            }
            if (since !== undefined) {
                const to = this.safeString (params, 'to');
                if (to === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a "to" iso8601 string param with the since argument is specified, max range is 100 days');
                }
                request['from'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['max_page_size'] = limit;
            }
            const response = await this.privateGetAccountTrades (this.extend (request, params));
            //
            //     {
            //         "trade_history": [
            //             {
            //                 "trade": {
            //                     "trade_id": "2b42efcd-d5b7-4a56-8e12-b69ffd68c5ef",
            //                     "order_id": "66756a10-3e86-48f4-9678-b634c4b135b2",
            //                     "account_id": "c2d0076a-c20d-41f8-9e9a-1a1d028b2b58",
            //                     "amount": "1234.5678",
            //                     "side": "BUY",
            //                     "instrument_code": "BTC_EUR",
            //                     "price": "1234.5678",
            //                     "time": "2019-08-24T14:15:22Z",
            //                     "price_tick_sequence": 0,
            //                     "sequence": 123456789
            //                 },
            //                 "fee": {
            //                     "fee_amount": "1234.5678",
            //                     "fee_percentage": "1234.5678",
            //                     "fee_group_id": "default",
            //                     "running_trading_volume": "1234.5678",
            //                     "fee_currency": "BTC",
            //                     "fee_type": "TAKER"
            //                 }
            //             }
            //         ],
            //         "max_page_size": 0,
            //         "cursor": "string"
            //     }
            //
            const tradeHistory = this.safeValue (response, 'trade_history', []);
            return this.parseTrades (tradeHistory, market, since, limit);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else if (api === 'private') {
                this.checkRequiredCredentials ();
                headers = {
                    'Accept': 'application/json',
                    'Authorization': 'Bearer ' + this.apiKey,
                };
                if (method === 'POST') {
                    body = this.json (query);
                    headers['Content-Type'] = 'application/json';
                } else {
                    if (Object.keys (query).length) {
                        url += '?' + this.urlencode (query);
                    }
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            //
            //     {"error":"MISSING_FROM_PARAM"}
            //     {"error":"MISSING_TO_PARAM"}
            //     {"error":"CANDLESTICKS_TIME_RANGE_TOO_BIG"}
            //
            const message = this.safeString (response, 'error');
            if (message !== undefined) {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/errors":9}],42:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, InvalidNonce, AuthenticationError, OrderNotFound } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitso extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitso',
                'name': 'Bitso',
                'countries': [ 'MX' ], // Mexico
                'rateLimit': 2000, // 30 requests per minute
                'version': 'v3',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchDepositAddress': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'withdraw': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87295554-11f98280-c50e-11ea-80d6-15b3bafa8cbf.jpg',
                    'api': 'https://api.bitso.com',
                    'www': 'https://bitso.com',
                    'doc': 'https://bitso.com/api_info',
                    'fees': 'https://bitso.com/fees',
                    'referral': 'https://bitso.com/?ref=itej',
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    'precision': {
                        'XRP': 0.000001,
                        'MXN': 0.01,
                        'TUSD': 0.01,
                    },
                    'defaultPrecision': 0.00000001,
                },
                'api': {
                    'public': {
                        'get': [
                            'available_books',
                            'ticker',
                            'order_book',
                            'trades',
                        ],
                    },
                    'private': {
                        'get': [
                            'account_status',
                            'balance',
                            'fees',
                            'fundings',
                            'fundings/{fid}',
                            'funding_destination',
                            'kyc_documents',
                            'ledger',
                            'ledger/trades',
                            'ledger/fees',
                            'ledger/fundings',
                            'ledger/withdrawals',
                            'mx_bank_codes',
                            'open_orders',
                            'order_trades/{oid}',
                            'orders/{oid}',
                            'user_trades',
                            'user_trades/{tid}',
                            'withdrawals/',
                            'withdrawals/{wid}',
                        ],
                        'post': [
                            'bitcoin_withdrawal',
                            'debit_card_withdrawal',
                            'ether_withdrawal',
                            'ripple_withdrawal',
                            'bcash_withdrawal',
                            'litecoin_withdrawal',
                            'orders',
                            'phone_number',
                            'phone_verification',
                            'phone_withdrawal',
                            'spei_withdrawal',
                            'ripple_withdrawal',
                            'bcash_withdrawal',
                            'litecoin_withdrawal',
                        ],
                        'delete': [
                            'orders/{oid}',
                            'orders/all',
                        ],
                    },
                },
                'exceptions': {
                    '0201': AuthenticationError, // Invalid Nonce or Invalid Credentials
                    '104': InvalidNonce, // Cannot perform request - nonce must be higher than 1520307203724237
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetAvailableBooks (params);
            //
            //     {
            //         "success":true,
            //         "payload":[
            //             {
            //                 "book":"btc_mxn",
            //                 "minimum_price":"500",
            //                 "maximum_price":"10000000",
            //                 "minimum_amount":"0.00005",
            //                 "maximum_amount":"500",
            //                 "minimum_value":"5",
            //                 "maximum_value":"10000000",
            //                 "tick_size":"0.01",
            //                 "fees":{
            //                     "flat_rate":{"maker":"0.500","taker":"0.650"},
            //                     "structure":[
            //                         {"volume":"1500000","maker":"0.00500","taker":"0.00650"},
            //                         {"volume":"2000000","maker":"0.00490","taker":"0.00637"},
            //                         {"volume":"5000000","maker":"0.00480","taker":"0.00624"},
            //                         {"volume":"7000000","maker":"0.00440","taker":"0.00572"},
            //                         {"volume":"10000000","maker":"0.00420","taker":"0.00546"},
            //                         {"volume":"15000000","maker":"0.00400","taker":"0.00520"},
            //                         {"volume":"35000000","maker":"0.00370","taker":"0.00481"},
            //                         {"volume":"50000000","maker":"0.00300","taker":"0.00390"},
            //                         {"volume":"150000000","maker":"0.00200","taker":"0.00260"},
            //                         {"volume":"250000000","maker":"0.00100","taker":"0.00130"},
            //                         {"volume":"9999999999","maker":"0.00000","taker":"0.00130"},
            //                     ]
            //                 }
            //             },
            //         ]
            //     }
            const markets = this.safeValue (response, 'payload');
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'book');
                const [ baseId, quoteId ] = id.split ('_');
                let base = baseId.toUpperCase ();
                let quote = quoteId.toUpperCase ();
                base = this.safeCurrencyCode (base);
                quote = this.safeCurrencyCode (quote);
                const symbol = base + '/' + quote;
                const limits = {
                    'amount': {
                        'min': this.safeNumber (market, 'minimum_amount'),
                        'max': this.safeNumber (market, 'maximum_amount'),
                    },
                    'price': {
                        'min': this.safeNumber (market, 'minimum_price'),
                        'max': this.safeNumber (market, 'maximum_price'),
                    },
                    'cost': {
                        'min': this.safeNumber (market, 'minimum_value'),
                        'max': this.safeNumber (market, 'maximum_value'),
                    },
                };
                const defaultPricePrecision = this.safeNumber (this.options['precision'], quote, this.options['defaultPrecision']);
                const pricePrecision = this.safeNumber (market, 'tick_size', defaultPricePrecision);
                const precision = {
                    'amount': this.safeNumber (this.options['precision'], base, this.options['defaultPrecision']),
                    'price': pricePrecision,
                };
                const fees = this.safeValue (market, 'fees', {});
                const flatRate = this.safeValue (fees, 'flat_rate', {});
                const makerString = this.safeString (flatRate, 'maker');
                const takerString = this.safeString (flatRate, 'taker');
                const maker = this.parseNumber (Precise.stringDiv (makerString, '100'));
                const taker = this.parseNumber (Precise.stringDiv (takerString, '100'));
                const feeTiers = this.safeValue (fees, 'structure', []);
                const fee = {
                    'taker': taker,
                    'maker': maker,
                    'percentage': true,
                    'tierBased': true,
                };
                const takerFees = [];
                const makerFees = [];
                for (let j = 0; j < feeTiers.length; j++) {
                    const tier = feeTiers[j];
                    const volume = this.safeNumber (tier, 'volume');
                    const takerFee = this.safeNumber (tier, 'taker');
                    const makerFee = this.safeNumber (tier, 'maker');
                    takerFees.push ([ volume, takerFee ]);
                    makerFees.push ([ volume, makerFee ]);
                    if (j === 0) {
                        fee['taker'] = takerFee;
                        fee['maker'] = makerFee;
                    }
                }
                const tiers = {
                    'taker': takerFees,
                    'maker': makerFees,
                };
                fee['tiers'] = tiers;
                result.push (this.extend ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                    'limits': limits,
                    'precision': precision,
                    'active': undefined,
                }, fee));
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetBalance (params);
            //
            //     {
            //       "success": true,
            //       "payload": {
            //         "balances": [
            //           {
            //             "currency": "bat",
            //             "available": "0.00000000",
            //             "locked": "0.00000000",
            //             "total": "0.00000000",
            //             "pending_deposit": "0.00000000",
            //             "pending_withdrawal": "0.00000000"
            //           },
            //           {
            //             "currency": "bch",
            //             "available": "0.00000000",
            //             "locked": "0.00000000",
            //             "total": "0.00000000",
            //             "pending_deposit": "0.00000000",
            //             "pending_withdrawal": "0.00000000"
            //           },
            //         ],
            //       },
            //     }
            //
            const payload = this.safeValue (response, 'payload', {});
            const balances = this.safeValue (payload, 'balances');
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'locked');
                account['total'] = this.safeString (balance, 'total');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'book': this.marketId (symbol),
            };
            const response = await this.publicGetOrderBook (this.extend (request, params));
            const orderbook = this.safeValue (response, 'payload');
            const timestamp = this.parse8601 (this.safeString (orderbook, 'updated_at'));
            return this.parseOrderBook (orderbook, symbol, timestamp, 'bids', 'asks', 'price', 'amount');
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const request = {
                'book': this.marketId (symbol),
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const ticker = this.safeValue (response, 'payload');
            const timestamp = this.parse8601 (this.safeString (ticker, 'created_at'));
            const vwap = this.safeNumber (ticker, 'vwap');
            const baseVolume = this.safeNumber (ticker, 'volume');
            let quoteVolume = undefined;
            if (baseVolume !== undefined && vwap !== undefined) {
                quoteVolume = baseVolume * vwap;
            }
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.parse8601 (this.safeString (trade, 'created_at'));
            const marketId = this.safeString (trade, 'book');
            const symbol = this.safeSymbol (marketId, market, '_');
            const side = this.safeString2 (trade, 'side', 'maker_side');
            let amount = this.safeNumber2 (trade, 'amount', 'major');
            if (amount !== undefined) {
                amount = Math.abs (amount);
            }
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fees_amount');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'fees_currency');
                const feeCurrency = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
            }
            let cost = this.safeNumber (trade, 'minor');
            if (cost !== undefined) {
                cost = Math.abs (cost);
            }
            const price = this.safeNumber (trade, 'price');
            const orderId = this.safeString (trade, 'oid');
            const id = this.safeString (trade, 'tid');
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'book': market['id'],
            };
            const response = await this.publicGetTrades (this.extend (request, params));
            return this.parseTrades (response['payload'], market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = 25, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            // the don't support fetching trades starting from a date yet
            // use the `marker` extra param for that
            // this is not a typo, the variable name is 'marker' (don't confuse with 'market')
            const markerInParams = ('marker' in params);
            // warn the user with an exception if the user wants to filter
            // starting from since timestamp, but does not set the trade id with an extra 'marker' param
            if ((since !== undefined) && !markerInParams) {
                throw new ExchangeError (this.id + ' fetchMyTrades does not support fetching trades starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id');
            }
            // convert it to an integer unconditionally
            if (markerInParams) {
                params = this.extend (params, {
                    'marker': parseInt (params['marker']),
                });
            }
            const request = {
                'book': market['id'],
                'limit': limit, // default = 25, max = 100
                // 'sort': 'desc', // default = desc
                // 'marker': id, // integer id to start from
            };
            const response = await this.privateGetUserTrades (this.extend (request, params));
            return this.parseTrades (response['payload'], market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'book': this.marketId (symbol),
                'side': side,
                'type': type,
                'major': this.amountToPrecision (symbol, amount),
            };
            if (type === 'limit') {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            const id = this.safeString (response['payload'], 'oid');
            return {
                'info': response,
                'id': id,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'oid': id,
            };
            return await this.privateDeleteOrdersOid (this.extend (request, params));
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'partial-fill': 'open', // this is a common substitution in ccxt
                'completed': 'closed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            const id = this.safeString (order, 'oid');
            const side = this.safeString (order, 'side');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const marketId = this.safeString (order, 'book');
            const symbol = this.safeSymbol (marketId, market, '_');
            const orderType = this.safeString (order, 'type');
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'original_amount');
            const remaining = this.safeNumber (order, 'unfilled_amount');
            const clientOrderId = this.safeString (order, 'client_id');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': orderType,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': undefined,
                'remaining': remaining,
                'filled': undefined,
                'status': status,
                'fee': undefined,
                'average': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = 25, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            // the don't support fetching trades starting from a date yet
            // use the `marker` extra param for that
            // this is not a typo, the variable name is 'marker' (don't confuse with 'market')
            const markerInParams = ('marker' in params);
            // warn the user with an exception if the user wants to filter
            // starting from since timestamp, but does not set the trade id with an extra 'marker' param
            if ((since !== undefined) && !markerInParams) {
                throw new ExchangeError (this.id + ' fetchOpenOrders does not support fetching orders starting from a timestamp with the `since` argument, use the `marker` extra param to filter starting from an integer trade id');
            }
            // convert it to an integer unconditionally
            if (markerInParams) {
                params = this.extend (params, {
                    'marker': parseInt (params['marker']),
                });
            }
            const request = {
                'book': market['id'],
                'limit': limit, // default = 25, max = 100
                // 'sort': 'desc', // default = desc
                // 'marker': id, // integer id to start from
            };
            const response = await this.privateGetOpenOrders (this.extend (request, params));
            const orders = this.parseOrders (response['payload'], market, since, limit);
            return orders;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetOrdersOid ({
                'oid': id,
            });
            const payload = this.safeValue (response, 'payload');
            if (Array.isArray (payload)) {
                const numOrders = response['payload'].length;
                if (numOrders === 1) {
                    return this.parseOrder (payload[0]);
                }
            }
            throw new OrderNotFound (this.id + ': The order ' + id + ' not found.');
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'oid': id,
            };
            const response = await this.privateGetOrderTradesOid (this.extend (request, params));
            return this.parseTrades (response['payload'], market);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'fund_currency': currency['id'],
            };
            const response = await this.privateGetFundingDestination (this.extend (request, params));
            let address = this.safeString (response['payload'], 'account_identifier');
            let tag = undefined;
            if (address.indexOf ('?dt=') >= 0) {
                const parts = address.split ('?dt=');
                address = this.safeString (parts, 0);
                tag = this.safeString (parts, 1);
            }
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const methods = {
                'BTC': 'Bitcoin',
                'ETH': 'Ether',
                'XRP': 'Ripple',
                'BCH': 'Bcash',
                'LTC': 'Litecoin',
            };
            const method = (code in methods) ? methods[code] : undefined;
            if (method === undefined) {
                throw new ExchangeError (this.id + ' not valid withdraw coin: ' + code);
            }
            const request = {
                'amount': amount,
                'address': address,
                'destination_tag': tag,
            };
            const classMethod = 'privatePost' + method + 'Withdrawal';
            const response = await this[classMethod] (this.extend (request, params));
            return {
                'info': response,
                'id': this.safeString (response['payload'], 'wid'),
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let endpoint = '/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (method === 'GET') {
                if (Object.keys (query).length) {
                    endpoint += '?' + this.urlencode (query);
                }
            }
            const url = this.urls['api'] + endpoint;
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                let request = [ nonce, method, endpoint ].join ('');
                if (method !== 'GET') {
                    if (Object.keys (query).length) {
                        body = this.json (query);
                        request += body;
                    }
                }
                const signature = this.hmac (this.encode (request), this.encode (this.secret));
                const auth = this.apiKey + ':' + nonce + ':' + signature;
                headers = {
                    'Authorization': 'Bitso ' + auth,
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if ('success' in response) {
                //
                //     {"success":false,"error":{"code":104,"message":"Cannot perform request - nonce must be higher than 1520307203724237"}}
                //
                let success = this.safeValue (response, 'success', false);
                if (typeof success === 'string') {
                    if ((success === 'true') || (success === '1')) {
                        success = true;
                    } else {
                        success = false;
                    }
                }
                if (!success) {
                    const feedback = this.id + ' ' + this.json (response);
                    const error = this.safeValue (response, 'error');
                    if (error === undefined) {
                        throw new ExchangeError (feedback);
                    }
                    const code = this.safeString (error, 'code');
                    this.throwExactlyMatchedException (this.exceptions, code, feedback);
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],43:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { AuthenticationError, BadRequest, ExchangeError, NotSupported, PermissionDenied, InvalidNonce, OrderNotFound, InsufficientFunds, InvalidAddress, InvalidOrder, ArgumentsRequired, OnMaintenance, ExchangeNotAvailable } = require ('./base/errors');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitstamp extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitstamp',
                'name': 'Bitstamp',
                'countries': [ 'GB' ],
                'rateLimit': 1000,
                'version': 'v2',
                'userAgent': this.userAgents['chrome'],
                'pro': true,
                'has': {
                    'CORS': true,
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchDepositAddress': true,
                    'fetchMarkets': true,
                    'fetchCurrencies': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'fetchTransactions': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                    'fetchTradingFee': true,
                    'fetchTradingFees': true,
                    'fetchFundingFees': true,
                    'fetchFees': true,
                    'fetchLedger': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                    'api': {
                        'public': 'https://www.bitstamp.net/api',
                        'private': 'https://www.bitstamp.net/api',
                    },
                    'www': 'https://www.bitstamp.net',
                    'doc': 'https://www.bitstamp.net/api',
                },
                'timeframes': {
                    '1m': '60',
                    '3m': '180',
                    '5m': '300',
                    '15m': '900',
                    '30m': '1800',
                    '1h': '3600',
                    '2h': '7200',
                    '4h': '14400',
                    '6h': '21600',
                    '12h': '43200',
                    '1d': '86400',
                    '1w': '259200',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'ohlc/{pair}/',
                            'order_book/{pair}/',
                            'ticker_hour/{pair}/',
                            'ticker/{pair}/',
                            'transactions/{pair}/',
                            'trading-pairs-info/',
                        ],
                    },
                    'private': {
                        'post': [
                            'balance/',
                            'balance/{pair}/',
                            'bch_withdrawal/',
                            'bch_address/',
                            'user_transactions/',
                            'user_transactions/{pair}/',
                            'open_orders/all/',
                            'open_orders/{pair}/',
                            'order_status/',
                            'cancel_order/',
                            'cancel_all_orders/',
                            'cancel_all_orders/{pair}/',
                            'buy/{pair}/',
                            'buy/market/{pair}/',
                            'buy/instant/{pair}/',
                            'sell/{pair}/',
                            'sell/market/{pair}/',
                            'sell/instant/{pair}/',
                            'btc_withdrawal/',
                            'btc_address/',
                            'ripple_withdrawal/',
                            'ripple_address/',
                            'ltc_withdrawal/',
                            'ltc_address/',
                            'eth_withdrawal/',
                            'eth_address/',
                            'xrp_withdrawal/',
                            'xrp_address/',
                            'xlm_withdrawal/',
                            'xlm_address/',
                            'pax_withdrawal/',
                            'pax_address/',
                            'link_withdrawal/',
                            'link_address/',
                            'usdc_withdrawal/',
                            'usdc_address/',
                            'omg_withdrawal/',
                            'omg_address/',
                            'dai_withdrawal/',
                            'dai_address/',
                            'knc_withdrawal/',
                            'knc_address/',
                            'mkr_withdrawal/',
                            'mkr_address/',
                            'zrx_withdrawal/',
                            'zrx_address/',
                            'gusd_withdrawal/',
                            'gusd_address/',
                            'aave_withdrawal/',
                            'aave_address/',
                            'bat_withdrawal/',
                            'bat_address/',
                            'uma_withdrawal/',
                            'uma_address/',
                            'snx_withdrawal/',
                            'snx_address/',
                            'uni_withdrawal/',
                            'uni_address/',
                            'yfi_withdrawal/',
                            'yfi_address',
                            'audio_withdrawal/',
                            'audio_address/',
                            'crv_withdrawal/',
                            'crv_address/',
                            'algo_withdrawal/',
                            'algo_address/',
                            'comp_withdrawal/',
                            'comp_address/',
                            'grt_withdrawal',
                            'grt_address/',
                            'usdt_withdrawal/',
                            'usdt_address/',
                            'eurt_withdrawal/',
                            'eurt_address/',
                            'matic_withdrawal/',
                            'matic_address/',
                            'sushi_withdrawal/',
                            'sushi_address/',
                            'chz_withdrawal/',
                            'chz_address/',
                            'enj_withdrawal/',
                            'enj_address/',
                            'alpha_withdrawal/',
                            'alpha_address/',
                            'ftt_withdrawal/',
                            'ftt_address/',
                            'storj_withdrawal/',
                            'storj_address/',
                            'transfer-to-main/',
                            'transfer-from-main/',
                            'withdrawal-requests/',
                            'withdrawal/open/',
                            'withdrawal/status/',
                            'withdrawal/cancel/',
                            'liquidation_address/new/',
                            'liquidation_address/info/',
                            'btc_unconfirmed/',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': this.parseNumber ('0.005'),
                        'maker': this.parseNumber ('0.005'),
                        'tiers': {
                            'taker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.005') ],
                                [ this.parseNumber ('20000'), this.parseNumber ('0.0025') ],
                                [ this.parseNumber ('100000'), this.parseNumber ('0.0024') ],
                                [ this.parseNumber ('200000'), this.parseNumber ('0.0022') ],
                                [ this.parseNumber ('400000'), this.parseNumber ('0.0020') ],
                                [ this.parseNumber ('600000'), this.parseNumber ('0.0015') ],
                                [ this.parseNumber ('1000000'), this.parseNumber ('0.0014') ],
                                [ this.parseNumber ('2000000'), this.parseNumber ('0.0013') ],
                                [ this.parseNumber ('4000000'), this.parseNumber ('0.0012') ],
                                [ this.parseNumber ('20000000'), this.parseNumber ('0.0011') ],
                                [ this.parseNumber ('50000000'), this.parseNumber ('0.0010') ],
                                [ this.parseNumber ('100000000'), this.parseNumber ('0.0007') ],
                                [ this.parseNumber ('500000000'), this.parseNumber ('0.0005') ],
                                [ this.parseNumber ('2000000000'), this.parseNumber ('0.0003') ],
                                [ this.parseNumber ('6000000000'), this.parseNumber ('0.0001') ],
                                [ this.parseNumber ('20000000000'), this.parseNumber ('0.00005') ],
                                [ this.parseNumber ('20000000001'), this.parseNumber ('0') ],
                            ],
                            'maker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.005') ],
                                [ this.parseNumber ('20000'), this.parseNumber ('0.0025') ],
                                [ this.parseNumber ('100000'), this.parseNumber ('0.0024') ],
                                [ this.parseNumber ('200000'), this.parseNumber ('0.0022') ],
                                [ this.parseNumber ('400000'), this.parseNumber ('0.0020') ],
                                [ this.parseNumber ('600000'), this.parseNumber ('0.0015') ],
                                [ this.parseNumber ('1000000'), this.parseNumber ('0.0014') ],
                                [ this.parseNumber ('2000000'), this.parseNumber ('0.0013') ],
                                [ this.parseNumber ('4000000'), this.parseNumber ('0.0012') ],
                                [ this.parseNumber ('20000000'), this.parseNumber ('0.0011') ],
                                [ this.parseNumber ('50000000'), this.parseNumber ('0.0010') ],
                                [ this.parseNumber ('100000000'), this.parseNumber ('0.0007') ],
                                [ this.parseNumber ('500000000'), this.parseNumber ('0.0005') ],
                                [ this.parseNumber ('2000000000'), this.parseNumber ('0.0003') ],
                                [ this.parseNumber ('6000000000'), this.parseNumber ('0.0001') ],
                                [ this.parseNumber ('20000000000'), this.parseNumber ('0.00005') ],
                                [ this.parseNumber ('20000000001'), this.parseNumber ('0') ],
                            ],
                        },
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                        'withdraw': {},
                        'deposit': {
                            'BTC': 0,
                            'BCH': 0,
                            'LTC': 0,
                            'ETH': 0,
                            'XRP': 0,
                            'XLM': 0,
                            'PAX': 0,
                            'USD': 7.5,
                            'EUR': 0,
                        },
                    },
                },
                'exceptions': {
                    'exact': {
                        'No permission found': PermissionDenied,
                        'API key not found': AuthenticationError,
                        'IP address not allowed': PermissionDenied,
                        'Invalid nonce': InvalidNonce,
                        'Invalid signature': AuthenticationError,
                        'Authentication failed': AuthenticationError,
                        'Missing key, signature and nonce parameters': AuthenticationError,
                        'Your account is frozen': PermissionDenied,
                        'Please update your profile with your FATCA information, before using API.': PermissionDenied,
                        'Order not found': OrderNotFound,
                        'Price is more than 20% below market price.': InvalidOrder,
                        'Bitstamp.net is under scheduled maintenance.': OnMaintenance, // { "error": "Bitstamp.net is under scheduled maintenance. We'll be back soon." }
                        'Order could not be placed.': ExchangeNotAvailable, // Order could not be placed (perhaps due to internal error or trade halt). Please retry placing order.
                        'Invalid offset.': BadRequest,
                    },
                    'broad': {
                        'Minimum order size is': InvalidOrder, // Minimum order size is 5.0 EUR.
                        'Check your account balance for details.': InsufficientFunds, // You have only 0.00100000 BTC available. Check your account balance for details.
                        'Ensure this value has at least': InvalidAddress, // Ensure this value has at least 25 characters (it has 4).
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.fetchMarketsFromCache (params);
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const name = this.safeString (market, 'name');
                let [ base, quote ] = name.split ('/');
                const baseId = base.toLowerCase ();
                const quoteId = quote.toLowerCase ();
                base = this.safeCurrencyCode (base);
                quote = this.safeCurrencyCode (quote);
                const symbol = base + '/' + quote;
                const symbolId = baseId + '_' + quoteId;
                const id = this.safeString (market, 'url_symbol');
                const amountPrecisionString = this.safeString (market, 'base_decimals');
                const pricePrecisionString = this.safeString (market, 'counter_decimals');
                const amountLimit = this.parsePrecision (amountPrecisionString);
                const priceLimit = this.parsePrecision (pricePrecisionString);
                const precision = {
                    'amount': parseInt (amountPrecisionString),
                    'price': parseInt (pricePrecisionString),
                };
                const minimumOrder = this.safeString (market, 'minimum_order');
                const parts = minimumOrder.split (' ');
                const cost = parts[0];
                // let [ cost, currency ] = market['minimum_order'].split (' ');
                const trading = this.safeString (market, 'trading');
                const active = (trading === 'Enabled');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'symbolId': symbolId,
                    'info': market,
                    'active': active,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.parseNumber (amountLimit),
                            'max': undefined,
                        },
                        'price': {
                            'min': this.parseNumber (priceLimit),
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.parseNumber (cost),
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        constructCurrencyObject (id, code, name, precision, minCost, originalPayload) {
            let currencyType = 'crypto';
            const description = this.describe ();
            if (this.isFiat (code)) {
                currencyType = 'fiat';
            }
            return {
                'id': id,
                'code': code,
                'info': originalPayload, // the original payload
                'type': currencyType,
                'name': name,
                'active': true,
                'fee': this.safeNumber (description['fees']['funding']['withdraw'], code),
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': Math.pow (10, -precision),
                        'max': undefined,
                    },
                    'price': {
                        'min': Math.pow (10, -precision),
                        'max': undefined,
                    },
                    'cost': {
                        'min': minCost,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            };
        }
    
        async fetchMarketsFromCache (params = {}) {
            // this method is now redundant
            // currencies are now fetched before markets
            const options = this.safeValue (this.options, 'fetchMarkets', {});
            const timestamp = this.safeInteger (options, 'timestamp');
            const expires = this.safeInteger (options, 'expires', 1000);
            const now = this.milliseconds ();
            if ((timestamp === undefined) || ((now - timestamp) > expires)) {
                const response = await this.publicGetTradingPairsInfo (params);
                this.options['fetchMarkets'] = this.extend (options, {
                    'response': response,
                    'timestamp': now,
                });
            }
            return this.safeValue (this.options['fetchMarkets'], 'response');
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.fetchMarketsFromCache (params);
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const name = this.safeString (market, 'name');
                let [ base, quote ] = name.split ('/');
                const baseId = base.toLowerCase ();
                const quoteId = quote.toLowerCase ();
                base = this.safeCurrencyCode (base);
                quote = this.safeCurrencyCode (quote);
                const description = this.safeString (market, 'description');
                const [ baseDescription, quoteDescription ] = description.split (' / ');
                const minimumOrder = this.safeString (market, 'minimum_order');
                const parts = minimumOrder.split (' ');
                const cost = parts[0];
                if (!(base in result)) {
                    const baseDecimals = this.safeInteger (market, 'base_decimals');
                    result[base] = this.constructCurrencyObject (baseId, base, baseDescription, baseDecimals, undefined, market);
                }
                if (!(quote in result)) {
                    const counterDecimals = this.safeInteger (market, 'counter_decimals');
                    result[quote] = this.constructCurrencyObject (quoteId, quote, quoteDescription, counterDecimals, this.parseNumber (cost), market);
                }
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
            };
            const response = await this.publicGetOrderBookPair (this.extend (request, params));
            //
            //     {
            //         "timestamp": "1583652948",
            //         "microtimestamp": "1583652948955826",
            //         "bids": [
            //             [ "8750.00", "1.33685271" ],
            //             [ "8749.39", "0.07700000" ],
            //             [ "8746.98", "0.07400000" ],
            //         ]
            //         "asks": [
            //             [ "8754.10", "1.51995636" ],
            //             [ "8754.71", "1.40000000" ],
            //             [ "8754.72", "2.50000000" ],
            //         ]
            //     }
            //
            const microtimestamp = this.safeInteger (response, 'microtimestamp');
            const timestamp = parseInt (microtimestamp / 1000);
            const orderbook = this.parseOrderBook (response, symbol, timestamp);
            orderbook['nonce'] = microtimestamp;
            return orderbook;
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
            };
            const ticker = await this.publicGetTickerPair (this.extend (request, params));
            const timestamp = this.safeTimestamp (ticker, 'timestamp');
            const vwap = this.safeNumber (ticker, 'vwap');
            const baseVolume = this.safeNumber (ticker, 'volume');
            let quoteVolume = undefined;
            if (baseVolume !== undefined && vwap !== undefined) {
                quoteVolume = baseVolume * vwap;
            }
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': this.safeNumber (ticker, 'open'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        getCurrencyIdFromTransaction (transaction) {
            //
            //     {
            //         "fee": "0.00000000",
            //         "btc_usd": "0.00",
            //         "datetime": XXX,
            //         "usd": 0.0,
            //         "btc": 0.0,
            //         "eth": "0.05000000",
            //         "type": "0",
            //         "id": XXX,
            //         "eur": 0.0
            //     }
            //
            const currencyId = this.safeStringLower (transaction, 'currency');
            if (currencyId !== undefined) {
                return currencyId;
            }
            transaction = this.omit (transaction, [
                'fee',
                'price',
                'datetime',
                'type',
                'status',
                'id',
            ]);
            const ids = Object.keys (transaction);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                if (id.indexOf ('_') < 0) {
                    const value = this.safeNumber (transaction, id);
                    if ((value !== undefined) && (value !== 0)) {
                        return id;
                    }
                }
            }
            return undefined;
        }
    
        getMarketFromTrade (trade) {
            trade = this.omit (trade, [
                'fee',
                'price',
                'datetime',
                'tid',
                'type',
                'order_id',
                'side',
            ]);
            const currencyIds = Object.keys (trade);
            const numCurrencyIds = currencyIds.length;
            if (numCurrencyIds > 2) {
                throw new ExchangeError (this.id + ' getMarketFromTrade too many keys: ' + this.json (currencyIds) + ' in the trade: ' + this.json (trade));
            }
            if (numCurrencyIds === 2) {
                let marketId = currencyIds[0] + currencyIds[1];
                if (marketId in this.markets_by_id) {
                    return this.markets_by_id[marketId];
                }
                marketId = currencyIds[1] + currencyIds[0];
                if (marketId in this.markets_by_id) {
                    return this.markets_by_id[marketId];
                }
            }
            return undefined;
        }
    
        getMarketFromTrades (trades) {
            const tradesBySymbol = this.indexBy (trades, 'symbol');
            const symbols = Object.keys (tradesBySymbol);
            const numSymbols = symbols.length;
            if (numSymbols === 1) {
                return this.markets[symbols[0]];
            }
            return undefined;
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         date: '1551814435',
            //         tid: '83581898',
            //         price: '0.03532850',
            //         type: '1',
            //         amount: '0.85945907'
            //     },
            //
            // fetchMyTrades, trades returned within fetchOrder (private)
            //
            //     {
            //         "usd": "6.0134400000000000",
            //         "price": "4008.96000000",
            //         "datetime": "2019-03-28 23:07:37.233599",
            //         "fee": "0.02",
            //         "btc": "0.00150000",
            //         "tid": 84452058,
            //         "type": 2
            //     }
            //
            // from fetchOrder:
            //    { fee: '0.000019',
            //     price: '0.00015803',
            //     datetime: '2018-01-07 10:45:34.132551',
            //     btc: '0.0079015000000000',
            //     tid: 42777395,
            //     type: 2, //(0 - deposit; 1 - withdrawal; 2 - market trade) NOT buy/sell
            //     xrp: '50.00000000' }
            const id = this.safeString2 (trade, 'id', 'tid');
            let symbol = undefined;
            let side = undefined;
            let price = this.safeNumber (trade, 'price');
            let amount = this.safeNumber (trade, 'amount');
            const orderId = this.safeString (trade, 'order_id');
            const type = undefined;
            let cost = this.safeNumber (trade, 'cost');
            if (market === undefined) {
                const keys = Object.keys (trade);
                for (let i = 0; i < keys.length; i++) {
                    if (keys[i].indexOf ('_') >= 0) {
                        const marketId = keys[i].replace ('_', '');
                        if (marketId in this.markets_by_id) {
                            market = this.markets_by_id[marketId];
                        }
                    }
                }
                // if the market is still not defined
                // try to deduce it from used keys
                if (market === undefined) {
                    market = this.getMarketFromTrade (trade);
                }
            }
            const feeCost = this.safeNumber (trade, 'fee');
            let feeCurrency = undefined;
            if (market !== undefined) {
                price = this.safeNumber (trade, market['symbolId'], price);
                amount = this.safeNumber (trade, market['baseId'], amount);
                cost = this.safeNumber (trade, market['quoteId'], cost);
                feeCurrency = market['quote'];
                symbol = market['symbol'];
            }
            let timestamp = this.safeString2 (trade, 'date', 'datetime');
            if (timestamp !== undefined) {
                if (timestamp.indexOf (' ') >= 0) {
                    // iso8601
                    timestamp = this.parse8601 (timestamp);
                } else {
                    // string unix epoch in seconds
                    timestamp = parseInt (timestamp);
                    timestamp = timestamp * 1000;
                }
            }
            // if it is a private trade
            if ('id' in trade) {
                if (amount !== undefined) {
                    if (amount < 0) {
                        side = 'sell';
                        amount = -amount;
                    } else {
                        side = 'buy';
                    }
                }
            } else {
                side = this.safeString (trade, 'type');
                if (side === '1') {
                    side = 'sell';
                } else if (side === '0') {
                    side = 'buy';
                }
            }
            if (cost === undefined) {
                if (price !== undefined) {
                    if (amount !== undefined) {
                        cost = price * amount;
                    }
                }
            }
            if (cost !== undefined) {
                cost = Math.abs (cost);
            }
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        parseTradingFee (balances, symbol) {
            const market = this.market (symbol);
            const tradeFee = this.safeNumber (balances, market['id'] + '_fee');
            return {
                'symbol': symbol,
                'maker': tradeFee,
                'taker': tradeFee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'time': 'hour',
            };
            const response = await this.publicGetTransactionsPair (this.extend (request, params));
            //
            //     [
            //         {
            //             date: '1551814435',
            //             tid: '83581898',
            //             price: '0.03532850',
            //             type: '1',
            //             amount: '0.85945907'
            //         },
            //         {
            //             date: '1551814434',
            //             tid: '83581896',
            //             price: '0.03532851',
            //             type: '1',
            //             amount: '11.34130961'
            //         },
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "high": "9064.77",
            //         "timestamp": "1593961440",
            //         "volume": "18.49436608",
            //         "low": "9040.87",
            //         "close": "9064.77",
            //         "open": "9040.87"
            //     }
            //
            return [
                this.safeTimestamp (ohlcv, 'timestamp'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'step': this.timeframes[timeframe],
            };
            const duration = this.parseTimeframe (timeframe);
            if (limit === undefined) {
                if (since === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchOHLCV() requires a since argument or a limit argument');
                } else {
                    limit = 1000;
                    const start = parseInt (since / 1000);
                    request['start'] = start;
                    request['end'] = this.sum (start, limit * duration);
                    request['limit'] = limit;
                }
            } else {
                if (since !== undefined) {
                    const start = parseInt (since / 1000);
                    request['start'] = start;
                    request['end'] = this.sum (start, limit * duration);
                }
                request['limit'] = Math.min (limit, 1000); // min 1, max 1000
            }
            const response = await this.publicGetOhlcPair (this.extend (request, params));
            //
            //     {
            //         "data": {
            //             "pair": "BTC/USD",
            //             "ohlc": [
            //                 {"high": "9064.77", "timestamp": "1593961440", "volume": "18.49436608", "low": "9040.87", "close": "9064.77", "open": "9040.87"},
            //                 {"high": "9071.59", "timestamp": "1593961500", "volume": "3.48631711", "low": "9058.76", "close": "9061.07", "open": "9064.66"},
            //                 {"high": "9067.33", "timestamp": "1593961560", "volume": "0.04142833", "low": "9061.94", "close": "9061.94", "open": "9067.33"},
            //             ],
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const ohlc = this.safeValue (data, 'ohlc', []);
            return this.parseOHLCVs (ohlc, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const balance = await this.privatePostBalance (params);
            //
            //     {
            //         "aave_available": "0.00000000",
            //         "aave_balance": "0.00000000",
            //         "aave_reserved": "0.00000000",
            //         "aave_withdrawal_fee": "0.07000000",
            //         "aavebtc_fee": "0.000",
            //         "aaveeur_fee": "0.000",
            //         "aaveusd_fee": "0.000",
            //         "bat_available": "0.00000000",
            //         "bat_balance": "0.00000000",
            //         "bat_reserved": "0.00000000",
            //         "bat_withdrawal_fee": "5.00000000",
            //         "batbtc_fee": "0.000",
            //         "bateur_fee": "0.000",
            //         "batusd_fee": "0.000",
            //     }
            //
            const result = {
                'info': balance,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const codes = Object.keys (this.currencies);
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const currency = this.currency (code);
                const currencyId = currency['id'];
                const account = this.account ();
                account['free'] = this.safeString (balance, currencyId + '_available');
                account['used'] = this.safeString (balance, currencyId + '_reserved');
                account['total'] = this.safeString (balance, currencyId + '_balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchTradingFee (symbol, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let method = 'privatePostBalance';
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
                method += 'Pair';
            }
            const balance = await this[method] (this.extend (request, params));
            return {
                'info': balance,
                'symbol': symbol,
                'maker': balance['fee'],
                'taker': balance['fee'],
            };
        }
    
        praseTradingFees (balance) {
            const result = { 'info': balance };
            const markets = Object.keys (this.markets);
            for (let i = 0; i < markets.length; i++) {
                const symbol = markets[i];
                const fee = this.parseTradingFee (balance, symbol);
                result[symbol] = fee;
            }
            return result;
        }
    
        async fetchTradingFees (params = {}) {
            await this.loadMarkets ();
            const balance = await this.privatePostBalance (params);
            return this.praseTradingFees (balance);
        }
    
        parseFundingFees (balance) {
            const withdraw = {};
            const ids = Object.keys (balance);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                if (id.indexOf ('_withdrawal_fee') >= 0) {
                    const currencyId = id.split ('_')[0];
                    const code = this.safeCurrencyCode (currencyId);
                    withdraw[code] = this.safeNumber (balance, id);
                }
            }
            return {
                'info': balance,
                'withdraw': withdraw,
                'deposit': {},
            };
        }
    
        async fetchFundingFees (params = {}) {
            await this.loadMarkets ();
            const balance = await this.privatePostBalance (params);
            return this.parseFundingFees (balance);
        }
    
        async fetchFees (params = {}) {
            await this.loadMarkets ();
            const balance = await this.privatePostBalance (params);
            const tradingFees = this.praseTradingFees (balance);
            delete tradingFees['info'];
            const fundingFees = this.parseFundingFees (balance);
            delete fundingFees['info'];
            return {
                'info': balance,
                'trading': tradingFees,
                'funding': fundingFees,
            };
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let method = 'privatePost' + this.capitalize (side);
            const request = {
                'pair': market['id'],
                'amount': this.amountToPrecision (symbol, amount),
            };
            if (type === 'market') {
                method += 'Market';
            } else if (type === 'instant') {
                method += 'Instant';
            } else {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            method += 'Pair';
            const response = await this[method] (this.extend (request, params));
            const order = this.parseOrder (response, market);
            return this.extend (order, {
                'type': type,
            });
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            return await this.privatePostCancelOrder (this.extend (request, params));
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            let method = 'privatePostCancelAllOrders';
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
                method = 'privatePostCancelAllOrdersPair';
            }
            return await this[method] (this.extend (request, params));
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'In Queue': 'open',
                'Open': 'open',
                'Finished': 'closed',
                'Canceled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        async fetchOrderStatus (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privatePostOrderStatus (this.extend (request, params));
            return this.parseOrderStatus (this.safeString (response, 'status'));
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const request = { 'id': id };
            const response = await this.privatePostOrderStatus (this.extend (request, params));
            //
            //     {
            //         "status": "Finished",
            //         "id": 3047704374,
            //         "transactions": [
            //             {
            //                 "usd": "6.0134400000000000",
            //                 "price": "4008.96000000",
            //                 "datetime": "2019-03-28 23:07:37.233599",
            //                 "fee": "0.02",
            //                 "btc": "0.00150000",
            //                 "tid": 84452058,
            //                 "type": 2
            //             }
            //         ]
            //     }
            return this.parseOrder (response, market);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let method = 'privatePostUserTransactions';
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
                method += 'Pair';
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this[method] (this.extend (request, params));
            const result = this.filterBy (response, 'type', '2');
            return this.parseTrades (result, market, since, limit);
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privatePostUserTransactions (this.extend (request, params));
            //
            //     [
            //         {
            //             "fee": "0.00000000",
            //             "btc_usd": "0.00",
            //             "id": 1234567894,
            //             "usd": 0,
            //             "btc": 0,
            //             "datetime": "2018-09-08 09:00:31",
            //             "type": "1",
            //             "xrp": "-20.00000000",
            //             "eur": 0,
            //         },
            //         {
            //             "fee": "0.00000000",
            //             "btc_usd": "0.00",
            //             "id": 1134567891,
            //             "usd": 0,
            //             "btc": 0,
            //             "datetime": "2018-09-07 18:47:52",
            //             "type": "0",
            //             "xrp": "20.00000000",
            //             "eur": 0,
            //         },
            //     ]
            //
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            const transactions = this.filterByArray (response, 'type', [ '0', '1' ], false);
            return this.parseTransactions (transactions, currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (since !== undefined) {
                request['timedelta'] = this.milliseconds () - since;
            } else {
                request['timedelta'] = 50000000; // use max bitstamp approved value
            }
            const response = await this.privatePostWithdrawalRequests (this.extend (request, params));
            //
            //     [
            //         {
            //             status: 2,
            //             datetime: '2018-10-17 10:58:13',
            //             currency: 'BTC',
            //             amount: '0.29669259',
            //             address: 'aaaaa',
            //             type: 1,
            //             id: 111111,
            //             transaction_id: 'xxxx',
            //         },
            //         {
            //             status: 2,
            //             datetime: '2018-10-17 10:55:17',
            //             currency: 'ETH',
            //             amount: '1.11010664',
            //             address: 'aaaa',
            //             type: 16,
            //             id: 222222,
            //             transaction_id: 'xxxxx',
            //         },
            //     ]
            //
            return this.parseTransactions (response, undefined, since, limit);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchTransactions
            //
            //     {
            //         "fee": "0.00000000",
            //         "btc_usd": "0.00",
            //         "id": 1234567894,
            //         "usd": 0,
            //         "btc": 0,
            //         "datetime": "2018-09-08 09:00:31",
            //         "type": "1",
            //         "xrp": "-20.00000000",
            //         "eur": 0,
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         status: 2,
            //         datetime: '2018-10-17 10:58:13',
            //         currency: 'BTC',
            //         amount: '0.29669259',
            //         address: 'aaaaa',
            //         type: 1,
            //         id: 111111,
            //         transaction_id: 'xxxx',
            //     }
            //
            //     {
            //         "id": 3386432,
            //         "type": 14,
            //         "amount": "863.21332500",
            //         "status": 2,
            //         "address": "rE1sdh25BJQ3qFwngiTBwaq3zPGGYcrjp1?dt=1455",
            //         "currency": "XRP",
            //         "datetime": "2018-01-05 15:27:55",
            //         "transaction_id": "001743B03B0C79BA166A064AC0142917B050347B4CB23BA2AB4B91B3C5608F4C"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (transaction, 'datetime'));
            const id = this.safeString (transaction, 'id');
            const currencyId = this.getCurrencyIdFromTransaction (transaction);
            const code = this.safeCurrencyCode (currencyId, currency);
            const feeCost = this.safeNumber (transaction, 'fee');
            let feeCurrency = undefined;
            let amount = undefined;
            if ('amount' in transaction) {
                amount = this.safeNumber (transaction, 'amount');
            } else if (currency !== undefined) {
                amount = this.safeNumber (transaction, currency['id'], amount);
                feeCurrency = currency['code'];
            } else if ((code !== undefined) && (currencyId !== undefined)) {
                amount = this.safeNumber (transaction, currencyId, amount);
                feeCurrency = code;
            }
            if (amount !== undefined) {
                // withdrawals have a negative amount
                amount = Math.abs (amount);
            }
            let status = 'ok';
            if ('status' in transaction) {
                status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            }
            let type = undefined;
            if ('type' in transaction) {
                // from fetchTransactions
                const rawType = this.safeString (transaction, 'type');
                if (rawType === '0') {
                    type = 'deposit';
                } else if (rawType === '1') {
                    type = 'withdrawal';
                }
            } else {
                // from fetchWithdrawals
                type = 'withdrawal';
            }
            const txid = this.safeString (transaction, 'transaction_id');
            let tag = undefined;
            let address = this.safeString (transaction, 'address');
            if (address !== undefined) {
                // dt (destination tag) is embedded into the address field
                const addressParts = address.split ('?dt=');
                const numParts = addressParts.length;
                if (numParts > 1) {
                    address = addressParts[0];
                    tag = addressParts[1];
                }
            }
            const addressFrom = undefined;
            const addressTo = address;
            const tagFrom = undefined;
            const tagTo = tag;
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = {
                    'currency': feeCurrency,
                    'cost': feeCost,
                    'rate': undefined,
                };
            }
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': addressFrom,
                'addressTo': addressTo,
                'address': address,
                'tagFrom': tagFrom,
                'tagTo': tagTo,
                'tag': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': fee,
            };
        }
    
        parseTransactionStatus (status) {
            // withdrawals:
            // 0 (open), 1 (in process), 2 (finished), 3 (canceled) or 4 (failed).
            const statuses = {
                '0': 'pending', // Open
                '1': 'pending', // In process
                '2': 'ok', // Finished
                '3': 'canceled', // Canceled
                '4': 'failed', // Failed
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            // from fetch order:
            //   { status: 'Finished',
            //     id: 731693945,
            //     transactions:
            //     [ { fee: '0.000019',
            //         price: '0.00015803',
            //         datetime: '2018-01-07 10:45:34.132551',
            //         btc: '0.0079015000000000',
            //         tid: 42777395,
            //         type: 2,
            //         xrp: '50.00000000' } ] }
            //
            // partially filled order:
            //   { "id": 468646390,
            //     "status": "Canceled",
            //     "transactions": [{
            //         "eth": "0.23000000",
            //         "fee": "0.09",
            //         "tid": 25810126,
            //         "usd": "69.8947000000000000",
            //         "type": 2,
            //         "price": "303.89000000",
            //         "datetime": "2017-11-11 07:22:20.710567"
            //     }]}
            //
            // from create order response:
            //     {
            //         price: '0.00008012',
            //         currency_pair: 'XRP/BTC',
            //         datetime: '2019-01-31 21:23:36',
            //         amount: '15.00000000',
            //         type: '0',
            //         id: '2814205012'
            //     }
            //
            const id = this.safeString (order, 'id');
            let side = this.safeString (order, 'type');
            if (side !== undefined) {
                side = (side === '1') ? 'sell' : 'buy';
            }
            // there is no timestamp from fetchOrder
            const timestamp = this.parse8601 (this.safeString (order, 'datetime'));
            const marketId = this.safeStringLower (order, 'currency_pair');
            let symbol = this.safeSymbol (marketId, market, '/');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const amount = this.safeNumber (order, 'amount');
            const transactions = this.safeValue (order, 'transactions', []);
            const trades = this.parseTrades (transactions, market);
            const length = trades.length;
            if (length) {
                symbol = trades[0]['symbol'];
            }
            const price = this.safeNumber (order, 'price');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': undefined,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'amount': amount,
                'filled': undefined,
                'remaining': undefined,
                'trades': trades,
                'fee': undefined,
                'info': order,
                'average': undefined,
            });
        }
    
        parseLedgerEntryType (type) {
            const types = {
                '0': 'transaction',
                '1': 'transaction',
                '2': 'trade',
                '14': 'transfer',
            };
            return this.safeString (types, type, type);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //     [
            //         {
            //             "fee": "0.00000000",
            //             "btc_usd": "0.00",
            //             "id": 1234567894,
            //             "usd": 0,
            //             "btc": 0,
            //             "datetime": "2018-09-08 09:00:31",
            //             "type": "1",
            //             "xrp": "-20.00000000",
            //             "eur": 0,
            //         },
            //         {
            //             "fee": "0.00000000",
            //             "btc_usd": "0.00",
            //             "id": 1134567891,
            //             "usd": 0,
            //             "btc": 0,
            //             "datetime": "2018-09-07 18:47:52",
            //             "type": "0",
            //             "xrp": "20.00000000",
            //             "eur": 0,
            //         },
            //     ]
            //
            const type = this.parseLedgerEntryType (this.safeString (item, 'type'));
            if (type === 'trade') {
                const parsedTrade = this.parseTrade (item);
                let market = undefined;
                const keys = Object.keys (item);
                for (let i = 0; i < keys.length; i++) {
                    if (keys[i].indexOf ('_') >= 0) {
                        const marketId = keys[i].replace ('_', '');
                        if (marketId in this.markets_by_id) {
                            market = this.markets_by_id[marketId];
                        }
                    }
                }
                // if the market is still not defined
                // try to deduce it from used keys
                if (market === undefined) {
                    market = this.getMarketFromTrade (item);
                }
                const direction = parsedTrade['side'] === 'buy' ? 'in' : 'out';
                return {
                    'id': parsedTrade['id'],
                    'info': item,
                    'timestamp': parsedTrade['timestamp'],
                    'datetime': parsedTrade['datetime'],
                    'direction': direction,
                    'account': undefined,
                    'referenceId': parsedTrade['order'],
                    'referenceAccount': undefined,
                    'type': type,
                    'currency': market['base'],
                    'amount': parsedTrade['amount'],
                    'before': undefined,
                    'after': undefined,
                    'status': 'ok',
                    'fee': parsedTrade['fee'],
                };
            } else {
                const parsedTransaction = this.parseTransaction (item, currency);
                let direction = undefined;
                if ('amount' in item) {
                    const amount = this.safeNumber (item, 'amount');
                    direction = amount > 0 ? 'in' : 'out';
                } else if (('currency' in parsedTransaction) && parsedTransaction['currency'] !== undefined) {
                    const code = parsedTransaction['currency'];
                    const currencyId = this.safeString (this.currencies_by_id, code, code);
                    const amount = this.safeNumber (item, currencyId);
                    direction = amount > 0 ? 'in' : 'out';
                }
                return {
                    'id': parsedTransaction['id'],
                    'info': item,
                    'timestamp': parsedTransaction['timestamp'],
                    'datetime': parsedTransaction['datetime'],
                    'direction': direction,
                    'account': undefined,
                    'referenceId': parsedTransaction['txid'],
                    'referenceAccount': undefined,
                    'type': type,
                    'currency': parsedTransaction['currency'],
                    'amount': parsedTransaction['amount'],
                    'before': undefined,
                    'after': undefined,
                    'status': parsedTransaction['status'],
                    'fee': parsedTransaction['fee'],
                };
            }
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privatePostUserTransactions (this.extend (request, params));
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            return this.parseLedger (response, currency, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            let market = undefined;
            await this.loadMarkets ();
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const response = await this.privatePostOpenOrdersAll (params);
            //     [
            //         {
            //             price: '0.00008012',
            //             currency_pair: 'XRP/BTC',
            //             datetime: '2019-01-31 21:23:36',
            //             amount: '15.00000000',
            //             type: '0',
            //             id: '2814205012',
            //         }
            //     ]
            //
            return this.parseOrders (response, market, since, limit, {
                'status': 'open',
                'type': 'limit',
            });
        }
    
        getCurrencyName (code) {
            return code.toLowerCase ();
        }
    
        isFiat (code) {
            return code === 'USD' || code === 'EUR' || code === 'GBP';
        }
    
        async fetchDepositAddress (code, params = {}) {
            if (this.isFiat (code)) {
                throw new NotSupported (this.id + ' fiat fetchDepositAddress() for ' + code + ' is not supported!');
            }
            const name = this.getCurrencyName (code);
            const method = 'privatePost' + this.capitalize (name) + 'Address';
            const response = await this[method] (params);
            const address = this.safeString (response, 'address');
            const tag = this.safeString2 (response, 'memo_id', 'destination_tag');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            // For fiat withdrawals please provide all required additional parameters in the 'params'
            // Check https://www.bitstamp.net/api/ under 'Open bank withdrawal' for list and description.
            await this.loadMarkets ();
            this.checkAddress (address);
            const request = {
                'amount': amount,
            };
            let method = undefined;
            if (!this.isFiat (code)) {
                const name = this.getCurrencyName (code);
                method = 'privatePost' + this.capitalize (name) + 'Withdrawal';
                if (code === 'XRP') {
                    if (tag !== undefined) {
                        request['destination_tag'] = tag;
                    }
                } else if (code === 'XLM') {
                    if (tag !== undefined) {
                        request['memo_id'] = tag;
                    }
                }
                request['address'] = address;
            } else {
                method = 'privatePostWithdrawalOpen';
                const currency = this.currency (code);
                request['iban'] = address;
                request['account_currency'] = currency['id'];
            }
            const response = await this[method] (this.extend (request, params));
            return {
                'info': response,
                'id': response['id'],
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/';
            url += this.version + '/';
            url += this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const xAuth = 'BITSTAMP ' + this.apiKey;
                const xAuthNonce = this.uuid ();
                const xAuthTimestamp = this.milliseconds ().toString ();
                const xAuthVersion = 'v2';
                let contentType = '';
                headers = {
                    'X-Auth': xAuth,
                    'X-Auth-Nonce': xAuthNonce,
                    'X-Auth-Timestamp': xAuthTimestamp,
                    'X-Auth-Version': xAuthVersion,
                };
                if (method === 'POST') {
                    if (Object.keys (query).length) {
                        body = this.urlencode (query);
                        contentType = 'application/x-www-form-urlencoded';
                        headers['Content-Type'] = contentType;
                    } else {
                        // sending an empty POST request will trigger
                        // an API0020 error returned by the exchange
                        // therefore for empty requests we send a dummy object
                        // https://github.com/ccxt/ccxt/issues/6846
                        body = this.urlencode ({ 'foo': 'bar' });
                        contentType = 'application/x-www-form-urlencoded';
                        headers['Content-Type'] = contentType;
                    }
                }
                const authBody = body ? body : '';
                const auth = xAuth + method + url.replace ('https://', '') + contentType + xAuthNonce + xAuthTimestamp + xAuthVersion + authBody;
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                headers['X-Auth-Signature'] = signature;
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            //
            //     {"error": "No permission found"} // fetchDepositAddress returns this on apiKeys that don't have the permission required
            //     {"status": "error", "reason": {"__all__": ["Minimum order size is 5.0 EUR."]}}
            //     reuse of a nonce gives: { status: 'error', reason: 'Invalid nonce', code: 'API0004' }
            const status = this.safeString (response, 'status');
            const error = this.safeValue (response, 'error');
            if ((status === 'error') || (error !== undefined)) {
                let errors = [];
                if (typeof error === 'string') {
                    errors.push (error);
                } else if (error !== undefined) {
                    const keys = Object.keys (error);
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const value = this.safeValue (error, key);
                        if (Array.isArray (value)) {
                            errors = this.arrayConcat (errors, value);
                        } else {
                            errors.push (value);
                        }
                    }
                }
                const reason = this.safeValue (response, 'reason', {});
                if (typeof reason === 'string') {
                    errors.push (reason);
                } else {
                    const all = this.safeValue (reason, '__all__', []);
                    for (let i = 0; i < all.length; i++) {
                        errors.push (all[i]);
                    }
                }
                const code = this.safeString (response, 'code');
                if (code === 'API0005') {
                    throw new AuthenticationError (this.id + ' invalid signature, use the uid for the main account if you have subaccounts');
                }
                const feedback = this.id + ' ' + body;
                for (let i = 0; i < errors.length; i++) {
                    const value = errors[i];
                    this.throwExactlyMatchedException (this.exceptions['exact'], value, feedback);
                    this.throwBroadlyMatchedException (this.exceptions['broad'], value, feedback);
                }
                throw new ExchangeError (feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/errors":9}],44:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { BadSymbol, ExchangeError, NotSupported } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitstamp1 extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitstamp1',
                'name': 'Bitstamp',
                'countries': [ 'GB' ],
                'rateLimit': 1000,
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'CORS': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMyTrades': true,
                    'fetchOrder': false,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27786377-8c8ab57e-5fe9-11e7-8ea4-2b05b6bcceec.jpg',
                    'api': 'https://www.bitstamp.net/api',
                    'www': 'https://www.bitstamp.net',
                    'doc': 'https://www.bitstamp.net/api',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'uid': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'ticker',
                            'ticker_hour',
                            'order_book',
                            'transactions',
                            'eur_usd',
                        ],
                    },
                    'private': {
                        'post': [
                            'balance',
                            'user_transactions',
                            'open_orders',
                            'order_status',
                            'cancel_order',
                            'cancel_all_orders',
                            'buy',
                            'sell',
                            'bitcoin_deposit_address',
                            'unconfirmed_btc',
                            'ripple_withdrawal',
                            'ripple_address',
                            'withdrawal_requests',
                            'bitcoin_withdrawal',
                        ],
                    },
                },
                'markets': {
                    'BTC/USD': { 'id': 'btcusd', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'baseId': 'btc', 'quoteId': 'usd', 'maker': 0.005, 'taker': 0.005 },
                    'BTC/EUR': { 'id': 'btceur', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'baseId': 'btc', 'quoteId': 'eur', 'maker': 0.005, 'taker': 0.005 },
                    'EUR/USD': { 'id': 'eurusd', 'symbol': 'EUR/USD', 'base': 'EUR', 'quote': 'USD', 'baseId': 'eur', 'quoteId': 'usd', 'maker': 0.005, 'taker': 0.005 },
                    'XRP/USD': { 'id': 'xrpusd', 'symbol': 'XRP/USD', 'base': 'XRP', 'quote': 'USD', 'baseId': 'xrp', 'quoteId': 'usd', 'maker': 0.005, 'taker': 0.005 },
                    'XRP/EUR': { 'id': 'xrpeur', 'symbol': 'XRP/EUR', 'base': 'XRP', 'quote': 'EUR', 'baseId': 'xrp', 'quoteId': 'eur', 'maker': 0.005, 'taker': 0.005 },
                    'XRP/BTC': { 'id': 'xrpbtc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'baseId': 'xrp', 'quoteId': 'btc', 'maker': 0.005, 'taker': 0.005 },
                    'LTC/USD': { 'id': 'ltcusd', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'baseId': 'ltc', 'quoteId': 'usd', 'maker': 0.005, 'taker': 0.005 },
                    'LTC/EUR': { 'id': 'ltceur', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'baseId': 'ltc', 'quoteId': 'eur', 'maker': 0.005, 'taker': 0.005 },
                    'LTC/BTC': { 'id': 'ltcbtc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'ltc', 'quoteId': 'btc', 'maker': 0.005, 'taker': 0.005 },
                    'ETH/USD': { 'id': 'ethusd', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'baseId': 'eth', 'quoteId': 'usd', 'maker': 0.005, 'taker': 0.005 },
                    'ETH/EUR': { 'id': 'etheur', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR', 'baseId': 'eth', 'quoteId': 'eur', 'maker': 0.005, 'taker': 0.005 },
                    'ETH/BTC': { 'id': 'ethbtc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'eth', 'quoteId': 'btc', 'maker': 0.005, 'taker': 0.005 },
                },
            });
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            if (symbol !== 'BTC/USD') {
                throw new ExchangeError (this.id + ' ' + this.version + " fetchOrderBook doesn't support " + symbol + ', use it for BTC/USD only');
            }
            await this.loadMarkets ();
            const orderbook = await this.publicGetOrderBook (params);
            const timestamp = this.safeTimestamp (orderbook, 'timestamp');
            return this.parseOrderBook (orderbook, symbol, timestamp);
        }
    
        async fetchTicker (symbol, params = {}) {
            if (symbol !== 'BTC/USD') {
                throw new ExchangeError (this.id + ' ' + this.version + " fetchTicker doesn't support " + symbol + ', use it for BTC/USD only');
            }
            await this.loadMarkets ();
            const ticker = await this.publicGetTicker (params);
            const timestamp = this.safeTimestamp (ticker, 'timestamp');
            const vwap = this.safeNumber (ticker, 'vwap');
            const baseVolume = this.safeNumber (ticker, 'volume');
            let quoteVolume = undefined;
            if (baseVolume !== undefined && vwap !== undefined) {
                quoteVolume = baseVolume * vwap;
            }
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': this.safeNumber (ticker, 'open'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeTimestamp2 (trade, 'date', 'datetime');
            const side = (trade['type'] === 0) ? 'buy' : 'sell';
            const orderId = this.safeString (trade, 'order_id');
            if ('currency_pair' in trade) {
                if (trade['currency_pair'] in this.markets_by_id) {
                    market = this.markets_by_id[trade['currency_pair']];
                }
            }
            const id = this.safeString (trade, 'tid');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            if (symbol !== 'BTC/USD') {
                throw new BadSymbol (this.id + ' ' + this.version + " fetchTrades doesn't support " + symbol + ', use it for BTC/USD only');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'time': 'minute',
            };
            const response = await this.publicGetTransactions (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            const balance = await this.privatePostBalance (params);
            const result = { 'info': balance };
            const codes = Object.keys (this.currencies);
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const currency = this.currency (code);
                const currencyId = currency['id'];
                const account = this.account ();
                account['free'] = this.safeString (balance, currencyId + '_available');
                account['used'] = this.safeString (balance, currencyId + '_reserved');
                account['total'] = this.safeString (balance, currencyId + '_balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            if (type !== 'limit') {
                throw new ExchangeError (this.id + ' ' + this.version + ' accepts limit orders only');
            }
            if (symbol !== 'BTC/USD') {
                throw new ExchangeError (this.id + ' v1 supports BTC/USD orders only');
            }
            await this.loadMarkets ();
            const method = 'privatePost' + this.capitalize (side);
            const request = {
                'amount': amount,
                'price': price,
            };
            const response = await this[method] (this.extend (request, params));
            const id = this.safeString (response, 'id');
            return {
                'info': response,
                'id': id,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            return await this.privatePostCancelOrder ({ 'id': id });
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'In Queue': 'open',
                'Open': 'open',
                'Finished': 'closed',
                'Canceled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        async fetchOrderStatus (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privatePostOrderStatus (this.extend (request, params));
            return this.parseOrderStatus (response);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const pair = market ? market['id'] : 'all';
            const request = {
                'id': pair,
            };
            const response = await this.privatePostOpenOrdersId (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            throw new NotSupported (this.id + ' fetchOrder is not implemented yet');
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.implodeParams (path, params);
            let query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const auth = nonce + this.uid + this.apiKey;
                const signature = this.encode (this.hmac (this.encode (auth), this.encode (this.secret)));
                query = this.extend ({
                    'key': this.apiKey,
                    'signature': signature.toUpperCase (),
                    'nonce': nonce,
                }, query);
                body = this.urlencode (query);
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const status = this.safeString (response, 'status');
            if (status === 'error') {
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],45:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { BadSymbol, ExchangeError, ExchangeNotAvailable, AuthenticationError, InvalidOrder, InsufficientFunds, OrderNotFound, DDoSProtection, PermissionDenied, AddressPending, OnMaintenance, BadRequest, InvalidAddress } = require ('./base/errors');
    const { TRUNCATE, DECIMAL_PLACES } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bittrex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bittrex',
                'name': 'Bittrex',
                'countries': [ 'US' ],
                'version': 'v3',
                'rateLimit': 1500,
                'certified': false,
                'pro': true,
                // new metainfo interface
                'has': {
                    'CORS': false,
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createDepositAddress': true,
                    'createMarketOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchDeposits': true,
                    'fetchDepositAddress': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': 'emulated',
                    'fetchOHLCV': true,
                    'fetchOrder': true,
                    'fetchOrderTrades': true,
                    'fetchOrderBook': true,
                    'fetchOpenOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTransactions': false,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': 'MINUTE_1',
                    '5m': 'MINUTE_5',
                    '1h': 'HOUR_1',
                    '1d': 'DAY_1',
                },
                'hostname': 'bittrex.com',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87153921-edf53180-c2c0-11ea-96b9-f2a9a95a455b.jpg',
                    'api': {
                        'public': 'https://api.bittrex.com',
                        'private': 'https://api.bittrex.com',
                    },
                    'www': 'https://bittrex.com',
                    'doc': [
                        'https://bittrex.github.io/api/v3',
                    ],
                    'fees': [
                        'https://bittrex.zendesk.com/hc/en-us/articles/115003684371-BITTREX-SERVICE-FEES-AND-WITHDRAWAL-LIMITATIONS',
                        'https://bittrex.zendesk.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-',
                    ],
                    'referral': 'https://bittrex.com/Account/Register?referralCode=1ZE-G0G-M3B',
                },
                'api': {
                    'public': {
                        'get': [
                            'ping',
                            'currencies',
                            'currencies/{symbol}',
                            'markets',
                            'markets/tickers',
                            'markets/summaries',
                            'markets/{marketSymbol}',
                            'markets/{marketSymbol}/summary',
                            'markets/{marketSymbol}/orderbook',
                            'markets/{marketSymbol}/trades',
                            'markets/{marketSymbol}/ticker',
                            'markets/{marketSymbol}/candles/{candleInterval}/recent',
                            'markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}/{day}',
                            'markets/{marketSymbol}/candles/{candleInterval}/historical/{year}/{month}',
                            'markets/{marketSymbol}/candles/{candleInterval}/historical/{year}',
                        ],
                    },
                    'private': {
                        'get': [
                            'account',
                            'account/volume',
                            'addresses',
                            'addresses/{currencySymbol}',
                            'balances',
                            'balances/{currencySymbol}',
                            'deposits/open',
                            'deposits/closed',
                            'deposits/ByTxId/{txId}',
                            'deposits/{depositId}',
                            'orders/closed',
                            'orders/open',
                            'orders/{orderId}',
                            'orders/{orderId}/executions',
                            'ping',
                            'subaccounts/{subaccountId}',
                            'subaccounts',
                            'withdrawals/open',
                            'withdrawals/closed',
                            'withdrawals/ByTxId/{txId}',
                            'withdrawals/{withdrawalId}',
                            'withdrawals/whitelistAddresses',
                            'conditional-orders/{conditionalOrderId}',
                            'conditional-orders/closed',
                            'conditional-orders/open',
                            'transfers/sent',
                            'transfers/received',
                            'transfers/{transferId}',
                        ],
                        'post': [
                            'addresses',
                            'orders',
                            'subaccounts',
                            'withdrawals',
                            'conditional-orders',
                            'transfers',
                        ],
                        'delete': [
                            'orders/open',
                            'orders/{orderId}',
                            'withdrawals/{withdrawalId}',
                            'conditional-orders/{conditionalOrderId}',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'maker': this.parseNumber ('0.0075'),
                        'taker': this.parseNumber ('0.0075'),
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                    },
                },
                'exceptions': {
                    'exact': {
                        'BAD_REQUEST': BadRequest, // {"code":"BAD_REQUEST","detail":"Refer to the data field for specific field validation failures.","data":{"invalidRequestParameter":"day"}}
                        'STARTDATE_OUT_OF_RANGE': BadRequest, // {"code":"STARTDATE_OUT_OF_RANGE"}
                        // 'Call to Cancel was throttled. Try again in 60 seconds.': DDoSProtection,
                        // 'Call to GetBalances was throttled. Try again in 60 seconds.': DDoSProtection,
                        'APISIGN_NOT_PROVIDED': AuthenticationError,
                        'APIKEY_INVALID': AuthenticationError,
                        'INVALID_SIGNATURE': AuthenticationError,
                        'INVALID_CURRENCY': ExchangeError,
                        'INVALID_PERMISSION': AuthenticationError,
                        'INSUFFICIENT_FUNDS': InsufficientFunds,
                        'INVALID_CEILING_MARKET_BUY': InvalidOrder,
                        'INVALID_FIAT_ACCOUNT': InvalidOrder,
                        'INVALID_ORDER_TYPE': InvalidOrder,
                        'QUANTITY_NOT_PROVIDED': InvalidOrder,
                        'MIN_TRADE_REQUIREMENT_NOT_MET': InvalidOrder,
                        'NOT_FOUND': OrderNotFound,
                        'ORDER_NOT_OPEN': OrderNotFound,
                        'INVALID_ORDER': InvalidOrder,
                        'UUID_INVALID': OrderNotFound,
                        'RATE_NOT_PROVIDED': InvalidOrder, // createLimitBuyOrder ('ETH/BTC', 1, 0)
                        'INVALID_MARKET': BadSymbol, // {"success":false,"message":"INVALID_MARKET","result":null,"explanation":null}
                        'WHITELIST_VIOLATION_IP': PermissionDenied,
                        'DUST_TRADE_DISALLOWED_MIN_VALUE': InvalidOrder,
                        'RESTRICTED_MARKET': BadSymbol,
                        'We are down for scheduled maintenance, but we\u2019ll be back up shortly.': OnMaintenance, // {"success":false,"message":"We are down for scheduled maintenance, but we\u2019ll be back up shortly.","result":null,"explanation":null}
                    },
                    'broad': {
                        'throttled': DDoSProtection,
                        'problem': ExchangeNotAvailable,
                    },
                },
                'options': {
                    'fetchTicker': {
                        'method': 'publicGetMarketsMarketSymbolTicker', // publicGetMarketsMarketSymbolSummary
                    },
                    'fetchTickers': {
                        'method': 'publicGetMarketsTickers', // publicGetMarketsSummaries
                    },
                    'parseOrderStatus': false,
                    'hasAlreadyAuthenticatedSuccessfully': false, // a workaround for APIKEY_INVALID
                    // With certain currencies, like
                    // AEON, BTS, GXS, NXT, SBD, STEEM, STR, XEM, XLM, XMR, XRP
                    // an additional tag / memo / payment id is usually required by exchanges.
                    // With Bittrex some currencies imply the "base address + tag" logic.
                    // The base address for depositing is stored on this.currencies[code]
                    // The base address identifies the exchange as the recipient
                    // while the tag identifies the user account within the exchange
                    // and the tag is retrieved with fetchDepositAddress.
                    'tag': {
                        'NXT': true, // NXT, BURST
                        'CRYPTO_NOTE_PAYMENTID': true, // AEON, XMR
                        'BITSHAREX': true, // BTS
                        'RIPPLE': true, // XRP
                        'NEM': true, // XEM
                        'STELLAR': true, // XLM
                        'STEEM': true, // SBD, GOLOS
                        // https://github.com/ccxt/ccxt/issues/4794
                        // 'LISK': true, // LSK
                    },
                    'subaccountId': undefined,
                    // see the implementation of fetchClosedOrdersV3 below
                    // 'fetchClosedOrdersMethod': 'fetch_closed_orders_v3',
                    'fetchClosedOrdersFilterBySince': true,
                    // 'createOrderMethod': 'create_order_v1',
                },
                'commonCurrencies': {
                    'REPV2': 'REP',
                },
            });
        }
    
        costToPrecision (symbol, cost) {
            return this.decimalToPrecision (cost, TRUNCATE, this.markets[symbol]['precision']['price'], DECIMAL_PLACES);
        }
    
        feeToPrecision (symbol, fee) {
            return this.decimalToPrecision (fee, TRUNCATE, this.markets[symbol]['precision']['price'], DECIMAL_PLACES);
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarkets (params);
            //
            //     [
            //         {
            //             "symbol":"LTC-BTC",
            //             "baseCurrencySymbol":"LTC",
            //             "quoteCurrencySymbol":"BTC",
            //             "minTradeSize":"0.01686767",
            //             "precision":8,
            //             "status":"ONLINE", // "OFFLINE"
            //             "createdAt":"2014-02-13T00:00:00Z"
            //         },
            //         {
            //             "symbol":"VDX-USDT",
            //             "baseCurrencySymbol":"VDX",
            //             "quoteCurrencySymbol":"USDT",
            //             "minTradeSize":"300.00000000",
            //             "precision":8,
            //             "status":"ONLINE", // "OFFLINE"
            //             "createdAt":"2019-05-23T00:41:21.843Z",
            //             "notice":"USDT has swapped to an ERC20-based token as of August 5, 2019."
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const baseId = this.safeString (market, 'baseCurrencySymbol');
                const quoteId = this.safeString (market, 'quoteCurrencySymbol');
                const id = this.safeString (market, 'symbol');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const pricePrecision = this.safeInteger (market, 'precision', 8);
                const precision = {
                    'amount': 8,
                    'price': pricePrecision,
                };
                const status = this.safeString (market, 'status');
                const active = (status === 'ONLINE');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'info': market,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'minTradeSize'),
                            'max': undefined,
                        },
                        'price': {
                            'min': 1 / Math.pow (10, precision['price']),
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const balances = await this.privateGetBalances (params);
            const result = { 'info': balances };
            const indexed = this.indexBy (balances, 'currencySymbol');
            const currencyIds = Object.keys (indexed);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                const balance = indexed[currencyId];
                account['free'] = this.safeString (balance, 'available');
                account['total'] = this.safeString (balance, 'total');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'marketSymbol': this.marketId (symbol),
            };
            if (limit !== undefined) {
                if ((limit !== 1) && (limit !== 25) && (limit !== 500)) {
                    throw new BadRequest (this.id + ' fetchOrderBook() limit argument must be undefined, 1, 25 or 500, default is 25');
                }
                request['depth'] = limit;
            }
            const response = await this.publicGetMarketsMarketSymbolOrderbook (this.extend (request, params));
            //
            //     {
            //         "bid":[
            //             {"quantity":"0.01250000","rate":"10718.56200003"},
            //             {"quantity":"0.10000000","rate":"10718.56200002"},
            //             {"quantity":"0.39648292","rate":"10718.56200001"},
            //         ],
            //         "ask":[
            //             {"quantity":"0.05100000","rate":"10724.30099631"},
            //             {"quantity":"0.10000000","rate":"10724.30099632"},
            //             {"quantity":"0.26000000","rate":"10724.30099634"},
            //         ]
            //     }
            //
            const sequence = this.safeInteger (this.last_response_headers, 'Sequence');
            const orderbook = this.parseOrderBook (response, symbol, undefined, 'bid', 'ask', 'rate', 'quantity');
            orderbook['nonce'] = sequence;
            return orderbook;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     [
            //         {
            //             "symbol":"1ST",
            //             "name":"Firstblood",
            //             "coinType":"ETH_CONTRACT",
            //             "status":"ONLINE",
            //             "minConfirmations":36,
            //             "notice":"",
            //             "txFee":"4.50000000",
            //             "logoUrl":"https://bittrexblobstorage.blob.core.windows.net/public/5685a7be-1edf-4ba0-a313-b5309bb204f8.png",
            //             "prohibitedIn":[],
            //             "baseAddress":"0xfbb1b73c4f0bda4f67dca266ce6ef42f520fbb98",
            //             "associatedTermsOfService":[]
            //         }
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'symbol');
                const code = this.safeCurrencyCode (id);
                const precision = 8; // default precision, todo: fix "magic constants"
                const fee = this.safeNumber (currency, 'txFee'); // todo: redesign
                const isActive = this.safeString (currency, 'status');
                result[code] = {
                    'id': id,
                    'code': code,
                    'address': this.safeString (currency, 'baseAddress'),
                    'info': currency,
                    'type': this.safeString (currency, 'coinType'),
                    'name': this.safeString (currency, 'name'),
                    'active': (isActive === 'ONLINE'),
                    'fee': fee,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': 1 / Math.pow (10, precision),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': fee,
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // ticker
            //
            //     {
            //         "symbol":"ETH-BTC",
            //         "lastTradeRate":"0.03284496",
            //         "bidRate":"0.03284523",
            //         "askRate":"0.03286857"
            //     }
            //
            // summary
            //
            //     {
            //         "symbol":"ETH-BTC",
            //         "high":"0.03369528",
            //         "low":"0.03282442",
            //         "volume":"4307.83794556",
            //         "quoteVolume":"143.08608869",
            //         "percentChange":"0.79",
            //         "updatedAt":"2020-09-29T07:36:57.823Z"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (ticker, 'updatedAt'));
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '-');
            const percentage = this.safeNumber (ticker, 'percentChange');
            const last = this.safeNumber (ticker, 'lastTradeRate');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bidRate'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'askRate'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': this.safeNumber (ticker, 'quoteVolume'),
                'info': ticker,
            };
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const options = this.safeValue (this.options, 'fetchTickers', {});
            const defaultMethod = this.safeString (options, 'method', 'publicGetMarketsTickers');
            const method = this.safeString (params, 'method', defaultMethod);
            params = this.omit (params, 'method');
            const response = await this[method] (params);
            //
            // publicGetMarketsTickers
            //
            //     [
            //         {
            //             "symbol":"4ART-BTC",
            //             "lastTradeRate":"0.00000210",
            //             "bidRate":"0.00000210",
            //             "askRate":"0.00000215"
            //         }
            //     ]
            //
            // publicGetMarketsSummaries
            //
            //     [
            //         {
            //             "symbol":"4ART-BTC",
            //             "high":"0.00000206",
            //             "low":"0.00000196",
            //             "volume":"14871.32000233",
            //             "quoteVolume":"0.02932756",
            //             "percentChange":"1.48",
            //             "updatedAt":"2020-09-29T07:34:32.757Z"
            //         }
            //     ]
            //
            const tickers = [];
            for (let i = 0; i < response.length; i++) {
                const ticker = this.parseTicker (response[i]);
                tickers.push (ticker);
            }
            return this.filterByArray (tickers, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketSymbol': market['id'],
            };
            const options = this.safeValue (this.options, 'fetchTicker', {});
            const defaultMethod = this.safeString (options, 'method', 'publicGetMarketsMarketSymbolTicker');
            const method = this.safeString (params, 'method', defaultMethod);
            params = this.omit (params, 'method');
            const response = await this[method] (this.extend (request, params));
            //
            // publicGetMarketsMarketSymbolTicker
            //
            //     {
            //         "symbol":"ETH-BTC",
            //         "lastTradeRate":"0.03284496",
            //         "bidRate":"0.03284523",
            //         "askRate":"0.03286857"
            //     }
            //
            //
            // publicGetMarketsMarketSymbolSummary
            //
            //     {
            //         "symbol":"ETH-BTC",
            //         "high":"0.03369528",
            //         "low":"0.03282442",
            //         "volume":"4307.83794556",
            //         "quoteVolume":"143.08608869",
            //         "percentChange":"0.79",
            //         "updatedAt":"2020-09-29T07:36:57.823Z"
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     {
            //         "id":"9c5589db-42fb-436c-b105-5e2edcb95673",
            //         "executedAt":"2020-10-03T11:48:43.38Z",
            //         "quantity":"0.17939626",
            //         "rate":"0.03297952",
            //         "takerSide":"BUY"
            //     }
            //
            // private fetchOrderTrades
            //
            //     {
            //         "id": "aaa3e9bd-5b86-4a21-8b3d-1275c1d30b8e",
            //         "marketSymbol": "OMG-BTC",
            //         "executedAt": "2020-10-02T16:00:30.3Z",
            //         "quantity": "7.52710000",
            //         "rate": "0.00034907",
            //         "orderId": "3a3dbd33-3a30-4ae5-a41d-68d3c1ac537e",
            //         "commission": "0.00000525",
            //         "isTaker": false
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (trade, 'executedAt'));
            const id = this.safeString (trade, 'id');
            const order = this.safeString (trade, 'orderId');
            const marketId = this.safeString (trade, 'marketSymbol');
            market = this.safeMarket (marketId, market, '-');
            const priceString = this.safeString (trade, 'rate');
            const amountString = this.safeString (trade, 'quantity');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let takerOrMaker = undefined;
            const isTaker = this.safeValue (trade, 'isTaker');
            if (isTaker !== undefined) {
                takerOrMaker = isTaker ? 'taker' : 'maker';
            }
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'commission');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': market['quote'],
                };
            }
            const side = this.safeStringLower (trade, 'takerSide');
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': market['symbol'],
                'id': id,
                'order': order,
                'takerOrMaker': takerOrMaker,
                'type': undefined,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetPing (params);
            //
            //     {
            //         "serverTime": 1594596023162
            //     }
            //
            return this.safeInteger (response, 'serverTime');
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketSymbol': this.marketId (symbol),
            };
            const response = await this.publicGetMarketsMarketSymbolTrades (this.extend (request, params));
            //
            //     [
            //         {
            //             "id":"9c5589db-42fb-436c-b105-5e2edcb95673",
            //             "executedAt":"2020-10-03T11:48:43.38Z",
            //             "quantity":"0.17939626",
            //             "rate":"0.03297952",
            //             "takerSide":"BUY"
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "startsAt":"2020-06-12T02:35:00Z",
            //         "open":"0.02493753",
            //         "high":"0.02493753",
            //         "low":"0.02493753",
            //         "close":"0.02493753",
            //         "volume":"0.09590123",
            //         "quoteVolume":"0.00239153"
            //     }
            //
            return [
                this.parse8601 (this.safeString (ohlcv, 'startsAt')),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const reverseId = market['baseId'] + '-' + market['quoteId'];
            const request = {
                'candleInterval': this.timeframes[timeframe],
                'marketSymbol': reverseId,
            };
            let method = 'publicGetMarketsMarketSymbolCandlesCandleIntervalRecent';
            if (since !== undefined) {
                const now = this.milliseconds ();
                const difference = Math.abs (now - since);
                const sinceDate = this.ymd (since);
                const parts = sinceDate.split ('-');
                const sinceYear = this.safeInteger (parts, 0);
                const sinceMonth = this.safeInteger (parts, 1);
                const sinceDay = this.safeInteger (parts, 2);
                if (timeframe === '1d') {
                    // if the since argument is beyond one year into the past
                    if (difference > 31622400000) {
                        method = 'publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYear';
                        request['year'] = sinceYear;
                    }
                    // request['year'] = year;
                } else if (timeframe === '1h') {
                    // if the since argument is beyond 31 days into the past
                    if (difference > 2678400000) {
                        method = 'publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonth';
                        request['year'] = sinceYear;
                        request['month'] = sinceMonth;
                    }
                } else {
                    // if the since argument is beyond 1 day into the past
                    if (difference > 86400000) {
                        method = 'publicGetMarketsMarketSymbolCandlesCandleIntervalHistoricalYearMonthDay';
                        request['year'] = sinceYear;
                        request['month'] = sinceMonth;
                        request['day'] = sinceDay;
                    }
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     [
            //         {"startsAt":"2020-06-12T02:35:00Z","open":"0.02493753","high":"0.02493753","low":"0.02493753","close":"0.02493753","volume":"0.09590123","quoteVolume":"0.00239153"},
            //         {"startsAt":"2020-06-12T02:40:00Z","open":"0.02491874","high":"0.02491874","low":"0.02490970","close":"0.02490970","volume":"0.04515695","quoteVolume":"0.00112505"},
            //         {"startsAt":"2020-06-12T02:45:00Z","open":"0.02490753","high":"0.02493143","low":"0.02490753","close":"0.02493143","volume":"0.17769640","quoteVolume":"0.00442663"}
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['marketSymbol'] = market['id'];
            }
            const response = await this.privateGetOrdersOpen (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderId': id,
            };
            const response = await this.privateGetOrdersOrderIdExecutions (this.extend (request, params));
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            // A ceiling order is a market or limit order that allows you to specify
            // the amount of quote currency you want to spend (or receive, if selling)
            // instead of the quantity of the market currency (e.g. buy $100 USD of BTC
            // at the current market BTC price)
            await this.loadMarkets ();
            const market = this.market (symbol);
            const uppercaseType = type.toUpperCase ();
            const reverseId = market['baseId'] + '-' + market['quoteId'];
            const request = {
                'marketSymbol': reverseId,
                'direction': side.toUpperCase (),
                'type': uppercaseType, // LIMIT, MARKET, CEILING_LIMIT, CEILING_MARKET
                // 'quantity': this.amountToPrecision (symbol, amount), // required for limit orders, excluded for ceiling orders
                // 'ceiling': this.priceToPrecision (symbol, price), // required for ceiling orders, excluded for non-ceiling orders
                // 'limit': this.priceToPrecision (symbol, price), // required for limit orders, excluded for market orders
                // 'timeInForce': 'GOOD_TIL_CANCELLED', // IMMEDIATE_OR_CANCEL, FILL_OR_KILL, POST_ONLY_GOOD_TIL_CANCELLED
                // 'useAwards': false, // optional
            };
            const isCeilingLimit = (uppercaseType === 'CEILING_LIMIT');
            const isCeilingMarket = (uppercaseType === 'CEILING_MARKET');
            const isCeilingOrder = isCeilingLimit || isCeilingMarket;
            if (isCeilingOrder) {
                let cost = undefined;
                if (isCeilingLimit) {
                    request['limit'] = this.priceToPrecision (symbol, price);
                    cost = this.safeNumber2 (params, 'ceiling', 'cost', amount);
                } else if (isCeilingMarket) {
                    cost = this.safeNumber2 (params, 'ceiling', 'cost');
                    if (cost === undefined) {
                        if (price === undefined) {
                            cost = amount;
                        } else {
                            cost = amount * price;
                        }
                    }
                }
                params = this.omit (params, [ 'ceiling', 'cost' ]);
                request['ceiling'] = this.costToPrecision (symbol, cost);
                // bittrex only accepts IMMEDIATE_OR_CANCEL or FILL_OR_KILL for ceiling orders
                request['timeInForce'] = 'IMMEDIATE_OR_CANCEL';
            } else {
                request['quantity'] = this.amountToPrecision (symbol, amount);
                if (uppercaseType === 'LIMIT') {
                    request['limit'] = this.priceToPrecision (symbol, price);
                    request['timeInForce'] = 'GOOD_TIL_CANCELLED';
                } else {
                    // bittrex does not allow GOOD_TIL_CANCELLED for market orders
                    request['timeInForce'] = 'IMMEDIATE_OR_CANCEL';
                }
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            //
            //     {
            //         id: 'f03d5e98-b5ac-48fb-8647-dd4db828a297',
            //         marketSymbol: 'BTC-USDT',
            //         direction: 'SELL',
            //         type: 'LIMIT',
            //         quantity: '0.01',
            //         limit: '6000',
            //         timeInForce: 'GOOD_TIL_CANCELLED',
            //         fillQuantity: '0.00000000',
            //         commission: '0.00000000',
            //         proceeds: '0.00000000',
            //         status: 'OPEN',
            //         createdAt: '2020-03-18T02:37:33.42Z',
            //         updatedAt: '2020-03-18T02:37:33.42Z'
            //       }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderId': id,
            };
            const response = await this.privateDeleteOrdersOrderId (this.extend (request, params));
            return this.extend (this.parseOrder (response), {
                'id': id,
                'info': response,
                'status': 'canceled',
            });
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['marketSymbol'] = market['id'];
            }
            const response = await this.privateDeleteOrdersOpen (this.extend (request, params));
            //
            //     [
            //         {
            //             "id":"66582be0-5337-4d8c-b212-c356dd525801",
            //             "statusCode":"SUCCESS",
            //             "result":{
            //                 "id":"66582be0-5337-4d8c-b212-c356dd525801",
            //                 "marketSymbol":"BTC-USDT",
            //                 "direction":"BUY",
            //                 "type":"LIMIT",
            //                 "quantity":"0.01000000",
            //                 "limit":"3000.00000000",
            //                 "timeInForce":"GOOD_TIL_CANCELLED",
            //                 "fillQuantity":"0.00000000",
            //                 "commission":"0.00000000",
            //                 "proceeds":"0.00000000",
            //                 "status":"CLOSED",
            //                 "createdAt":"2020-10-06T12:31:53.39Z",
            //                 "updatedAt":"2020-10-06T12:54:28.8Z",
            //                 "closedAt":"2020-10-06T12:54:28.8Z"
            //             }
            //         }
            //     ]
            //
            const orders = [];
            for (let i = 0; i < response.length; i++) {
                const result = this.safeValue (response[i], 'result', {});
                orders.push (result);
            }
            return this.parseOrders (orders, market);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            // https://support.bittrex.com/hc/en-us/articles/115003723911
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currencySymbol'] = currency['id'];
            }
            const response = await this.privateGetDepositsClosed (this.extend (request, params));
            // we cannot filter by `since` timestamp, as it isn't set by Bittrex
            // see https://github.com/ccxt/ccxt/issues/4067
            // return this.parseTransactions (response, currency, since, limit);
            return this.parseTransactions (response, currency, undefined, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            // https://support.bittrex.com/hc/en-us/articles/115003723911
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currencySymbol'] = currency['id'];
            }
            const response = await this.privateGetWithdrawalsClosed (this.extend (request, params));
            return this.parseTransactions (response, currency, since, limit);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //     {
            //         "id": "d00fdf2e-df9e-48f1-....",
            //         "currencySymbol": "BTC",
            //         "quantity": "0.00550000",
            //         "cryptoAddress": "1PhmYjnJPZH5NUwV8AU...",
            //         "txId": "d1f1afffe1b9b6614eaee7e8133c85d98...",
            //         "confirmations": 2,
            //         "updatedAt": "2020-01-12T16:49:30.41Z",
            //         "completedAt": "2020-01-12T16:49:30.41Z",
            //         "status": "COMPLETED",
            //         "source": "BLOCKCHAIN"
            //     }
            //
            // fetchWithdrawals
            //     {
            //         "PaymentUuid" : "e293da98-788c-4188-a8f9-8ec2c33fdfcf",
            //         "Currency" : "XC",
            //         "Amount" : 7513.75121715,
            //         "Address" : "EVnSMgAd7EonF2Dgc4c9K14L12RBaW5S5J",
            //         "Opened" : "2014-07-08T23:13:31.83",
            //         "Authorized" : true,
            //         "PendingPayment" : false,
            //         "TxCost" : 0.00002000,
            //         "TxId" : "b4a575c2a71c7e56d02ab8e26bb1ef0a2f6cf2094f6ca2116476a569c1e84f6e",
            //         "Canceled" : false,
            //         "InvalidAddress" : false
            //     }
            //
            const id = this.safeString (transaction, 'id');
            const amount = this.safeNumber (transaction, 'quantity');
            const address = this.safeString (transaction, 'cryptoAddress');
            const txid = this.safeString (transaction, 'txId');
            const updated = this.parse8601 (this.safeString (transaction, 'updatedAt'));
            const opened = this.parse8601 (this.safeString (transaction, 'createdAt'));
            const timestamp = opened ? opened : updated;
            const type = (opened === undefined) ? 'deposit' : 'withdrawal';
            const currencyId = this.safeString (transaction, 'currencySymbol');
            const code = this.safeCurrencyCode (currencyId, currency);
            let status = 'pending';
            if (type === 'deposit') {
                //
                // deposits numConfirmations never reach the minConfirmations number
                // we set all of them to 'ok', otherwise they'd all be 'pending'
                //
                //     const numConfirmations = this.safeInteger (transaction, 'Confirmations', 0);
                //     const minConfirmations = this.safeInteger (currency['info'], 'MinConfirmation');
                //     if (numConfirmations >= minConfirmations) {
                //         status = 'ok';
                //     }
                //
                status = 'ok';
            } else {
                const responseStatus = this.safeString (transaction, 'status');
                if (responseStatus === 'ERROR_INVALID_ADDRESS') {
                    status = 'failed';
                } else if (responseStatus === 'CANCELLED') {
                    status = 'canceled';
                } else if (responseStatus === 'PENDING') {
                    status = 'pending';
                } else if (responseStatus === 'COMPLETED') {
                    status = 'ok';
                } else if (responseStatus === 'AUTHORIZED' && (txid !== undefined)) {
                    status = 'ok';
                }
            }
            let feeCost = this.safeNumber (transaction, 'txCost');
            if (feeCost === undefined) {
                if (type === 'deposit') {
                    // according to https://support.bittrex.com/hc/en-us/articles/115000199651-What-fees-does-Bittrex-charge-
                    feeCost = 0;
                }
            }
            return {
                'info': transaction,
                'id': id,
                'currency': code,
                'amount': amount,
                'address': address,
                'tag': undefined,
                'status': status,
                'type': type,
                'updated': updated,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': {
                    'currency': code,
                    'cost': feeCost,
                },
            };
        }
    
        parseTimeInForce (timeInForce) {
            const timeInForces = {
                'GOOD_TIL_CANCELLED': 'GTC',
                'IMMEDIATE_OR_CANCEL': 'IOC',
                'FILL_OR_KILL': 'FOK',
                'POST_ONLY_GOOD_TIL_CANCELLED': 'PO',
            };
            return this.safeString (timeInForces, timeInForce, timeInForce);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         id: '1be35109-b763-44ce-b6ea-05b6b0735c0c',
            //         marketSymbol: 'LTC-ETH',
            //         direction: 'BUY',
            //         type: 'LIMIT',
            //         quantity: '0.50000000',
            //         limit: '0.17846699',
            //         timeInForce: 'GOOD_TIL_CANCELLED',
            //         fillQuantity: '0.50000000',
            //         commission: '0.00022286',
            //         proceeds: '0.08914915',
            //         status: 'CLOSED',
            //         createdAt: '2018-06-23T13:14:28.613Z',
            //         updatedAt: '2018-06-23T13:14:30.19Z',
            //         closedAt: '2018-06-23T13:14:30.19Z'
            //     }
            //
            const marketSymbol = this.safeString (order, 'marketSymbol');
            market = this.safeMarket (marketSymbol, market, '-');
            const symbol = market['symbol'];
            const feeCurrency = market['quote'];
            const direction = this.safeStringLower (order, 'direction');
            const createdAt = this.safeString (order, 'createdAt');
            const updatedAt = this.safeString (order, 'updatedAt');
            const closedAt = this.safeString (order, 'closedAt');
            let lastTradeTimestamp = undefined;
            if (closedAt !== undefined) {
                lastTradeTimestamp = this.parse8601 (closedAt);
            } else if (updatedAt) {
                lastTradeTimestamp = this.parse8601 (updatedAt);
            }
            const timestamp = this.parse8601 (createdAt);
            const type = this.safeStringLower (order, 'type');
            const quantity = this.safeNumber (order, 'quantity');
            const limit = this.safeNumber (order, 'limit');
            const fillQuantity = this.safeNumber (order, 'fillQuantity');
            const commission = this.safeNumber (order, 'commission');
            const proceeds = this.safeNumber (order, 'proceeds');
            const status = this.safeStringLower (order, 'status');
            const timeInForce = this.parseTimeInForce (this.safeString (order, 'timeInForce'));
            const postOnly = (timeInForce === 'PO');
            return this.safeOrder ({
                'id': this.safeString (order, 'id'),
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': direction,
                'price': limit,
                'stopPrice': undefined,
                'cost': proceeds,
                'average': undefined,
                'amount': quantity,
                'filled': fillQuantity,
                'remaining': undefined,
                'status': status,
                'fee': {
                    'cost': commission,
                    'currency': feeCurrency,
                },
                'info': order,
                'trades': undefined,
            });
        }
    
        parseOrders (orders, market = undefined, since = undefined, limit = undefined, params = {}) {
            if (this.options['fetchClosedOrdersFilterBySince']) {
                return super.parseOrders (orders, market, since, limit, params);
            } else {
                return super.parseOrders (orders, market, undefined, limit, params);
            }
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'CLOSED': 'closed',
                'OPEN': 'open',
                'CANCELLED': 'canceled',
                'CANCELED': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            let response = undefined;
            try {
                const request = {
                    'orderId': id,
                };
                response = await this.privateGetOrdersOrderId (this.extend (request, params));
            } catch (e) {
                if (this.last_json_response) {
                    const message = this.safeString (this.last_json_response, 'message');
                    if (message === 'UUID_INVALID') {
                        throw new OrderNotFound (this.id + ' fetchOrder() error: ' + this.last_http_response);
                    }
                }
                throw e;
            }
            return this.parseOrder (response);
        }
    
        orderToTrade (order) {
            // this entire method should be moved to the base class
            const timestamp = this.safeInteger2 (order, 'lastTradeTimestamp', 'timestamp');
            return {
                'id': this.safeString (order, 'id'),
                'side': this.safeString (order, 'side'),
                'order': this.safeString (order, 'id'),
                'type': this.safeString (order, 'type'),
                'price': this.safeNumber (order, 'average'),
                'amount': this.safeNumber (order, 'filled'),
                'cost': this.safeNumber (order, 'cost'),
                'symbol': this.safeString (order, 'symbol'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': this.safeValue (order, 'fee'),
                'info': order,
                'takerOrMaker': undefined,
            };
        }
    
        ordersToTrades (orders) {
            // this entire method should be moved to the base class
            const result = [];
            for (let i = 0; i < orders.length; i++) {
                result.push (this.orderToTrade (orders[i]));
            }
            return result;
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            if (since !== undefined) {
                request['startDate'] = this.ymdhms (since, 'T') + 'Z';
            }
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                // because of this line we will have to rethink the entire v3
                // in other words, markets define all the rest of the API
                // and v3 market ids are reversed in comparison to v1
                // v3 has to be a completely separate implementation
                // otherwise we will have to shuffle symbols and currencies everywhere
                // which is prone to errors, as was shown here
                // https://github.com/ccxt/ccxt/pull/5219#issuecomment-499646209
                request['marketSymbol'] = market['base'] + '-' + market['quote'];
            }
            const response = await this.privateGetOrdersClosed (this.extend (request, params));
            const orders = this.parseOrders (response, market);
            const trades = this.ordersToTrades (orders);
            return this.filterBySymbolSinceLimit (trades, symbol, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            if (since !== undefined) {
                request['startDate'] = this.ymdhms (since, 'T') + 'Z';
            }
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                // because of this line we will have to rethink the entire v3
                // in other words, markets define all the rest of the API
                // and v3 market ids are reversed in comparison to v1
                // v3 has to be a completely separate implementation
                // otherwise we will have to shuffle symbols and currencies everywhere
                // which is prone to errors, as was shown here
                // https://github.com/ccxt/ccxt/pull/5219#issuecomment-499646209
                request['marketSymbol'] = market['base'] + '-' + market['quote'];
            }
            const response = await this.privateGetOrdersClosed (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currencySymbol': currency['id'],
            };
            const response = await this.privatePostAddresses (this.extend (request, params));
            //
            //     {
            //         "status":"PROVISIONED",
            //         "currencySymbol":"XRP",
            //         "cryptoAddress":"rPVMhWBsfF9iMXYj3aAzJVkPDTFNSyWdKy",
            //         "cryptoAddressTag":"392034158"
            //     }
            //
            let address = this.safeString (response, 'cryptoAddress');
            const message = this.safeString (response, 'status');
            if (!address || message === 'REQUESTED') {
                throw new AddressPending (this.id + ' the address for ' + code + ' is being generated (pending, not ready yet, retry again later)');
            }
            let tag = this.safeString (response, 'cryptoAddressTag');
            if ((tag === undefined) && (currency['type'] in this.options['tag'])) {
                tag = address;
                address = currency['address'];
            }
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currencySymbol': currency['id'],
            };
            const response = await this.privateGetAddressesCurrencySymbol (this.extend (request, params));
            //
            //     {
            //         "status":"PROVISIONED",
            //         "currencySymbol":"XRP",
            //         "cryptoAddress":"rPVMhWBsfF9iMXYj3aAzJVkPDTFNSyWdKy",
            //         "cryptoAddressTag":"392034158"
            //     }
            //
            let address = this.safeString (response, 'cryptoAddress');
            const message = this.safeString (response, 'status');
            if (!address || message === 'REQUESTED') {
                throw new AddressPending (this.id + ' the address for ' + code + ' is being generated (pending, not ready yet, retry again later)');
            }
            let tag = this.safeString (response, 'cryptoAddressTag');
            if ((tag === undefined) && (currency['type'] in this.options['tag'])) {
                tag = address;
                address = currency['address'];
            }
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currencySymbol': currency['id'],
                'quantity': amount,
                'cryptoAddress': address,
            };
            if (tag !== undefined) {
                request['cryptoAddressTag'] = tag;
            }
            const response = await this.privatePostWithdrawals (this.extend (request, params));
            const id = this.safeString (response, 'id');
            return {
                'info': response,
                'id': id,
            };
        }
    
        sign (path, api = 'v3', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.implodeParams (this.urls['api'][api], {
                'hostname': this.hostname,
            }) + '/';
            if (api === 'private') {
                url += this.version + '/';
                this.checkRequiredCredentials ();
                url += this.implodeParams (path, params);
                params = this.omit (params, this.extractParams (path));
                let hashString = '';
                if (method === 'POST') {
                    body = this.json (params);
                    hashString = body;
                } else {
                    if (Object.keys (params).length) {
                        url += '?' + this.rawencode (params);
                    }
                }
                const contentHash = this.hash (this.encode (hashString), 'sha512', 'hex');
                const timestamp = this.milliseconds ().toString ();
                let auth = timestamp + url + method + contentHash;
                const subaccountId = this.safeValue (this.options, 'subaccountId');
                if (subaccountId !== undefined) {
                    auth += subaccountId;
                }
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha512');
                headers = {
                    'Api-Key': this.apiKey,
                    'Api-Timestamp': timestamp,
                    'Api-Content-Hash': contentHash,
                    'Api-Signature': signature,
                };
                if (subaccountId !== undefined) {
                    headers['Api-Subaccount-Id'] = subaccountId;
                }
                if (method === 'POST') {
                    headers['Content-Type'] = 'application/json';
                }
            } else {
                if (api === 'public') {
                    url += this.version + '/';
                }
                url += this.implodeParams (path, params);
                params = this.omit (params, this.extractParams (path));
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     { success: false, message: "message" }
            //
            if (body[0] === '{') {
                const feedback = this.id + ' ' + body;
                let success = this.safeValue (response, 'success');
                if (success === undefined) {
                    const code = this.safeString (response, 'code');
                    if ((code === 'NOT_FOUND') && (url.indexOf ('addresses') >= 0)) {
                        throw new InvalidAddress (feedback);
                    }
                    if (code !== undefined) {
                        this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);
                        this.throwBroadlyMatchedException (this.exceptions['broad'], code, feedback);
                    }
                    // throw new ExchangeError (this.id + ' malformed response ' + this.json (response));
                    return;
                }
                if (typeof success === 'string') {
                    // bleutrade uses string instead of boolean
                    success = (success === 'true');
                }
                if (!success) {
                    const message = this.safeString (response, 'message');
                    if (message === 'APIKEY_INVALID') {
                        if (this.options['hasAlreadyAuthenticatedSuccessfully']) {
                            throw new DDoSProtection (feedback);
                        } else {
                            throw new AuthenticationError (feedback);
                        }
                    }
                    // https://github.com/ccxt/ccxt/issues/4932
                    // the following two lines are now redundant, see line 171 in describe()
                    //
                    //     if (message === 'DUST_TRADE_DISALLOWED_MIN_VALUE_50K_SAT')
                    //         throw new InvalidOrder (this.id + ' order cost should be over 50k satoshi ' + this.json (response));
                    //
                    if (message === 'INVALID_ORDER') {
                        // Bittrex will return an ambiguous INVALID_ORDER message
                        // upon canceling already-canceled and closed orders
                        // therefore this special case for cancelOrder
                        // let url = 'https://bittrex.com/api/v1.1/market/cancel?apikey=API_KEY&uuid=ORDER_UUID'
                        const cancel = 'cancel';
                        const indexOfCancel = url.indexOf (cancel);
                        if (indexOfCancel >= 0) {
                            const urlParts = url.split ('?');
                            const numParts = urlParts.length;
                            if (numParts > 1) {
                                const query = urlParts[1];
                                const params = query.split ('&');
                                const numParams = params.length;
                                let orderId = undefined;
                                for (let i = 0; i < numParams; i++) {
                                    const param = params[i];
                                    const keyValue = param.split ('=');
                                    if (keyValue[0] === 'uuid') {
                                        orderId = keyValue[1];
                                        break;
                                    }
                                }
                                if (orderId !== undefined) {
                                    throw new OrderNotFound (this.id + ' cancelOrder ' + orderId + ' ' + this.json (response));
                                } else {
                                    throw new OrderNotFound (this.id + ' cancelOrder ' + this.json (response));
                                }
                            }
                        }
                    }
                    this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                    if (message !== undefined) {
                        this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                    }
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],46:[function(require,module,exports){
    'use strict';
    
    // ----------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, BadSymbol, AuthenticationError, InsufficientFunds, InvalidOrder, ArgumentsRequired, OrderNotFound, InvalidAddress, BadRequest, RateLimitExceeded, PermissionDenied, ExchangeNotAvailable, AccountSuspended, OnMaintenance } = require ('./base/errors');
    const { SIGNIFICANT_DIGITS, DECIMAL_PLACES, TRUNCATE, ROUND } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    // ----------------------------------------------------------------------------
    
    module.exports = class bitvavo extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitvavo',
                'name': 'Bitvavo',
                'countries': [ 'NL' ], // Netherlands
                'rateLimit': 500,
                'version': 'v2',
                'certified': true,
                'pro': true,
                'has': {
                    'CORS': false,
                    'publicAPI': true,
                    'privateAPI': true,
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrders': true,
                    'fetchOrderBook': true,
                    'fetchMarkets': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '2h': '2h',
                    '4h': '4h',
                    '6h': '6h',
                    '8h': '8h',
                    '12h': '12h',
                    '1d': '1d',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/83165440-2f1cf200-a116-11ea-9046-a255d09fb2ed.jpg',
                    'api': {
                        'public': 'https://api.bitvavo.com',
                        'private': 'https://api.bitvavo.com',
                    },
                    'www': 'https://bitvavo.com/',
                    'doc': 'https://docs.bitvavo.com/',
                    'fees': 'https://bitvavo.com/en/fees',
                    'referral': 'https://bitvavo.com/?a=24F34952F7',
                },
                'api': {
                    'public': {
                        'get': [
                            'time',
                            'markets',
                            'assets',
                            '{market}/book',
                            '{market}/trades',
                            '{market}/candles',
                            'ticker/price',
                            'ticker/book',
                            'ticker/24h',
                        ],
                    },
                    'private': {
                        'get': [
                            'order',
                            'orders',
                            'ordersOpen',
                            'trades',
                            'balance',
                            'deposit',
                            'depositHistory',
                            'withdrawalHistory',
                        ],
                        'post': [
                            'order',
                            'withdrawal',
                        ],
                        'put': [
                            'order',
                        ],
                        'delete': [
                            'order',
                            'orders',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': this.parseNumber ('0.0025'),
                        'maker': this.parseNumber ('0.002'),
                        'tiers': {
                            'taker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.0025') ],
                                [ this.parseNumber ('50000'), this.parseNumber ('0.0024') ],
                                [ this.parseNumber ('100000'), this.parseNumber ('0.0022') ],
                                [ this.parseNumber ('250000'), this.parseNumber ('0.0020') ],
                                [ this.parseNumber ('500000'), this.parseNumber ('0.0018') ],
                                [ this.parseNumber ('1000000'), this.parseNumber ('0.0016') ],
                                [ this.parseNumber ('2500000'), this.parseNumber ('0.0014') ],
                                [ this.parseNumber ('5000000'), this.parseNumber ('0.0012') ],
                                [ this.parseNumber ('10000000'), this.parseNumber ('0.0010') ],
                            ],
                            'maker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.0020') ],
                                [ this.parseNumber ('50000'), this.parseNumber ('0.0015') ],
                                [ this.parseNumber ('100000'), this.parseNumber ('0.0010') ],
                                [ this.parseNumber ('250000'), this.parseNumber ('0.0006') ],
                                [ this.parseNumber ('500000'), this.parseNumber ('0.0003') ],
                                [ this.parseNumber ('1000000'), this.parseNumber ('0.0001') ],
                                [ this.parseNumber ('2500000'), this.parseNumber ('-0.0001') ],
                                [ this.parseNumber ('5000000'), this.parseNumber ('-0.0003') ],
                                [ this.parseNumber ('10000000'), this.parseNumber ('-0.0005') ],
                            ],
                        },
                    },
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                },
                'exceptions': {
                    'exact': {
                        '101': ExchangeError, // Unknown error. Operation may or may not have succeeded.
                        '102': BadRequest, // Invalid JSON.
                        '103': RateLimitExceeded, // You have been rate limited. Please observe the Bitvavo-Ratelimit-AllowAt header to see when you can send requests again. Failure to respect this limit will result in an IP ban. The default value is 1000 weighted requests per minute. Please contact support if you wish to increase this limit.
                        '104': RateLimitExceeded, // You have been rate limited by the number of new orders. The default value is 100 new orders per second or 100.000 new orders per day. Please update existing orders instead of cancelling and creating orders. Please contact support if you wish to increase this limit.
                        '105': PermissionDenied, // Your IP or API key has been banned for not respecting the rate limit. The ban expires at ${expiryInMs}.
                        '107': ExchangeNotAvailable, // The matching engine is overloaded. Please wait 500ms and resubmit your order.
                        '108': ExchangeNotAvailable, // The matching engine could not process your order in time. Please consider increasing the access window or resubmit your order.
                        '109': ExchangeNotAvailable, // The matching engine did not respond in time. Operation may or may not have succeeded.
                        '110': BadRequest, // Invalid endpoint. Please check url and HTTP method.
                        '200': BadRequest, // ${param} url parameter is not supported. Please note that parameters are case-sensitive and use body parameters for PUT and POST requests.
                        '201': BadRequest, // ${param} body parameter is not supported. Please note that parameters are case-sensitive and use url parameters for GET and DELETE requests.
                        '202': BadRequest, // ${param} order parameter is not supported. Please note that certain parameters are only allowed for market or limit orders.
                        '203': BadSymbol, // {"errorCode":203,"error":"symbol parameter is required."}
                        '204': BadRequest, // ${param} parameter is not supported.
                        '205': BadRequest, // ${param} parameter is invalid.
                        '206': BadRequest, // Use either ${paramA} or ${paramB}. The usage of both parameters at the same time is not supported.
                        '210': InvalidOrder, // Amount exceeds the maximum allowed amount (1000000000).
                        '211': InvalidOrder, // Price exceeds the maximum allowed amount (100000000000).
                        '212': InvalidOrder, // Amount is below the minimum allowed amount for this asset.
                        '213': InvalidOrder, // Price is below the minimum allowed amount (0.000000000000001).
                        '214': InvalidOrder, // Price is too detailed
                        '215': InvalidOrder, // Price is too detailed. A maximum of 15 digits behind the decimal point are allowed.
                        '216': InsufficientFunds, // {"errorCode":216,"error":"You do not have sufficient balance to complete this operation."}
                        '217': InvalidOrder, // {"errorCode":217,"error":"Minimum order size in quote currency is 5 EUR or 0.001 BTC."}
                        '230': ExchangeError, // The order is rejected by the matching engine.
                        '231': ExchangeError, // The order is rejected by the matching engine. TimeInForce must be GTC when markets are paused.
                        '232': BadRequest, // You must change at least one of amount, amountRemaining, price, timeInForce, selfTradePrevention or postOnly.
                        '233': InvalidOrder, // {"errorCode":233,"error":"Order must be active (status new or partiallyFilled) to allow updating/cancelling."}
                        '234': InvalidOrder, // Market orders cannot be updated.
                        '235': ExchangeError, // You can only have 100 open orders on each book.
                        '236': BadRequest, // You can only update amount or amountRemaining, not both.
                        '240': OrderNotFound, // {"errorCode":240,"error":"No order found. Please be aware that simultaneously updating the same order may return this error."}
                        '300': AuthenticationError, // Authentication is required for this endpoint.
                        '301': AuthenticationError, // {"errorCode":301,"error":"API Key must be of length 64."}
                        '302': AuthenticationError, // Timestamp is invalid. This must be a timestamp in ms. See Bitvavo-Access-Timestamp header or timestamp parameter for websocket.
                        '303': AuthenticationError, // Window must be between 100 and 60000 ms.
                        '304': AuthenticationError, // Request was not received within acceptable window (default 30s, or custom with Bitvavo-Access-Window header) of Bitvavo-Access-Timestamp header (or timestamp parameter for websocket).
                        // '304': AuthenticationError, // Authentication is required for this endpoint.
                        '305': AuthenticationError, // {"errorCode":305,"error":"No active API key found."}
                        '306': AuthenticationError, // No active API key found. Please ensure that you have confirmed the API key by e-mail.
                        '307': PermissionDenied, // This key does not allow access from this IP.
                        '308': AuthenticationError, // {"errorCode":308,"error":"The signature length is invalid (HMAC-SHA256 should return a 64 length hexadecimal string)."}
                        '309': AuthenticationError, // {"errorCode":309,"error":"The signature is invalid."}
                        '310': PermissionDenied, // This key does not allow trading actions.
                        '311': PermissionDenied, // This key does not allow showing account information.
                        '312': PermissionDenied, // This key does not allow withdrawal of funds.
                        '315': BadRequest, // Websocket connections may not be used in a browser. Please use REST requests for this.
                        '317': AccountSuspended, // This account is locked. Please contact support.
                        '400': ExchangeError, // Unknown error. Please contact support with a copy of your request.
                        '401': ExchangeError, // Deposits for this asset are not available at this time.
                        '402': PermissionDenied, // You need to verify your identitiy before you can deposit and withdraw digital assets.
                        '403': PermissionDenied, // You need to verify your phone number before you can deposit and withdraw digital assets.
                        '404': OnMaintenance, // Could not complete this operation, because our node cannot be reached. Possibly under maintenance.
                        '405': ExchangeError, // You cannot withdraw digital assets during a cooldown period. This is the result of newly added bank accounts.
                        '406': BadRequest, // {"errorCode":406,"error":"Your withdrawal is too small."}
                        '407': ExchangeError, // Internal transfer is not possible.
                        '408': InsufficientFunds, // {"errorCode":408,"error":"You do not have sufficient balance to complete this operation."}
                        '409': InvalidAddress, // {"errorCode":409,"error":"This is not a verified bank account."}
                        '410': ExchangeError, // Withdrawals for this asset are not available at this time.
                        '411': BadRequest, // You can not transfer assets to yourself.
                        '412': InvalidAddress, // {"errorCode":412,"error":"eth_address_invalid."}
                        '413': InvalidAddress, // This address violates the whitelist.
                        '414': ExchangeError, // You cannot withdraw assets within 2 minutes of logging in.
                    },
                    'broad': {
                        'start parameter is invalid': BadRequest, // {"errorCode":205,"error":"start parameter is invalid."}
                        'symbol parameter is invalid': BadSymbol, // {"errorCode":205,"error":"symbol parameter is invalid."}
                        'amount parameter is invalid': InvalidOrder, // {"errorCode":205,"error":"amount parameter is invalid."}
                        'orderId parameter is invalid': InvalidOrder, // {"errorCode":205,"error":"orderId parameter is invalid."}
                    },
                },
                'options': {
                    'BITVAVO-ACCESS-WINDOW': 10000, // default 10 sec
                    'fetchCurrencies': {
                        'expires': 1000, // 1 second
                    },
                },
                'precisionMode': SIGNIFICANT_DIGITS,
                'commonCurrencies': {
                    'MIOTA': 'IOTA', // https://github.com/ccxt/ccxt/issues/7487
                },
            });
        }
    
        currencyToPrecision (currency, fee) {
            return this.decimalToPrecision (fee, 0, this.currencies[currency]['precision']);
        }
    
        amountToPrecision (symbol, amount) {
            // https://docs.bitfinex.com/docs/introduction#amount-precision
            // The amount field allows up to 8 decimals.
            // Anything exceeding this will be rounded to the 8th decimal.
            return this.decimalToPrecision (amount, TRUNCATE, this.markets[symbol]['precision']['amount'], DECIMAL_PLACES);
        }
    
        priceToPrecision (symbol, price) {
            price = this.decimalToPrecision (price, ROUND, this.markets[symbol]['precision']['price'], this.precisionMode);
            // https://docs.bitfinex.com/docs/introduction#price-precision
            // The precision level of all trading prices is based on significant figures.
            // All pairs on Bitfinex use up to 5 significant digits and up to 8 decimals (e.g. 1.2345, 123.45, 1234.5, 0.00012345).
            // Prices submit with a precision larger than 5 will be cut by the API.
            return this.decimalToPrecision (price, TRUNCATE, 8, DECIMAL_PLACES);
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     { "time": 1590379519148 }
            //
            return this.safeInteger (response, 'time');
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarkets (params);
            const currencies = await this.fetchCurrenciesFromCache (params);
            const currenciesById = this.indexBy (currencies, 'symbol');
            //
            //     [
            //         {
            //             "market":"ADA-BTC",
            //             "status":"trading", // "trading" "halted" "auction"
            //             "base":"ADA",
            //             "quote":"BTC",
            //             "pricePrecision":5,
            //             "minOrderInBaseAsset":"100",
            //             "minOrderInQuoteAsset":"0.001",
            //             "orderTypes": [ "market", "limit" ]
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'market');
                const baseId = this.safeString (market, 'base');
                const quoteId = this.safeString (market, 'quote');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const status = this.safeString (market, 'status');
                const active = (status === 'trading');
                const baseCurrency = this.safeValue (currenciesById, baseId);
                let amountPrecision = undefined;
                if (baseCurrency !== undefined) {
                    amountPrecision = this.safeInteger (baseCurrency, 'decimals', 8);
                }
                const precision = {
                    'price': this.safeInteger (market, 'pricePrecision'),
                    'amount': amountPrecision,
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                    'active': active,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'minOrderInBaseAsset'),
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.safeNumber (market, 'minOrderInQuoteAsset'),
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchCurrenciesFromCache (params = {}) {
            // this method is now redundant
            // currencies are now fetched before markets
            const options = this.safeValue (this.options, 'fetchCurrencies', {});
            const timestamp = this.safeInteger (options, 'timestamp');
            const expires = this.safeInteger (options, 'expires', 1000);
            const now = this.milliseconds ();
            if ((timestamp === undefined) || ((now - timestamp) > expires)) {
                const response = await this.publicGetAssets (params);
                this.options['fetchCurrencies'] = this.extend (options, {
                    'response': response,
                    'timestamp': now,
                });
            }
            return this.safeValue (this.options['fetchCurrencies'], 'response');
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.fetchCurrenciesFromCache (params);
            //
            //     [
            //         {
            //             "symbol":"ADA",
            //             "name":"Cardano",
            //             "decimals":6,
            //             "depositFee":"0",
            //             "depositConfirmations":15,
            //             "depositStatus":"OK", // "OK", "MAINTENANCE", "DELISTED"
            //             "withdrawalFee":"0.2",
            //             "withdrawalMinAmount":"0.2",
            //             "withdrawalStatus":"OK", // "OK", "MAINTENANCE", "DELISTED"
            //             "networks": [ "Mainnet" ], // "ETH", "NEO", "ONT", "SEPA", "VET"
            //             "message":"",
            //         },
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'symbol');
                const code = this.safeCurrencyCode (id);
                const depositStatus = this.safeValue (currency, 'depositStatus');
                const deposit = (depositStatus === 'OK');
                const withdrawalStatus = this.safeValue (currency, 'withdrawalStatus');
                const withdrawal = (withdrawalStatus === 'OK');
                const active = deposit && withdrawal;
                const name = this.safeString (currency, 'name');
                const precision = this.safeInteger (currency, 'decimals', 8);
                result[code] = {
                    'id': id,
                    'info': currency,
                    'code': code,
                    'name': name,
                    'active': active,
                    'fee': this.safeNumber (currency, 'withdrawalFee'),
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'withdrawalMinAmount'),
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetTicker24h (this.extend (request, params));
            //
            //     {
            //         "market":"ETH-BTC",
            //         "open":"0.022578",
            //         "high":"0.023019",
            //         "low":"0.022573",
            //         "last":"0.023019",
            //         "volume":"25.16366324",
            //         "volumeQuote":"0.57333305",
            //         "bid":"0.023039",
            //         "bidSize":"0.53500578",
            //         "ask":"0.023041",
            //         "askSize":"0.47859202",
            //         "timestamp":1590381666900
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker
            //
            //     {
            //         "market":"ETH-BTC",
            //         "open":"0.022578",
            //         "high":"0.023019",
            //         "low":"0.022573",
            //         "last":"0.023019",
            //         "volume":"25.16366324",
            //         "volumeQuote":"0.57333305",
            //         "bid":"0.023039",
            //         "bidSize":"0.53500578",
            //         "ask":"0.023041",
            //         "askSize":"0.47859202",
            //         "timestamp":1590381666900
            //     }
            //
            const marketId = this.safeString (ticker, 'market');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = this.safeInteger (ticker, 'timestamp');
            const last = this.safeNumber (ticker, 'last');
            const baseVolume = this.safeNumber (ticker, 'volume');
            const quoteVolume = this.safeNumber (ticker, 'volumeQuote');
            const vwap = this.vwap (baseVolume, quoteVolume);
            const open = this.safeNumber (ticker, 'open');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': this.safeNumber (ticker, 'bidSize'),
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': this.safeNumber (ticker, 'askSize'),
                'vwap': vwap,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined, // previous day close
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTicker24h (params);
            //
            //     [
            //         {
            //             "market":"ADA-BTC",
            //             "open":"0.0000059595",
            //             "high":"0.0000059765",
            //             "low":"0.0000059595",
            //             "last":"0.0000059765",
            //             "volume":"2923.172",
            //             "volumeQuote":"0.01743483",
            //             "bid":"0.0000059515",
            //             "bidSize":"1117.630919",
            //             "ask":"0.0000059585",
            //             "askSize":"809.999739",
            //             "timestamp":1590382266324
            //         }
            //     ]
            //
            return this.parseTickers (response, symbols);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                // 'limit': 500, // default 500, max 1000
                // 'start': since,
                // 'end': this.milliseconds (),
                // 'tradeIdFrom': '57b1159b-6bf5-4cde-9e2c-6bd6a5678baf',
                // 'tradeIdTo': '57b1159b-6bf5-4cde-9e2c-6bd6a5678baf',
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            const response = await this.publicGetMarketTrades (this.extend (request, params));
            //
            //     [
            //         {
            //             "id":"94154c98-6e8b-4e33-92a8-74e33fc05650",
            //             "timestamp":1590382761859,
            //             "amount":"0.06026079",
            //             "price":"8095.3",
            //             "side":"buy"
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "id":"94154c98-6e8b-4e33-92a8-74e33fc05650",
            //         "timestamp":1590382761859,
            //         "amount":"0.06026079",
            //         "price":"8095.3",
            //         "side":"buy"
            //     }
            //
            // createOrder, fetchOpenOrders, fetchOrders, editOrder (private)
            //
            //     {
            //         "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //         "timestamp":1590505649245,
            //         "amount":"0.249825",
            //         "price":"183.49",
            //         "taker":true,
            //         "fee":"0.12038925",
            //         "feeCurrency":"EUR",
            //         "settled":true
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //         "orderId":"af76d6ce-9f7c-4006-b715-bb5d430652d0",
            //         "timestamp":1590505649245,
            //         "market":"ETH-EUR",
            //         "side":"sell",
            //         "amount":"0.249825",
            //         "price":"183.49",
            //         "taker":true,
            //         "fee":"0.12038925",
            //         "feeCurrency":"EUR",
            //         "settled":true
            //     }
            //
            // watchMyTrades (private)
            //
            //     {
            //         event: 'fill',
            //         timestamp: 1590964470132,
            //         market: 'ETH-EUR',
            //         orderId: '85d082e1-eda4-4209-9580-248281a29a9a',
            //         fillId: '861d2da5-aa93-475c-8d9a-dce431bd4211',
            //         side: 'sell',
            //         amount: '0.1',
            //         price: '211.46',
            //         taker: true,
            //         fee: '0.056',
            //         feeCurrency: 'EUR'
            //     }
            //
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const timestamp = this.safeInteger (trade, 'timestamp');
            const side = this.safeString (trade, 'side');
            const id = this.safeString2 (trade, 'id', 'fillId');
            const marketId = this.safeInteger (trade, 'market');
            const symbol = this.safeSymbol (marketId, market, '-');
            const taker = this.safeValue (trade, 'taker');
            let takerOrMaker = undefined;
            if (taker !== undefined) {
                takerOrMaker = taker ? 'taker' : 'maker';
            }
            const feeCost = this.safeNumber (trade, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'feeCurrency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            const orderId = this.safeString (trade, 'orderId');
            return {
                'info': trade,
                'id': id,
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'market': this.marketId (symbol),
            };
            if (limit !== undefined) {
                request['depth'] = limit;
            }
            const response = await this.publicGetMarketBook (this.extend (request, params));
            //
            //     {
            //         "market":"BTC-EUR",
            //         "nonce":35883831,
            //         "bids":[
            //             ["8097.4","0.6229099"],
            //             ["8097.2","0.64151283"],
            //             ["8097.1","0.24966294"],
            //         ],
            //         "asks":[
            //             ["8097.5","1.36916911"],
            //             ["8098.8","0.33462248"],
            //             ["8099.3","1.12908646"],
            //         ]
            //     }
            //
            const orderbook = this.parseOrderBook (response, symbol);
            orderbook['nonce'] = this.safeInteger (response, 'nonce');
            return orderbook;
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1590383700000,
            //         "8088.5",
            //         "8088.5",
            //         "8088.5",
            //         "8088.5",
            //         "0.04788623"
            //     ]
            //
            return [
                this.safeInteger (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                'interval': this.timeframes[timeframe],
                // 'limit': 1440, // default 1440, max 1440
                // 'start': since,
                // 'end': this.milliseconds (),
            };
            if (since !== undefined) {
                // https://github.com/ccxt/ccxt/issues/9227
                const duration = this.parseTimeframe (timeframe);
                request['start'] = since;
                if (limit === undefined) {
                    limit = 1440;
                }
                request['end'] = this.sum (since, limit * duration * 1000);
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 1440, max 1440
            }
            const response = await this.publicGetMarketCandles (this.extend (request, params));
            //
            //     [
            //         [1590383700000,"8088.5","8088.5","8088.5","8088.5","0.04788623"],
            //         [1590383580000,"8091.3","8091.5","8091.3","8091.5","0.04931221"],
            //         [1590383520000,"8090.3","8092.7","8090.3","8092.5","0.04001286"],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetBalance (params);
            //
            //     [
            //         {
            //             "symbol": "BTC",
            //             "available": "1.57593193",
            //             "inOrder": "0.74832374"
            //         }
            //     ]
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'symbol');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'inOrder');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'symbol': currency['id'],
            };
            const response = await this.privateGetDeposit (this.extend (request, params));
            //
            //     {
            //         "address": "0x449889e3234514c45d57f7c5a571feba0c7ad567",
            //         "paymentId": "10002653"
            //     }
            //
            const address = this.safeString (response, 'address');
            const tag = this.safeString (response, 'paymentId');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                'side': side,
                'orderType': type, // 'market', 'limit', 'stopLoss', 'stopLossLimit', 'takeProfit', 'takeProfitLimit'
                // 'amount': this.amountToPrecision (symbol, amount),
                // 'price': this.priceToPrecision (symbol, price),
                // 'amountQuote': this.costToPrecision (symbol, cost),
                // 'timeInForce': 'GTC', // 'GTC', 'IOC', 'FOK'
                // 'selfTradePrevention': 'decrementAndCancel', // 'decrementAndCancel', 'cancelOldest', 'cancelNewest', 'cancelBoth'
                // 'postOnly': false,
                // 'disableMarketProtection': false, // don't cancel if the next fill price is 10% worse than the best fill price
                // 'responseRequired': true, // false is faster
            };
            const isStopLimit = (type === 'stopLossLimit') || (type === 'takeProfitLimit');
            const isStopMarket = (type === 'stopLoss') || (type === 'takeProfit');
            if (type === 'market') {
                let cost = undefined;
                if (price !== undefined) {
                    cost = amount * price;
                } else {
                    cost = this.safeNumber2 (params, 'cost', 'amountQuote');
                }
                if (cost !== undefined) {
                    const precision = market['precision']['price'];
                    request['amountQuote'] = this.decimalToPrecision (cost, TRUNCATE, precision, this.precisionMode);
                } else {
                    request['amount'] = this.amountToPrecision (symbol, amount);
                }
                params = this.omit (params, [ 'cost', 'amountQuote' ]);
            } else if (type === 'limit') {
                request['price'] = this.priceToPrecision (symbol, price);
                request['amount'] = this.amountToPrecision (symbol, amount);
            } else if (isStopMarket || isStopLimit) {
                let stopPrice = this.safeNumber2 (params, 'stopPrice', 'triggerAmount');
                if (stopPrice === undefined) {
                    if (isStopLimit) {
                        throw new ArgumentsRequired (this.id + ' createOrder requires a stopPrice parameter for a ' + type + ' order');
                    } else if (isStopMarket) {
                        if (price === undefined) {
                            throw new ArgumentsRequired (this.id + ' createOrder requires a price argument or a stopPrice parameter for a ' + type + ' order');
                        } else {
                            stopPrice = price;
                        }
                    }
                }
                if (isStopLimit) {
                    request['price'] = this.priceToPrecision (symbol, price);
                }
                params = this.omit (params, [ 'stopPrice', 'triggerAmount' ]);
                request['triggerAmount'] = this.priceToPrecision (symbol, stopPrice);
                request['triggerType'] = 'price';
                request['amount'] = this.amountToPrecision (symbol, amount);
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            //
            //     {
            //         "orderId":"af76d6ce-9f7c-4006-b715-bb5d430652d0",
            //         "market":"ETH-EUR",
            //         "created":1590505649241,
            //         "updated":1590505649241,
            //         "status":"filled",
            //         "side":"sell",
            //         "orderType":"market",
            //         "amount":"0.249825",
            //         "amountRemaining":"0",
            //         "onHold":"0",
            //         "onHoldCurrency":"ETH",
            //         "filledAmount":"0.249825",
            //         "filledAmountQuote":"45.84038925",
            //         "feePaid":"0.12038925",
            //         "feeCurrency":"EUR",
            //         "fills":[
            //             {
            //                 "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //                 "timestamp":1590505649245,
            //                 "amount":"0.249825",
            //                 "price":"183.49",
            //                 "taker":true,
            //                 "fee":"0.12038925",
            //                 "feeCurrency":"EUR",
            //                 "settled":true
            //             }
            //         ],
            //         "selfTradePrevention":"decrementAndCancel",
            //         "visible":false,
            //         "disableMarketProtection":false
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async editOrder (id, symbol, type, side, amount = undefined, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let request = {};
            const amountRemaining = this.safeNumber (params, 'amountRemaining');
            params = this.omit (params, 'amountRemaining');
            if (price !== undefined) {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            if (amount !== undefined) {
                request['amount'] = this.amountToPrecision (symbol, amount);
            }
            if (amountRemaining !== undefined) {
                request['amountRemaining'] = this.amountToPrecision (symbol, amountRemaining);
            }
            request = this.extend (request, params);
            if (Object.keys (request).length) {
                request['orderId'] = id;
                request['market'] = market['id'];
                const response = await this.privatePutOrder (this.extend (request, params));
                return this.parseOrder (response, market);
            } else {
                throw new ArgumentsRequired (this.id + ' editOrder() requires an amount argument, or a price argument, or non-empty params');
            }
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'orderId': id,
                'market': market['id'],
            };
            const response = await this.privateDeleteOrder (this.extend (request, params));
            //
            //     {
            //         "orderId": "2e7ce7fc-44e2-4d80-a4a7-d079c4750b61"
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['market'] = market['id'];
            }
            const response = await this.privateDeleteOrders (this.extend (request, params));
            //
            //     [
            //         {
            //             "orderId": "1be6d0df-d5dc-4b53-a250-3376f3b393e6"
            //         }
            //     ]
            //
            return this.parseOrders (response, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'orderId': id,
                'market': market['id'],
            };
            const response = await this.privateGetOrder (this.extend (request, params));
            //
            //     {
            //         "orderId":"af76d6ce-9f7c-4006-b715-bb5d430652d0",
            //         "market":"ETH-EUR",
            //         "created":1590505649241,
            //         "updated":1590505649241,
            //         "status":"filled",
            //         "side":"sell",
            //         "orderType":"market",
            //         "amount":"0.249825",
            //         "amountRemaining":"0",
            //         "onHold":"0",
            //         "onHoldCurrency":"ETH",
            //         "filledAmount":"0.249825",
            //         "filledAmountQuote":"45.84038925",
            //         "feePaid":"0.12038925",
            //         "feeCurrency":"EUR",
            //         "fills":[
            //             {
            //                 "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //                 "timestamp":1590505649245,
            //                 "amount":"0.249825",
            //                 "price":"183.49",
            //                 "taker":true,
            //                 "fee":"0.12038925",
            //                 "feeCurrency":"EUR",
            //                 "settled":true
            //             }
            //         ],
            //         "selfTradePrevention":"decrementAndCancel",
            //         "visible":false,
            //         "disableMarketProtection":false
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                // 'limit': 500,
                // 'start': since,
                // 'end': this.milliseconds (),
                // 'orderIdFrom': 'af76d6ce-9f7c-4006-b715-bb5d430652d0',
                // 'orderIdTo': 'af76d6ce-9f7c-4006-b715-bb5d430652d0',
            };
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.privateGetOrders (this.extend (request, params));
            //
            //     [
            //         {
            //             "orderId":"af76d6ce-9f7c-4006-b715-bb5d430652d0",
            //             "market":"ETH-EUR",
            //             "created":1590505649241,
            //             "updated":1590505649241,
            //             "status":"filled",
            //             "side":"sell",
            //             "orderType":"market",
            //             "amount":"0.249825",
            //             "amountRemaining":"0",
            //             "onHold":"0",
            //             "onHoldCurrency":"ETH",
            //             "filledAmount":"0.249825",
            //             "filledAmountQuote":"45.84038925",
            //             "feePaid":"0.12038925",
            //             "feeCurrency":"EUR",
            //             "fills":[
            //                 {
            //                     "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //                     "timestamp":1590505649245,
            //                     "amount":"0.249825",
            //                     "price":"183.49",
            //                     "taker":true,
            //                     "fee":"0.12038925",
            //                     "feeCurrency":"EUR",
            //                     "settled":true
            //                 }
            //             ],
            //             "selfTradePrevention":"decrementAndCancel",
            //             "visible":false,
            //             "disableMarketProtection":false
            //         }
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'market': market['id'], // rate limit 25 without a market, 1 with market specified
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['market'] = market['id'];
            }
            const response = await this.privateGetOrdersOpen (this.extend (request, params));
            //
            //     [
            //         {
            //             "orderId":"af76d6ce-9f7c-4006-b715-bb5d430652d0",
            //             "market":"ETH-EUR",
            //             "created":1590505649241,
            //             "updated":1590505649241,
            //             "status":"filled",
            //             "side":"sell",
            //             "orderType":"market",
            //             "amount":"0.249825",
            //             "amountRemaining":"0",
            //             "onHold":"0",
            //             "onHoldCurrency":"ETH",
            //             "filledAmount":"0.249825",
            //             "filledAmountQuote":"45.84038925",
            //             "feePaid":"0.12038925",
            //             "feeCurrency":"EUR",
            //             "fills":[
            //                 {
            //                     "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //                     "timestamp":1590505649245,
            //                     "amount":"0.249825",
            //                     "price":"183.49",
            //                     "taker":true,
            //                     "fee":"0.12038925",
            //                     "feeCurrency":"EUR",
            //                     "settled":true
            //                 }
            //             ],
            //             "selfTradePrevention":"decrementAndCancel",
            //             "visible":false,
            //             "disableMarketProtection":false
            //         }
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'new': 'open',
                'canceled': 'canceled',
                'canceledAuction': 'canceled',
                'canceledSelfTradePrevention': 'canceled',
                'canceledIOC': 'canceled',
                'canceledFOK': 'canceled',
                'canceledMarketProtection': 'canceled',
                'canceledPostOnly': 'canceled',
                'filled': 'closed',
                'partiallyFilled': 'open',
                'expired': 'canceled',
                'rejected': 'canceled',
                'awaitingTrigger': 'open', // https://github.com/ccxt/ccxt/issues/8489
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // cancelOrder, cancelAllOrders
            //
            //     {
            //         "orderId": "2e7ce7fc-44e2-4d80-a4a7-d079c4750b61"
            //     }
            //
            // createOrder, fetchOrder, fetchOpenOrders, fetchOrders, editOrder
            //
            //     {
            //         "orderId":"af76d6ce-9f7c-4006-b715-bb5d430652d0",
            //         "market":"ETH-EUR",
            //         "created":1590505649241,
            //         "updated":1590505649241,
            //         "status":"filled",
            //         "side":"sell",
            //         "orderType":"market",
            //         "amount":"0.249825",
            //         "amountRemaining":"0",
            //         "price": "183.49", // limit orders only
            //         "onHold":"0",
            //         "onHoldCurrency":"ETH",
            //         "filledAmount":"0.249825",
            //         "filledAmountQuote":"45.84038925",
            //         "feePaid":"0.12038925",
            //         "feeCurrency":"EUR",
            //         "fills":[
            //             {
            //                 "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //                 "timestamp":1590505649245,
            //                 "amount":"0.249825",
            //                 "price":"183.49",
            //                 "taker":true,
            //                 "fee":"0.12038925",
            //                 "feeCurrency":"EUR",
            //                 "settled":true
            //             }
            //         ],
            //         "selfTradePrevention":"decrementAndCancel",
            //         "visible":false,
            //         "disableMarketProtection":false
            //         "timeInForce": "GTC",
            //         "postOnly": true,
            //     }
            //
            const id = this.safeString (order, 'orderId');
            const timestamp = this.safeInteger (order, 'created');
            const marketId = this.safeString (order, 'market');
            const symbol = this.safeSymbol (marketId, market, '-');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const side = this.safeString (order, 'side');
            const type = this.safeString (order, 'orderType');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount');
            const remaining = this.safeNumber (order, 'amountRemaining');
            const filled = this.safeNumber (order, 'filledAmount');
            const cost = this.safeNumber (order, 'filledAmountQuote');
            let fee = undefined;
            const feeCost = this.safeNumber (order, 'feePaid');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (order, 'feeCurrency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            const rawTrades = this.safeValue (order, 'fills', []);
            const trades = this.parseTrades (rawTrades, market, undefined, undefined, {
                'symbol': symbol,
                'order': id,
                'side': side,
                'type': type,
            });
            const timeInForce = this.safeString (order, 'timeInForce');
            const postOnly = this.safeValue (order, 'postOnly');
            // https://github.com/ccxt/ccxt/issues/8489
            const stopPrice = this.safeNumber (order, 'triggerPrice');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': cost,
                'average': undefined,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': trades,
            });
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                // 'limit': 500,
                // 'start': since,
                // 'end': this.milliseconds (),
                // 'tradeIdFrom': 'af76d6ce-9f7c-4006-b715-bb5d430652d0',
                // 'tradeIdTo': 'af76d6ce-9f7c-4006-b715-bb5d430652d0',
            };
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.privateGetTrades (this.extend (request, params));
            //
            //     [
            //         {
            //             "id":"b0c86aa5-6ed3-4a2d-ba3a-be9a964220f4",
            //             "orderId":"af76d6ce-9f7c-4006-b715-bb5d430652d0",
            //             "timestamp":1590505649245,
            //             "market":"ETH-EUR",
            //             "side":"sell",
            //             "amount":"0.249825",
            //             "price":"183.49",
            //             "taker":true,
            //             "fee":"0.12038925",
            //             "feeCurrency":"EUR",
            //             "settled":true
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'symbol': currency['id'],
                'amount': this.currencyToPrecision (code, amount),
                'address': address, // address or IBAN
                // 'internal': false, // transfer to another Bitvavo user address, no fees
                // 'addWithdrawalFee': false, // true = add the fee on top, otherwise the fee is subtracted from the amount
            };
            if (tag !== undefined) {
                request['paymentId'] = tag;
            }
            const response = await this.privatePostWithdrawal (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "symbol": "BTC",
            //         "amount": "1.5"
            //     }
            //
            return this.parseTransaction (response, currency);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'symbol': currency['id'],
                // 'limit': 500, // default 500, max 1000
                // 'start': since,
                // 'end': this.milliseconds (),
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['symbol'] = currency['id'];
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.privateGetWithdrawalHistory (this.extend (request, params));
            //
            //     [
            //         {
            //             "timestamp":1590531212000,
            //             "symbol":"ETH",
            //             "amount":"0.091",
            //             "fee":"0.009",
            //             "status":"awaiting_bitvavo_inspection",
            //             "address":"0xe42b309f1eE9F0cbf7f54CcF3bc2159eBfA6735b",
            //             "paymentId": "10002653",
            //             "txId": "927b3ea50c5bb52c6854152d305dfa1e27fc01d10464cf10825d96d69d235eb3",
            //         }
            //     ]
            //
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'symbol': currency['id'],
                // 'limit': 500, // default 500, max 1000
                // 'start': since,
                // 'end': this.milliseconds (),
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['symbol'] = currency['id'];
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.privateGetDepositHistory (this.extend (request, params));
            //
            //     [
            //         {
            //             "timestamp":1590492401000,
            //             "symbol":"ETH",
            //             "amount":"0.249825",
            //             "fee":"0",
            //             "status":"completed",
            //             "txId":"0x5167b473fd37811f9ef22364c3d54726a859ef9d98934b3a1e11d7baa8d2c2e2"
            //         }
            //     ]
            //
            return this.parseTransactions (response, currency, since, limit);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'awaiting_processing': 'pending',
                'awaiting_email_confirmation': 'pending',
                'awaiting_bitvavo_inspection': 'pending',
                'approved': 'pending',
                'sending': 'pending',
                'in_mempool': 'pending',
                'processed': 'pending',
                'completed': 'ok',
                'canceled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // withdraw
            //
            //     {
            //         "success": true,
            //         "symbol": "BTC",
            //         "amount": "1.5"
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         "timestamp": 1542967486256,
            //         "symbol": "BTC",
            //         "amount": "0.99994",
            //         "address": "BitcoinAddress",
            //         "paymentId": "10002653",
            //         "txId": "927b3ea50c5bb52c6854152d305dfa1e27fc01d10464cf10825d96d69d235eb3",
            //         "fee": "0.00006",
            //         "status": "awaiting_processing"
            //     }
            //
            // fetchDeposits
            //
            //     {
            //         "timestamp":1590492401000,
            //         "symbol":"ETH",
            //         "amount":"0.249825",
            //         "fee":"0",
            //         "status":"completed",
            //         "txId":"0x5167b473fd37811f9ef22364c3d54726a859ef9d98934b3a1e11d7baa8d2c2e2"
            //     }
            //
            const id = undefined;
            const timestamp = this.safeInteger (transaction, 'timestamp');
            const currencyId = this.safeString (transaction, 'symbol');
            const code = this.safeCurrencyCode (currencyId, currency);
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const amount = this.safeNumber (transaction, 'amount');
            const address = this.safeString (transaction, 'address');
            const txid = this.safeString (transaction, 'txId');
            let fee = undefined;
            const feeCost = this.safeNumber (transaction, 'fee');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': code,
                };
            }
            let type = undefined;
            if ('success' in transaction) {
                type = 'withdrawal';
            } else {
                type = (status === undefined) ? 'deposit' : 'withdrawal';
            }
            const tag = this.safeString (transaction, 'paymentId');
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': undefined,
                'address': address,
                'addressTo': address,
                'tagFrom': undefined,
                'tag': tag,
                'tagTo': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': fee,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const query = this.omit (params, this.extractParams (path));
            let url = '/' + this.version + '/' + this.implodeParams (path, params);
            const getOrDelete = (method === 'GET') || (method === 'DELETE');
            if (getOrDelete) {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                let payload = '';
                if (!getOrDelete) {
                    if (Object.keys (query).length) {
                        body = this.json (query);
                        payload = body;
                    }
                }
                const timestamp = this.milliseconds ().toString ();
                const auth = timestamp + method + url + payload;
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                const accessWindow = this.safeString (this.options, 'BITVAVO-ACCESS-WINDOW', '10000');
                headers = {
                    'BITVAVO-ACCESS-KEY': this.apiKey,
                    'BITVAVO-ACCESS-SIGNATURE': signature,
                    'BITVAVO-ACCESS-TIMESTAMP': timestamp,
                    'BITVAVO-ACCESS-WINDOW': accessWindow,
                };
                if (!getOrDelete) {
                    headers['Content-Type'] = 'application/json';
                }
            }
            url = this.urls['api'][api] + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     {"errorCode":308,"error":"The signature length is invalid (HMAC-SHA256 should return a 64 length hexadecimal string)."}
            //     {"errorCode":203,"error":"symbol parameter is required."}
            //     {"errorCode":205,"error":"symbol parameter is invalid."}
            //
            const errorCode = this.safeString (response, 'errorCode');
            const error = this.safeString (response, 'error');
            if (errorCode !== undefined) {
                const feedback = this.id + ' ' + body;
                this.throwBroadlyMatchedException (this.exceptions['broad'], error, feedback);
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],47:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, ExchangeNotAvailable, PermissionDenied, InvalidOrder, AuthenticationError, InsufficientFunds, OrderNotFound, DDoSProtection, OnMaintenance, RateLimitExceeded } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bitz extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bitz',
                'name': 'Bit-Z',
                'countries': [ 'HK' ],
                'rateLimit': 2000,
                'version': 'v2',
                'userAgent': this.userAgents['chrome'],
                'has': {
                    'cancelOrder': true,
                    'cancelOrders': true,
                    'createOrder': true,
                    'createMarketOrder': false,
                    'fetchBalance': true,
                    'fetchDeposits': true,
                    'fetchClosedOrders': true,
                    'fetchMarkets': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTransactions': false,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '60min',
                    '4h': '4hour',
                    '1d': '1day',
                    '5d': '5day',
                    '1w': '1week',
                    '1M': '1mon',
                },
                'hostname': 'apiv2.bitz.com',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87443304-fec5e000-c5fd-11ea-98f8-ba8e67f7eaff.jpg',
                    'api': {
                        'market': 'https://{hostname}',
                        'trade': 'https://{hostname}',
                        'assets': 'https://{hostname}',
                    },
                    'www': 'https://www.bitz.com',
                    'doc': 'https://apidocv2.bitz.plus/en/',
                    'fees': 'https://www.bitz.com/fee?type=1',
                    'referral': 'https://u.bitz.com/register?invite_code=1429193',
                },
                'api': {
                    'market': {
                        'get': [
                            'ticker',
                            'depth',
                            'order', // trades
                            'tickerall',
                            'kline',
                            'symbolList',
                            'getServerTime',
                            'currencyRate',
                            'currencyCoinRate',
                            'coinRate',
                            'getContractCoin',
                            'getContractKline',
                            'getContractOrderBook',
                            'getContractTradesHistory',
                            'getContractTickers',
                        ],
                    },
                    'trade': {
                        'post': [
                            'addEntrustSheet',
                            'cancelEntrustSheet',
                            'cancelAllEntrustSheet',
                            'coinOut', // withdraw
                            'getUserHistoryEntrustSheet', // closed orders
                            'getUserNowEntrustSheet', // open orders
                            'getEntrustSheetInfo', // order
                            'depositOrWithdraw', // transactions
                            'getCoinAddress',
                            'getCoinAddressList',
                            'marketTrade',
                            'addEntrustSheetBatch',
                        ],
                    },
                    'assets': {
                        'post': [
                            'getUserAssets',
                        ],
                    },
                    'contract': {
                        'post': [
                            'addContractTrade',
                            'cancelContractTrade',
                            'getContractActivePositions',
                            'getContractAccountInfo',
                            'getContractMyPositions',
                            'getContractOrderResult',
                            'getContractTradeResult',
                            'getContractOrder',
                            'getContractMyHistoryTrade',
                            'getContractMyTrades',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.002'),
                        'taker': this.parseNumber ('0.002'),
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'precision': {
                    'amount': 8,
                    'price': 8,
                },
                'options': {
                    'fetchOHLCVVolume': true,
                    'fetchOHLCVWarning': true,
                    'lastNonceTimestamp': 0,
                },
                'commonCurrencies': {
                    // https://github.com/ccxt/ccxt/issues/3881
                    // https://support.bit-z.pro/hc/en-us/articles/360007500654-BOX-BOX-Token-
                    'BOX': 'BOX Token',
                    'XBT': 'XBT',
                    'LEO': 'LeoCoin',
                    'XRB': 'NANO',
                    'PXC': 'Pixiecoin',
                    'VTC': 'VoteCoin',
                    'TTC': 'TimesChain',
                },
                'exceptions': {
                    // '200': Success
                    '-102': ExchangeError, // Invalid parameter
                    '-103': AuthenticationError, // Verification failed
                    '-104': ExchangeNotAvailable, // Network Error-1
                    '-105': AuthenticationError, // Invalid api signature
                    '-106': ExchangeNotAvailable, // Network Error-2
                    '-109': AuthenticationError, // Invalid scretKey
                    '-110': DDoSProtection, // The number of access requests exceeded
                    '-111': PermissionDenied, // Current IP is not in the range of trusted IP
                    '-112': OnMaintenance, // Service is under maintenance
                    '-114': RateLimitExceeded, // The number of daily requests has reached the limit
                    '-117': AuthenticationError, // The apikey expires
                    '-100015': AuthenticationError, // Trade password error
                    '-100044': ExchangeError, // Fail to request data
                    '-100101': ExchangeError, // Invalid symbol
                    '-100201': ExchangeError, // Invalid symbol
                    '-100301': ExchangeError, // Invalid symbol
                    '-100401': ExchangeError, // Invalid symbol
                    '-100302': ExchangeError, // Type of K-line error
                    '-100303': ExchangeError, // Size of K-line error
                    '-200003': AuthenticationError, // Please set trade password
                    '-200005': PermissionDenied, // This account can not trade
                    '-200025': ExchangeNotAvailable, // Temporary trading halt
                    '-200027': InvalidOrder, // Price Error
                    '-200028': InvalidOrder, // Amount must be greater than 0
                    '-200029': InvalidOrder, // Number must be between %s and %d
                    '-200030': InvalidOrder, // Over price range
                    '-200031': InsufficientFunds, // Insufficient assets
                    '-200032': ExchangeError, // System error. Please contact customer service
                    '-200033': ExchangeError, // Fail to trade
                    '-200034': OrderNotFound, // The order does not exist
                    '-200035': OrderNotFound, // Cancellation error, order filled
                    '-200037': InvalidOrder, // Trade direction error
                    '-200038': ExchangeError, // Trading Market Error
                    '-200055': OrderNotFound, // Order record does not exist
                    '-300069': AuthenticationError, // api_key is illegal
                    '-300101': ExchangeError, // Transaction type error
                    '-300102': InvalidOrder, // Price or number cannot be less than 0
                    '-300103': AuthenticationError, // Trade password error
                    '-301001': ExchangeNotAvailable, // Network Error-3
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.marketGetSymbolList (params);
            //
            //     {    status:    200,
            //             msg:   "",
            //            data: {   ltc_btc: {          id: "1",
            //                                        name: "ltc_btc",
            //                                    coinFrom: "ltc",
            //                                      coinTo: "btc",
            //                                 numberFloat: "4",
            //                                  priceFloat: "8",
            //                                      status: "1",
            //                                    minTrade: "0.010",
            //                                    maxTrade: "500000000.000" },
            //                    qtum_usdt: {          id: "196",
            //                                        name: "qtum_usdt",
            //                                    coinFrom: "qtum",
            //                                      coinTo: "usdt",
            //                                 numberFloat: "4",
            //                                  priceFloat: "2",
            //                                      status: "1",
            //                                    minTrade: "0.100",
            //                                    maxTrade: "500000000.000" },  },
            //            time:    1535969146,
            //       microtime:   "0.66955600 1535969146",
            //          source:   "api"                                           }
            //
            const markets = this.safeValue (response, 'data');
            const ids = Object.keys (markets);
            const result = [];
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const market = markets[id];
                const numericId = this.safeString (market, 'id');
                const baseId = this.safeString (market, 'coinFrom');
                const quoteId = this.safeString (market, 'coinTo');
                let base = baseId.toUpperCase ();
                let quote = quoteId.toUpperCase ();
                base = this.safeCurrencyCode (base);
                quote = this.safeCurrencyCode (quote);
                const symbol = base + '/' + quote;
                const pricePrecisionString = this.safeString (market, 'priceFloat');
                const minPrice = this.parsePrecision (pricePrecisionString);
                const precision = {
                    'amount': this.safeInteger (market, 'numberFloat'),
                    'price': parseInt (pricePrecisionString),
                };
                const minAmount = this.safeString (market, 'minTrade');
                result.push ({
                    'info': market,
                    'id': id,
                    'numericId': numericId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.parseNumber (minAmount),
                            'max': this.safeNumber (market, 'maxTrade'),
                        },
                        'price': {
                            'min': this.parseNumber (minPrice),
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.parseNumber (Precise.stringMul (minPrice, minAmount)),
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.assetsPostGetUserAssets (params);
            //
            //     {
            //         status: 200,
            //         msg: "",
            //         data: {
            //             cny: 0,
            //             usd: 0,
            //             btc_total: 0,
            //             info: [{
            //                 "name": "zpr",
            //                 "num": "37.49067275",
            //                 "over": "37.49067275",
            //                 "lock": "0.00000000",
            //                 "btc": "0.00000000",
            //                 "usd": "0.00000000",
            //                 "cny": "0.00000000",
            //             }],
            //         },
            //         time: 1535983966,
            //         microtime: "0.70400500 1535983966",
            //         source: "api",
            //     }
            //
            const balances = this.safeValue (response['data'], 'info');
            const timestamp = this.parseMicrotime (this.safeString (response, 'microtime'));
            const result = {
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
            };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'name');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['used'] = this.safeString (balance, 'lock');
                account['total'] = this.safeString (balance, 'num');
                account['free'] = this.safeString (balance, 'over');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //      {          symbol: "eth_btc",
            //            quoteVolume: "3905.72",
            //                 volume: "97058.21",
            //            priceChange: "-1.72",
            //         priceChange24h: "-1.65",
            //               askPrice: "0.03971272",
            //                 askQty: "0.0663",
            //               bidPrice: "0.03961469",
            //                 bidQty: "19.5451",
            //                   open: "0.04036769",
            //                   high: "0.04062988",
            //                    low: "0.03956123",
            //                    now: "0.03970100",
            //                firstId:  115567767,
            //                 lastId:  115795316,
            //              dealCount:  14078,
            //        numberPrecision:  4,
            //         pricePrecision:  8,
            //                    cny: "1959.05",
            //                    usd: "287.10",
            //                    krw: "318655.82"   }
            //
            const timestamp = undefined;
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '_');
            const last = this.safeNumber (ticker, 'now');
            const open = this.safeNumber (ticker, 'open');
            let change = undefined;
            let average = undefined;
            if (last !== undefined && open !== undefined) {
                change = last - open;
                average = this.sum (last, open) / 2;
            }
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bidPrice'),
                'bidVolume': this.safeNumber (ticker, 'bidQty'),
                'ask': this.safeNumber (ticker, 'askPrice'),
                'askVolume': this.safeNumber (ticker, 'askQty'),
                'vwap': undefined,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': change,
                'percentage': this.safeNumber (ticker, 'priceChange24h'),
                'average': average,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': this.safeNumber (ticker, 'quoteVolume'),
                'info': ticker,
            };
        }
    
        parseMicrotime (microtime) {
            if (microtime === undefined) {
                return microtime;
            }
            const parts = microtime.split (' ');
            const milliseconds = parseFloat (parts[0]);
            const seconds = parseInt (parts[1]);
            const total = this.sum (seconds, milliseconds);
            return parseInt (total * 1000);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.marketGetTicker (this.extend (request, params));
            //
            //     {    status:    200,
            //             msg:   "",
            //            data: {          symbol: "eth_btc",
            //                        quoteVolume: "3905.72",
            //                             volume: "97058.21",
            //                        priceChange: "-1.72",
            //                     priceChange24h: "-1.65",
            //                           askPrice: "0.03971272",
            //                             askQty: "0.0663",
            //                           bidPrice: "0.03961469",
            //                             bidQty: "19.5451",
            //                               open: "0.04036769",
            //                               high: "0.04062988",
            //                                low: "0.03956123",
            //                                now: "0.03970100",
            //                            firstId:  115567767,
            //                             lastId:  115795316,
            //                          dealCount:  14078,
            //                    numberPrecision:  4,
            //                     pricePrecision:  8,
            //                                cny: "1959.05",
            //                                usd: "287.10",
            //                                krw: "318655.82"   },
            //            time:    1535970397,
            //       microtime:   "0.76341900 1535970397",
            //          source:   "api"                             }
            //
            const ticker = this.parseTicker (response['data'], market);
            const timestamp = this.parseMicrotime (this.safeString (response, 'microtime'));
            return this.extend (ticker, {
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
            });
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbols !== undefined) {
                const ids = this.marketIds (symbols);
                request['symbols'] = ids.join (',');
            }
            const response = await this.marketGetTickerall (this.extend (request, params));
            //
            //     {    status:    200,
            //             msg:   "",
            //            data: {   ela_btc: {          symbol: "ela_btc",
            //                                     quoteVolume: "0.00",
            //                                          volume: "3.28",
            //                                     priceChange: "0.00",
            //                                  priceChange24h: "0.00",
            //                                        askPrice: "0.00147984",
            //                                          askQty: "5.4580",
            //                                        bidPrice: "0.00120230",
            //                                          bidQty: "12.5384",
            //                                            open: "0.00149078",
            //                                            high: "0.00149078",
            //                                             low: "0.00149078",
            //                                             now: "0.00149078",
            //                                         firstId:  115581219,
            //                                          lastId:  115581219,
            //                                       dealCount:  1,
            //                                 numberPrecision:  4,
            //                                  pricePrecision:  8,
            //                                             cny: "73.66",
            //                                             usd: "10.79",
            //                                             krw: "11995.03"    }     },
            //            time:    1535971578,
            //       microtime:   "0.39854200 1535971578",
            //          source:   "api"                                                }
            //
            const tickers = this.safeValue (response, 'data');
            const timestamp = this.parseMicrotime (this.safeString (response, 'microtime'));
            const result = {};
            const ids = Object.keys (tickers);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                let ticker = tickers[id];
                let market = undefined;
                if (id in this.markets_by_id) {
                    market = this.markets_by_id[id];
                }
                ticker = this.parseTicker (tickers[id], market);
                let symbol = ticker['symbol'];
                if (symbol === undefined) {
                    if (market !== undefined) {
                        symbol = market['symbol'];
                    } else {
                        const [ baseId, quoteId ] = id.split ('_');
                        const base = this.safeCurrencyCode (baseId);
                        const quote = this.safeCurrencyCode (quoteId);
                        symbol = base + '/' + quote;
                    }
                }
                if (symbol !== undefined) {
                    result[symbol] = this.extend (ticker, {
                        'timestamp': timestamp,
                        'datetime': this.iso8601 (timestamp),
                    });
                }
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTime (params = {}) {
            const response = await this.marketGetGetServerTime (params);
            //
            //     {
            //         "status":200,
            //         "msg":"",
            //         "data":[],
            //         "time":1555490875,
            //         "microtime":"0.35994200 1555490875",
            //         "source":"api"
            //     }
            //
            return this.safeTimestamp (response, 'time');
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            const response = await this.marketGetDepth (this.extend (request, params));
            //
            //     {    status:    200,
            //             msg:   "",
            //            data: {     asks: [ ["10.00000000", "0.4426", "4.4260"],
            //                                ["1.00000000", "0.8339", "0.8339"],
            //                                ["0.91700000", "0.0500", "0.0458"],
            //                                ["0.20000000", "0.1000", "0.0200"],
            //                                ["0.03987120", "16.1262", "0.6429"],
            //                                ["0.03986120", "9.7523", "0.3887"]   ],
            //                        bids: [ ["0.03976145", "0.0359", "0.0014"],
            //                                ["0.03973401", "20.9493", "0.8323"],
            //                                ["0.03967970", "0.0328", "0.0013"],
            //                                ["0.00000002", "10000.0000", "0.0002"],
            //                                ["0.00000001", "231840.7500", "0.0023"] ],
            //                    coinPair:   "eth_btc"                                  },
            //            time:    1535974778,
            //       microtime:   "0.04017400 1535974778",
            //          source:   "api"                                                     }
            //
            const orderbook = this.safeValue (response, 'data');
            const timestamp = this.parseMicrotime (this.safeString (response, 'microtime'));
            return this.parseOrderBook (orderbook, symbol, timestamp);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //    { id:  115807453,
            //       t: "19:36:24",
            //       T:  1535974584,
            //       p: "0.03983296",
            //       n: "0.1000",
            //       s: "buy"         },
            //
            const id = this.safeString (trade, 'id');
            const timestamp = this.safeTimestamp (trade, 'T');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const priceString = this.safeString (trade, 'p');
            const amountString = this.safeString (trade, 'n');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const side = this.safeString (trade, 's');
            return {
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': undefined,
                'type': 'limit',
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
                'info': trade,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.marketGetOrder (this.extend (request, params));
            //
            //     {    status:    200,
            //             msg:   "",
            //            data: [ { id:  115807453,
            //                       t: "19:36:24",
            //                       T:  1535974584,
            //                       p: "0.03983296",
            //                       n: "0.1000",
            //                       s: "buy"         },
            //                    { id:  115806811,
            //                       t: "19:33:19",
            //                       T:  1535974399,
            //                       p: "0.03981135",
            //                       n: "9.4612",
            //                       s: "sell"        }  ],
            //            time:    1535974583,
            //       microtime:   "0.57118100 1535974583",
            //          source:   "api"                     }
            //
            return this.parseTrades (response['data'], market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         time: "1535973420000",
            //         open: "0.03975084",
            //         high: "0.03975084",
            //         low: "0.03967700",
            //         close: "0.03967700",
            //         volume: "12.4733",
            //         datetime: "2018-09-03 19:17:00"
            //     }
            //
            return [
                this.safeInteger (ohlcv, 'time'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const duration = this.parseTimeframe (timeframe);
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'resolution': this.timeframes[timeframe],
            };
            if (limit !== undefined) {
                request['size'] = Math.min (limit, 300); // 1-300
                if (since !== undefined) {
                    request['to'] = this.sum (since, limit * duration * 1000);
                }
            } else {
                if (since !== undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchOHLCV() requires a limit argument if the since argument is specified');
                }
            }
            const response = await this.marketGetKline (this.extend (request, params));
            //
            //     {
            //         status: 200,
            //         msg: "",
            //         data: {
            //             bars: [
            //                 { time: "1535973420000", open: "0.03975084", high: "0.03975084", low: "0.03967700", close: "0.03967700", volume: "12.4733", datetime: "2018-09-03 19:17:00" },
            //                 { time: "1535955480000", open: "0.04009900", high: "0.04016745", low: "0.04009900", close: "0.04012074", volume: "74.4803", datetime: "2018-09-03 14:18:00" },
            //             ],
            //             resolution: "1min",
            //             symbol: "eth_btc",
            //             from: "1535973420000",
            //             to: "1535955480000",
            //             size: 300
            //         },
            //         time: 1535973435,
            //         microtime: "0.56462100 1535973435",
            //         source: "api"
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const bars = this.safeValue (data, 'bars', []);
            return this.parseOHLCVs (bars, market, timeframe, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '0': 'open',
                '1': 'open', // partially filled
                '2': 'closed', // filled
                '3': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //    {
            //         "id": "693248739",   // order id
            //         "uId": "2074056",    // uid
            //         "price": "100",      // price
            //         "number": "10",      // number
            //         "numberOver": "10",  // undealed
            //         "flag": "sale",      // flag
            //         "status": "0",       // unfilled
            //         "coinFrom": "vtc",
            //         "coinTo": "dkkt",
            //         "numberDeal": "0"    // dealed
            //     }
            //
            const id = this.safeString (order, 'id');
            let symbol = undefined;
            if (market === undefined) {
                const baseId = this.safeString (order, 'coinFrom');
                const quoteId = this.safeString (order, 'coinTo');
                if ((baseId !== undefined) && (quoteId !== undefined)) {
                    const marketId = baseId + '_' + quoteId;
                    if (marketId in this.markets_by_id) {
                        market = this.safeValue (this.markets_by_id, marketId);
                    } else {
                        const base = this.safeCurrencyCode (baseId);
                        const quote = this.safeCurrencyCode (quoteId);
                        symbol = base + '/' + quote;
                    }
                }
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            let side = this.safeString (order, 'flag');
            if (side !== undefined) {
                side = (side === 'sale') ? 'sell' : 'buy';
            }
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'number');
            const remaining = this.safeNumber (order, 'numberOver');
            const filled = this.safeNumber (order, 'numberDeal');
            let timestamp = this.safeInteger (order, 'timestamp');
            if (timestamp === undefined) {
                timestamp = this.safeTimestamp (order, 'created');
            }
            const cost = this.safeNumber (order, 'orderTotalPrice');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'trades': undefined,
                'fee': undefined,
                'info': order,
                'average': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            if (type !== 'limit') {
                throw new ExchangeError (this.id + ' createOrder allows limit orders only');
            }
            const market = this.market (symbol);
            const orderType = (side === 'buy') ? '1' : '2';
            if (!this.password) {
                throw new ExchangeError (this.id + ' createOrder() requires you to set exchange.password = "YOUR_TRADING_PASSWORD" (a trade password is NOT THE SAME as your login password)');
            }
            const request = {
                'symbol': market['id'],
                'type': orderType,
                'price': this.priceToPrecision (symbol, price),
                'number': this.amountToPrecision (symbol, amount),
                'tradePwd': this.password,
            };
            const response = await this.tradePostAddEntrustSheet (this.extend (request, params));
            //
            //     {
            //         "status": 200,
            //         "msg": "",
            //         "data": {
            //             "id": "693248739",   // order id
            //             "uId": "2074056",    // uid
            //             "price": "100",      // price
            //             "number": "10",      // number
            //             "numberOver": "10",  // undealed
            //             "flag": "sale",      // flag
            //             "status": "0",       // unfilled
            //             "coinFrom": "vtc",
            //             "coinTo": "dkkt",
            //             "numberDeal": "0"    // dealed
            //         },
            //         "time": "1533035297",
            //         "microtime": "0.41892000 1533035297",
            //         "source": "api",
            //     }
            //
            const timestamp = this.parseMicrotime (this.safeString (response, 'microtime'));
            const order = this.extend ({
                'timestamp': timestamp,
            }, response['data']);
            return this.parseOrder (order, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'entrustSheetId': id,
            };
            const response = await this.tradePostCancelEntrustSheet (this.extend (request, params));
            //
            //     {
            //         "status":200,
            //         "msg":"",
            //         "data":{
            //             "updateAssetsData":{
            //                 "coin":"bz",
            //                 "over":"1000.00000000",
            //                 "lock":"-1000.00000000"
            //             },
            //             "assetsInfo":{
            //                 "coin":"bz",
            //                 "over":"9999.99999999",
            //                 "lock":"9999.99999999"
            //             }
            //         },
            //         "time":"1535464383",
            //         "microtime":"0.91558000 1535464383",
            //         "source":"api"
            //     }
            //
            return response;
        }
    
        async cancelOrders (ids, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'ids': ids.join (','),
            };
            const response = await this.tradePostCancelEntrustSheet (this.extend (request, params));
            //
            //     {
            //         "status":200,
            //         "msg":"",
            //         "data":{
            //             "744173808":{
            //                 "updateAssetsData":{
            //                     "coin":"bz",
            //                     "over":"100.00000000",
            //                     "lock":"-100.00000000"
            //                 },
            //                 "assetsInfo":{
            //                     "coin":"bz",
            //                     "over":"899.99999999",
            //                     "lock":"19099.99999999"
            //                 }
            //             },
            //             "744173809":{
            //                 "updateAssetsData":{
            //                     "coin":"bz",
            //                     "over":"100.00000000",
            //                     "lock":"-100.00000000"
            //                 },
            //                 "assetsInfo":{
            //                     "coin":"bz",
            //                     "over":"999.99999999",
            //                     "lock":"18999.99999999"
            //                 }
            //             }
            //         },
            //         "time":"1535525649",
            //         "microtime":"0.05009400 1535525649",
            //         "source":"api"
            //     }
            //
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'entrustSheetId': id,
            };
            const response = await this.tradePostGetEntrustSheetInfo (this.extend (request, params));
            //
            //     {
            //         "status":200,
            //         "msg":"",
            //         "data":{
            //             "id":"708279852",
            //             "uId":"2074056",
            //             "price":"100.00000000",
            //             "number":"10.0000",
            //             "total":"0.00000000",
            //             "numberOver":"10.0000",
            //             "numberDeal":"0.0000",
            //             "flag":"sale",
            //             "status":"0",  //0:unfilled, 1:partial deal, 2:all transactions, 3:already cancelled
            //             "coinFrom":"bz",
            //             "coinTo":"usdt",
            //             "orderTotalPrice":"0",
            //             "created":"1533279876"
            //         },
            //         "time":"1533280294",
            //         "microtime":"0.36859200 1533280294",
            //         "source":"api"
            //     }
            //
            return this.parseOrder (response['data']);
        }
    
        async fetchOrdersWithMethod (method, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'coinFrom': market['baseId'],
                'coinTo': market['quoteId'],
                // 'type': 1, // optional integer, 1 = buy, 2 = sell
                // 'page': 1, // optional integer
                // 'pageSize': 100, // optional integer, max 100
                // 'startTime': 1510235730, // optional integer timestamp in seconds
                // 'endTime': 1510235730, // optional integer timestamp in seconds
            };
            if (limit !== undefined) {
                request['page'] = 1;
                request['pageSize'] = limit;
            }
            if (since !== undefined) {
                request['startTime'] = parseInt (since / 1000);
                // request['endTime'] = parseInt (since / 1000);
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "status": 200,
            //         "msg": "",
            //         "data": {
            //             "data": [
            //                 {
            //                     "id": "693248739",
            //                     "uid": "2074056",
            //                     "price": "100.00000000",
            //                     "number": "10.0000",
            //                     "total": "0.00000000",
            //                     "numberOver": "0.0000",
            //                     "numberDeal": "0.0000",
            //                     "flag": "sale",
            //                     "status": "3", // 0:unfilled, 1:partial deal, 2:all transactions, 3:already cancelled
            //                     "isNew": "N",
            //                     "coinFrom": "vtc",
            //                     "coinTo": "dkkt",
            //                     "created": "1533035300",
            //                 },
            //                 {
            //                     "id": "723086996",
            //                     "uid": "2074056",
            //                     "price": "100.00000000",
            //                     "number": "10.0000",
            //                     "total": "0.00000000",
            //                     "numberOver": "0.0000",
            //                     "numberDeal": "0.0000",
            //                     "flag": "sale",
            //                     "status": "3",
            //                     "isNew": "N",
            //                     "coinFrom": "bz",
            //                     "coinTo": "usdt",
            //                     "created": "1533523568",
            //                 },
            //             ],
            //             "pageInfo": {
            //                 "limit": "10",
            //                 "offest": "0",
            //                 "current_page": "1",
            //                 "page_size": "10",
            //                 "total_count": "17",
            //                 "page_count": "2",
            //             }
            //         },
            //         "time": "1533279329",
            //         "microtime": "0.15305300 1533279329",
            //         "source": "api"
            //     }
            //
            const orders = this.safeValue (response['data'], 'data', []);
            return this.parseOrders (orders, undefined, since, limit);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersWithMethod ('tradePostGetUserHistoryEntrustSheet', symbol, since, limit, params);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersWithMethod ('tradePostGetUserNowEntrustSheet', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersWithMethod ('tradePostGetUserHistoryEntrustSheet', symbol, since, limit, params);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                '1': 'pending',
                '2': 'pending',
                '3': 'pending',
                '4': 'ok',
                '5': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            //     {
            //         "id": '96275',
            //         "uid": '2109073',
            //         "wallet": '0xf4c4141c0127bc37b1d0c409a091920eba13ada7',
            //         "txid": '0xb7adfa52aa566f9ac112e3c01f77bd91179b19eab12092a9a5a8b33d5086e31d',
            //         "confirm": '12',
            //         "number": '0.50000000',
            //         "status": 4,
            //         "updated": '1534944168605',
            //         "addressUrl": 'https://etherscan.io/address/',
            //         "txidUrl": 'https://etherscan.io/tx/',
            //         "description": 'Ethereum',
            //         "coin": 'eth',
            //         "memo": ''
            //     }
            //
            //     {
            //         "id":"397574",
            //         "uid":"2033056",
            //         "wallet":"1AG1gZvQAYu3WBvgg7p4BMMghQD2gE693k",
            //         "txid":"",
            //         "confirm":"0",
            //         "number":"1000.00000000",
            //         "status":1,
            //         "updated":"0",
            //         "addressUrl":"http://omniexplorer.info/lookupadd.aspx?address=",
            //         "txidUrl":"http://omniexplorer.info/lookuptx.aspx?txid=",
            //         "description":"Tether",
            //         "coin":"usdt",
            //         "memo":""
            //     }
            //
            //     {
            //         "id":"153606",
            //         "uid":"2033056",
            //         "wallet":"1AG1gZvQAYu3WBvgg7p4BMMghQD2gE693k",
            //         "txid":"aa2b179f84cd6dedafd41845e0fbf7f01e14c0d71ea3140d03d6f5a9ccd93199",
            //         "confirm":"0",
            //         "number":"761.11110000",
            //         "status":4,
            //         "updated":"1536726133579",
            //         "addressUrl":"http://omniexplorer.info/lookupadd.aspx?address=",
            //         "txidUrl":"http://omniexplorer.info/lookuptx.aspx?txid=",
            //         "description":"Tether",
            //         "coin":"usdt",
            //         "memo":""
            //     }
            //
            // withdraw
            //
            //     {
            //         "id":397574,
            //         "email":"***@email.com",
            //         "coin":"usdt",
            //         "network_fee":"",
            //         "eid":23112
            //     }
            //
            let timestamp = this.safeInteger (transaction, 'updated');
            if (timestamp === 0) {
                timestamp = undefined;
            }
            const currencyId = this.safeString (transaction, 'coin');
            const code = this.safeCurrencyCode (currencyId, currency);
            const type = this.safeStringLower (transaction, 'type');
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            let fee = undefined;
            const feeCost = this.safeNumber (transaction, 'network_fee');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'code': code,
                };
            }
            return {
                'id': this.safeString (transaction, 'id'),
                'txid': this.safeString (transaction, 'txid'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': this.safeString (transaction, 'wallet'),
                'tag': this.safeString (transaction, 'memo'),
                'type': type,
                'amount': this.safeNumber (transaction, 'number'),
                'currency': code,
                'status': status,
                'updated': timestamp,
                'fee': fee,
                'info': transaction,
            };
        }
    
        parseTransactionsByType (type, transactions, code = undefined, since = undefined, limit = undefined) {
            const result = [];
            for (let i = 0; i < transactions.length; i++) {
                const transaction = this.parseTransaction (this.extend ({
                    'type': type,
                }, transactions[i]));
                result.push (transaction);
            }
            return this.filterByCurrencySinceLimit (result, code, since, limit);
        }
    
        parseTransactionType (type) {
            const types = {
                'deposit': 1,
                'withdrawal': 2,
            };
            return this.safeInteger (types, type, type);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsForType ('deposit', code, since, limit, params);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsForType ('withdrawal', code, since, limit, params);
        }
    
        async fetchTransactionsForType (type, code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchTransactions() requires a currency `code` argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'coin': currency['id'],
                'type': this.parseTransactionType (type),
            };
            if (since !== undefined) {
                request['startTime'] = parseInt (since / 1000).toString ();
            }
            if (limit !== undefined) {
                request['page'] = 1;
                request['pageSize'] = limit;
            }
            const response = await this.tradePostDepositOrWithdraw (this.extend (request, params));
            const transactions = this.safeValue (response['data'], 'data', []);
            return this.parseTransactionsByType (type, transactions, code, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'coin': currency['id'],
                'number': this.currencyToPrecision (code, amount),
                'address': address,
                // 'type': 'erc20', // omni, trc20, optional
            };
            if (tag !== undefined) {
                request['memo'] = tag;
            }
            const response = await this.tradePostCoinOut (this.extend (request, params));
            //
            //     {
            //         "status":200,
            //         "msg":"",
            //         "data":{
            //             "id":397574,
            //             "email":"***@email.com",
            //             "coin":"usdt",
            //             "network_fee":"",
            //             "eid":23112
            //         },
            //         "time":1552641646,
            //         "microtime":"0.70304500 1552641646",
            //         "source":"api"
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.parseTransaction (data, currency);
        }
    
        nonce () {
            const currentTimestamp = this.seconds ();
            if (currentTimestamp > this.options['lastNonceTimestamp']) {
                this.options['lastNonceTimestamp'] = currentTimestamp;
                this.options['lastNonce'] = 100000;
            }
            this.options['lastNonce'] = this.sum (this.options['lastNonce'], 1);
            return this.options['lastNonce'];
        }
    
        sign (path, api = 'market', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const baseUrl = this.implodeHostname (this.urls['api'][api]);
            let url = baseUrl + '/' + this.capitalize (api) + '/' + path;
            let query = undefined;
            if (api === 'market') {
                query = this.urlencode (params);
                if (query.length) {
                    url += '?' + query;
                }
            } else {
                this.checkRequiredCredentials ();
                body = this.rawencode (this.keysort (this.extend ({
                    'apiKey': this.apiKey,
                    'timeStamp': this.seconds (),
                    'nonce': this.nonce (),
                }, params)));
                body += '&sign=' + this.hash (this.encode (body + this.secret));
                headers = { 'Content-type': 'application/x-www-form-urlencoded' };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            const status = this.safeString (response, 'status');
            if (status !== undefined) {
                const feedback = this.id + ' ' + body;
                //
                //     {"status":-107,"msg":"","data":"","time":1535968848,"microtime":"0.89092200 1535968848","source":"api"}
                //
                if (status === '200') {
                    //
                    //     {"status":200,"msg":"","data":-200031,"time":1535999806,"microtime":"0.85476800 1535999806","source":"api"}
                    //
                    const code = this.safeInteger (response, 'data');
                    if (code !== undefined) {
                        this.throwExactlyMatchedException (this.exceptions, code, feedback);
                        throw new ExchangeError (feedback);
                    } else {
                        return; // no error
                    }
                }
                this.throwExactlyMatchedException (this.exceptions, status, feedback);
                throw new ExchangeError (feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],48:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const Precise = require ('./base/Precise');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class bl3p extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bl3p',
                'name': 'BL3P',
                'countries': [ 'NL', 'EU' ], // Netherlands, EU
                'rateLimit': 1000,
                'version': '1',
                'comment': 'An exchange market by BitonicNL',
                'has': {
                    'CORS': false,
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/28501752-60c21b82-6feb-11e7-818b-055ee6d0e754.jpg',
                    'api': 'https://api.bl3p.eu',
                    'www': 'https://bl3p.eu', // 'https://bitonic.nl'
                    'doc': [
                        'https://github.com/BitonicNL/bl3p-api/tree/master/docs',
                        'https://bl3p.eu/api',
                        'https://bitonic.nl/en/api',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            '{market}/ticker',
                            '{market}/orderbook',
                            '{market}/trades',
                        ],
                    },
                    'private': {
                        'post': [
                            '{market}/money/depth/full',
                            '{market}/money/order/add',
                            '{market}/money/order/cancel',
                            '{market}/money/order/result',
                            '{market}/money/orders',
                            '{market}/money/orders/history',
                            '{market}/money/trades/fetch',
                            'GENMKT/money/info',
                            'GENMKT/money/deposit_address',
                            'GENMKT/money/new_deposit_address',
                            'GENMKT/money/wallet/history',
                            'GENMKT/money/withdraw',
                        ],
                    },
                },
                'markets': {
                    'BTC/EUR': { 'id': 'BTCEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'baseId': 'BTC', 'quoteId': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                    'LTC/EUR': { 'id': 'LTCEUR', 'symbol': 'LTC/EUR', 'base': 'LTC', 'quote': 'EUR', 'baseId': 'LTC', 'quoteId': 'EUR', 'maker': 0.0025, 'taker': 0.0025 },
                },
            });
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostGENMKTMoneyInfo (params);
            const data = this.safeValue (response, 'data', {});
            const wallets = this.safeValue (data, 'wallets');
            const result = { 'info': data };
            const codes = Object.keys (this.currencies);
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const currency = this.currency (code);
                const currencyId = currency['id'];
                const wallet = this.safeValue (wallets, currencyId, {});
                const available = this.safeValue (wallet, 'available', {});
                const balance = this.safeValue (wallet, 'balance', {});
                const account = this.account ();
                account['free'] = this.safeString (available, 'value');
                account['total'] = this.safeString (balance, 'value');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseBidAsk (bidask, priceKey = 0, amountKey = 1) {
            const price = this.safeNumber (bidask, priceKey);
            const size = this.safeNumber (bidask, amountKey);
            return [
                price / 100000.0,
                size / 100000000.0,
            ];
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetMarketOrderbook (this.extend (request, params));
            const orderbook = this.safeValue (response, 'data');
            return this.parseOrderBook (orderbook, symbol, undefined, 'bids', 'asks', 'price_int', 'amount_int');
        }
    
        async fetchTicker (symbol, params = {}) {
            const request = {
                'market': this.marketId (symbol),
            };
            const ticker = await this.publicGetMarketTicker (this.extend (request, params));
            const timestamp = this.safeTimestamp (ticker, 'timestamp');
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker['volume'], '24h'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        parseTrade (trade, market = undefined) {
            const id = this.safeString (trade, 'trade_id');
            const timestamp = this.safeInteger (trade, 'date');
            let priceString = this.safeString (trade, 'price_int');
            priceString = Precise.stringDiv (priceString, '100000');
            let amountString = this.safeString (trade, 'amount_int');
            amountString = Precise.stringDiv (amountString, '100000000');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': undefined,
                'order': undefined,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            const market = this.market (symbol);
            const response = await this.publicGetMarketTrades (this.extend ({
                'market': market['id'],
            }, params));
            const result = this.parseTrades (response['data']['trades'], market, since, limit);
            return result;
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            const market = this.market (symbol);
            const order = {
                'market': market['id'],
                'amount_int': parseInt (amount * 100000000),
                'fee_currency': market['quote'],
                'type': (side === 'buy') ? 'bid' : 'ask',
            };
            if (type === 'limit') {
                order['price_int'] = parseInt (price * 100000.0);
            }
            const response = await this.privatePostMarketMoneyOrderAdd (this.extend (order, params));
            const orderId = this.safeString (response['data'], 'order_id');
            return {
                'info': response,
                'id': orderId,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const request = {
                'order_id': id,
            };
            return await this.privatePostMarketMoneyOrderCancel (this.extend (request, params));
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const request = this.implodeParams (path, params);
            let url = this.urls['api'] + '/' + this.version + '/' + request;
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
                const secret = this.base64ToBinary (this.secret);
                // eslint-disable-next-line quotes
                const auth = request + "\0" + body;
                const signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Rest-Key': this.apiKey,
                    'Rest-Sign': signature,
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7}],49:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AuthenticationError, DDoSProtection, InvalidOrder, InsufficientFunds } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class btcalpha extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'btcalpha',
                'name': 'BTC-Alpha',
                'countries': [ 'US' ],
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': false,
                    'fetchTrades': true,
                },
                'timeframes': {
                    '1m': '1',
                    '5m': '5',
                    '15m': '15',
                    '30m': '30',
                    '1h': '60',
                    '4h': '240',
                    '1d': 'D',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/42625213-dabaa5da-85cf-11e8-8f99-aa8f8f7699f0.jpg',
                    'api': 'https://btc-alpha.com/api',
                    'www': 'https://btc-alpha.com',
                    'doc': 'https://btc-alpha.github.io/api-docs',
                    'fees': 'https://btc-alpha.com/fees/',
                    'referral': 'https://btc-alpha.com/?r=123788',
                },
                'api': {
                    'public': {
                        'get': [
                            'currencies/',
                            'pairs/',
                            'orderbook/{pair_name}/',
                            'exchanges/',
                            'charts/{pair}/{type}/chart/',
                        ],
                    },
                    'private': {
                        'get': [
                            'wallets/',
                            'orders/own/',
                            'order/{id}/',
                            'exchanges/own/',
                            'deposits/',
                            'withdraws/',
                        ],
                        'post': [
                            'order/',
                            'order-cancel/',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.002'),
                        'taker': this.parseNumber ('0.002'),
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'commonCurrencies': {
                    'CBC': 'Cashbery',
                },
                'exceptions': {
                    'exact': {},
                    'broad': {
                        'Out of balance': InsufficientFunds, // {"date":1570599531.4814300537,"error":"Out of balance -9.99243661 BTC"}
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetPairs (params);
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'name');
                const baseId = this.safeString (market, 'currency1');
                const quoteId = this.safeString (market, 'currency2');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const pricePrecision = this.safeString (market, 'price_precision');
                const priceLimit = this.parsePrecision (pricePrecision);
                const precision = {
                    'amount': 8,
                    'price': parseInt (pricePrecision),
                };
                const amountLimit = this.safeString (market, 'minimum_order_size');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'active': true,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.parseNumber (amountLimit),
                            'max': this.safeNumber (market, 'maximum_order_size'),
                        },
                        'price': {
                            'min': this.parseNumber (priceLimit),
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.parseNumber (Precise.stringMul (priceLimit, amountLimit)),
                            'max': undefined,
                        },
                    },
                    'info': market,
                    'baseId': undefined,
                    'quoteId': undefined,
                });
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair_name': this.marketId (symbol),
            };
            if (limit) {
                request['limit_sell'] = limit;
                request['limit_buy'] = limit;
            }
            const response = await this.publicGetOrderbookPairName (this.extend (request, params));
            return this.parseOrderBook (response, symbol, undefined, 'buy', 'sell', 'price', 'amount');
        }
    
        parseBidsAsks (bidasks, priceKey = 0, amountKey = 1) {
            const result = [];
            for (let i = 0; i < bidasks.length; i++) {
                const bidask = bidasks[i];
                if (bidask) {
                    result.push (this.parseBidAsk (bidask, priceKey, amountKey));
                }
            }
            return result;
        }
    
        parseTrade (trade, market = undefined) {
            let symbol = undefined;
            if (market === undefined) {
                market = this.safeValue (this.markets_by_id, trade['pair']);
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const timestamp = this.safeTimestamp (trade, 'timestamp');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const id = this.safeString2 (trade, 'id', 'tid');
            const side = this.safeString2 (trade, 'my_side', 'side');
            const orderId = this.safeString (trade, 'o_id');
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': 'limit',
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const trades = await this.publicGetExchanges (this.extend (request, params));
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "time":1591296000,
            //         "open":0.024746,
            //         "close":0.024728,
            //         "low":0.024728,
            //         "high":0.024753,
            //         "volume":16.624
            //     }
            //
            return [
                this.safeTimestamp (ohlcv, 'time'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '5m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'type': this.timeframes[timeframe],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['since'] = parseInt (since / 1000);
            }
            const response = await this.publicGetChartsPairTypeChart (this.extend (request, params));
            //
            //     [
            //         {"time":1591296000,"open":0.024746,"close":0.024728,"low":0.024728,"high":0.024753,"volume":16.624},
            //         {"time":1591295700,"open":0.024718,"close":0.02475,"low":0.024711,"high":0.02475,"volume":31.645},
            //         {"time":1591295400,"open":0.024721,"close":0.024717,"low":0.024711,"high":0.02473,"volume":65.071}
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetWallets (params);
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['used'] = this.safeString (balance, 'reserve');
                account['total'] = this.safeString (balance, 'balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '1': 'open',
                '2': 'canceled',
                '3': 'closed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            let symbol = undefined;
            if (market === undefined) {
                market = this.safeValue (this.markets_by_id, order['pair']);
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const timestamp = this.safeTimestamp (order, 'date');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const id = this.safeString2 (order, 'oid', 'id');
            let trades = this.safeValue (order, 'trades', []);
            trades = this.parseTrades (trades, market);
            const side = this.safeString2 (order, 'my_side', 'type');
            let filled = undefined;
            const numTrades = trades.length;
            if (numTrades > 0) {
                filled = 0.0;
                for (let i = 0; i < numTrades; i++) {
                    filled = this.sum (filled, trades[i]['amount']);
                }
            }
            let remaining = undefined;
            if ((amount !== undefined) && (amount > 0) && (filled !== undefined)) {
                remaining = Math.max (0, amount - filled);
            }
            return {
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'status': status,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'trades': trades,
                'fee': undefined,
                'info': order,
                'lastTradeTimestamp': undefined,
                'average': undefined,
            };
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'type': side,
                'amount': amount,
                'price': this.priceToPrecision (symbol, price),
            };
            const response = await this.privatePostOrder (this.extend (request, params));
            if (!response['success']) {
                throw new InvalidOrder (this.id + ' ' + this.json (response));
            }
            const order = this.parseOrder (response, market);
            amount = (order['amount'] > 0) ? order['amount'] : amount;
            return this.extend (order, {
                'amount': amount,
            });
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const request = {
                'order': id,
            };
            const response = await this.privatePostOrderCancel (this.extend (request, params));
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const order = await this.privateGetOrderId (this.extend (request, params));
            return this.parseOrder (order);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const orders = await this.privateGetOrdersOwn (this.extend (request, params));
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': '1',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': '3',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbol !== undefined) {
                const market = this.market (symbol);
                request['pair'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const trades = await this.privateGetExchangesOwn (this.extend (request, params));
            return this.parseTrades (trades, undefined, since, limit);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const query = this.urlencode (this.keysort (this.omit (params, this.extractParams (path))));
            let url = this.urls['api'] + '/';
            if (path !== 'charts/{pair}/{type}/chart/') {
                url += 'v1/';
            }
            url += this.implodeParams (path, params);
            headers = { 'Accept': 'application/json' };
            if (api === 'public') {
                if (query.length) {
                    url += '?' + query;
                }
            } else {
                this.checkRequiredCredentials ();
                let payload = this.apiKey;
                if (method === 'POST') {
                    headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    body = query;
                    payload += body;
                } else if (query.length) {
                    url += '?' + query;
                }
                headers['X-KEY'] = this.apiKey;
                headers['X-SIGN'] = this.hmac (this.encode (payload), this.encode (this.secret));
                headers['X-NONCE'] = this.nonce ().toString ();
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     {"date":1570599531.4814300537,"error":"Out of balance -9.99243661 BTC"}
            //
            const error = this.safeString (response, 'error');
            const feedback = this.id + ' ' + body;
            if (error !== undefined) {
                this.throwExactlyMatchedException (this.exceptions['exact'], error, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], error, feedback);
            }
            if (code === 401 || code === 403) {
                throw new AuthenticationError (feedback);
            } else if (code === 429) {
                throw new DDoSProtection (feedback);
            }
            if (code < 400) {
                return;
            }
            throw new ExchangeError (feedback);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],50:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, InsufficientFunds, InvalidOrder, AuthenticationError, PermissionDenied, InvalidNonce, OrderNotFound, DDoSProtection } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class btcbox extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'btcbox',
                'name': 'BtcBox',
                'countries': [ 'JP' ],
                'rateLimit': 1000,
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': false,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87327317-98c55400-c53c-11ea-9a11-81f7d951cc74.jpg',
                    'api': 'https://www.btcbox.co.jp/api',
                    'www': 'https://www.btcbox.co.jp/',
                    'doc': 'https://blog.btcbox.jp/en/archives/8762',
                    'fees': 'https://support.btcbox.co.jp/hc/en-us/articles/360001235694-Fees-introduction',
                },
                'api': {
                    'public': {
                        'get': [
                            'depth',
                            'orders',
                            'ticker',
                        ],
                    },
                    'private': {
                        'post': [
                            'balance',
                            'trade_add',
                            'trade_cancel',
                            'trade_list',
                            'trade_view',
                            'wallet',
                        ],
                    },
                },
                'markets': {
                    'BTC/JPY': { 'id': 'btc', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY', 'baseId': 'btc', 'quoteId': 'jpy', 'taker': 0.05 / 100, 'maker': 0.05 / 100 },
                    'ETH/JPY': { 'id': 'eth', 'symbol': 'ETH/JPY', 'base': 'ETH', 'quote': 'JPY', 'baseId': 'eth', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },
                    'LTC/JPY': { 'id': 'ltc', 'symbol': 'LTC/JPY', 'base': 'LTC', 'quote': 'JPY', 'baseId': 'ltc', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },
                    'BCH/JPY': { 'id': 'bch', 'symbol': 'BCH/JPY', 'base': 'BCH', 'quote': 'JPY', 'baseId': 'bch', 'quoteId': 'jpy', 'taker': 0.10 / 100, 'maker': 0.10 / 100 },
                },
                'exceptions': {
                    '104': AuthenticationError,
                    '105': PermissionDenied,
                    '106': InvalidNonce,
                    '107': InvalidOrder, // price should be an integer
                    '200': InsufficientFunds,
                    '201': InvalidOrder, // amount too small
                    '202': InvalidOrder, // price should be [0 : 1000000]
                    '203': OrderNotFound,
                    '401': OrderNotFound, // cancel canceled, closed or non-existent order
                    '402': DDoSProtection,
                },
            });
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostBalance (params);
            const result = { 'info': response };
            const codes = Object.keys (this.currencies);
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const currency = this.currency (code);
                const currencyId = currency['id'];
                const free = currencyId + '_balance';
                if (free in response) {
                    const account = this.account ();
                    const used = currencyId + '_lock';
                    account['free'] = this.safeString (response, free);
                    account['used'] = this.safeString (response, used);
                    result[code] = account;
                }
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            const numSymbols = this.symbols.length;
            if (numSymbols > 1) {
                request['coin'] = market['baseId'];
            }
            const response = await this.publicGetDepth (this.extend (request, params));
            return this.parseOrderBook (response, symbol);
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.milliseconds ();
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': this.safeNumber (ticker, 'volume'),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            const numSymbols = this.symbols.length;
            if (numSymbols > 1) {
                request['coin'] = market['baseId'];
            }
            const response = await this.publicGetTicker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeTimestamp (trade, 'date');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const id = this.safeString (trade, 'tid');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const type = undefined;
            const side = this.safeString (trade, 'type');
            return {
                'info': trade,
                'id': id,
                'order': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            const numSymbols = this.symbols.length;
            if (numSymbols > 1) {
                request['coin'] = market['baseId'];
            }
            const response = await this.publicGetOrders (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'amount': amount,
                'price': price,
                'type': side,
                'coin': market['baseId'],
            };
            const response = await this.privatePostTradeAdd (this.extend (request, params));
            //
            //     {
            //         "result":true,
            //         "id":"11"
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            // a special case for btcbox – default symbol is BTC/JPY
            if (symbol === undefined) {
                symbol = 'BTC/JPY';
            }
            const market = this.market (symbol);
            const request = {
                'id': id,
                'coin': market['baseId'],
            };
            const response = await this.privatePostTradeCancel (this.extend (request, params));
            //
            //     {"result":true, "id":"11"}
            //
            return this.parseOrder (response, market);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                // TODO: complete list
                'part': 'open', // partially or not at all executed
                'all': 'closed', // fully executed
                'cancelled': 'canceled',
                'closed': 'closed', // never encountered, seems to be bug in the doc
                'no': 'closed', // not clarified in the docs...
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "id":11,
            //         "datetime":"2014-10-21 10:47:20",
            //         "type":"sell",
            //         "price":42000,
            //         "amount_original":1.2,
            //         "amount_outstanding":1.2,
            //         "status":"closed",
            //         "trades":[]
            //     }
            //
            const id = this.safeString (order, 'id');
            const datetimeString = this.safeString (order, 'datetime');
            let timestamp = undefined;
            if (datetimeString !== undefined) {
                timestamp = this.parse8601 (order['datetime'] + '+09:00'); // Tokyo time
            }
            const amount = this.safeNumber (order, 'amount_original');
            const remaining = this.safeNumber (order, 'amount_outstanding');
            const price = this.safeNumber (order, 'price');
            // status is set by fetchOrder method only
            let status = this.parseOrderStatus (this.safeString (order, 'status'));
            // fetchOrders do not return status, use heuristic
            if (status === undefined) {
                if (remaining !== undefined && remaining === 0) {
                    status = 'closed';
                }
            }
            const trades = undefined; // todo: this.parseTrades (order['trades']);
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const side = this.safeString (order, 'type');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'amount': amount,
                'remaining': remaining,
                'filled': undefined,
                'side': side,
                'type': undefined,
                'timeInForce': undefined,
                'postOnly': undefined,
                'status': status,
                'symbol': symbol,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'trades': trades,
                'fee': undefined,
                'info': order,
                'average': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            // a special case for btcbox – default symbol is BTC/JPY
            if (symbol === undefined) {
                symbol = 'BTC/JPY';
            }
            const market = this.market (symbol);
            const request = this.extend ({
                'id': id,
                'coin': market['baseId'],
            }, params);
            const response = await this.privatePostTradeView (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        async fetchOrdersByType (type, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            // a special case for btcbox – default symbol is BTC/JPY
            if (symbol === undefined) {
                symbol = 'BTC/JPY';
            }
            const market = this.market (symbol);
            const request = {
                'type': type, // 'open' or 'all'
                'coin': market['baseId'],
            };
            const response = await this.privatePostTradeList (this.extend (request, params));
            const orders = this.parseOrders (response, market, since, limit);
            // status (open/closed/canceled) is undefined
            // btcbox does not return status, but we know it's 'open' as we queried for open orders
            if (type === 'open') {
                for (let i = 0; i < orders.length; i++) {
                    orders[i]['status'] = 'open';
                }
            }
            return orders;
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByType ('all', symbol, since, limit, params);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByType ('open', symbol, since, limit, params);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.version + '/' + path;
            if (api === 'public') {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const query = this.extend ({
                    'key': this.apiKey,
                    'nonce': nonce,
                }, params);
                const request = this.urlencode (query);
                const secret = this.hash (this.encode (this.secret));
                query['signature'] = this.hmac (this.encode (request), this.encode (secret));
                body = this.urlencode (query);
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // resort to defaultErrorHandler
            }
            // typical error response: {"result":false,"code":"401"}
            if (httpCode >= 400) {
                return; // resort to defaultErrorHandler
            }
            const result = this.safeValue (response, 'result');
            if (result === undefined || result === true) {
                return; // either public API (no error codes expected) or success
            }
            const code = this.safeValue (response, 'code');
            const feedback = this.id + ' ' + body;
            this.throwExactlyMatchedException (this.exceptions, code, feedback);
            throw new ExchangeError (feedback); // unknown message
        }
    
        async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined, config = {}, context = {}) {
            let response = await this.fetch2 (path, api, method, params, headers, body, config, context);
            if (typeof response === 'string') {
                // sometimes the exchange returns whitespace prepended to json
                response = this.strip (response);
                if (!this.isJsonEncodedObject (response)) {
                    throw new ExchangeError (this.id + ' ' + response);
                }
                response = JSON.parse (response);
            }
            return response;
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],51:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ArgumentsRequired, ExchangeError, OrderNotFound, InvalidOrder, InsufficientFunds, DDoSProtection, BadRequest } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class btcmarkets extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'btcmarkets',
                'name': 'BTC Markets',
                'countries': [ 'AU' ], // Australia
                'rateLimit': 1000, // market data cached for 1 second (trades cached for 2 seconds)
                'version': 'v3',
                'has': {
                    'cancelOrder': true,
                    'cancelOrders': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': 'emulated',
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTransactions': true,
                    'fetchWithdrawals': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/89731817-b3fb8480-da52-11ea-817f-783b08aaf32b.jpg',
                    'api': {
                        'public': 'https://api.btcmarkets.net',
                        'private': 'https://api.btcmarkets.net',
                    },
                    'www': 'https://btcmarkets.net',
                    'doc': [
                        'https://api.btcmarkets.net/doc/v3',
                        'https://github.com/BTCMarkets/API',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            'markets',
                            'markets/{marketId}/ticker',
                            'markets/{marketId}/trades',
                            'markets/{marketId}/orderbook',
                            'markets/{marketId}/candles',
                            'markets/tickers',
                            'markets/orderbooks',
                            'time',
                        ],
                    },
                    'private': {
                        'get': [
                            'orders',
                            'orders/{id}',
                            'batchorders/{ids}',
                            'trades',
                            'trades/{id}',
                            'withdrawals',
                            'withdrawals/{id}',
                            'deposits',
                            'deposits/{id}',
                            'transfers',
                            'transfers/{id}',
                            'addresses',
                            'withdrawal-fees',
                            'assets',
                            'accounts/me/trading-fees',
                            'accounts/me/withdrawal-limits',
                            'accounts/me/balances',
                            'accounts/me/transactions',
                            'reports/{id}',
                        ],
                        'post': [
                            'orders',
                            'batchorders',
                            'withdrawals',
                            'reports',
                        ],
                        'delete': [
                            'orders',
                            'orders/{id}',
                            'batchorders/{ids}',
                        ],
                        'put': [
                            'orders/{id}',
                        ],
                    },
                },
                'timeframes': {
                    '1m': '1m',
                    '1h': '1h',
                    '1d': '1d',
                },
                'exceptions': {
                    '3': InvalidOrder,
                    '6': DDoSProtection,
                    'InsufficientFund': InsufficientFunds,
                    'InvalidPrice': InvalidOrder,
                    'InvalidAmount': InvalidOrder,
                    'MissingArgument': InvalidOrder,
                    'OrderAlreadyCancelled': InvalidOrder,
                    'OrderNotFound': OrderNotFound,
                    'OrderStatusIsFinal': InvalidOrder,
                    'InvalidPaginationParameter': BadRequest,
                },
                'fees': {
                    'percentage': true,
                    'tierBased': true,
                    'maker': this.parseNumber ('-0.0005'),
                    'taker': this.parseNumber ('0.0020'),
                },
                'options': {
                    'fees': {
                        'AUD': {
                            'maker': 0.85 / 100,
                            'taker': 0.85 / 100,
                        },
                    },
                },
            });
        }
    
        async fetchTransactionsWithMethod (method, code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['after'] = since;
            }
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            const response = await this[method] (this.extend (request, params));
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsWithMethod ('privateGetTransfers', code, since, limit, params);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsWithMethod ('privateGetDeposits', code, since, limit, params);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsWithMethod ('privateGetWithdrawals', code, since, limit, params);
        }
    
        parseTransactionStatus (status) {
            // todo: find more statuses
            const statuses = {
                'Complete': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransactionType (type) {
            const statuses = {
                'Withdraw': 'withdrawal',
                'Deposit': 'deposit',
            };
            return this.safeString (statuses, type, type);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            //    {
            //         "id": "6500230339",
            //         "assetName": "XRP",
            //         "amount": "500",
            //         "type": "Deposit",
            //         "creationTime": "2020-07-27T07:52:08.640000Z",
            //         "status": "Complete",
            //         "description": "RIPPLE Deposit, XRP 500",
            //         "fee": "0",
            //         "lastUpdate": "2020-07-27T07:52:08.665000Z",
            //         "paymentDetail": {
            //             "txId": "lsjflsjdfljsd",
            //             "address": "kjasfkjsdf?dt=873874545"
            //         }
            //    }
            //
            //    {
            //         "id": "500985282",
            //         "assetName": "BTC",
            //         "amount": "0.42570126",
            //         "type": "Withdraw",
            //         "creationTime": "2017-07-29T12:49:03.931000Z",
            //         "status": "Complete",
            //         "description": "BTC withdraw from [nick-btcmarkets@snowmonkey.co.uk] to Address: 1B9DsnSYQ54VMqFHVJYdGoLMCYzFwrQzsj amount: 0.42570126 fee: 0.00000000",
            //         "fee": "0.0005",
            //         "lastUpdate": "2017-07-29T12:52:20.676000Z",
            //         "paymentDetail": {
            //             "txId": "fkjdsfjsfljsdfl",
            //             "address": "a;daddjas;djas"
            //         }
            //    }
            //
            //    {
            //         "id": "505102262",
            //         "assetName": "XRP",
            //         "amount": "979.836",
            //         "type": "Deposit",
            //         "creationTime": "2017-07-31T08:50:01.053000Z",
            //         "status": "Complete",
            //         "description": "Ripple Deposit, X 979.8360",
            //         "fee": "0",
            //         "lastUpdate": "2017-07-31T08:50:01.290000Z"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (transaction, 'creationTime'));
            const lastUpdate = this.parse8601 (this.safeString (transaction, 'lastUpdate'));
            let type = this.parseTransactionType (this.safeStringLower (transaction, 'type'));
            if (type === 'withdraw') {
                type = 'withdrawal';
            }
            const cryptoPaymentDetail = this.safeValue (transaction, 'paymentDetail', {});
            const txid = this.safeString (cryptoPaymentDetail, 'txId');
            let address = this.safeString (cryptoPaymentDetail, 'address');
            let tag = undefined;
            if (address !== undefined) {
                const addressParts = address.split ('?dt=');
                const numParts = addressParts.length;
                if (numParts > 1) {
                    address = addressParts[0];
                    tag = addressParts[1];
                }
            }
            const addressTo = address;
            const tagTo = tag;
            const addressFrom = undefined;
            const tagFrom = undefined;
            const fee = this.safeNumber (transaction, 'fee');
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const currencyId = this.safeString (transaction, 'assetName');
            const code = this.safeCurrencyCode (currencyId);
            let amount = this.safeNumber (transaction, 'amount');
            if (fee) {
                amount -= fee;
            }
            return {
                'id': this.safeString (transaction, 'id'),
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'addressTo': addressTo,
                'addressFrom': addressFrom,
                'tag': tag,
                'tagTo': tagTo,
                'tagFrom': tagFrom,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': lastUpdate,
                'fee': {
                    'currency': code,
                    'cost': fee,
                },
                'info': transaction,
            };
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarkets (params);
            //
            //     [
            //         {
            //             "marketId":"COMP-AUD",
            //             "baseAssetName":"COMP",
            //             "quoteAssetName":"AUD",
            //             "minOrderAmount":"0.00007",
            //             "maxOrderAmount":"1000000",
            //             "amountDecimals":"8",
            //             "priceDecimals":"2"
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const baseId = this.safeString (market, 'baseAssetName');
                const quoteId = this.safeString (market, 'quoteAssetName');
                const id = this.safeString (market, 'marketId');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const fees = this.safeValue (this.safeValue (this.options, 'fees', {}), quote, this.fees);
                const pricePrecision = this.safeInteger (market, 'priceDecimals');
                const amountPrecision = this.safeInteger (market, 'amountDecimals');
                const minAmount = this.safeNumber (market, 'minOrderAmount');
                const maxAmount = this.safeNumber (market, 'maxOrderAmount');
                let minPrice = undefined;
                if (quote === 'AUD') {
                    minPrice = Math.pow (10, -pricePrecision);
                }
                const precision = {
                    'amount': amountPrecision,
                    'price': pricePrecision,
                };
                const limits = {
                    'amount': {
                        'min': minAmount,
                        'max': maxAmount,
                    },
                    'price': {
                        'min': minPrice,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                result.push ({
                    'info': market,
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': undefined,
                    'maker': fees['maker'],
                    'taker': fees['taker'],
                    'limits': limits,
                    'precision': precision,
                });
            }
            return result;
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     {
            //         "timestamp": "2019-09-01T18:34:27.045000Z"
            //     }
            //
            return this.parse8601 (this.safeString (response, 'timestamp'));
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccountsMeBalances (params);
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'assetName');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['used'] = this.safeString (balance, 'locked');
                account['total'] = this.safeString (balance, 'balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         "2020-09-12T18:30:00.000000Z",
            //         "14409.45", // open
            //         "14409.45", // high
            //         "14403.91", // low
            //         "14403.91", // close
            //         "0.01571701" // volume
            //     ]
            //
            return [
                this.parse8601 (this.safeString (ohlcv, 0)),
                this.safeNumber (ohlcv, 1), // open
                this.safeNumber (ohlcv, 2), // high
                this.safeNumber (ohlcv, 3), // low
                this.safeNumber (ohlcv, 4), // close
                this.safeNumber (ohlcv, 5), // volume
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
                'timeWindow': this.timeframes[timeframe],
                // 'from': this.iso8601 (since),
                // 'to': this.iso8601 (this.milliseconds ()),
                // 'before': 1234567890123,
                // 'after': 1234567890123,
                // 'limit': limit, // default 10, max 200
            };
            if (since !== undefined) {
                request['from'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default is 10, max 200
            }
            const response = await this.publicGetMarketsMarketIdCandles (this.extend (request, params));
            //
            //     [
            //         ["2020-09-12T18:30:00.000000Z","14409.45","14409.45","14403.91","14403.91","0.01571701"],
            //         ["2020-09-12T18:21:00.000000Z","14409.45","14409.45","14409.45","14409.45","0.0035"],
            //         ["2020-09-12T18:03:00.000000Z","14361.37","14361.37","14361.37","14361.37","0.00345221"],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
            };
            const response = await this.publicGetMarketsMarketIdOrderbook (this.extend (request, params));
            //
            //     {
            //         "marketId":"BTC-AUD",
            //         "snapshotId":1599936148941000,
            //         "asks":[
            //             ["14459.45","0.00456475"],
            //             ["14463.56","2"],
            //             ["14470.91","0.98"],
            //         ],
            //         "bids":[
            //             ["14421.01","0.52"],
            //             ["14421","0.75"],
            //             ["14418","0.3521"],
            //         ]
            //     }
            //
            const timestamp = this.safeIntegerProduct (response, 'snapshotId', 0.001);
            const orderbook = this.parseOrderBook (response, symbol, timestamp);
            orderbook['nonce'] = this.safeInteger (response, 'snapshotId');
            return orderbook;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker
            //
            //     {
            //         "marketId":"BAT-AUD",
            //         "bestBid":"0.3751",
            //         "bestAsk":"0.377",
            //         "lastPrice":"0.3769",
            //         "volume24h":"56192.97613335",
            //         "volumeQte24h":"21179.13270465",
            //         "price24h":"0.0119",
            //         "pricePct24h":"3.26",
            //         "low24h":"0.3611",
            //         "high24h":"0.3799",
            //         "timestamp":"2020-08-09T18:28:23.280000Z"
            //     }
            //
            let symbol = undefined;
            const marketId = this.safeString (ticker, 'marketId');
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const [ baseId, quoteId ] = marketId.split ('-');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const timestamp = this.parse8601 (this.safeString (ticker, 'timestamp'));
            const last = this.safeNumber (ticker, 'lastPrice');
            const baseVolume = this.safeNumber (ticker, 'volume24h');
            const quoteVolume = this.safeNumber (ticker, 'volumeQte24h');
            const vwap = this.vwap (baseVolume, quoteVolume);
            const change = this.safeNumber (ticker, 'price24h');
            const percentage = this.safeNumber (ticker, 'pricePct24h');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high24h'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bestBid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'bestAsk'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
            };
            const response = await this.publicGetMarketsMarketIdTicker (this.extend (request, params));
            //
            //     {
            //         "marketId":"BAT-AUD",
            //         "bestBid":"0.3751",
            //         "bestAsk":"0.377",
            //         "lastPrice":"0.3769",
            //         "volume24h":"56192.97613335",
            //         "volumeQte24h":"21179.13270465",
            //         "price24h":"0.0119",
            //         "pricePct24h":"3.26",
            //         "low24h":"0.3611",
            //         "high24h":"0.3799",
            //         "timestamp":"2020-08-09T18:28:23.280000Z"
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchTicker2 (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'],
            };
            const response = await this.publicGetMarketIdTick (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     {
            //         "id":"6191646611",
            //         "price":"539.98",
            //         "amount":"0.5",
            //         "timestamp":"2020-08-09T15:21:05.016000Z",
            //         "side":"Ask"
            //     }
            //
            // private fetchMyTrades
            //
            //     {
            //         "id": "36014819",
            //         "marketId": "XRP-AUD",
            //         "timestamp": "2019-06-25T16:01:02.977000Z",
            //         "price": "0.67",
            //         "amount": "1.50533262",
            //         "side": "Ask",
            //         "fee": "0.00857285",
            //         "orderId": "3648306",
            //         "liquidityType": "Taker",
            //         "clientOrderId": "48"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (trade, 'timestamp'));
            const marketId = this.safeString (trade, 'marketId');
            let symbol = undefined;
            let base = undefined;
            let quote = undefined;
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const [ baseId, quoteId ] = marketId.split ('-');
                    base = this.safeCurrencyCode (baseId);
                    quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
                base = market['base'];
                quote = market['quote'];
            }
            let feeCurrencyCode = undefined;
            if (quote === 'AUD') {
                feeCurrencyCode = quote;
            } else {
                feeCurrencyCode = base;
            }
            let side = this.safeString (trade, 'side');
            if (side === 'Bid') {
                side = 'buy';
            } else if (side === 'Ask') {
                side = 'sell';
            }
            const id = this.safeString (trade, 'id');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const orderId = this.safeString (trade, 'orderId');
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            const takerOrMaker = this.safeStringLower (trade, 'liquidityType');
            return {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'order': orderId,
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'takerOrMaker': takerOrMaker,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                // 'since': 59868345231,
                'marketId': market['id'],
            };
            const response = await this.publicGetMarketsMarketIdTrades (this.extend (request, params));
            //
            //     [
            //         {"id":"6191646611","price":"539.98","amount":"0.5","timestamp":"2020-08-09T15:21:05.016000Z","side":"Ask"},
            //         {"id":"6191646610","price":"539.99","amount":"0.5","timestamp":"2020-08-09T15:21:05.015000Z","side":"Ask"},
            //         {"id":"6191646590","price":"540","amount":"0.00233785","timestamp":"2020-08-09T15:21:04.171000Z","side":"Bid"},
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
                // 'price': this.priceToPrecision (symbol, price),
                'amount': this.amountToPrecision (symbol, amount),
                // 'type': 'Limit', // "Limit", "Market", "Stop Limit", "Stop", "Take Profit"
                'side': (side === 'buy') ? 'Bid' : 'Ask',
                // 'triggerPrice': this.priceToPrecision (symbol, triggerPrice), // required for Stop, Stop Limit, Take Profit orders
                // 'targetAmount': this.amountToPrecision (symbol, targetAmount), // target amount when a desired target outcome is required for order execution
                // 'timeInForce': 'GTC', // GTC, FOK, IOC
                // 'postOnly': false, // boolean if this is a post-only order
                // 'selfTrade': 'A', // A = allow, P = prevent
                // 'clientOrderId': this.uuid (),
            };
            const lowercaseType = type.toLowerCase ();
            const orderTypes = this.safeValue (this.options, 'orderTypes', {
                'limit': 'Limit',
                'market': 'Market',
                'stop': 'Stop',
                'stop limit': 'Stop Limit',
                'take profit': 'Take Profit',
            });
            request['type'] = this.safeString (orderTypes, lowercaseType, type);
            let priceIsRequired = false;
            let triggerPriceIsRequired = false;
            if (lowercaseType === 'limit') {
                priceIsRequired = true;
            // } else if (lowercaseType === 'market') {
            //     ...
            // }
            } else if (lowercaseType === 'stop limit') {
                triggerPriceIsRequired = true;
                priceIsRequired = true;
            } else if (lowercaseType === 'take profit') {
                triggerPriceIsRequired = true;
            } else if (lowercaseType === 'stop') {
                triggerPriceIsRequired = true;
            }
            if (priceIsRequired) {
                if (price === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a price argument for a ' + type + 'order');
                } else {
                    request['price'] = this.priceToPrecision (symbol, price);
                }
            }
            if (triggerPriceIsRequired) {
                const triggerPrice = this.safeNumber (params, 'triggerPrice');
                params = this.omit (params, 'triggerPrice');
                if (triggerPrice === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a triggerPrice parameter for a ' + type + 'order');
                } else {
                    request['triggerPrice'] = this.priceToPrecision (symbol, triggerPrice);
                }
            }
            const clientOrderId = this.safeString (params, 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['clientOrderId'] = clientOrderId;
            }
            params = this.omit (params, 'clientOrderId');
            const response = await this.privatePostOrders (this.extend (request, params));
            //
            //     {
            //         "orderId": "7524",
            //         "marketId": "BTC-AUD",
            //         "side": "Bid",
            //         "type": "Limit",
            //         "creationTime": "2019-08-30T11:08:21.956000Z",
            //         "price": "100.12",
            //         "amount": "1.034",
            //         "openAmount": "1.034",
            //         "status": "Accepted",
            //         "clientOrderId": "1234-5678",
            //         "timeInForce": "IOC",
            //         "postOnly": false,
            //         "selfTrade": "P",
            //         "triggerAmount": "105",
            //         "targetAmount": "1000"
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrders (ids, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            for (let i = 0; i < ids.length; i++) {
                ids[i] = parseInt (ids[i]);
            }
            const request = {
                'ids': ids,
            };
            return await this.privateDeleteBatchordersIds (this.extend (request, params));
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            return await this.privateDeleteOrdersId (this.extend (request, params));
        }
    
        calculateFee (symbol, type, side, amount, price, takerOrMaker = 'taker', params = {}) {
            const market = this.markets[symbol];
            const rate = market[takerOrMaker];
            let currency = undefined;
            let cost = undefined;
            if (market['quote'] === 'AUD') {
                currency = market['quote'];
                cost = parseFloat (this.costToPrecision (symbol, amount * price));
            } else {
                currency = market['base'];
                cost = parseFloat (this.amountToPrecision (symbol, amount));
            }
            return {
                'type': takerOrMaker,
                'currency': currency,
                'rate': rate,
                'cost': parseFloat (this.feeToPrecision (symbol, rate * cost)),
            };
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'Accepted': 'open',
                'Placed': 'open',
                'Partially Matched': 'open',
                'Fully Matched': 'closed',
                'Cancelled': 'canceled',
                'Partially Cancelled': 'canceled',
                'Failed': 'rejected',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "orderId": "7524",
            //         "marketId": "BTC-AUD",
            //         "side": "Bid",
            //         "type": "Limit",
            //         "creationTime": "2019-08-30T11:08:21.956000Z",
            //         "price": "100.12",
            //         "amount": "1.034",
            //         "openAmount": "1.034",
            //         "status": "Accepted",
            //         "clientOrderId": "1234-5678",
            //         "timeInForce": "IOC",
            //         "postOnly": false,
            //         "selfTrade": "P",
            //         "triggerAmount": "105",
            //         "targetAmount": "1000"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (order, 'creationTime'));
            const marketId = this.safeString (order, 'marketId');
            let symbol = undefined;
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const [ baseId, quoteId ] = marketId.split ('-');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            let side = this.safeString (order, 'side');
            if (side === 'Bid') {
                side = 'buy';
            } else if (side === 'Ask') {
                side = 'sell';
            }
            const type = this.safeStringLower (order, 'type');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount');
            const remaining = this.safeNumber (order, 'openAmount');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const id = this.safeString (order, 'orderId');
            const clientOrderId = this.safeString (order, 'clientOrderId');
            const timeInForce = this.safeString (order, 'timeInForce');
            const stopPrice = this.safeNumber (order, 'triggerPrice');
            const postOnly = this.safeValue (order, 'postOnly');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'cost': undefined,
                'amount': amount,
                'filled': undefined,
                'remaining': remaining,
                'average': undefined,
                'status': status,
                'trades': undefined,
                'fee': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privateGetOrdersId (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'status': 'all',
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['marketId'] = market['id'];
            }
            if (since !== undefined) {
                request['after'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetOrders (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = { 'status': 'open' };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const orders = await this.fetchOrders (symbol, since, limit, params);
            return this.filterBy (orders, 'status', 'closed');
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['marketId'] = market['id'];
            }
            if (since !== undefined) {
                request['after'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetTrades (this.extend (request, params));
            //
            //     [
            //         {
            //             "id": "36014819",
            //             "marketId": "XRP-AUD",
            //             "timestamp": "2019-06-25T16:01:02.977000Z",
            //             "price": "0.67",
            //             "amount": "1.50533262",
            //             "side": "Ask",
            //             "fee": "0.00857285",
            //             "orderId": "3648306",
            //             "liquidityType": "Taker",
            //             "clientOrderId": "48"
            //         },
            //         {
            //             "id": "3568960",
            //             "marketId": "GNT-AUD",
            //             "timestamp": "2019-06-20T08:44:04.488000Z",
            //             "price": "0.1362",
            //             "amount": "0.85",
            //             "side": "Bid",
            //             "fee": "0.00098404",
            //             "orderId": "3543015",
            //             "liquidityType": "Maker"
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        lookupSymbolFromMarketId (marketId) {
            let market = undefined;
            let symbol = undefined;
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const [ baseId, quoteId ] = marketId.split ('-');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            return symbol;
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.keysort (this.omit (params, this.extractParams (path)));
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const secret = this.base64ToBinary (this.encode (this.secret));
                let auth = method + request + nonce;
                if ((method === 'GET') || (method === 'DELETE')) {
                    if (Object.keys (query).length) {
                        request += '?' + this.urlencode (query);
                    }
                } else {
                    body = this.json (query);
                    auth += body;
                }
                const signature = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
                headers = {
                    'Accept': 'application/json',
                    'Accept-Charset': 'UTF-8',
                    'Content-Type': 'application/json',
                    'BM-AUTH-APIKEY': this.apiKey,
                    'BM-AUTH-TIMESTAMP': nonce,
                    'BM-AUTH-SIGNATURE': signature,
                };
            } else if (api === 'public') {
                if (Object.keys (query).length) {
                    request += '?' + this.urlencode (query);
                }
            }
            const url = this.urls['api'][api] + request;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if ('success' in response) {
                if (!response['success']) {
                    const error = this.safeString (response, 'errorCode');
                    const feedback = this.id + ' ' + body;
                    this.throwExactlyMatchedException (this.exceptions, error, feedback);
                    throw new ExchangeError (feedback);
                }
            }
            // v3 api errors
            if (code >= 400) {
                const errorCode = this.safeString (response, 'code');
                const message = this.safeString (response, 'message');
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions, errorCode, feedback);
                this.throwExactlyMatchedException (this.exceptions, message, feedback);
                throw new ExchangeError (feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],52:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class btctradeua extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'btctradeua',
                'name': 'BTC Trade UA',
                'countries': [ 'UA' ], // Ukraine,
                'rateLimit': 3000,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchOpenOrders': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'signIn': true,
                },
                'urls': {
                    'referral': 'https://btc-trade.com.ua/registration/22689',
                    'logo': 'https://user-images.githubusercontent.com/1294454/27941483-79fc7350-62d9-11e7-9f61-ac47f28fcd96.jpg',
                    'api': 'https://btc-trade.com.ua/api',
                    'www': 'https://btc-trade.com.ua',
                    'doc': 'https://docs.google.com/document/d/1ocYA0yMy_RXd561sfG3qEPZ80kyll36HUxvCRe5GbhE/edit',
                },
                'api': {
                    'public': {
                        'get': [
                            'deals/{symbol}',
                            'trades/sell/{symbol}',
                            'trades/buy/{symbol}',
                            'japan_stat/high/{symbol}',
                        ],
                    },
                    'private': {
                        'post': [
                            'auth',
                            'ask/{symbol}',
                            'balance',
                            'bid/{symbol}',
                            'buy/{symbol}',
                            'my_orders/{symbol}',
                            'order/status/{id}',
                            'remove/order/{id}',
                            'sell/{symbol}',
                        ],
                    },
                },
                'markets': {
                    'BCH/UAH': { 'id': 'bch_uah', 'symbol': 'BCH/UAH', 'base': 'BCH', 'quote': 'UAH', 'baseId': 'bch', 'quoteId': 'uah' },
                    'BTC/UAH': { 'id': 'btc_uah', 'symbol': 'BTC/UAH', 'base': 'BTC', 'quote': 'UAH', 'baseId': 'btc', 'quoteId': 'uah', 'precision': { 'price': 1 }, 'limits': { 'amount': { 'min': 0.0000000001 }}},
                    'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'dash', 'quoteId': 'btc' },
                    'DASH/UAH': { 'id': 'dash_uah', 'symbol': 'DASH/UAH', 'base': 'DASH', 'quote': 'UAH', 'baseId': 'dash', 'quoteId': 'uah' },
                    'DOGE/BTC': { 'id': 'doge_btc', 'symbol': 'DOGE/BTC', 'base': 'DOGE', 'quote': 'BTC', 'baseId': 'doge', 'quoteId': 'btc' },
                    'DOGE/UAH': { 'id': 'doge_uah', 'symbol': 'DOGE/UAH', 'base': 'DOGE', 'quote': 'UAH', 'baseId': 'doge', 'quoteId': 'uah' },
                    'ETH/UAH': { 'id': 'eth_uah', 'symbol': 'ETH/UAH', 'base': 'ETH', 'quote': 'UAH', 'baseId': 'eth', 'quoteId': 'uah' },
                    'ITI/UAH': { 'id': 'iti_uah', 'symbol': 'ITI/UAH', 'base': 'ITI', 'quote': 'UAH', 'baseId': 'iti', 'quoteId': 'uah' },
                    'KRB/UAH': { 'id': 'krb_uah', 'symbol': 'KRB/UAH', 'base': 'KRB', 'quote': 'UAH', 'baseId': 'krb', 'quoteId': 'uah' },
                    'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'ltc', 'quoteId': 'btc' },
                    'LTC/UAH': { 'id': 'ltc_uah', 'symbol': 'LTC/UAH', 'base': 'LTC', 'quote': 'UAH', 'baseId': 'ltc', 'quoteId': 'uah' },
                    'NVC/BTC': { 'id': 'nvc_btc', 'symbol': 'NVC/BTC', 'base': 'NVC', 'quote': 'BTC', 'baseId': 'nvc', 'quoteId': 'btc' },
                    'NVC/UAH': { 'id': 'nvc_uah', 'symbol': 'NVC/UAH', 'base': 'NVC', 'quote': 'UAH', 'baseId': 'nvc', 'quoteId': 'uah' },
                    'PPC/BTC': { 'id': 'ppc_btc', 'symbol': 'PPC/BTC', 'base': 'PPC', 'quote': 'BTC', 'baseId': 'ppc', 'quoteId': 'btc' },
                    'SIB/UAH': { 'id': 'sib_uah', 'symbol': 'SIB/UAH', 'base': 'SIB', 'quote': 'UAH', 'baseId': 'sib', 'quoteId': 'uah' },
                    'XMR/UAH': { 'id': 'xmr_uah', 'symbol': 'XMR/UAH', 'base': 'XMR', 'quote': 'UAH', 'baseId': 'xmr', 'quoteId': 'uah' },
                    'ZEC/UAH': { 'id': 'zec_uah', 'symbol': 'ZEC/UAH', 'base': 'ZEC', 'quote': 'UAH', 'baseId': 'zec', 'quoteId': 'uah' },
                },
                'fees': {
                    'trading': {
                        'maker': 0.1 / 100,
                        'taker': 0.1 / 100,
                    },
                    'funding': {
                        'withdraw': {
                            'BTC': 0.0006,
                            'LTC': 0.01,
                            'NVC': 0.01,
                            'DOGE': 10,
                        },
                    },
                },
            });
        }
    
        async signIn (params = {}) {
            return await this.privatePostAuth (params);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostBalance (params);
            const result = { 'info': response };
            const balances = this.safeValue (response, 'accounts');
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['total'] = this.safeString (balance, 'balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const bids = await this.publicGetTradesBuySymbol (this.extend (request, params));
            const asks = await this.publicGetTradesSellSymbol (this.extend (request, params));
            const orderbook = {
                'bids': [],
                'asks': [],
            };
            if (bids) {
                if ('list' in bids) {
                    orderbook['bids'] = bids['list'];
                }
            }
            if (asks) {
                if ('list' in asks) {
                    orderbook['asks'] = asks['list'];
                }
            }
            return this.parseOrderBook (orderbook, symbol, undefined, 'bids', 'asks', 'price', 'currency_trade');
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            const response = await this.publicGetJapanStatHighSymbol (this.extend (request, params));
            const ticker = this.safeValue (response, 'trades');
            const timestamp = this.milliseconds ();
            const result = {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': undefined,
                'low': undefined,
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': undefined,
                'last': undefined,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': undefined,
                'info': ticker,
            };
            const tickerLength = ticker.length;
            if (tickerLength > 0) {
                const start = Math.max (tickerLength - 48, 0);
                for (let i = start; i < ticker.length; i++) {
                    const candle = ticker[i];
                    if (result['open'] === undefined) {
                        result['open'] = this.safeNumber (candle, 1);
                    }
                    const high = this.safeNumber (candle, 2);
                    if ((result['high'] === undefined) || ((high !== undefined) && (result['high'] < high))) {
                        result['high'] = high;
                    }
                    const low = this.safeNumber (candle, 3);
                    if ((result['low'] === undefined) || ((low !== undefined) && (result['low'] > low))) {
                        result['low'] = low;
                    }
                    const baseVolume = this.safeNumber (candle, 5);
                    if (result['baseVolume'] === undefined) {
                        result['baseVolume'] = baseVolume;
                    } else {
                        result['baseVolume'] = this.sum (result['baseVolume'], baseVolume);
                    }
                }
                const last = tickerLength - 1;
                result['last'] = this.safeNumber (ticker[last], 4);
                result['close'] = result['last'];
            }
            return result;
        }
    
        convertMonthNameToString (cyrillic) {
            const months = {
                'Jan': '01',
                'Feb': '02',
                'Mar': '03',
                'Apr': '04',
                'May': '05',
                'Jun': '06',
                'Jul': '07',
                'Aug': '08',
                'Sept': '09',
                'Oct': '10',
                'Nov': '11',
                'Dec': '12',
            };
            return this.safeString (months, cyrillic);
        }
    
        parseExchangeSpecificDatetime (cyrillic) {
            const parts = cyrillic.split (' ');
            let month = parts[0];
            let day = parts[1].replace (',', '');
            if (day.length < 2) {
                day = '0' + day;
            }
            const year = parts[2].replace (',', '');
            month = month.replace (',', '');
            month = month.replace ('.', '');
            month = this.convertMonthNameToString (month);
            if (!month) {
                throw new ExchangeError (this.id + ' parseTrade() unrecognized month name: ' + cyrillic);
            }
            const hms = parts[3];
            const hmsParts = hms.split (':');
            let h = this.safeString (hmsParts, 0);
            let m = '00';
            const ampm = this.safeString (parts, 4);
            if (h === 'noon') {
                h = '12';
            } else {
                let intH = parseInt (h);
                if ((ampm !== undefined) && (ampm[0] === 'p')) {
                    intH = 12 + intH;
                    if (intH > 23) {
                        intH = 0;
                    }
                }
                h = intH.toString ();
                if (h.length < 2) {
                    h = '0' + h;
                }
                m = this.safeString (hmsParts, 1, '00');
                if (m.length < 2) {
                    m = '0' + m;
                }
            }
            const ymd = [ year, month, day ].join ('-');
            const ymdhms = ymd + 'T' + h + ':' + m + ':00';
            const timestamp = this.parse8601 (ymdhms);
            // server reports local time, adjust to UTC
            // a special case for DST
            // subtract 2 hours during winter
            const intM = parseInt (m);
            if (intM < 11 || intM > 2) {
                return timestamp - 7200000;
            }
            // subtract 3 hours during summer
            return timestamp - 10800000;
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.parseExchangeSpecificDatetime (this.safeString (trade, 'pub_date'));
            const id = this.safeString (trade, 'id');
            const type = 'limit';
            const side = this.safeString (trade, 'type');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amnt_trade');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'order': undefined,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetDealsSymbol (this.extend (request, params));
            // they report each trade twice (once for both of the two sides of the fill)
            // deduplicate trades for that reason
            const trades = [];
            for (let i = 0; i < response.length; i++) {
                const id = this.safeInteger (response[i], 'id');
                if (id % 2) {
                    trades.push (response[i]);
                }
            }
            return this.parseTrades (trades, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            if (type === 'market') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const method = 'privatePost' + this.capitalize (side) + 'Id';
            const request = {
                'count': amount,
                'currency1': market['quoteId'],
                'currency': market['baseId'],
                'price': price,
            };
            return this[method] (this.extend (request, params));
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const request = {
                'id': id,
            };
            return await this.privatePostRemoveOrderId (this.extend (request, params));
        }
    
        parseOrder (order, market = undefined) {
            const timestamp = this.milliseconds ();
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'id': this.safeString (order, 'id'),
                'clientOrderId': undefined,
                'timestamp': timestamp, // until they fix their timestamp
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': 'open',
                'symbol': symbol,
                'type': undefined,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': this.safeString (order, 'type'),
                'price': this.safeNumber (order, 'price'),
                'stopPrice': undefined,
                'amount': this.safeNumber (order, 'amnt_trade'),
                'filled': 0,
                'remaining': this.safeNumber (order, 'amnt_trade'),
                'trades': undefined,
                'info': order,
                'cost': undefined,
                'average': undefined,
                'fee': undefined,
            };
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.privatePostMyOrdersSymbol (this.extend (request, params));
            const orders = this.safeValue (response, 'your_open_orders');
            return this.parseOrders (orders, market, since, limit);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += this.implodeParams (path, query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                body = this.urlencode (this.extend ({
                    'out_order_id': nonce,
                    'nonce': nonce,
                }, query));
                const auth = body + this.secret;
                headers = {
                    'public-key': this.apiKey,
                    'api-sign': this.hash (this.encode (auth), 'sha256'),
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],53:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, InsufficientFunds, InvalidOrder } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class btcturk extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'btcturk',
                'name': 'BTCTurk',
                'countries': [ 'TR' ], // Turkey
                'rateLimit': 10,
                'has': {
                    'cancelOrder': true,
                    'CORS': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchOHLCV': true,
                    'fetchOrderBook': true,
                    'fetchOpenOrders': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchMyTrades': true,
                },
                'timeframes': {
                    '1d': '1d',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87153926-efbef500-c2c0-11ea-9842-05b63612c4b9.jpg',
                    'api': {
                        'public': 'https://api.btcturk.com/api/v2',
                        'private': 'https://api.btcturk.com/api/v1',
                        'graph': 'https://graph-api.btcturk.com/v1',
                    },
                    'www': 'https://www.btcturk.com',
                    'doc': 'https://github.com/BTCTrader/broker-api-docs',
                },
                'api': {
                    'public': {
                        'get': {
                            'orderbook': 10,
                            'ticker': 1,
                            'trades': 10,   // ?last=COUNT (max 50)
                            'server/exchangeinfo': 10,
                        },
                    },
                    'private': {
                        'get': {
                            'users/balances': 10,
                            'openOrders': 10,
                            'allOrders': 10,
                            'users/transactions/trade': 10,
                        },
                        'post': {
                            'order': 10,
                            'cancelOrder': 10,
                        },
                        'delete': {
                            'order': 10,
                        },
                    },
                    'graph': {
                        'get': {
                            'ohlcs': 10,
                        },
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.0005'),
                        'taker': this.parseNumber ('0.0009'),
                    },
                },
                'exceptions': {
                    'exact': {
                        'FAILED_ORDER_WITH_OPEN_ORDERS': InsufficientFunds,
                        'FAILED_LIMIT_ORDER': InvalidOrder,
                        'FAILED_MARKET_ORDER': InvalidOrder,
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetServerExchangeinfo (params);
            //
            //     {
            //       "data": {
            //         "timeZone": "UTC",
            //         "serverTime": "1618826678404",
            //         "symbols": [
            //           {
            //             "id": "1",
            //             "name": "BTCTRY",
            //             "nameNormalized": "BTC_TRY",
            //             "status": "TRADING",
            //             "numerator": "BTC",
            //             "denominator": "TRY",
            //             "numeratorScale": "8",
            //             "denominatorScale": "2",
            //             "hasFraction": false,
            //             "filters": [
            //               {
            //                 "filterType": "PRICE_FILTER",
            //                 "minPrice": "0.0000000000001",
            //                 "maxPrice": "10000000",
            //                 "tickSize": "10",
            //                 "minExchangeValue": "99.91",
            //                 "minAmount": null,
            //                 "maxAmount": null
            //               }
            //             ],
            //             "orderMethods": [
            //               "MARKET",
            //               "LIMIT",
            //               "STOP_MARKET",
            //               "STOP_LIMIT"
            //             ],
            //             "displayFormat": "#,###",
            //             "commissionFromNumerator": false,
            //             "order": "1000",
            //             "priceRounding": false
            //           },
            //         },
            //       ],
            //     }
            //
            const data = this.safeValue (response, 'data');
            const markets = this.safeValue (data, 'symbols', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const entry = markets[i];
                const id = this.safeString (entry, 'name');
                const baseId = this.safeString (entry, 'numerator');
                const quoteId = this.safeString (entry, 'denominator');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const filters = this.safeValue (entry, 'filters');
                let minPrice = undefined;
                let maxPrice = undefined;
                let minAmount = undefined;
                let maxAmount = undefined;
                let minCost = undefined;
                for (let j = 0; j < filters.length; j++) {
                    const filter = filters[j];
                    const filterType = this.safeString (filter, 'filterType');
                    if (filterType === 'PRICE_FILTER') {
                        minPrice = this.safeNumber (filter, 'minPrice');
                        maxPrice = this.safeNumber (filter, 'maxPrice');
                        minAmount = this.safeNumber (filter, 'minAmount');
                        maxAmount = this.safeNumber (filter, 'maxAmount');
                        minCost = this.safeNumber (filter, 'minExchangeValue');
                    }
                }
                const status = this.safeString (entry, 'status');
                const active = status === 'TRADING';
                const limits = {
                    'price': {
                        'min': minPrice,
                        'max': maxPrice,
                    },
                    'amount': {
                        'min': minAmount,
                        'max': maxAmount,
                    },
                    'cost': {
                        'min': minCost,
                        'max': undefined,
                    },
                };
                const precision = {
                    'price': this.safeInteger (entry, 'denominatorScale'),
                    'amount': this.safeInteger (entry, 'numeratorScale'),
                };
                result.push ({
                    'info': entry,
                    'symbol': symbol,
                    'id': id,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'limits': limits,
                    'precision': precision,
                    'active': active,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetUsersBalances (params);
            //
            //     {
            //       "data": [
            //         {
            //           "asset": "TRY",
            //           "assetname": "Türk Lirası",
            //           "balance": "0",
            //           "locked": "0",
            //           "free": "0",
            //           "orderFund": "0",
            //           "requestFund": "0",
            //           "precision": 2
            //         }
            //       ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            for (let i = 0; i < data.length; i++) {
                const entry = data[i];
                const currencyId = this.safeString (entry, 'asset');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['total'] = this.safeString (entry, 'balance');
                account['free'] = this.safeString (entry, 'free');
                account['used'] = this.safeString (entry, 'locked');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pairSymbol': market['id'],
            };
            const response = await this.publicGetOrderbook (this.extend (request, params));
            //     {
            //       "data": {
            //         "timestamp": 1618827901241,
            //         "bids": [
            //           [
            //             "460263.00",
            //             "0.04244000"
            //           ]
            //         ]
            //       }
            //     }
            const data = this.safeValue (response, 'data');
            const timestamp = this.safeInteger (data, 'timestamp');
            return this.parseOrderBook (data, symbol, timestamp, 'bids', 'asks', 0, 1);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //   {
            //     "pair": "BTCTRY",
            //     "pairNormalized": "BTC_TRY",
            //     "timestamp": 1618826361234,
            //     "last": 462485,
            //     "high": 473976,
            //     "low": 444201,
            //     "bid": 461928,
            //     "ask": 462485,
            //     "open": 456915,
            //     "volume": 917.41368645,
            //     "average": 462868.29574589,
            //     "daily": 5570,
            //     "dailyPercent": 1.22,
            //     "denominatorSymbol": "TRY",
            //     "numeratorSymbol": "BTC",
            //     "order": 1000
            //   }
            //
            const marketId = this.safeString (ticker, 'pair');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.safeInteger (ticker, 'timestamp');
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': this.safeNumber (ticker, 'open'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': this.safeNumber (ticker, 'daily'),
                'percentage': this.safeNumber (ticker, 'dailyPercent'),
                'average': this.safeNumber (ticker, 'average'),
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTicker (params);
            const tickers = this.safeValue (response, 'data');
            return this.parseTickers (tickers, symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const tickers = await this.fetchTickers ([ symbol ], params);
            return this.safeValue (tickers, symbol);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades
            //     {
            //       "pair": "BTCUSDT",
            //       "pairNormalized": "BTC_USDT",
            //       "numerator": "BTC",
            //       "denominator": "USDT",
            //       "date": "1618916879083",
            //       "tid": "637545136790672520",
            //       "price": "55774",
            //       "amount": "0.27917100",
            //       "side": "buy"
            //     }
            //
            // fetchMyTrades
            //     {
            //       "price": "56000",
            //       "numeratorSymbol": "BTC",
            //       "denominatorSymbol": "USDT",
            //       "orderType": "buy",
            //       "orderId": "2606935102",
            //       "id": "320874372",
            //       "timestamp": "1618916479593",
            //       "amount": "0.00020000",
            //       "fee": "0",
            //       "tax": "0"
            //     }
            //
            const timestamp = this.safeInteger2 (trade, 'date', 'timestamp');
            const id = this.safeString2 (trade, 'tid', 'id');
            const order = this.safeString (trade, 'orderId');
            const priceString = this.safeString (trade, 'price');
            const amountString = Precise.stringAbs (this.safeString (trade, 'amount'));
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const marketId = this.safeString (trade, 'pair');
            const symbol = this.safeSymbol (marketId, market);
            const side = this.safeString2 (trade, 'side', 'orderType');
            let fee = undefined;
            const feeAmountString = this.safeString (trade, 'fee');
            if (feeAmountString !== undefined) {
                const feeCurrency = this.safeString (trade, 'denominatorSymbol');
                fee = {
                    'cost': this.parseNumber (Precise.stringAbs (feeAmountString)),
                    'currency': this.safeCurrencyCode (feeCurrency),
                };
            }
            return {
                'info': trade,
                'id': id,
                'order': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            // let maxCount = 50;
            const request = {
                'pairSymbol': market['id'],
            };
            if (limit !== undefined) {
                request['last'] = limit;
            }
            const response = await this.publicGetTrades (this.extend (request, params));
            //
            //     {
            //       "data": [
            //         {
            //           "pair": "BTCTRY",
            //           "pairNormalized": "BTC_TRY",
            //           "numerator": "BTC",
            //           "denominator": "TRY",
            //           "date": 1618828421497,
            //           "tid": "637544252214980918",
            //           "price": "462585.00",
            //           "amount": "0.01618411",
            //           "side": "sell"
            //         }
            //       ]
            //     }
            //
            const data = this.safeValue (response, 'data');
            return this.parseTrades (data, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //     {
            //        "pair": "BTCTRY",
            //        "time": 1508284800,
            //        "open": 20873.689453125,
            //        "high": 20925.0,
            //        "low": 19310.0,
            //        "close": 20679.55078125,
            //        "volume": 402.216101626982,
            //        "total": 8103096.44443274,
            //        "average": 20146.13,
            //        "dailyChangeAmount": -194.14,
            //        "dailyChangePercentage": -0.93
            //      },
            return [
                this.safeTimestamp (ohlcv, 'time'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1d', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            if (limit !== undefined) {
                request['last'] = limit;
            }
            const response = await this.graphGetOhlcs (this.extend (request, params));
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'orderType': side,
                'orderMethod': type,
                'pairSymbol': market['id'],
                'quantity': this.amountToPrecision (symbol, amount),
            };
            if (type !== 'market') {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            if ('clientOrderId' in params) {
                request['newClientOrderId'] = params['clientOrderId'];
            } else if (!('newClientOrderId' in params)) {
                request['newClientOrderId'] = this.uuid ();
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const request = {
                'id': id,
            };
            return await this.privateDeleteOrder (this.extend (request, params));
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pairSymbol'] = market['id'];
            }
            const response = await this.privateGetOpenOrders (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            const bids = this.safeValue (data, 'bids', []);
            const asks = this.safeValue (data, 'asks', []);
            return this.parseOrders (this.arrayConcat (bids, asks), market, since, limit);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pairSymbol': market['id'],
            };
            if (limit !== undefined) {
                // default 100 max 1000
                request['last'] = limit;
            }
            if (since !== undefined) {
                request['startTime'] = Math.floor (since / 1000);
            }
            const response = await this.privateGetAllOrders (this.extend (request, params));
            // {
            //   "data": [
            //     {
            //       "id": "2606012912",
            //       "price": "55000",
            //       "amount": "0.0003",
            //       "quantity": "0.0003",
            //       "stopPrice": "0",
            //       "pairSymbol": "BTCUSDT",
            //       "pairSymbolNormalized": "BTC_USDT",
            //       "type": "buy",
            //       "method": "limit",
            //       "orderClientId": "2ed187bd-59a8-4875-a212-1b793963b85c",
            //       "time": "1618913189253",
            //       "updateTime": "1618913189253",
            //       "status": "Untouched",
            //       "leftAmount": "0.0003000000000000"
            //     }
            //   ]
            // }
            const data = this.safeValue (response, 'data');
            return this.parseOrders (data, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'Untouched': 'open',
                'Partial': 'open',
                'Canceled': 'canceled',
                'Closed': 'closed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market) {
            //
            // fetchOrders / fetchOpenOrders
            //     {
            //       "id": 2605984008,
            //       "price": "55000",
            //       "amount": "0.00050000",
            //       "quantity": "0.00050000",
            //       "stopPrice": "0",
            //       "pairSymbol": "BTCUSDT",
            //       "pairSymbolNormalized": "BTC_USDT",
            //       "type": "buy",
            //       "method": "limit",
            //       "orderClientId": "f479bdb6-0965-4f03-95b5-daeb7aa5a3a5",
            //       "time": 0,
            //       "updateTime": 1618913083543,
            //       "status": "Untouched",
            //       "leftAmount": "0.00050000"
            //     }
            //
            // createOrder
            //     {
            //       "id": "2606935102",
            //       "quantity": "0.0002",
            //       "price": "56000",
            //       "stopPrice": null,
            //       "newOrderClientId": "98e5c491-7ed9-462b-9666-93553180fb28",
            //       "type": "buy",
            //       "method": "limit",
            //       "pairSymbol": "BTCUSDT",
            //       "pairSymbolNormalized": "BTC_USDT",
            //       "datetime": "1618916479523"
            //     }
            //
            const id = this.safeString (order, 'id');
            const priceString = this.safeString (order, 'price');
            const precisePrice = new Precise (priceString);
            let price = undefined;
            const isZero = precisePrice.toString () === '0';
            if (!isZero) {
                price = this.parseNumber (precisePrice);
            }
            const amountString = this.safeString (order, 'quantity');
            const amount = this.parseNumber (Precise.stringAbs (amountString));
            const remaining = this.safeNumber (order, 'leftAmount');
            const marketId = this.safeNumber (order, 'pairSymbol');
            const symbol = this.safeSymbol (marketId, market);
            const side = this.safeString (order, 'type');
            const type = this.safeString (order, 'method');
            const clientOrderId = this.safeString (order, 'orderClientId');
            const timestamp = this.safeInteger2 (order, 'updateTime', 'datetime');
            const rawStatus = this.safeString (order, 'status');
            const status = this.parseOrderStatus (rawStatus);
            return this.safeOrder ({
                'info': order,
                'id': id,
                'price': price,
                'amount': amount,
                'remaining': remaining,
                'filled': undefined,
                'cost': undefined,
                'average': undefined,
                'status': status,
                'side': side,
                'type': type,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'fee': undefined,
            });
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const response = await this.privateGetUsersTransactionsTrade ();
            //
            //     {
            //       "data": [
            //         {
            //           "price": "56000",
            //           "numeratorSymbol": "BTC",
            //           "denominatorSymbol": "USDT",
            //           "orderType": "buy",
            //           "orderId": "2606935102",
            //           "id": "320874372",
            //           "timestamp": "1618916479593",
            //           "amount": "0.00020000",
            //           "fee": "0",
            //           "tax": "0"
            //         }
            //       ],
            //       "success": true,
            //       "message": "SUCCESS",
            //       "code": "0"
            //     }
            //
            const data = this.safeValue (response, 'data');
            return this.parseTrades (data, market, since, limit);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            if (this.id === 'btctrader') {
                throw new ExchangeError (this.id + ' is an abstract base API for BTCExchange, BTCTurk');
            }
            let url = this.urls['api'][api] + '/' + path;
            if ((method === 'GET') || (method === 'DELETE')) {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                body = this.json (params);
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const secret = this.base64ToBinary (this.secret);
                const auth = this.apiKey + nonce;
                headers = {
                    'X-PCK': this.apiKey,
                    'X-Stamp': nonce,
                    'X-Signature': this.hmac (this.encode (auth), secret, 'sha256', 'base64'),
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            const errorCode = this.safeString (response, 'code', '0');
            const message = this.safeString (response, 'message');
            const output = (message === undefined) ? body : message;
            this.throwExactlyMatchedException (this.exceptions['exact'], message, this.id + ' ' + output);
            if (errorCode !== '0') {
                throw new ExchangeError (this.id + ' ' + output);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],54:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { AddressPending, AuthenticationError, ExchangeError, NotSupported, PermissionDenied, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class buda extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'buda',
                'name': 'Buda',
                'countries': [ 'AR', 'CL', 'CO', 'PE' ],
                'rateLimit': 1000,
                'version': 'v2',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchFundingFees': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': false,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTrades': true,
                    'fetchTicker': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/47380619-8a029200-d706-11e8-91e0-8a391fe48de3.jpg',
                    'api': 'https://www.buda.com/api',
                    'www': 'https://www.buda.com',
                    'doc': 'https://api.buda.com',
                    'fees': 'https://www.buda.com/comisiones',
                },
                'status': {
                    'status': 'error',
                    'updated': undefined,
                    'eta': undefined,
                    'url': undefined,
                },
                'api': {
                    'public': {
                        'get': [
                            'pairs',
                            'markets',
                            'currencies',
                            'markets/{market}',
                            'markets/{market}/ticker',
                            'markets/{market}/volume',
                            'markets/{market}/order_book',
                            'markets/{market}/trades',
                            'currencies/{currency}/fees/deposit',
                            'currencies/{currency}/fees/withdrawal',
                            'tv/history',
                        ],
                        'post': [
                            'markets/{market}/quotations',
                        ],
                    },
                    'private': {
                        'get': [
                            'balances',
                            'balances/{currency}',
                            'currencies/{currency}/balances',
                            'orders',
                            'orders/{id}',
                            'markets/{market}/orders',
                            'deposits',
                            'currencies/{currency}/deposits',
                            'withdrawals',
                            'currencies/{currency}/withdrawals',
                            'currencies/{currency}/receive_addresses',
                            'currencies/{currency}/receive_addresses/{id}',
                        ],
                        'post': [
                            'markets/{market}/orders',
                            'currencies/{currency}/deposits',
                            'currencies/{currency}/withdrawals',
                            'currencies/{currency}/simulated_withdrawals',
                            'currencies/{currency}/receive_addresses',
                        ],
                        'put': [
                            'orders/{id}',
                        ],
                    },
                },
                'timeframes': {
                    '1m': '1',
                    '5m': '5',
                    '30m': '30',
                    '1h': '60',
                    '2h': '120',
                    '1d': 'D',
                    '1w': 'W',
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': 0.008,  // 0.8%
                        'maker': 0.004,  // 0.4%
                        'tiers': {
                            'taker': [
                                [0, 0.008],  // 0.8%
                                [2000, 0.007],  // 0.7%
                                [20000, 0.006],  // 0.6%
                                [100000, 0.005],  // 0.5%
                                [500000, 0.004],  // 0.4%
                                [2500000, 0.003],  // 0.3%
                                [12500000, 0.002],  // 0.2%
                            ],
                            'maker': [
                                [0, 0.004],  // 0.4%
                                [2000, 0.0035],  // 0.35%
                                [20000, 0.003],  // 0.3%
                                [100000, 0.0025],  // 0.25%
                                [500000, 0.002],  // 0.2%
                                [2500000, 0.0015],  // 0.15%
                                [12500000, 0.001],  // 0.1%
                            ],
                        },
                    },
                },
                'exceptions': {
                    'not_authorized': AuthenticationError,  // { message: 'Invalid credentials', code: 'not_authorized' }
                    'forbidden': PermissionDenied,  // { message: 'You dont have access to this resource', code: 'forbidden' }
                    'invalid_record': ExchangeError,  // { message: 'Validation Failed', code: 'invalid_record', errors: [] }
                    'not_found': ExchangeError,  // { message: 'Not found', code: 'not_found' }
                    'parameter_missing': ExchangeError,  // { message: 'Parameter missing', code: 'parameter_missing' }
                    'bad_parameter': ExchangeError,  // { message: 'Bad Parameter format', code: 'bad_parameter' }
                },
            });
        }
    
        async fetchCurrencyInfo (currency, currencies = undefined) {
            if (!currencies) {
                const response = await this.publicGetCurrencies ();
                currencies = this.safeValue (response, 'currencies');
            }
            for (let i = 0; i < currencies.length; i++) {
                const currencyInfo = currencies[i];
                if (currencyInfo['id'] === currency) {
                    return currencyInfo;
                }
            }
            return undefined;
        }
    
        async fetchMarkets (params = {}) {
            const marketsResponse = await this.publicGetMarkets (params);
            const markets = this.safeValue (marketsResponse, 'markets');
            const currenciesResponse = await this.publicGetCurrencies ();
            const currencies = this.safeValue (currenciesResponse, 'currencies');
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'id');
                const baseId = this.safeString (market, 'base_currency');
                const quoteId = this.safeString (market, 'quote_currency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const baseInfo = await this.fetchCurrencyInfo (baseId, currencies);
                const quoteInfo = await this.fetchCurrencyInfo (quoteId, currencies);
                const symbol = base + '/' + quote;
                const pricePrecisionString = this.safeString (quoteInfo, 'input_decimals');
                const priceLimit = this.parsePrecision (pricePrecisionString);
                const precision = {
                    'amount': this.safeInteger (baseInfo, 'input_decimals'),
                    'price': parseInt (pricePrecisionString),
                };
                const minimumOrderAmount = this.safeValue (market, 'minimum_order_amount', []);
                const limits = {
                    'amount': {
                        'min': this.safeNumber (minimumOrderAmount, 0),
                        'max': undefined,
                    },
                    'price': {
                        'min': priceLimit,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies ();
            const currencies = response['currencies'];
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                if (!currency['managed']) {
                    continue;
                }
                const id = this.safeString (currency, 'id');
                const code = this.safeCurrencyCode (id);
                const precision = this.safeNumber (currency, 'input_decimals');
                const minimum = Math.pow (10, -precision);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'name': undefined,
                    'active': true,
                    'fee': undefined,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': minimum,
                            'max': undefined,
                        },
                        'deposit': {
                            'min': parseFloat (currency['deposit_minimum'][0]),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': parseFloat (currency['withdrawal_minimum'][0]),
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchFundingFees (codes = undefined, params = {}) {
            //  by default it will try load withdrawal fees of all currencies (with separate requests)
            //  however if you define codes = [ 'ETH', 'BTC' ] in args it will only load those
            await this.loadMarkets ();
            const withdrawFees = {};
            const depositFees = {};
            const info = {};
            if (codes === undefined) {
                codes = Object.keys (this.currencies);
            }
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const currency = this.currency (code);
                const request = { 'currency': currency['id'] };
                const withdrawResponse = await this.publicGetCurrenciesCurrencyFeesWithdrawal (request);
                const depositResponse = await this.publicGetCurrenciesCurrencyFeesDeposit (request);
                withdrawFees[code] = this.parseFundingFee (withdrawResponse['fee']);
                depositFees[code] = this.parseFundingFee (depositResponse['fee']);
                info[code] = {
                    'withdraw': withdrawResponse,
                    'deposit': depositResponse,
                };
            }
            return {
                'withdraw': withdrawFees,
                'deposit': depositFees,
                'info': info,
            };
        }
    
        parseFundingFee (fee, type = undefined) {
            if (type === undefined) {
                type = fee['name'];
            }
            if (type === 'withdrawal') {
                type = 'withdraw';
            }
            return {
                'type': type,
                'currency': fee['base'][1],
                'rate': fee['percent'],
                'cost': parseFloat (fee['base'][0]),
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetMarketsMarketTicker (this.extend (request, params));
            const ticker = this.safeValue (response, 'ticker');
            return this.parseTicker (ticker, market);
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.milliseconds ();
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const last = parseFloat (ticker['last_price'][0]);
            const percentage = parseFloat (ticker['price_variation_24h']);
            const open = parseFloat (this.priceToPrecision (symbol, last / (percentage + 1)));
            const change = last - open;
            const average = this.sum (last, open) / 2;
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': undefined,
                'low': undefined,
                'bid': parseFloat (ticker['max_bid'][0]),
                'bidVolume': undefined,
                'ask': parseFloat (ticker['min_ask'][0]),
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': open,
                'change': change,
                'percentage': percentage * 100,
                'average': average,
                'baseVolume': parseFloat (ticker['volume'][0]),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            // the since argument works backwards – returns trades up to the specified timestamp
            // therefore not implemented here
            // the method is still available for users to be able to traverse backwards in time
            // by using the timestamp from the first received trade upon each iteration
            if (limit !== undefined) {
                request['limit'] = limit; // 50 max
            }
            const response = await this.publicGetMarketsMarketTrades (this.extend (request, params));
            //
            //     { trades: {      market_id:   "ETH-BTC",
            //                      timestamp:    null,
            //                 last_timestamp:   "1536901277302",
            //                        entries: [ [ "1540077456791", "0.0063767", "0.03", "sell", 479842 ],
            //                                   [ "1539916642772", "0.01888263", "0.03019563", "sell", 479438 ],
            //                                   [ "1539834081787", "0.023718648", "0.031001", "sell", 479069 ],
            //                                   ... ]
            //
            return this.parseTrades (response['trades']['entries'], market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //  [ "1540077456791", "0.0063767", "0.03", "sell", 479842 ]
            //
            let timestamp = undefined;
            let side = undefined;
            const type = undefined;
            let priceString = undefined;
            let amountString = undefined;
            let id = undefined;
            const order = undefined;
            const fee = undefined;
            let symbol = undefined;
            if (market) {
                symbol = market['symbol'];
            }
            if (Array.isArray (trade)) {
                timestamp = this.safeInteger (trade, 0);
                priceString = this.safeString (trade, 1);
                amountString = this.safeString (trade, 2);
                side = this.safeString (trade, 3);
                id = this.safeString (trade, 4);
            }
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            return {
                'id': id,
                'order': order,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetMarketsMarketOrderBook (this.extend (request, params));
            const orderbook = this.safeValue (response, 'order_book');
            return this.parseOrderBook (orderbook, symbol);
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (since === undefined) {
                since = this.milliseconds () - 86400000;
            }
            const request = {
                'symbol': market['id'],
                'resolution': this.timeframes[timeframe],
                'from': since / 1000,
                'to': this.seconds (),
            };
            const response = await this.publicGetTvHistory (this.extend (request, params));
            return this.parseTradingViewOHLCV (response, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetBalances (params);
            const result = { 'info': response };
            const balances = this.safeValue (response, 'balances');
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'id');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance['available_amount'], 0);
                account['total'] = this.safeString (balance['amount'], 0);
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': parseInt (id),
            };
            const response = await this.privateGetOrdersId (this.extend (request, params));
            const order = this.safeValue (response, 'order');
            return this.parseOrder (order);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const request = {
                'market': market['id'],
                'per': limit,
            };
            const response = await this.privateGetMarketsMarketOrders (this.extend (request, params));
            const orders = this.safeValue (response, 'orders');
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'state': 'pending',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'state': 'traded',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            side = (side === 'buy') ? 'Bid' : 'Ask';
            const request = {
                'market': this.marketId (symbol),
                'price_type': type,
                'type': side,
                'amount': this.amountToPrecision (symbol, amount),
            };
            if (type === 'limit') {
                request['limit'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePostMarketsMarketOrders (this.extend (request, params));
            const order = this.safeValue (response, 'order');
            return this.parseOrder (order);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': parseInt (id),
                'state': 'canceling',
            };
            const response = await this.privatePutOrdersId (this.extend (request, params));
            const order = this.safeValue (response, 'order');
            return this.parseOrder (order);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'traded': 'closed',
                'received': 'open',
                'canceling': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         'id': 63679183,
            //         'uuid': 'f9697bee-627e-4175-983f-0d5a41963fec',
            //         'market_id': 'ETH-CLP',
            //         'account_id': 51590,
            //         'type': 'Ask',
            //         'state': 'received',
            //         'created_at': '2021-01-04T08:29:52.730Z',
            //         'fee_currency': 'CLP',
            //         'price_type': 'limit',
            //         'source': None,
            //         'limit': ['741000.0', 'CLP'],
            //         'amount': ['0.001', 'ETH'],
            //         'original_amount': ['0.001', 'ETH'],
            //         'traded_amount': ['0.0', 'ETH'],
            //         'total_exchanged': ['0.0', 'CLP'],
            //         'paid_fee': ['0.0', 'CLP']
            //     }
            //
            const id = this.safeString (order, 'id');
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const marketId = this.safeString (order, 'market_id');
            const symbol = this.safeSymbol (marketId, market, '-');
            const type = this.safeString (order, 'price_type');
            const side = this.safeStringLower (order, 'type');
            const status = this.parseOrderStatus (this.safeString (order, 'state'));
            const originalAmount = this.safeValue (order, 'original_amount', []);
            const amount = this.safeNumber (originalAmount, 0);
            const remainingAmount = this.safeValue (order, 'amount', []);
            const remaining = this.safeNumber (remainingAmount, 0);
            const tradedAmount = this.safeValue (order, 'traded_amount', []);
            const filled = this.safeNumber (tradedAmount, 0);
            const totalExchanged = this.safeValue (order, 'totalExchanged', []);
            const cost = this.safeNumber (totalExchanged, 0);
            const limitPrice = this.safeValue (order, 'limit', []);
            let price = this.safeNumber (limitPrice, 0);
            if (price === undefined) {
                if (limitPrice !== undefined) {
                    price = limitPrice;
                }
            }
            const paidFee = this.safeValue (order, 'paid_fee', []);
            const feeCost = this.safeNumber (paidFee, 0);
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (paidFee, 1);
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'code': feeCurrencyCode,
                };
            }
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'average': undefined,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'trades': undefined,
                'fee': fee,
            });
        }
    
        isFiat (code) {
            const fiats = {
                'ARS': true,
                'CLP': true,
                'COP': true,
                'PEN': true,
            };
            return this.safeValue (fiats, code, false);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            if (this.isFiat (code)) {
                throw new NotSupported (this.id + ' fetchDepositAddress() for fiat ' + code + ' is not supported');
            }
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetCurrenciesCurrencyReceiveAddresses (this.extend (request, params));
            const receiveAddresses = this.safeValue (response, 'receive_addresses');
            const addressPool = [];
            for (let i = 1; i < receiveAddresses.length; i++) {
                const receiveAddress = receiveAddresses[i];
                if (receiveAddress['ready']) {
                    const address = receiveAddress['address'];
                    this.checkAddress (address);
                    addressPool.push (address);
                }
            }
            const addressPoolLength = addressPool.length;
            if (addressPoolLength < 1) {
                throw new AddressPending (this.id + ': there are no addresses ready for receiving ' + code + ', retry again later)');
            }
            const address = addressPool[0];
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': receiveAddresses,
            };
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            if (this.isFiat (code)) {
                throw new NotSupported (this.id + ': fiat fetchDepositAddress() for ' + code + ' is not supported');
            }
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privatePostCurrenciesCurrencyReceiveAddresses (this.extend (request, params));
            const address = this.safeString (response['receive_address'], 'address');  // the creation is async and returns a null address, returns only the id
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': response,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'rejected': 'failed',
                'confirmed': 'ok',
                'anulled': 'canceled',
                'retained': 'canceled',
                'pending_confirmation': 'pending',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            const id = this.safeString (transaction, 'id');
            const timestamp = this.parse8601 (this.safeString (transaction, 'created_at'));
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const amount = parseFloat (transaction['amount'][0]);
            const fee = parseFloat (transaction['fee'][0]);
            const feeCurrency = transaction['fee'][1];
            const status = this.parseTransactionStatus (this.safeString (transaction, 'state'));
            const type = ('deposit_data' in transaction) ? 'deposit' : 'withdrawal';
            const data = this.safeValue (transaction, type + '_data', {});
            const address = this.safeValue (data, 'target_address');
            const txid = this.safeString (data, 'tx_hash');
            const updated = this.parse8601 (this.safeString (data, 'updated_at'));
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': {
                    'cost': fee,
                    'rate': feeCurrency,
                },
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ': fetchDeposits() requires a currency code argument');
            }
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'per': limit,
            };
            const response = await this.privateGetCurrenciesCurrencyDeposits (this.extend (request, params));
            const deposits = this.safeValue (response, 'deposits');
            return this.parseTransactions (deposits, currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ': fetchDeposits() requires a currency code argument');
            }
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'per': limit,
            };
            const response = await this.privateGetCurrenciesCurrencyWithdrawals (this.extend (request, params));
            const withdrawals = this.safeValue (response, 'withdrawals');
            return this.parseTransactions (withdrawals, currency, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'amount': amount,
                'withdrawal_data': {
                    'target_address': address,
                },
            };
            const response = await this.privatePostCurrenciesCurrencyWithdrawals (this.extend (request, params));
            const withdrawal = this.safeValue (response, 'withdrawal');
            return this.parseTransaction (withdrawal);
        }
    
        nonce () {
            return this.microseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (Object.keys (query).length) {
                if (method === 'GET') {
                    request += '?' + this.urlencode (query);
                } else {
                    body = this.json (query);
                }
            }
            const url = this.urls['api'] + '/' + this.version + '/' + request;
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const components = [ method, '/api/' + this.version + '/' + request ];
                if (body) {
                    const base64Body = this.stringToBase64 (body);
                    components.push (this.decode (base64Body));
                }
                components.push (nonce);
                const message = components.join (' ');
                const signature = this.hmac (this.encode (message), this.encode (this.secret), 'sha384');
                headers = {
                    'X-SBTC-APIKEY': this.apiKey,
                    'X-SBTC-SIGNATURE': signature,
                    'X-SBTC-NONCE': nonce,
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if (code >= 400) {
                const errorCode = this.safeString (response, 'code');
                const message = this.safeString (response, 'message', body);
                const feedback = this.id + ' ' + message;
                if (errorCode !== undefined) {
                    this.throwExactlyMatchedException (this.exceptions, errorCode, feedback);
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],55:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { RateLimitExceeded, BadSymbol, OrderNotFound, ExchangeError, AuthenticationError, ArgumentsRequired, ExchangeNotAvailable } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bw extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bw',
                'name': 'BW',
                'countries': [ 'CN' ],
                'rateLimit': 1500,
                'version': 'v1',
                'has': {
                    'cancelAllOrders': false,
                    'cancelOrder': true,
                    'cancelOrders': false,
                    'CORS': false,
                    'createDepositAddress': false,
                    'createLimitOrder': true,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'deposit': false,
                    'editOrder': false,
                    'fetchBalance': true,
                    'fetchBidsAsks': false,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchFundingFees': false,
                    'fetchL2OrderBook': false,
                    'fetchLedger': false,
                    'fetchMarkets': true,
                    'fetchMyTrades': false,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrderBooks': false,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTradingFee': false,
                    'fetchTradingFees': false,
                    'fetchTradingLimits': false,
                    'fetchTransactions': false,
                    'fetchWithdrawals': true,
                    'privateAPI': false,
                    'publicAPI': false,
                    'withdraw': false,
                },
                'timeframes': {
                    '1m': '1M',
                    '5m': '5M',
                    '15m': '15M',
                    '30m': '30M',
                    '1h': '1H',
                    '1w': '1W',
                },
                'hostname': 'bw.com', // set to 'bw.io' for China mainland
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/69436317-31128c80-0d52-11ea-91d1-eb7bb5818812.jpg',
                    'api': 'https://www.{hostname}',
                    'www': 'https://www.bw.com',
                    'doc': 'https://github.com/bw-exchange/api_docs_en/wiki',
                    'fees': 'https://www.bw.com/feesRate',
                    'referral': 'https://www.bw.com/regGetCommission/N3JuT1R3bWxKTE0',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'taker': this.parseNumber ('0.002'),
                        'maker': this.parseNumber ('0.002'),
                    },
                    'funding': {
                    },
                },
                'exceptions': {
                    'exact': {
                        '999': AuthenticationError,
                        '1000': ExchangeNotAvailable, // {"datas":null,"resMsg":{"message":"getKlines error:data not exitsts\uff0cplease wait ,dataType=4002_KLINE_1M","method":null,"code":"1000"}}
                        '2012': OrderNotFound, // {"datas":null,"resMsg":{"message":"entrust not exists or on dealing with system","method":null,"code":"2012"}}
                        '5017': BadSymbol, // {"datas":null,"resMsg":{"message":"market not exist","method":null,"code":"5017"}}
                        '10001': RateLimitExceeded, // {"resMsg":{"code":"10001","message":"API frequency limit"}}
                    },
                },
                'api': {
                    'public': {
                        'get': [
                            'api/data/v1/klines',
                            'api/data/v1/ticker',
                            'api/data/v1/tickers',
                            'api/data/v1/trades',
                            'api/data/v1/entrusts',
                            'exchange/config/controller/website/marketcontroller/getByWebId',
                            'exchange/config/controller/website/currencycontroller/getCurrencyList',
                        ],
                    },
                    'private': {
                        'get': [
                            'exchange/entrust/controller/website/EntrustController/getEntrustById',
                            'exchange/entrust/controller/website/EntrustController/getUserEntrustRecordFromCacheWithPage',
                            'exchange/entrust/controller/website/EntrustController/getUserEntrustList',
                            'exchange/fund/controller/website/fundwebsitecontroller/getwithdrawaddress',
                            'exchange/fund/controller/website/fundwebsitecontroller/getpayoutcoinrecord',
                            'exchange/entrust/controller/website/EntrustController/getUserEntrustList',
                            // the docs say that the following URLs are HTTP POST
                            // in the docs header and HTTP GET in the docs body
                            // the docs contradict themselves, a typo most likely
                            // the actual HTTP method is POST for this endpoint
                            // 'exchange/fund/controller/website/fundcontroller/getPayinAddress',
                            // 'exchange/fund/controller/website/fundcontroller/getPayinCoinRecord',
                        ],
                        'post': [
                            'exchange/fund/controller/website/fundcontroller/getPayinAddress', // see the comment above
                            'exchange/fund/controller/website/fundcontroller/getPayinCoinRecord', // see the comment above
                            'exchange/fund/controller/website/fundcontroller/findbypage',
                            'exchange/entrust/controller/website/EntrustController/addEntrust',
                            'exchange/entrust/controller/website/EntrustController/cancelEntrust',
                        ],
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetExchangeConfigControllerWebsiteMarketcontrollerGetByWebId (params);
            //
            //     {
            //         "datas": [
            //             {
            //                 "orderNum":null,
            //                 "leverEnable":true,
            //                 "leverMultiple":10,
            //                 "marketId":"291",
            //                 "webId":"102",
            //                 "serverId":"entrust_bw_23",
            //                 "name":"eos_usdt",
            //                 "leverType":"2",
            //                 "buyerCurrencyId":"11",
            //                 "sellerCurrencyId":"7",
            //                 "amountDecimal":4,
            //                 "priceDecimal":3,
            //                 "minAmount":"0.0100000000",
            //                 "state":1,
            //                 "openTime":1572537600000,
            //                 "defaultFee":"0.00200000",
            //                 "createUid":null,
            //                 "createTime":0,
            //                 "modifyUid":null,
            //                 "modifyTime":1574160113735,
            //                 "combineMarketId":"",
            //                 "isCombine":0,
            //                 "isMining":0
            //             }
            //         ],
            //         "resMsg": { "message":"success !", "method":null, "code":"1" }
            //     }
            //
            const markets = this.safeValue (response, 'datas', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'marketId');
                const numericId = parseInt (id);
                const name = this.safeStringUpper (market, 'name');
                let [ base, quote ] = name.split ('_');
                base = this.safeCurrencyCode (base);
                quote = this.safeCurrencyCode (quote);
                const baseId = this.safeString (market, 'sellerCurrencyId');
                const quoteId = this.safeString (market, 'buyerCurrencyId');
                const baseNumericId = parseInt (baseId);
                const quoteNumericId = parseInt (quoteId);
                const symbol = base + '/' + quote;
                const state = this.safeInteger (market, 'state');
                const active = (state === 1);
                const fee = this.safeNumber (market, 'defaultFee');
                result.push ({
                    'id': id,
                    'active': active,
                    'numericId': numericId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'baseNumericId': baseNumericId,
                    'quoteNumericId': quoteNumericId,
                    'maker': fee,
                    'taker': fee,
                    'info': market,
                    'precision': {
                        'amount': this.safeInteger (market, 'amountDecimal'),
                        'price': this.safeInteger (market, 'priceDecimal'),
                    },
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'minAmount'),
                            'max': undefined,
                        },
                        'price': {
                            'min': 0,
                            'max': undefined,
                        },
                        'cost': {
                            'min': 0,
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetExchangeConfigControllerWebsiteCurrencycontrollerGetCurrencyList (params);
            //
            //     {
            //         "datas":[
            //             {
            //                 "currencyId":"456",
            //                 "name":"pan",
            //                 "alias":"pan",
            //                 "logo":"pan.svg",
            //                 "description":"pan",
            //                 "descriptionEnglish":"pan",
            //                 "defaultDecimal":2,
            //                 "createUid":null,
            //                 "createTime":1574068133762,
            //                 "modifyUid":null,
            //                 "modifyTime":0,
            //                 "state":1,
            //                 "mark":"pan",
            //                 "totalNumber":"0",
            //                 "publishNumber":"0",
            //                 "marketValue":"0",
            //                 "isLegalCoin":0,
            //                 "needBlockUrl":1,
            //                 "blockChainUrl":"https://etherscan.io/tx/",
            //                 "tradeSearchUrl":null,
            //                 "tokenCoinsId":0,
            //                 "isMining":"0",
            //                 "arithmetic":null,
            //                 "founder":"bw_nxwal",
            //                 "teamAddress":null,
            //                 "remark":null,
            //                 "tokenName":"ethw2",
            //                 "isMemo":0,
            //                 "websiteCurrencyId":"7rhqoHLohkG",
            //                 "drawFlag":0,
            //                 "rechargeFlag":1,
            //                 "drawFee":"0.03000000",
            //                 "onceDrawLimit":100,
            //                 "dailyDrawLimit":500,
            //                 "timesFreetrial":"0",
            //                 "hourFreetrial":"0",
            //                 "dayFreetrial":"0",
            //                 "minFee":"0",
            //                 "inConfigTimes":7,
            //                 "outConfigTimes":7,
            //                 "minCash":"0.06000000",
            //                 "limitAmount":"0",
            //                 "zbExist":false,
            //                 "zone":1
            //             },
            //         ],
            //         "resMsg": { "message":"success !", "method":null, "code":"1" }
            //     }
            //
            const currencies = this.safeValue (response, 'datas', []);
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                const id = this.safeString (currency, 'currencyId');
                const code = this.safeCurrencyCode (this.safeStringUpper (currency, 'name'));
                const state = this.safeInteger (currency, 'state');
                const active = state === 1;
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'name': code,
                    'active': active,
                    'fee': this.safeNumber (currency, 'drawFee'),
                    'precision': undefined,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (currency, 'limitAmount', 0),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': this.safeNumber (currency, 'onceDrawLimit'),
                        },
                    },
                };
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     [
            //         "281",            // market id
            //         "9754.4",         // last
            //         "9968.8",         // high
            //         "9631.5",         // low
            //         "47865.6432",     // base volume
            //         "-2.28",          // change
            //         // closing price for last 6 hours
            //         "[[1, 9750.1], [2, 9737.1], [3, 9727.5], [4, 9722], [5, 9722.1], [6, 9754.4]]",
            //         "9752.12",        // bid
            //         "9756.69",        // ask
            //         "469849357.2364"  // quote volume
            //     ]
            //
            const marketId = this.safeString (ticker, 0);
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.milliseconds ();
            const close = this.safeNumber (ticker, 1);
            const bid = this.safeValue (ticker, 'bid', {});
            const ask = this.safeValue (ticker, 'ask', {});
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 2),
                'low': this.safeNumber (ticker, 3),
                'bid': this.safeNumber (ticker, 7),
                'bidVolume': this.safeNumber (bid, 'quantity'),
                'ask': this.safeNumber (ticker, 8),
                'askVolume': this.safeNumber (ask, 'quantity'),
                'vwap': undefined,
                'open': undefined,
                'close': close,
                'last': close,
                'previousClose': undefined,
                'change': this.safeNumber (ticker, 5),
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 4),
                'quoteVolume': this.safeNumber (ticker, 9),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
            };
            const response = await this.publicGetApiDataV1Ticker (this.extend (request, params));
            //
            //     {
            //         "datas": [
            //             "281",
            //             "7601.99",
            //             "8126.5",
            //             "7474.68",
            //             "47004.8708",
            //             "-6.18",
            //             "[[1, 7800.34], [2, 7626.41], [3, 7609.97], [4, 7569.04], [5, 7577.93], [6, 7601.99]]",
            //             "7600.24",
            //             "7603.69",
            //             "371968300.0119",
            //         ],
            //         "resMsg": { "message": "success !", "method": null, "code": "1" }
            //     }
            //
            const ticker = this.safeValue (response, 'datas', []);
            return this.parseTicker (ticker, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetApiDataV1Tickers (params);
            //
            //     {
            //         "datas": [
            //             [
            //                 "4051",
            //                 "0.00194",
            //                 "0.00863",
            //                 "0.0012",
            //                 "1519020",
            //                 "-38.22",
            //                 "[[1, 0.0023], [2, 0.00198], [3, 0.00199], [4, 0.00195], [5, 0.00199], [6, 0.00194]]",
            //                 "0.00123",
            //                 "0.0045",
            //                 "4466.8104",
            //             ],
            //         ],
            //         "resMsg": { "message": "success !", "method": null, "code": "1" },
            //     }
            //
            const datas = this.safeValue (response, 'datas', []);
            const result = {};
            for (let i = 0; i < datas.length; i++) {
                const ticker = this.parseTicker (datas[i]);
                const symbol = ticker['symbol'];
                if ((symbols === undefined) || this.inArray (symbol, symbols)) {
                    result[symbol] = ticker;
                }
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
            };
            if (limit !== undefined) {
                request['dataSize'] = limit;
            }
            const response = await this.publicGetApiDataV1Entrusts (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "asks": [
            //                 [ "9740.43", "0.0083" ],
            //             ],
            //             "bids": [
            //                 [ "9734.33", "0.0133" ],
            //             ],
            //             "timestamp": "1569303520",
            //         },
            //         "resMsg": {
            //             "message": "success !",
            //             "method": null,
            //             "code": "1",
            //         },
            //     }
            //
            const orderbook = this.safeValue (response, 'datas', []);
            const timestamp = this.safeTimestamp (orderbook, 'timestamp');
            return this.parseOrderBook (orderbook, symbol, timestamp);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     [
            //         "T",          // trade
            //         "281",        // market id
            //         "1569303302", // timestamp
            //         "BTC_USDT",   // market name
            //         "ask",        // side
            //         "9745.08",    // price
            //         "0.0026"      // amount
            //     ]
            //
            // fetchMyTrades (private)
            //
            //     ...
            //
            const timestamp = this.safeTimestamp (trade, 2);
            const priceString = this.safeString (trade, 5);
            const amountString = this.safeString (trade, 6);
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const marketId = this.safeString (trade, 1);
            let symbol = undefined;
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const marketName = this.safeString (trade, 3);
                    const [ baseId, quoteId ] = marketName.split ('_');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const sideString = this.safeString (trade, 4);
            const side = (sideString === 'ask') ? 'sell' : 'buy';
            return {
                'id': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': undefined,
                'type': 'limit',
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
                'info': trade,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
            };
            if (limit !== undefined) {
                request['dataSize'] = limit; // max 20
            }
            const response = await this.publicGetApiDataV1Trades (this.extend (request, params));
            //
            //     {
            //         "datas": [
            //             [
            //                 "T",          // trade
            //                 "281",        // market id
            //                 "1569303302", // timestamp
            //                 "BTC_USDT",   // market name
            //                 "ask",        // side
            //                 "9745.08",    // price
            //                 "0.0026"      // amount
            //             ],
            //         ],
            //         "resMsg": { "code": "1", "method": null, "message": "success !" },
            //     }
            //
            const trades = this.safeValue (response, 'datas', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         "K",
            //         "305",
            //         "eth_btc",
            //         "1591511280",
            //         "0.02504",
            //         "0.02504",
            //         "0.02504",
            //         "0.02504",
            //         "0.0123",
            //         "0",
            //         "285740.17",
            //         "1M",
            //         "false",
            //         "0.000308"
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
                this.safeNumber (ohlcv, 6),
                this.safeNumber (ohlcv, 7),
                this.safeNumber (ohlcv, 8),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
                'type': this.timeframes[timeframe],
                'dataSize': 500,
            };
            if (limit !== undefined) {
                request['dataSize'] = limit;
            }
            const response = await this.publicGetApiDataV1Klines (this.extend (request, params));
            //
            //     {
            //         "datas":[
            //             ["K","305","eth_btc","1591511280","0.02504","0.02504","0.02504","0.02504","0.0123","0","285740.17","1M","false","0.000308"],
            //             ["K","305","eth_btc","1591511220","0.02504","0.02504","0.02504","0.02504","0.0006","0","285740.17","1M","false","0.00001502"],
            //             ["K","305","eth_btc","1591511100","0.02505","0.02505","0.02504","0.02504","0.0012","-0.0399","285740.17","1M","false","0.00003005"],
            //         ],
            //         "resMsg":{"code":"1","method":null,"message":"success !"}
            //     }
            //
            const data = this.safeValue (response, 'datas', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostExchangeFundControllerWebsiteFundcontrollerFindbypage (params);
            //
            //     {
            //         "datas": {
            //             "totalRow": 6,
            //             "pageSize": 99,
            //             "list": [
            //                 {
            //                     "amount": "0.000090000000000000", // The current number of tokens available
            //                     "currencyTypeId": 2,              // Token ID
            //                     "freeze": "0.009900000000000000", // Current token freezing quantity
            //                 },
            //             ],
            //             "pageNum": 1,
            //         },
            //         "resMsg": { "code": "1", "message": "success !" }
            //     }
            //
            const data = this.safeValue (response, 'datas', {});
            const balances = this.safeValue (data, 'list', []);
            const result = { 'info': response };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currencyTypeId');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'amount');
                account['used'] = this.safeString (balance, 'freeze');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            if (price === undefined) {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'amount': this.amountToPrecision (symbol, amount),
                'price': this.priceToPrecision (symbol, price),
                'type': (side === 'buy') ? 1 : 0,
                'rangeType': 0, // limit order
                'marketId': market['id'],
            };
            const response = await this.privatePostExchangeEntrustControllerWebsiteEntrustControllerAddEntrust (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "entrustId": "E6581105708337483776",
            //         },
            //         "resMsg": {
            //             "message": "success !",
            //             "method": null,
            //             "code": "1"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'datas');
            const id = this.safeString (data, 'entrustId');
            return {
                'id': id,
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': undefined,
                'average': undefined,
                'filled': undefined,
                'remaining': undefined,
                'status': 'open',
                'fee': undefined,
                'trades': undefined,
                'clientOrderId': undefined,
            };
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '-3': 'canceled',
                '-2': 'canceled',
                '-1': 'canceled',
                '0': 'open',
                '1': 'canceled',
                '2': 'closed',
                '3': 'open',
                '4': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // fetchOrder, fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "entrustId": "E6581108027628212224", // Order id
            //         "price": "1450",                     // price
            //         "rangeType": 0,                      // Commission type 0: limit price commission 1: interval commission
            //         "amount": "14.05",                   // Order quantity
            //         "totalMoney": "20372.50",            // Total order amount
            //         "completeAmount": "0",               // Quantity sold
            //         "completeTotalMoney": "0",           // Total dealt amount
            //         "type": 1,                           // 0 = sell, 1 = buy, -1 = cancel
            //         "entrustType": 0,                    // 0 = ordinary current price commission, 1 = lever commission
            //         "status": 0,                         //
            //         "marketId": "318",                   // The market id
            //         "createTime": 1569058424861,         // Create time
            //         "availabelAmount": "14.05"           // Outstanding quantity, typo in the docs or in the API, availabel vs available
            //     }
            //
            const marketId = this.safeString (order, 'marketId');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.safeInteger (order, 'createTime');
            let side = this.safeString (order, 'type');
            if (side === '0') {
                side = 'sell';
            } else if (side === '1') {
                side = 'buy';
            }
            const amount = this.safeNumber (order, 'amount');
            const price = this.safeNumber (order, 'price');
            const filled = this.safeNumber (order, 'completeAmount');
            const remaining = this.safeNumber2 (order, 'availabelAmount', 'availableAmount'); // typo in the docs or in the API, availabel vs available
            const cost = this.safeNumber (order, 'totalMoney');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            return this.safeOrder ({
                'info': order,
                'id': this.safeString (order, 'entrustId'),
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': cost,
                'average': undefined,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
                'entrustId': id,
            };
            const response = await this.privateGetExchangeEntrustControllerWebsiteEntrustControllerGetEntrustById (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "entrustId": "E6581108027628212224", // Order id
            //             "price": "1450",                     // price
            //             "rangeType": 0,                      // Commission type 0: limit price commission 1: interval commission
            //             "amount": "14.05",                   // Order quantity
            //             "totalMoney": "20372.50",            // Total order amount
            //             "completeAmount": "0",               // Quantity sold
            //             "completeTotalMoney": "0",           // Total dealt amount
            //             "type": 1,                           // Trade direction, 0: sell, 1: buy, -1: cancel
            //             "entrustType": 0,                    // Commission type, 0: ordinary current price commission, 1: lever commission
            //             "status": 0,                         // Order status,-3:fund Freeze exception,Order status to be confirmed  -2: fund freeze failure, order failure, -1: insufficient funds, order failure, 0: pending order, 1: cancelled, 2: dealt, 3: partially dealt
            //             "marketId": "318",                   // The market id
            //             "createTime": 1569058424861,         // Create time
            //             "availabelAmount": "14.05"           // Outstanding quantity
            //         },
            //         "resMsg": { "message": "success !", "method": null, "code": "1" }
            //     }
            //
            const order = this.safeValue (response, 'datas', {});
            return this.parseOrder (order, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
                'entrustId': id,
            };
            const response = await this.privatePostExchangeEntrustControllerWebsiteEntrustControllerCancelEntrust (this.extend (request, params));
            //
            //     {
            //         "datas": null,
            //         "resMsg": { "message": "success !", "method": null, "code": "1" }
            //     }
            //
            return {
                'info': response,
                'id': id,
            };
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
                // 'pageSize': limit, // documented as required, but it works without it
                // 'pageIndex': 0, // also works without it, most likely a typo in the docs
            };
            if (limit !== undefined) {
                request['pageSize'] = limit; // default limit is 20
            }
            const response = await this.privateGetExchangeEntrustControllerWebsiteEntrustControllerGetUserEntrustRecordFromCacheWithPage (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "pageNum": 1,
            //             "pageSize": 2,
            //             "totalPage": 20,
            //             "totalRow": 40,
            //             "entrustList": [
            //                 {
            //                     "amount": "14.050000000000000000",        // Order quantity
            //                     "rangeType": 0,                           // Commission type 0: limit price commission 1: interval commission
            //                     "totalMoney": "20372.500000000000000000", // Total order amount
            //                     "entrustId": "E6581108027628212224",      // Order id
            //                     "type": 1,                                // Trade direction, 0: sell, 1: buy, -1: cancel
            //                     "completeAmount": "0",                    // Quantity sold
            //                     "marketId": "318",                        // The market id
            //                     "createTime": 1569058424861,              // Create time
            //                     "price": "1450.000000000",                // price
            //                     "completeTotalMoney": "0",                // Quantity sold
            //                     "entrustType": 0,                         // Commission type, 0: ordinary current price commission, 1: lever commission
            //                     "status": 0                               // Order status,-3:fund Freeze exception,Order status to be confirmed  -2: fund freeze failure, order failure, -1: insufficient funds, order failure, 0: pending order, 1: cancelled, 2: dealt, 3: partially dealt
            //                 },
            //             ],
            //         },
            //         "resMsg": { "message": "success !", "method": null, "code": "1" },
            //     }
            //
            const data = this.safeValue (response, 'datas', {});
            const orders = this.safeValue (data, 'entrustList', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchClosedOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
            };
            if (limit !== undefined) {
                request['pageSize'] = limit; // default limit is 20
            }
            if (since !== undefined) {
                request['startDateTime'] = since;
            }
            const response = await this.privateGetExchangeEntrustControllerWebsiteEntrustControllerGetUserEntrustList (this.extend (request, params));
            const data = this.safeValue (response, 'datas', {});
            const orders = this.safeValue (data, 'entrustList', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'marketId': market['id'],
                // 'pageSize': limit, // documented as required, but it works without it
                // 'pageIndex': 0, // also works without it, most likely a typo in the docs
                // 'type': 0, // 0 = sell, 1 = buy, -1 = cancel
                // 'status': -1, // -1 = insufficient funds, failed orders, 0 = pending orders, 1 = canceled, 2 = closed, 3 = partial
                // 'startDateTime': since,
                // 'endDateTime': this.milliseconds (),
            };
            if (since !== undefined) {
                request['startDateTime'] = since;
            }
            if (limit !== undefined) {
                request['pageSize'] = limit; // default limit is 20
            }
            const response = await this.privateGetExchangeEntrustControllerWebsiteEntrustControllerGetUserEntrustList (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "pageNum": 1,
            //             "pageSize": 2,
            //             "totalPage": 20,
            //             "totalRow": 40,
            //             "entrustList": [
            //                 {
            //                     "amount": "14.050000000000000000",        // Order quantity
            //                     "rangeType": 0,                           // Commission type 0: limit price commission 1: interval commission
            //                     "totalMoney": "20372.500000000000000000", // Total order amount
            //                     "entrustId": "E6581108027628212224",      // Order id
            //                     "type": 1,                                // Trade direction, 0: sell, 1: buy, -1: cancel
            //                     "completeAmount": "0",                    // Quantity sold
            //                     "marketId": "318",                        // The market id
            //                     "createTime": 1569058424861,              // Create time
            //                     "price": "1450.000000000",                // price
            //                     "completeTotalMoney": "0",                // Quantity sold
            //                     "entrustType": 0,                         // Commission type, 0: ordinary current price commission, 1: lever commission
            //                     "status": 0                               // Order status,-3:fund Freeze exception,Order status to be confirmed  -2: fund freeze failure, order failure, -1: insufficient funds, order failure, 0: pending order, 1: cancelled, 2: dealt, 3: partially dealt
            //                 },
            //             ],
            //         },
            //         "resMsg": { "message": "success !", "method": null, "code": "1" },
            //     }
            //
            const data = this.safeValue (response, 'datas', {});
            const orders = this.safeValue (data, 'entrustList', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.implodeHostname (this.urls['api']) + '/' + path;
            if (method === 'GET') {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                body = this.json (params);
            }
            if (api === 'private') {
                const ms = this.milliseconds ().toString ();
                let content = '';
                if (method === 'GET') {
                    const sortedParams = this.keysort (params);
                    const keys = Object.keys (sortedParams);
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        content += key + sortedParams[key].toString ();
                    }
                } else {
                    content = body;
                }
                const signature = this.apiKey + ms + content + this.secret;
                const hash = this.hash (this.encode (signature), 'md5');
                if (!headers) {
                    headers = {};
                }
                headers['Apiid'] = this.apiKey;
                headers['Timestamp'] = ms;
                headers['Sign'] = hash;
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currencyTypeName': currency['name'],
            };
            const response = await this.privatePostExchangeFundControllerWebsiteFundcontrollerGetPayinAddress (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "isMemo": true,                                // 是否为memo 格式，false：否，true ：是
            //             "address": "bweosdeposit_787928102918558272",  // 充币地址
            //             "memo": "787928102918558272",                  // 币种memo
            //             "account": "bweosdeposit"                      // 币种账户
            //         },
            //         "resMsg": { "message": "success !", "method": null, "code": "1" }
            //     }
            //
            const data = this.safeValue (response, 'datas', {});
            const address = this.safeString (data, 'address');
            const tag = this.safeString (data, 'memo');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': this.checkAddress (address),
                'tag': tag,
                'info': response,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                '-1': 'canceled', // or auditing failed
                '0': 'pending',
                '1': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         "depositId": "D6574268549744189441",                  // Deposit ID
            //         "amount": "54.753589700000000000",                    // Deposit amount
            //         "txId": "INNER_SYSTEM_TRANSFER_1198941",              // Trading ID
            //         "confirmTimes": 0,                                    // Confirmation number
            //         "depositAddress": "bweosdeposit_787928102918558272",  // Deposit address
            //         "createTime": "2019-09-02 20:36:08.0",                // Deposit time
            //         "status": 1,                                          // Deposit status, 0: not received, 1: received
            //         "currencyTypeId": 7,                                  // Token ID
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         "withdrawalId": "W6527498439872634880",      // Withdrawal ID
            //         "fees": "0.500000000000000000",              // Withdrawal fee
            //         "withdrawalAddress": "okbtothemoon_941657",  // Withdrawal address
            //         "currencyId": "7",                           // Token ID
            //         "amount": "10.000000000000000000",           // Withdrawal amount
            //         "state": 1,                                  // Status, 1: normal, -1: delete
            //         "verifyStatus": 1,                           // Audit status, 0: to be audited, 1: auditing passed, -1: auditing failed
            //         "createTime": 1556276903656,                 // WIthdrawal time
            //         "actuallyAmount": "9.500000000000000000",    // Actual amount received
            //     }
            //
            const id = this.safeString (transaction, 'depositId', 'withdrawalId');
            const address = this.safeString2 (transaction, 'depositAddress', 'withdrawalAddress');
            const currencyId = this.safeString2 (transaction, 'currencyId', 'currencyTypeId');
            let code = undefined;
            if (currencyId in this.currencies_by_id) {
                currency = this.currencies_by_id[currencyId];
            }
            if ((code === undefined) && (currency !== undefined)) {
                code = currency['code'];
            }
            const type = ('depositId' in transaction) ? 'deposit' : 'withdrawal';
            const amount = this.safeNumber2 (transaction, 'actuallyAmount', 'amount');
            const status = this.parseTransactionStatus (this.safeString2 (transaction, 'verifyStatus', 'state'));
            const timestamp = this.safeInteger (transaction, 'createTime');
            const txid = this.safeString (transaction, 'txId');
            let fee = undefined;
            const feeCost = this.safeNumber (transaction, 'fees');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': code,
                };
            }
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': undefined,
                'address': address,
                'addressTo': undefined,
                'tagFrom': undefined,
                'tag': undefined,
                'tagTo': undefined,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': fee,
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchDeposits() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currencyTypeName': currency['name'],
                // 'pageSize': limit, // documented as required, but it works without it
                // 'pageNum': 0, // also works without it, most likely a typo in the docs
                // 'sort': 1, // 1 = asc, 0 = desc
            };
            if (limit !== undefined) {
                request['pageSize'] = limit; // default 50
            }
            const response = await this.privatePostExchangeFundControllerWebsiteFundcontrollerGetPayinCoinRecord (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "totalRow":2,
            //             "totalPage": 1,
            //             "pageSize": 2,
            //             "pageNum": 1,
            //             "list": [
            //                 {
            //                     "depositId": "D6574268549744189441",                  // Deposit ID
            //                     "amount": "54.753589700000000000",                    // Deposit amount
            //                     "txId": "INNER_SYSTEM_TRANSFER_1198941",              // Trading ID
            //                     "confirmTimes": 0,                                    // Confirmation number
            //                     "depositAddress": "bweosdeposit_787928102918558272",  // Deposit address
            //                     "createTime": "2019-09-02 20:36:08.0",                // Deposit time
            //                     "status": 1,                                          // Deposit status, 0: not received, 1: received
            //                     "currencyTypeId": 7,                                  // Token ID
            //                 },
            //             ]
            //         },
            //         "resMsg": { "message": "success !", "method": null, "code": "1" },
            //     }
            //
            const data = this.safeValue (response, 'datas', {});
            const deposits = this.safeValue (data, 'list', []);
            return this.parseTransactions (deposits, code, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchWithdrawals() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currencyId': currency['id'],
                // 'pageSize': limit, // documented as required, but it works without it
                // 'pageIndex': 0, // also works without it, most likely a typo in the docs
                // 'tab': 'all', // all, wait (submitted, not audited), success (auditing passed), fail (auditing failed), cancel (canceled by user)
            };
            if (limit !== undefined) {
                request['pageSize'] = limit; // default 50
            }
            const response = await this.privateGetExchangeFundControllerWebsiteFundwebsitecontrollerGetpayoutcoinrecord (this.extend (request, params));
            //
            //     {
            //         "datas": {
            //             "totalRow": 1,
            //             "totalPage": 1,
            //             "pageSize": 2,
            //             "pageNum": 1,
            //             "list": [
            //                 {
            //                     "withdrawalId": "W6527498439872634880",      // Withdrawal ID
            //                     "fees": "0.500000000000000000",              // Withdrawal fee
            //                     "withdrawalAddress": "okbtothemoon_941657",  // Withdrawal address
            //                     "currencyId": "7",                           // Token ID
            //                     "amount": "10.000000000000000000",           // Withdrawal amount
            //                     "state": 1,                                  // Status, 1: normal, -1: delete
            //                     "verifyStatus": 1,                           // Audit status, 0: to be audited, 1: auditing passed, -1: auditing failed
            //                     "createTime": 1556276903656,                 // WIthdrawal time
            //                     "actuallyAmount": "9.500000000000000000",    // Actual amount received
            //                 },
            //             ],
            //         },
            //         "resMsg": { "message": "success !", "method": null, "code": "1" },
            //     }
            //
            const data = this.safeValue (response, 'datas', {});
            const withdrawals = this.safeValue (data, 'list', []);
            return this.parseTransactions (withdrawals, code, since, limit);
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (!response) {
                return; // default error handler
            }
            const resMsg = this.safeValue (response, 'resMsg');
            const errorCode = this.safeString (resMsg, 'code');
            if (errorCode !== '1') {
                const feedback = this.id + ' ' + this.json (response);
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                throw new ExchangeError (feedback); // unknown error
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],56:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { TICK_SIZE } = require ('./base/functions/number');
    const { AuthenticationError, ExchangeError, ArgumentsRequired, PermissionDenied, InvalidOrder, OrderNotFound, InsufficientFunds, BadRequest, RateLimitExceeded, InvalidNonce } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class bybit extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'bybit',
                'name': 'Bybit',
                'countries': [ 'VG' ], // British Virgin Islands
                'version': 'v2',
                'userAgent': undefined,
                'rateLimit': 100,
                'hostname': 'bybit.com', // bybit.com, bytick.com
                'has': {
                    'cancelOrder': true,
                    'CORS': true,
                    'cancelAllOrders': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchDeposits': true,
                    'fetchLedger': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTransactions': false,
                    'fetchWithdrawals': true,
                    'fetchPositions': true,
                },
                'timeframes': {
                    '1m': '1',
                    '3m': '3',
                    '5m': '5',
                    '15m': '15',
                    '30m': '30',
                    '1h': '60',
                    '2h': '120',
                    '4h': '240',
                    '6h': '360',
                    '12h': '720',
                    '1d': 'D',
                    '1w': 'W',
                    '1M': 'M',
                    '1y': 'Y',
                },
                'urls': {
                    'test': {
                        'futures': 'https://api-testnet.{hostname}',
                        'v2': 'https://api-testnet.{hostname}',
                        'public': 'https://api-testnet.{hostname}',
                        'private': 'https://api-testnet.{hostname}',
                    },
                    'logo': 'https://user-images.githubusercontent.com/51840849/76547799-daff5b80-649e-11ea-87fb-3be9bac08954.jpg',
                    'api': {
                        'futures': 'https://api.{hostname}',
                        'v2': 'https://api.{hostname}',
                        'public': 'https://api.{hostname}',
                        'private': 'https://api.{hostname}',
                    },
                    'www': 'https://www.bybit.com',
                    'doc': [
                        'https://bybit-exchange.github.io/docs/inverse/',
                        'https://bybit-exchange.github.io/docs/linear/',
                        'https://github.com/bybit-exchange',
                    ],
                    'fees': 'https://help.bybit.com/hc/en-us/articles/360039261154',
                    'referral': 'https://www.bybit.com/app/register?ref=X7Prm',
                },
                'api': {
                    'futures': {
                        'private': {
                            'get': [
                                'order/list',
                                'order',
                                'stop-order/list',
                                'stop-order',
                                'position/list',
                                'execution/list',
                                'trade/closed-pnl/list',
                            ],
                            'post': [
                                'order/create',
                                'order/cancel',
                                'order/cancelAll',
                                'order/replace',
                                'stop-order/create',
                                'stop-order/cancel',
                                'stop-order/cancelAll',
                                'stop-order/replace',
                                'position/change-position-margin',
                                'position/trading-stop',
                                'position/leverage/save',
                                'position/switch-mode',
                                'position/switch-isolated',
                                'position/risk-limit',
                            ],
                        },
                    },
                    'v2': {
                        'public': {
                            'get': [
                                'orderBook/L2',
                                'kline/list',
                                'tickers',
                                'trading-records',
                                'symbols',
                                'liq-records',
                                'mark-price-kline',
                                'index-price-kline',
                                'premium-index-kline',
                                'open-interest',
                                'big-deal',
                                'account-ratio',
                                'time',
                                'announcement',
                                'funding/prev-funding-rate',
                                'risk-limit/list',
                            ],
                        },
                        'private': {
                            'get': [
                                'order/list',
                                'order',
                                'stop-order/list',
                                'stop-order',
                                'position/list',
                                'execution/list',
                                'trade/closed-pnl/list',
                                'funding/prev-funding-rate',
                                'funding/prev-funding',
                                'funding/predicted-funding',
                                'account/api-key',
                                'account/lcp',
                                'wallet/balance',
                                'wallet/fund/records',
                                'wallet/withdraw/list',
                                'exchange-order/list',
                            ],
                            'post': [
                                'order/create',
                                'order/cancel',
                                'order/cancelAll',
                                'order/replace',
                                'stop-order/create',
                                'stop-order/cancel',
                                'stop-order/cancelAll',
                                'stop-order/replace',
                                'position/change-position-margin',
                                'position/trading-stop',
                                'position/leverage/save',
                                'position/switch-mode',
                                'position/switch-isolated',
                                'position/risk-limit',
                            ],
                        },
                    },
                    'public': {
                        'linear': {
                            'get': [
                                'kline',
                                'recent-trading-records',
                                'funding/prev-funding-rate',
                                'mark-price-kline',
                                'index-price-kline',
                                'premium-index-kline',
                                'risk-limit',
                            ],
                        },
                    },
                    'private': {
                        'linear': {
                            'get': [
                                'order/list',
                                'order/search',
                                'stop-order/list',
                                'stop-order/search',
                                'position/list',
                                'trade/execution/list',
                                'trade/closed-pnl/list',
                                'funding/predicted-funding',
                                'funding/prev-funding',
                            ],
                            'post': [
                                'order/create',
                                'order/cancel',
                                'order/cancel-all',
                                'order/replace',
                                'stop-order/create',
                                'stop-order/cancel',
                                'stop-order/cancel-all',
                                'stop-order/replace',
                                'position/set-auto-add-margin',
                                'position/switch-isolated',
                                'tpsl/switch-mode',
                                'position/add-margin',
                                'position/set-leverage',
                                'position/trading-stop',
                                'position/set-risk',
                            ],
                        },
                    },
                },
                'httpExceptions': {
                    '403': RateLimitExceeded, // Forbidden -- You request too many times
                },
                'exceptions': {
                    'exact': {
                        '10001': BadRequest, // parameter error
                        '10002': InvalidNonce, // request expired, check your timestamp and recv_window
                        '10003': AuthenticationError, // Invalid apikey
                        '10004': AuthenticationError, // invalid sign
                        '10005': PermissionDenied, // permission denied for current apikey
                        '10006': RateLimitExceeded, // too many requests
                        '10007': AuthenticationError, // api_key not found in your request parameters
                        '10010': PermissionDenied, // request ip mismatch
                        '10017': BadRequest, // request path not found or request method is invalid
                        '10018': RateLimitExceeded, // exceed ip rate limit
                        '20001': OrderNotFound, // Order not exists
                        '20003': InvalidOrder, // missing parameter side
                        '20004': InvalidOrder, // invalid parameter side
                        '20005': InvalidOrder, // missing parameter symbol
                        '20006': InvalidOrder, // invalid parameter symbol
                        '20007': InvalidOrder, // missing parameter order_type
                        '20008': InvalidOrder, // invalid parameter order_type
                        '20009': InvalidOrder, // missing parameter qty
                        '20010': InvalidOrder, // qty must be greater than 0
                        '20011': InvalidOrder, // qty must be an integer
                        '20012': InvalidOrder, // qty must be greater than zero and less than 1 million
                        '20013': InvalidOrder, // missing parameter price
                        '20014': InvalidOrder, // price must be greater than 0
                        '20015': InvalidOrder, // missing parameter time_in_force
                        '20016': InvalidOrder, // invalid value for parameter time_in_force
                        '20017': InvalidOrder, // missing parameter order_id
                        '20018': InvalidOrder, // invalid date format
                        '20019': InvalidOrder, // missing parameter stop_px
                        '20020': InvalidOrder, // missing parameter base_price
                        '20021': InvalidOrder, // missing parameter stop_order_id
                        '20022': BadRequest, // missing parameter leverage
                        '20023': BadRequest, // leverage must be a number
                        '20031': BadRequest, // leverage must be greater than zero
                        '20070': BadRequest, // missing parameter margin
                        '20071': BadRequest, // margin must be greater than zero
                        '20084': BadRequest, // order_id or order_link_id is required
                        '30001': BadRequest, // order_link_id is repeated
                        '30003': InvalidOrder, // qty must be more than the minimum allowed
                        '30004': InvalidOrder, // qty must be less than the maximum allowed
                        '30005': InvalidOrder, // price exceeds maximum allowed
                        '30007': InvalidOrder, // price exceeds minimum allowed
                        '30008': InvalidOrder, // invalid order_type
                        '30009': ExchangeError, // no position found
                        '30010': InsufficientFunds, // insufficient wallet balance
                        '30011': PermissionDenied, // operation not allowed as position is undergoing liquidation
                        '30012': PermissionDenied, // operation not allowed as position is undergoing ADL
                        '30013': PermissionDenied, // position is in liq or adl status
                        '30014': InvalidOrder, // invalid closing order, qty should not greater than size
                        '30015': InvalidOrder, // invalid closing order, side should be opposite
                        '30016': ExchangeError, // TS and SL must be cancelled first while closing position
                        '30017': InvalidOrder, // estimated fill price cannot be lower than current Buy liq_price
                        '30018': InvalidOrder, // estimated fill price cannot be higher than current Sell liq_price
                        '30019': InvalidOrder, // cannot attach TP/SL params for non-zero position when placing non-opening position order
                        '30020': InvalidOrder, // position already has TP/SL params
                        '30021': InvalidOrder, // cannot afford estimated position_margin
                        '30022': InvalidOrder, // estimated buy liq_price cannot be higher than current mark_price
                        '30023': InvalidOrder, // estimated sell liq_price cannot be lower than current mark_price
                        '30024': InvalidOrder, // cannot set TP/SL/TS for zero-position
                        '30025': InvalidOrder, // trigger price should bigger than 10% of last price
                        '30026': InvalidOrder, // price too high
                        '30027': InvalidOrder, // price set for Take profit should be higher than Last Traded Price
                        '30028': InvalidOrder, // price set for Stop loss should be between Liquidation price and Last Traded Price
                        '30029': InvalidOrder, // price set for Stop loss should be between Last Traded Price and Liquidation price
                        '30030': InvalidOrder, // price set for Take profit should be lower than Last Traded Price
                        '30031': InsufficientFunds, // insufficient available balance for order cost
                        '30032': InvalidOrder, // order has been filled or cancelled
                        '30033': RateLimitExceeded, // The number of stop orders exceeds maximum limit allowed
                        '30034': OrderNotFound, // no order found
                        '30035': RateLimitExceeded, // too fast to cancel
                        '30036': ExchangeError, // the expected position value after order execution exceeds the current risk limit
                        '30037': InvalidOrder, // order already cancelled
                        '30041': ExchangeError, // no position found
                        '30042': InsufficientFunds, // insufficient wallet balance
                        '30043': InvalidOrder, // operation not allowed as position is undergoing liquidation
                        '30044': InvalidOrder, // operation not allowed as position is undergoing AD
                        '30045': InvalidOrder, // operation not allowed as position is not normal status
                        '30049': InsufficientFunds, // insufficient available balance
                        '30050': ExchangeError, // any adjustments made will trigger immediate liquidation
                        '30051': ExchangeError, // due to risk limit, cannot adjust leverage
                        '30052': ExchangeError, // leverage can not less than 1
                        '30054': ExchangeError, // position margin is invalid
                        '30057': ExchangeError, // requested quantity of contracts exceeds risk limit
                        '30063': ExchangeError, // reduce-only rule not satisfied
                        '30067': InsufficientFunds, // insufficient available balance
                        '30068': ExchangeError, // exit value must be positive
                        '30074': InvalidOrder, // can't create the stop order, because you expect the order will be triggered when the LastPrice(or IndexPrice、 MarkPrice, determined by trigger_by) is raising to stop_px, but the LastPrice(or IndexPrice、 MarkPrice) is already equal to or greater than stop_px, please adjust base_price or stop_px
                        '30075': InvalidOrder, // can't create the stop order, because you expect the order will be triggered when the LastPrice(or IndexPrice、 MarkPrice, determined by trigger_by) is falling to stop_px, but the LastPrice(or IndexPrice、 MarkPrice) is already equal to or less than stop_px, please adjust base_price or stop_px
                        '33004': AuthenticationError, // apikey already expired
                        '34026': ExchangeError, // the limit is no change
                    },
                    'broad': {
                        'unknown orderInfo': OrderNotFound, // {"ret_code":-1,"ret_msg":"unknown orderInfo","ext_code":"","ext_info":"","result":null,"time_now":"1584030414.005545","rate_limit_status":99,"rate_limit_reset_ms":1584030414003,"rate_limit":100}
                        'invalid api_key': AuthenticationError, // {"ret_code":10003,"ret_msg":"invalid api_key","ext_code":"","ext_info":"","result":null,"time_now":"1599547085.415797"}
                    },
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    'marketTypes': {
                        'BTC/USDT': 'linear',
                        'ETH/USDT': 'linear',
                        'BNB/USDT': 'linear',
                        'ADA/USDT': 'linear',
                        'DOGE/USDT': 'linear',
                        'XRP/USDT': 'linear',
                        'DOT/USDT': 'linear',
                        'UNI/USDT': 'linear',
                        'BCH/USDT': 'linear',
                        'LTC/USDT': 'linear',
                        'SOL/USDT': 'linear',
                        'LINK/USDT': 'linear',
                        'MATIC/USDT': 'linear',
                        'ETC/USDT': 'linear',
                        'FIL/USDT': 'linear',
                        'EOS/USDT': 'linear',
                        'AAVE/USDT': 'linear',
                        'XTZ/USDT': 'linear',
                        'SUSHI/USDT': 'linear',
                        'XEM/USDT': 'linear',
                        'BTC/USD': 'inverse',
                        'ETH/USD': 'inverse',
                        'EOS/USD': 'inverse',
                        'XRP/USD': 'inverse',
                    },
                    'defaultType': 'linear',  // linear, inverse, futures
                    'code': 'BTC',
                    'cancelAllOrders': {
                        // 'method': 'v2PrivatePostOrderCancelAll', // v2PrivatePostStopOrderCancelAll
                    },
                    'recvWindow': 5 * 1000, // 5 sec default
                    'timeDifference': 0, // the difference between system clock and exchange server clock
                    'adjustForTimeDifference': false, // controls the adjustment logic upon instantiation
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'taker': 0.00075,
                        'maker': -0.00025,
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                        'withdraw': {},
                        'deposit': {},
                    },
                },
            });
        }
    
        nonce () {
            return this.milliseconds () - this.options['timeDifference'];
        }
    
        async loadTimeDifference (params = {}) {
            const serverTime = await this.fetchTime (params);
            const after = this.milliseconds ();
            this.options['timeDifference'] = after - serverTime;
            return this.options['timeDifference'];
        }
    
        async fetchTime (params = {}) {
            const response = await this.v2PublicGetTime (params);
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: {},
            //         time_now: '1583933682.448826'
            //     }
            //
            return this.safeTimestamp (response, 'time_now');
        }
    
        async fetchMarkets (params = {}) {
            if (this.options['adjustForTimeDifference']) {
                await this.loadTimeDifference ();
            }
            const response = await this.v2PublicGetSymbols (params);
            //
            //     {
            //         "ret_code":0,
            //         "ret_msg":"OK",
            //         "ext_code":"",
            //         "ext_info":"",
            //         "result":[
            //             {
            //                 "name":"BTCUSD",
            //                 "alias":"BTCUSD",
            //                 "status":"Trading",
            //                 "base_currency":"BTC",
            //                 "quote_currency":"USD",
            //                 "price_scale":2,
            //                 "taker_fee":"0.00075",
            //                 "maker_fee":"-0.00025",
            //                 "leverage_filter":{"min_leverage":1,"max_leverage":100,"leverage_step":"0.01"},
            //                 "price_filter":{"min_price":"0.5","max_price":"999999.5","tick_size":"0.5"},
            //                 "lot_size_filter":{"max_trading_qty":1000000,"min_trading_qty":1,"qty_step":1}
            //             },
            //             {
            //                 "name":"BTCUSDT",
            //                 "alias":"BTCUSDT",
            //                 "status":"Trading",
            //                 "base_currency":"BTC",
            //                 "quote_currency":"USDT",
            //                 "price_scale":2,
            //                 "taker_fee":"0.00075",
            //                 "maker_fee":"-0.00025",
            //                 "leverage_filter":{"min_leverage":1,"max_leverage":100,"leverage_step":"0.01"},
            //                 "price_filter":{"min_price":"0.5","max_price":"999999.5","tick_size":"0.5"},
            //                 "lot_size_filter":{"max_trading_qty":100,"min_trading_qty":0.001,"qty_step":0.001}
            //             },
            //         ],
            //         "time_now":"1610539664.818033"
            //     }
            //
            const markets = this.safeValue (response, 'result', []);
            const options = this.safeValue (this.options, 'fetchMarkets', {});
            const linearQuoteCurrencies = this.safeValue (options, 'linear', { 'USDT': true });
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString2 (market, 'name', 'symbol');
                const baseId = this.safeString (market, 'base_currency');
                const quoteId = this.safeString (market, 'quote_currency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const linear = (quote in linearQuoteCurrencies);
                const inverse = !linear;
                let symbol = base + '/' + quote;
                const baseQuote = base + quote;
                let type = 'swap';
                if (baseQuote !== id) {
                    symbol = id;
                    type = 'futures';
                }
                const lotSizeFilter = this.safeValue (market, 'lot_size_filter', {});
                const priceFilter = this.safeValue (market, 'price_filter', {});
                const precision = {
                    'amount': this.safeNumber (lotSizeFilter, 'qty_step'),
                    'price': this.safeNumber (priceFilter, 'tick_size'),
                };
                const status = this.safeString (market, 'status');
                let active = undefined;
                if (status !== undefined) {
                    active = (status === 'Trading');
                }
                const spot = (type === 'spot');
                const swap = (type === 'swap');
                const futures = (type === 'futures');
                const option = (type === 'option');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'active': active,
                    'precision': precision,
                    'taker': this.safeNumber (market, 'taker_fee'),
                    'maker': this.safeNumber (market, 'maker_fee'),
                    'type': type,
                    'spot': spot,
                    'swap': swap,
                    'futures': futures,
                    'option': option,
                    'linear': linear,
                    'inverse': inverse,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (lotSizeFilter, 'min_trading_qty'),
                            'max': this.safeNumber (lotSizeFilter, 'max_trading_qty'),
                        },
                        'price': {
                            'min': this.safeNumber (priceFilter, 'min_price'),
                            'max': this.safeNumber (priceFilter, 'max_price'),
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'info': market,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker
            //
            //     {
            //         symbol: 'BTCUSD',
            //         bid_price: '7680',
            //         ask_price: '7680.5',
            //         last_price: '7680.00',
            //         last_tick_direction: 'MinusTick',
            //         prev_price_24h: '7870.50',
            //         price_24h_pcnt: '-0.024204',
            //         high_price_24h: '8035.00',
            //         low_price_24h: '7671.00',
            //         prev_price_1h: '7780.00',
            //         price_1h_pcnt: '-0.012853',
            //         mark_price: '7683.27',
            //         index_price: '7682.74',
            //         open_interest: 188829147,
            //         open_value: '23670.06',
            //         total_turnover: '25744224.90',
            //         turnover_24h: '102997.83',
            //         total_volume: 225448878806,
            //         volume_24h: 809919408,
            //         funding_rate: '0.0001',
            //         predicted_funding_rate: '0.0001',
            //         next_funding_time: '2020-03-12T00:00:00Z',
            //         countdown_hour: 7
            //     }
            //
            const timestamp = undefined;
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber (ticker, 'last_price');
            const open = this.safeNumber (ticker, 'prev_price_24h');
            let percentage = this.safeNumber (ticker, 'price_24h_pcnt');
            if (percentage !== undefined) {
                percentage *= 100;
            }
            let change = undefined;
            let average = undefined;
            if ((last !== undefined) && (open !== undefined)) {
                change = last - open;
                average = this.sum (open, last) / 2;
            }
            const baseVolume = this.safeNumber (ticker, 'turnover_24h');
            const quoteVolume = this.safeNumber (ticker, 'volume_24h');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high_price_24h'),
                'low': this.safeNumber (ticker, 'low_price_24h'),
                'bid': this.safeNumber (ticker, 'bid_price'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask_price'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': average,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.v2PublicGetTickers (this.extend (request, params));
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: [
            //             {
            //                 symbol: 'BTCUSD',
            //                 bid_price: '7680',
            //                 ask_price: '7680.5',
            //                 last_price: '7680.00',
            //                 last_tick_direction: 'MinusTick',
            //                 prev_price_24h: '7870.50',
            //                 price_24h_pcnt: '-0.024204',
            //                 high_price_24h: '8035.00',
            //                 low_price_24h: '7671.00',
            //                 prev_price_1h: '7780.00',
            //                 price_1h_pcnt: '-0.012853',
            //                 mark_price: '7683.27',
            //                 index_price: '7682.74',
            //                 open_interest: 188829147,
            //                 open_value: '23670.06',
            //                 total_turnover: '25744224.90',
            //                 turnover_24h: '102997.83',
            //                 total_volume: 225448878806,
            //                 volume_24h: 809919408,
            //                 funding_rate: '0.0001',
            //                 predicted_funding_rate: '0.0001',
            //                 next_funding_time: '2020-03-12T00:00:00Z',
            //                 countdown_hour: 7
            //             }
            //         ],
            //         time_now: '1583948195.818255'
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            const first = this.safeValue (result, 0);
            const timestamp = this.safeTimestamp (response, 'time_now');
            const ticker = this.parseTicker (first, market);
            ticker['timestamp'] = timestamp;
            ticker['datetime'] = this.iso8601 (timestamp);
            return ticker;
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.v2PublicGetTickers (params);
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: [
            //             {
            //                 symbol: 'BTCUSD',
            //                 bid_price: '7680',
            //                 ask_price: '7680.5',
            //                 last_price: '7680.00',
            //                 last_tick_direction: 'MinusTick',
            //                 prev_price_24h: '7870.50',
            //                 price_24h_pcnt: '-0.024204',
            //                 high_price_24h: '8035.00',
            //                 low_price_24h: '7671.00',
            //                 prev_price_1h: '7780.00',
            //                 price_1h_pcnt: '-0.012853',
            //                 mark_price: '7683.27',
            //                 index_price: '7682.74',
            //                 open_interest: 188829147,
            //                 open_value: '23670.06',
            //                 total_turnover: '25744224.90',
            //                 turnover_24h: '102997.83',
            //                 total_volume: 225448878806,
            //                 volume_24h: 809919408,
            //                 funding_rate: '0.0001',
            //                 predicted_funding_rate: '0.0001',
            //                 next_funding_time: '2020-03-12T00:00:00Z',
            //                 countdown_hour: 7
            //             }
            //         ],
            //         time_now: '1583948195.818255'
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            const tickers = {};
            for (let i = 0; i < result.length; i++) {
                const ticker = this.parseTicker (result[i]);
                const symbol = ticker['symbol'];
                tickers[symbol] = ticker;
            }
            return this.filterByArray (tickers, 'symbol', symbols);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            // inverse perpetual BTC/USD
            //
            //     {
            //         symbol: 'BTCUSD',
            //         interval: '1',
            //         open_time: 1583952540,
            //         open: '7760.5',
            //         high: '7764',
            //         low: '7757',
            //         close: '7763.5',
            //         volume: '1259766',
            //         turnover: '162.32773718999994'
            //     }
            //
            // linear perpetual BTC/USDT
            //
            //     {
            //         "id":143536,
            //         "symbol":"BTCUSDT",
            //         "period":"15",
            //         "start_at":1587883500,
            //         "volume":1.035,
            //         "open":7540.5,
            //         "high":7541,
            //         "low":7540.5,
            //         "close":7541
            //     }
            //
            return [
                this.safeTimestamp2 (ohlcv, 'open_time', 'start_at'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber2 (ohlcv, 'turnover', 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'interval': this.timeframes[timeframe],
            };
            const duration = this.parseTimeframe (timeframe);
            const now = this.seconds ();
            if (since === undefined) {
                if (limit === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchOHLCV() requires a since argument or a limit argument');
                } else {
                    request['from'] = now - limit * duration;
                }
            } else {
                request['from'] = parseInt (since / 1000);
            }
            if (limit !== undefined) {
                request['limit'] = limit; // max 200, default 200
            }
            const method = market['linear'] ? 'publicLinearGetKline' : 'v2PublicGetKlineList';
            const response = await this[method] (this.extend (request, params));
            //
            // inverse perpetual BTC/USD
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: [
            //             {
            //                 symbol: 'BTCUSD',
            //                 interval: '1',
            //                 open_time: 1583952540,
            //                 open: '7760.5',
            //                 high: '7764',
            //                 low: '7757',
            //                 close: '7763.5',
            //                 volume: '1259766',
            //                 turnover: '162.32773718999994'
            //             },
            //         ],
            //         time_now: '1583953082.397330'
            //     }
            //
            // linear perpetual BTC/USDT
            //
            //     {
            //         "ret_code":0,
            //         "ret_msg":"OK",
            //         "ext_code":"",
            //         "ext_info":"",
            //         "result":[
            //             {
            //                 "id":143536,
            //                 "symbol":"BTCUSDT",
            //                 "period":"15",
            //                 "start_at":1587883500,
            //                 "volume":1.035,
            //                 "open":7540.5,
            //                 "high":7541,
            //                 "low":7540.5,
            //                 "close":7541
            //             }
            //         ],
            //         "time_now":"1587884120.168077"
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseOHLCVs (result, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         id: 43785688,
            //         symbol: 'BTCUSD',
            //         price: 7786,
            //         qty: 67,
            //         side: 'Sell',
            //         time: '2020-03-11T19:18:30.123Z'
            //     }
            //
            // fetchMyTrades, fetchOrderTrades (private)
            //
            //     {
            //         "closed_size": 0,
            //         "cross_seq": 277136382,
            //         "exec_fee": "0.0000001",
            //         "exec_id": "256e5ef8-abfe-5772-971b-f944e15e0d68",
            //         "exec_price": "8178.5",
            //         "exec_qty": 1,
            //         // the docs say the exec_time field is "abandoned" now
            //         // the user should use "trade_time_ms"
            //         "exec_time": "1571676941.70682",
            //         "exec_type": "Trade", //Exec Type Enum
            //         "exec_value": "0.00012227",
            //         "fee_rate": "0.00075",
            //         "last_liquidity_ind": "RemovedLiquidity", //Liquidity Enum
            //         "leaves_qty": 0,
            //         "nth_fill": 2,
            //         "order_id": "7ad50cb1-9ad0-4f74-804b-d82a516e1029",
            //         "order_link_id": "",
            //         "order_price": "8178",
            //         "order_qty": 1,
            //         "order_type": "Market", //Order Type Enum
            //         "side": "Buy", //Side Enum
            //         "symbol": "BTCUSD", //Symbol Enum
            //         "user_id": 1,
            //         "trade_time_ms": 1577480599000
            //     }
            //
            const id = this.safeString2 (trade, 'id', 'exec_id');
            const marketId = this.safeString (trade, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = market['symbol'];
            const amountString = this.safeString2 (trade, 'qty', 'exec_qty');
            const priceString = this.safeString2 (trade, 'exec_price', 'price');
            let cost = this.safeNumber (trade, 'exec_value');
            const amount = this.parseNumber (amountString);
            const price = this.parseNumber (priceString);
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            let timestamp = this.parse8601 (this.safeString (trade, 'time'));
            if (timestamp === undefined) {
                timestamp = this.safeInteger (trade, 'trade_time_ms');
            }
            const side = this.safeStringLower (trade, 'side');
            const lastLiquidityInd = this.safeString (trade, 'last_liquidity_ind');
            const takerOrMaker = (lastLiquidityInd === 'AddedLiquidity') ? 'maker' : 'taker';
            const feeCost = this.safeNumber (trade, 'exec_fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyCode = market['inverse'] ? market['base'] : market['quote'];
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                    'rate': this.safeNumber (trade, 'fee_rate'),
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': this.safeString (trade, 'order_id'),
                'type': this.safeStringLower (trade, 'order_type'),
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                // 'from': 123, // from id
            };
            if (limit !== undefined) {
                request['count'] = limit; // default 500, max 1000
            }
            const method = market['linear'] ? 'publicLinearGetRecentTradingRecords' : 'v2PublicGetTradingRecords';
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: [
            //             {
            //                 id: 43785688,
            //                 symbol: 'BTCUSD',
            //                 price: 7786,
            //                 qty: 67,
            //                 side: 'Sell',
            //                 time: '2020-03-11T19:18:30.123Z'
            //             },
            //         ],
            //         time_now: '1583954313.393362'
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseTrades (result, market, since, limit);
        }
    
        parseOrderBook (orderbook, symbol, timestamp = undefined, bidsKey = 'Buy', asksKey = 'Sell', priceKey = 'price', amountKey = 'size') {
            const bids = [];
            const asks = [];
            for (let i = 0; i < orderbook.length; i++) {
                const bidask = orderbook[i];
                const side = this.safeString (bidask, 'side');
                if (side === 'Buy') {
                    bids.push (this.parseBidAsk (bidask, priceKey, amountKey));
                } else if (side === 'Sell') {
                    asks.push (this.parseBidAsk (bidask, priceKey, amountKey));
                } else {
                    throw new ExchangeError (this.id + ' parseOrderBook encountered an unrecognized bidask format: ' + this.json (bidask));
                }
            }
            return {
                'symbol': symbol,
                'bids': this.sortBy (bids, 0, true),
                'asks': this.sortBy (asks, 0),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'nonce': undefined,
            };
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.v2PublicGetOrderBookL2 (this.extend (request, params));
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: [
            //             { symbol: 'BTCUSD', price: '7767.5', size: 677956, side: 'Buy' },
            //             { symbol: 'BTCUSD', price: '7767', size: 580690, side: 'Buy' },
            //             { symbol: 'BTCUSD', price: '7766.5', size: 475252, side: 'Buy' },
            //             { symbol: 'BTCUSD', price: '7768', size: 330847, side: 'Sell' },
            //             { symbol: 'BTCUSD', price: '7768.5', size: 97159, side: 'Sell' },
            //             { symbol: 'BTCUSD', price: '7769', size: 6508, side: 'Sell' },
            //         ],
            //         time_now: '1583954829.874823'
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            const timestamp = this.safeTimestamp (response, 'time_now');
            return this.parseOrderBook (result, symbol, timestamp, 'Buy', 'Sell', 'price', 'size');
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const request = {};
            const coin = this.safeString (params, 'coin');
            const code = this.safeString (params, 'code');
            if (coin !== undefined) {
                request['coin'] = coin;
            } else if (code !== undefined) {
                const currency = this.currency (code);
                request['coin'] = currency['id'];
            }
            const response = await this.v2PrivateGetWalletBalance (this.extend (request, params));
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: {
            //             BTC: {
            //                 equity: 0,
            //                 available_balance: 0,
            //                 used_margin: 0,
            //                 order_margin: 0,
            //                 position_margin: 0,
            //                 occ_closing_fee: 0,
            //                 occ_funding_fee: 0,
            //                 wallet_balance: 0,
            //                 realised_pnl: 0,
            //                 unrealised_pnl: 0,
            //                 cum_realised_pnl: 0,
            //                 given_cash: 0,
            //                 service_cash: 0
            //             }
            //         },
            //         time_now: '1583937810.370020',
            //         rate_limit_status: 119,
            //         rate_limit_reset_ms: 1583937810367,
            //         rate_limit: 120
            //     }
            //
            const result = {
                'info': response,
            };
            const balances = this.safeValue (response, 'result', {});
            const currencyIds = Object.keys (balances);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const balance = balances[currencyId];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available_balance');
                account['used'] = this.safeString (balance, 'used_margin');
                account['total'] = this.safeString (balance, 'equity');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                // basic orders
                'Created': 'open',
                'Rejected': 'rejected', // order is triggered but failed upon being placed
                'New': 'open',
                'PartiallyFilled': 'open',
                'Filled': 'closed',
                'Cancelled': 'canceled',
                'PendingCancel': 'canceling', // the engine has received the cancellation but there is no guarantee that it will be successful
                // conditional orders
                'Active': 'open', // order is triggered and placed successfully
                'Untriggered': 'open', // order waits to be triggered
                'Triggered': 'closed', // order is triggered
                // 'Cancelled': 'canceled', // order is cancelled
                // 'Rejected': 'rejected', // order is triggered but fail to be placed
                'Deactivated': 'canceled', // conditional order was cancelled before triggering
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTimeInForce (timeInForce) {
            const timeInForces = {
                'GoodTillCancel': 'GTC',
                'ImmediateOrCancel': 'IOC',
                'FillOrKill': 'FOK',
                'PostOnly': 'PO',
            };
            return this.safeString (timeInForces, timeInForce, timeInForce);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "user_id": 1,
            //         "order_id": "335fd977-e5a5-4781-b6d0-c772d5bfb95b",
            //         "symbol": "BTCUSD",
            //         "side": "Buy",
            //         "order_type": "Limit",
            //         "price": 8800,
            //         "qty": 1,
            //         "time_in_force": "GoodTillCancel",
            //         "order_status": "Created",
            //         "last_exec_time": 0,
            //         "last_exec_price": 0,
            //         "leaves_qty": 1,
            //         "cum_exec_qty": 0, // in contracts, where 1 contract = 1 quote currency unit (USD for inverse contracts)
            //         "cum_exec_value": 0, // in contract's underlying currency (BTC for inverse contracts)
            //         "cum_exec_fee": 0,
            //         "reject_reason": "",
            //         "order_link_id": "",
            //         "created_at": "2019-11-30T11:03:43.452Z",
            //         "updated_at": "2019-11-30T11:03:43.455Z"
            //     }
            //
            // fetchOrder
            //
            //     {
            //         "user_id" : 599946,
            //         "symbol" : "BTCUSD",
            //         "side" : "Buy",
            //         "order_type" : "Limit",
            //         "price" : "7948",
            //         "qty" : 10,
            //         "time_in_force" : "GoodTillCancel",
            //         "order_status" : "Filled",
            //         "ext_fields" : {
            //             "o_req_num" : -1600687220498,
            //             "xreq_type" : "x_create"
            //         },
            //         "last_exec_time" : "1588150113.968422",
            //         "last_exec_price" : "7948",
            //         "leaves_qty" : 0,
            //         "leaves_value" : "0",
            //         "cum_exec_qty" : 10,
            //         "cum_exec_value" : "0.00125817",
            //         "cum_exec_fee" : "-0.00000031",
            //         "reject_reason" : "",
            //         "cancel_type" : "",
            //         "order_link_id" : "",
            //         "created_at" : "2020-04-29T08:45:24.399146Z",
            //         "updated_at" : "2020-04-29T08:48:33.968422Z",
            //         "order_id" : "dd2504b9-0157-406a-99e1-efa522373944"
            //     }
            //
            // conditional order
            //
            //     {
            //         "user_id":##,
            //         "symbol":"BTCUSD",
            //         "side":"Buy",
            //         "order_type":"Market",
            //         "price":0,
            //         "qty":10,
            //         "time_in_force":"GoodTillCancel",
            //         "stop_order_type":"Stop",
            //         "trigger_by":"LastPrice",
            //         "base_price":11833,
            //         "order_status":"Untriggered",
            //         "ext_fields":{
            //             "stop_order_type":"Stop",
            //             "trigger_by":"LastPrice",
            //             "base_price":11833,
            //             "expected_direction":"Rising",
            //             "trigger_price":12400,
            //             "close_on_trigger":true,
            //             "op_from":"api",
            //             "remark":"x.x.x.x",
            //             "o_req_num":0
            //         },
            //         "leaves_qty":10,
            //         "leaves_value":0.00080645,
            //         "reject_reason":null,
            //         "cross_seq":-1,
            //         "created_at":"2020-08-21T09:18:48.000Z",
            //         "updated_at":"2020-08-21T09:18:48.000Z",
            //         "trigger_price":12400,
            //         "stop_order_id":"3f3b54b1-3379-42c7-8510-44f4d9915be0"
            //     }
            //
            const marketId = this.safeString (order, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = market['symbol'];
            let feeCurrency = undefined;
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const id = this.safeString2 (order, 'order_id', 'stop_order_id');
            const type = this.safeStringLower (order, 'order_type');
            let price = this.safeNumber (order, 'price');
            if (price === 0.0) {
                price = undefined;
            }
            const average = this.safeNumber (order, 'average_price');
            const amount = this.safeNumber (order, 'qty');
            const cost = this.safeNumber (order, 'cum_exec_value');
            const filled = this.safeNumber (order, 'cum_exec_qty');
            const remaining = this.safeNumber (order, 'leaves_qty');
            const marketTypes = this.safeValue (this.options, 'marketTypes', {});
            const marketType = this.safeString (marketTypes, symbol);
            if (market !== undefined) {
                if (marketType === 'linear') {
                    feeCurrency = market['quote'];
                } else {
                    feeCurrency = market['base'];
                }
            }
            let lastTradeTimestamp = this.safeTimestamp (order, 'last_exec_time');
            if (lastTradeTimestamp === 0) {
                lastTradeTimestamp = undefined;
            }
            const status = this.parseOrderStatus (this.safeString2 (order, 'order_status', 'stop_order_status'));
            const side = this.safeStringLower (order, 'side');
            let feeCost = this.safeNumber (order, 'cum_exec_fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                feeCost = Math.abs (feeCost);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
            }
            let clientOrderId = this.safeString (order, 'order_link_id');
            if ((clientOrderId !== undefined) && (clientOrderId.length < 1)) {
                clientOrderId = undefined;
            }
            const timeInForce = this.parseTimeInForce (this.safeString (order, 'time_in_force'));
            const stopPrice = this.safeNumber2 (order, 'trigger_price', 'stop_px');
            const postOnly = (timeInForce === 'PO');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': cost,
                'average': average,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                // 'order_link_id': 'string', // one of order_id, stop_order_id or order_link_id is required
                // regular orders ---------------------------------------------
                // 'order_id': id, // one of order_id or order_link_id is required for regular orders
                // conditional orders ---------------------------------------------
                // 'stop_order_id': id, // one of stop_order_id or order_link_id is required for conditional orders
            };
            let method = undefined;
            if (market['swap']) {
                if (market['linear']) {
                    method = 'privateLinearGetOrderSearch';
                } else if (market['inverse']) {
                    method = 'v2PrivateGetOrder';
                }
            } else if (market['futures']) {
                method = 'futuresPrivateGetOrder';
            }
            const stopOrderId = this.safeString (params, 'stop_order_id');
            if (stopOrderId === undefined) {
                const orderLinkId = this.safeString (params, 'order_link_id');
                if (orderLinkId === undefined) {
                    request['order_id'] = id;
                }
            } else {
                if (market['swap']) {
                    if (market['linear']) {
                        method = 'privateLinearGetStopOrderSearch';
                    } else if (market['inverse']) {
                        method = 'v2PrivateGetStopOrder';
                    }
                } else if (market['futures']) {
                    method = 'futuresPrivateGetStopOrder';
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "OK",
            //         "ext_code": "",
            //         "ext_info": "",
            //         "result": {
            //             "user_id": 1,
            //             "symbol": "BTCUSD",
            //             "side": "Sell",
            //             "order_type": "Limit",
            //             "price": "8083",
            //             "qty": 10,
            //             "time_in_force": "GoodTillCancel",
            //             "order_status": "New",
            //             "ext_fields": { "o_req_num": -308787, "xreq_type": "x_create", "xreq_offset": 4154640 },
            //             "leaves_qty": 10,
            //             "leaves_value": "0.00123716",
            //             "cum_exec_qty": 0,
            //             "reject_reason": "",
            //             "order_link_id": "",
            //             "created_at": "2019-10-21T07:28:19.396246Z",
            //             "updated_at": "2019-10-21T07:28:19.396246Z",
            //             "order_id": "efa44157-c355-4a98-b6d6-1d846a936b93"
            //         },
            //         "time_now": "1571651135.291930",
            //         "rate_limit_status": 99, // The remaining number of accesses in one minute
            //         "rate_limit_reset_ms": 1580885703683,
            //         "rate_limit": 100
            //     }
            //
            // conditional orders
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "OK",
            //         "ext_code": "",
            //         "ext_info": "",
            //         "result": {
            //             "user_id": 1,
            //             "symbol": "BTCUSD",
            //             "side": "Buy",
            //             "order_type": "Limit",
            //             "price": "8000",
            //             "qty": 1,
            //             "time_in_force": "GoodTillCancel",
            //             "order_status": "Untriggered",
            //             "ext_fields": {},
            //             "leaves_qty": 1,
            //             "leaves_value": "0.00013333",
            //             "cum_exec_qty": 0,
            //             "cum_exec_value": null,
            //             "cum_exec_fee": null,
            //             "reject_reason": "",
            //             "order_link_id": "",
            //             "created_at": "2019-12-27T19:56:24.052194Z",
            //             "updated_at": "2019-12-27T19:56:24.052194Z",
            //             "order_id": "378a1bbc-a93a-4e75-87f4-502ea754ba36"
            //         },
            //         "time_now": "1577476584.386958",
            //         "rate_limit_status": 99,
            //         "rate_limit_reset_ms": 1580885703683,
            //         "rate_limit": 100
            //     }
            //
            const result = this.safeValue (response, 'result');
            return this.parseOrder (result, market);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let qty = this.amountToPrecision (symbol, amount);
            if (market['inverse']) {
                qty = parseInt (qty);
            } else {
                qty = parseFloat (qty);
            }
            const request = {
                // orders ---------------------------------------------------------
                'side': this.capitalize (side),
                'symbol': market['id'],
                'order_type': this.capitalize (type),
                'qty': qty, // order quantity in USD, integer only
                // 'price': parseFloat (this.priceToPrecision (symbol, price)), // required for limit orders
                'time_in_force': 'GoodTillCancel', // ImmediateOrCancel, FillOrKill, PostOnly
                // 'take_profit': 123.45, // take profit price, only take effect upon opening the position
                // 'stop_loss': 123.45, // stop loss price, only take effect upon opening the position
                // 'reduce_only': false, // reduce only, required for linear orders
                // when creating a closing order, bybit recommends a True value for
                // close_on_trigger to avoid failing due to insufficient available margin
                // 'close_on_trigger': false, required for linear orders
                // 'order_link_id': 'string', // unique client order id, max 36 characters
                // conditional orders ---------------------------------------------
                // base_price is used to compare with the value of stop_px, to decide
                // whether your conditional order will be triggered by crossing trigger
                // price from upper side or lower side, mainly used to identify the
                // expected direction of the current conditional order
                // 'base_price': 123.45, // required for conditional orders
                // 'stop_px': 123.45, // trigger price, required for conditional orders
                // 'trigger_by': 'LastPrice', // IndexPrice, MarkPrice
            };
            let priceIsRequired = false;
            if (type === 'limit') {
                priceIsRequired = true;
            }
            if (priceIsRequired) {
                if (price !== undefined) {
                    request['price'] = parseFloat (this.priceToPrecision (symbol, price));
                } else {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a price argument for a ' + type + ' order');
                }
            }
            const clientOrderId = this.safeString2 (params, 'order_link_id', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['order_link_id'] = clientOrderId;
                params = this.omit (params, [ 'order_link_id', 'clientOrderId' ]);
            }
            const stopPx = this.safeValue2 (params, 'stop_px', 'stopPrice');
            const basePrice = this.safeValue (params, 'base_price');
            let method = undefined;
            if (market['swap']) {
                if (market['linear']) {
                    method = 'privateLinearPostOrderCreate';
                    request['reduce_only'] = false;
                    request['close_on_trigger'] = false;
                } else if (market['inverse']) {
                    method = 'v2PrivatePostOrderCreate';
                }
            } else if (market['futures']) {
                method = 'futuresPrivatePostOrderCreate';
            }
            if (stopPx !== undefined) {
                if (basePrice === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires both the stop_px and base_price params for a conditional ' + type + ' order');
                } else {
                    if (market['swap']) {
                        if (market['linear']) {
                            method = 'privateLinearPostStopOrderCreate';
                        } else if (market['inverse']) {
                            method = 'v2PrivatePostStopOrderCreate';
                        }
                    } else if (market['futures']) {
                        method = 'futuresPrivatePostStopOrderCreate';
                    }
                    request['stop_px'] = parseFloat (this.priceToPrecision (symbol, stopPx));
                    request['base_price'] = parseFloat (this.priceToPrecision (symbol, basePrice));
                    params = this.omit (params, [ 'stop_px', 'stopPrice', 'base_price' ]);
                }
            } else if (basePrice !== undefined) {
                throw new ArgumentsRequired (this.id + ' createOrder() requires both the stop_px and base_price params for a conditional ' + type + ' order');
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "OK",
            //         "ext_code": "",
            //         "ext_info": "",
            //         "result": {
            //             "user_id": 1,
            //             "order_id": "335fd977-e5a5-4781-b6d0-c772d5bfb95b",
            //             "symbol": "BTCUSD",
            //             "side": "Buy",
            //             "order_type": "Limit",
            //             "price": 8800,
            //             "qty": 1,
            //             "time_in_force": "GoodTillCancel",
            //             "order_status": "Created",
            //             "last_exec_time": 0,
            //             "last_exec_price": 0,
            //             "leaves_qty": 1,
            //             "cum_exec_qty": 0,
            //             "cum_exec_value": 0,
            //             "cum_exec_fee": 0,
            //             "reject_reason": "",
            //             "order_link_id": "",
            //             "created_at": "2019-11-30T11:03:43.452Z",
            //             "updated_at": "2019-11-30T11:03:43.455Z"
            //         },
            //         "time_now": "1575111823.458705",
            //         "rate_limit_status": 98,
            //         "rate_limit_reset_ms": 1580885703683,
            //         "rate_limit": 100
            //     }
            //
            // conditional orders
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": {
            //             "user_id": 1,
            //             "symbol": "BTCUSD",
            //             "side": "Buy",
            //             "order_type": "Limit",
            //             "price": 8000,
            //             "qty": 1,
            //             "time_in_force": "GoodTillCancel",
            //             "stop_order_type": "Stop",
            //             "trigger_by": "LastPrice",
            //             "base_price": 7000,
            //             "order_status": "Untriggered",
            //             "ext_fields": {
            //                 "stop_order_type": "Stop",
            //                 "trigger_by": "LastPrice",
            //                 "base_price": 7000,
            //                 "expected_direction": "Rising",
            //                 "trigger_price": 7500,
            //                 "op_from": "api",
            //                 "remark": "127.0.01",
            //                 "o_req_num": 0
            //             },
            //             "leaves_qty": 1,
            //             "leaves_value": 0.00013333,
            //             "reject_reason": null,
            //             "cross_seq": -1,
            //             "created_at": "2019-12-27T12:48:24.000Z",
            //             "updated_at": "2019-12-27T12:48:24.000Z",
            //             "stop_px": 7500,
            //             "stop_order_id": "a85cd1c0-a9a4-49d3-a1bd-bab5ebe946d5"
            //         },
            //         "ext_info": null,
            //         "time_now": "1577450904.327654",
            //         "rate_limit_status": 99,
            //         "rate_limit_reset_ms": 1577450904335,
            //         "rate_limit": "100"
            //     }
            //
            const result = this.safeValue (response, 'result');
            return this.parseOrder (result, market);
        }
    
        async editOrder (id, symbol, type, side, amount = undefined, price = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' editOrder() requires an symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                // 'order_id': id, // only for non-conditional orders
                'symbol': market['id'],
                // 'p_r_qty': this.amountToPrecision (symbol, amount), // new order quantity, optional
                // 'p_r_price' this.priceToprecision (symbol, price), // new order price, optional
                // ----------------------------------------------------------------
                // conditional orders
                // 'stop_order_id': id, // only for conditional orders
                // 'p_r_trigger_price': 123.45, // new trigger price also known as stop_px
            };
            let method = undefined;
            if (market['swap']) {
                if (market['linear']) {
                    method = 'privateLinearPostOrderReplace';
                } else if (market['inverse']) {
                    method = 'v2PrivatePostOrderReplace';
                }
            } else if (market['futures']) {
                method = 'futuresPrivatePostOrderReplace';
            }
            const stopOrderId = this.safeString (params, 'stop_order_id');
            if (stopOrderId !== undefined) {
                if (market['swap']) {
                    if (market['linear']) {
                        method = 'privateLinearPostStopOrderReplace';
                    } else if (market['inverse']) {
                        method = 'v2PrivatePostStopOrderReplace';
                    }
                } else if (market['futures']) {
                    method = 'futuresPrivatePostStopOrderReplace';
                }
                request['stop_order_id'] = stopOrderId;
                params = this.omit (params, [ 'stop_order_id' ]);
            } else {
                request['order_id'] = id;
            }
            if (amount !== undefined) {
                let qty = this.amountToPrecision (symbol, amount);
                if (market['inverse']) {
                    qty = parseInt (qty);
                } else {
                    qty = parseFloat (qty);
                }
                request['p_r_qty'] = qty;
            }
            if (price !== undefined) {
                request['p_r_price'] = parseFloat (this.priceToPrecision (symbol, price));
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": { "order_id": "efa44157-c355-4a98-b6d6-1d846a936b93" },
            //         "time_now": "1539778407.210858",
            //         "rate_limit_status": 99, // remaining number of accesses in one minute
            //         "rate_limit_reset_ms": 1580885703683,
            //         "rate_limit": 100
            //     }
            //
            // conditional orders
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": { "stop_order_id": "378a1bbc-a93a-4e75-87f4-502ea754ba36" },
            //         "ext_info": null,
            //         "time_now": "1577475760.604942",
            //         "rate_limit_status": 96,
            //         "rate_limit_reset_ms": 1577475760612,
            //         "rate_limit": "100"
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return {
                'info': response,
                'id': this.safeString2 (result, 'order_id', 'stop_order_id'),
                'order_id': this.safeString (result, 'order_id'),
                'stop_order_id': this.safeString (result, 'stop_order_id'),
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                // 'order_link_id': 'string', // one of order_id, stop_order_id or order_link_id is required
                // regular orders ---------------------------------------------
                // 'order_id': id, // one of order_id or order_link_id is required for regular orders
                // conditional orders ---------------------------------------------
                // 'stop_order_id': id, // one of stop_order_id or order_link_id is required for conditional orders
            };
            let method = undefined;
            if (market['swap']) {
                if (market['linear']) {
                    method = 'privateLinearPostOrderCancel';
                } else if (market['inverse']) {
                    method = 'v2PrivatePostOrderCancel';
                }
            } else if (market['futures']) {
                method = 'futuresPrivatePostOrderCancel';
            }
            const stopOrderId = this.safeString (params, 'stop_order_id');
            if (stopOrderId === undefined) {
                const orderLinkId = this.safeString (params, 'order_link_id');
                if (orderLinkId === undefined) {
                    request['order_id'] = id;
                }
            } else {
                if (market['swap']) {
                    if (market['linear']) {
                        method = 'privateLinearPostStopOrderCancel';
                    } else if (market['inverse']) {
                        method = 'v2PrivatePostStopOrderCancel';
                    }
                } else if (market['futures']) {
                    method = 'futuresPrivatePostStopOrderCancel';
                }
            }
            const response = await this[method] (this.extend (request, params));
            const result = this.safeValue (response, 'result', {});
            return this.parseOrder (result, market);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelAllOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const options = this.safeValue (this.options, 'cancelAllOrders', {});
            let defaultMethod = undefined;
            if (market['swap']) {
                if (market['linear']) {
                    defaultMethod = 'privateLinearPostOrderCancelAll';
                } else if (market['inverse']) {
                    defaultMethod = 'v2PrivatePostOrderCancelAll';
                }
            } else if (market['futures']) {
                defaultMethod = 'futuresPrivatePostOrderCancelAll';
            }
            const method = this.safeString (options, 'method', defaultMethod);
            const response = await this[method] (this.extend (request, params));
            const result = this.safeValue (response, 'result', []);
            return this.parseOrders (result, market);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'order_id': 'string'
                // 'order_link_id': 'string', // unique client order id, max 36 characters
                // 'symbol': market['id'], // default BTCUSD
                // 'order': 'desc', // asc
                // 'page': 1,
                // 'limit': 20, // max 50
                // 'order_status': 'Created,New'
                // conditional orders ---------------------------------------------
                // 'stop_order_id': 'string',
                // 'stop_order_status': 'Untriggered',
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const options = this.safeValue (this.options, 'fetchOrders', {});
            const defaultType = this.safeString (this.options, 'defaultType', 'linear');
            const marketTypes = this.safeValue (this.options, 'marketTypes', {});
            const marketType = this.safeString (marketTypes, symbol, defaultType);
            let defaultMethod = undefined;
            const marketDefined = (market !== undefined);
            const linear = (marketDefined && market['linear']) || (marketType === 'linear');
            const inverse = (marketDefined && market['swap'] && market['inverse']) || (marketType === 'inverse');
            const futures = (marketDefined && market['futures']) || (marketType === 'futures');
            if (linear) {
                defaultMethod = 'privateLinearGetOrderList';
            } else if (inverse) {
                defaultMethod = 'v2PrivateGetOrderList';
            } else if (futures) {
                defaultMethod = 'futuresPrivateGetOrderList';
            }
            let query = params;
            if (('stop_order_id' in params) || ('stop_order_status' in params)) {
                let stopOrderStatus = this.safeValue (params, 'stop_order_status');
                if (stopOrderStatus !== undefined) {
                    if (Array.isArray (stopOrderStatus)) {
                        stopOrderStatus = stopOrderStatus.join (',');
                    }
                    request['stop_order_status'] = stopOrderStatus;
                    query = this.omit (params, 'stop_order_status');
                }
                if (linear) {
                    defaultMethod = 'privateLinearGetStopOrderList';
                } else if (inverse) {
                    defaultMethod = 'v2PrivateGetStopOrderList';
                } else if (futures) {
                    defaultMethod = 'futuresPrivateGetStopOrderList';
                }
            }
            const method = this.safeString (options, 'method', defaultMethod);
            const response = await this[method] (this.extend (request, query));
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": {
            //             "current_page": 1,
            //             "last_page": 6,
            //             "data": [
            //                 {
            //                     "user_id": 1,
            //                     "symbol": "BTCUSD",
            //                     "side": "Sell",
            //                     "order_type": "Market",
            //                     "price": 7074,
            //                     "qty": 2,
            //                     "time_in_force": "ImmediateOrCancel",
            //                     "order_status": "Filled",
            //                     "ext_fields": {
            //                         "close_on_trigger": true,
            //                         "orig_order_type": "BLimit",
            //                         "prior_x_req_price": 5898.5,
            //                         "op_from": "pc",
            //                         "remark": "127.0.0.1",
            //                         "o_req_num": -34799032763,
            //                         "xreq_type": "x_create"
            //                     },
            //                     "last_exec_time": "1577448481.696421",
            //                     "last_exec_price": 7070.5,
            //                     "leaves_qty": 0,
            //                     "leaves_value": 0,
            //                     "cum_exec_qty": 2,
            //                     "cum_exec_value": 0.00028283,
            //                     "cum_exec_fee": 0.00002,
            //                     "reject_reason": "NoError",
            //                     "order_link_id": "",
            //                     "created_at": "2019-12-27T12:08:01.000Z",
            //                     "updated_at": "2019-12-27T12:08:01.000Z",
            //                     "order_id": "f185806b-b801-40ff-adec-52289370ed62"
            //                 }
            //             ]
            //         },
            //         "ext_info": null,
            //         "time_now": "1577448922.437871",
            //         "rate_limit_status": 98,
            //         "rate_limit_reset_ms": 1580885703683,
            //         "rate_limit": 100
            //     }
            //
            // conditional orders
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": {
            //             "current_page": 1,
            //             "last_page": 1,
            //             "data": [
            //                 {
            //                     "user_id": 1,
            //                     "stop_order_status": "Untriggered",
            //                     "symbol": "BTCUSD",
            //                     "side": "Buy",
            //                     "order_type": "Limit",
            //                     "price": 8000,
            //                     "qty": 1,
            //                     "time_in_force": "GoodTillCancel",
            //                     "stop_order_type": "Stop",
            //                     "trigger_by": "LastPrice",
            //                     "base_price": 7000,
            //                     "order_link_id": "",
            //                     "created_at": "2019-12-27T12:48:24.000Z",
            //                     "updated_at": "2019-12-27T12:48:24.000Z",
            //                     "stop_px": 7500,
            //                     "stop_order_id": "a85cd1c0-a9a4-49d3-a1bd-bab5ebe946d5"
            //                 },
            //             ]
            //         },
            //         "ext_info": null,
            //         "time_now": "1577451658.755468",
            //         "rate_limit_status": 599,
            //         "rate_limit_reset_ms": 1577451658762,
            //         "rate_limit": 600
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const defaultStatuses = [
                'Rejected',
                'Filled',
                'Cancelled',
                // conditional orders
                // 'Active',
                // 'Triggered',
                // 'Cancelled',
                // 'Rejected',
                // 'Deactivated',
            ];
            const options = this.safeValue (this.options, 'fetchClosedOrders', {});
            let status = this.safeValue (options, 'order_status', defaultStatuses);
            if (Array.isArray (status)) {
                status = status.join (',');
            }
            const request = {};
            const stopOrderStatus = this.safeValue (params, 'stop_order_status');
            if (stopOrderStatus === undefined) {
                request['order_status'] = status;
            } else {
                request['stop_order_status'] = stopOrderStatus;
            }
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const defaultStatuses = [
                'Created',
                'New',
                'PartiallyFilled',
                'PendingCancel',
                // conditional orders
                // 'Untriggered',
            ];
            const options = this.safeValue (this.options, 'fetchOpenOrders', {});
            let status = this.safeValue (options, 'order_status', defaultStatuses);
            if (Array.isArray (status)) {
                status = status.join (',');
            }
            const request = {};
            const stopOrderStatus = this.safeValue (params, 'stop_order_status');
            if (stopOrderStatus === undefined) {
                request['order_status'] = status;
            } else {
                request['stop_order_status'] = stopOrderStatus;
            }
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'order_id': id,
            };
            return await this.fetchMyTrades (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'order_id': 'f185806b-b801-40ff-adec-52289370ed62', // if not provided will return user's trading records
                // 'symbol': market['id'],
                // 'start_time': parseInt (since / 1000),
                // 'page': 1,
                // 'limit' 20, // max 50
            };
            let market = undefined;
            if (symbol === undefined) {
                const orderId = this.safeString (params, 'order_id');
                if (orderId === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument or an order_id param');
                } else {
                    request['order_id'] = orderId;
                    params = this.omit (params, 'order_id');
                }
            } else {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['start_time'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 20, max 50
            }
            const defaultType = this.safeString (this.options, 'defaultType', 'linear');
            const marketTypes = this.safeValue (this.options, 'marketTypes', {});
            const marketType = this.safeString (marketTypes, symbol, defaultType);
            const marketDefined = (market !== undefined);
            const linear = (marketDefined && market['linear']) || (marketType === 'linear');
            const inverse = (marketDefined && market['swap'] && market['inverse']) || (marketType === 'inverse');
            const futures = (marketDefined && market['futures']) || (marketType === 'futures');
            let method = undefined;
            if (linear) {
                method = 'privateLinearGetTradeExecutionList';
            } else if (inverse) {
                method = 'v2PrivateGetExecutionList';
            } else if (futures) {
                method = 'futuresPrivateGetExecutionList';
            }
            const response = await this[method] (this.extend (request, params));
            //
            // inverse
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "OK",
            //         "ext_code": "",
            //         "ext_info": "",
            //         "result": {
            //             "order_id": "Abandoned!!", // Abandoned!!
            //             "trade_list": [
            //                 {
            //                     "closed_size": 0,
            //                     "cross_seq": 277136382,
            //                     "exec_fee": "0.0000001",
            //                     "exec_id": "256e5ef8-abfe-5772-971b-f944e15e0d68",
            //                     "exec_price": "8178.5",
            //                     "exec_qty": 1,
            //                     "exec_time": "1571676941.70682",
            //                     "exec_type": "Trade", //Exec Type Enum
            //                     "exec_value": "0.00012227",
            //                     "fee_rate": "0.00075",
            //                     "last_liquidity_ind": "RemovedLiquidity", //Liquidity Enum
            //                     "leaves_qty": 0,
            //                     "nth_fill": 2,
            //                     "order_id": "7ad50cb1-9ad0-4f74-804b-d82a516e1029",
            //                     "order_link_id": "",
            //                     "order_price": "8178",
            //                     "order_qty": 1,
            //                     "order_type": "Market", //Order Type Enum
            //                     "side": "Buy", //Side Enum
            //                     "symbol": "BTCUSD", //Symbol Enum
            //                     "user_id": 1
            //                 }
            //             ]
            //         },
            //         "time_now": "1577483699.281488",
            //         "rate_limit_status": 118,
            //         "rate_limit_reset_ms": 1577483699244737,
            //         "rate_limit": 120
            //     }
            //
            // linear
            //
            //     {
            //         "ret_code":0,
            //         "ret_msg":"OK",
            //         "ext_code":"",
            //         "ext_info":"",
            //         "result":{
            //             "current_page":1,
            //             "data":[
            //                 {
            //                     "order_id":"b59418ec-14d4-4ef9-b9f4-721d5d576974",
            //                     "order_link_id":"",
            //                     "side":"Sell",
            //                     "symbol":"BTCUSDT",
            //                     "exec_id":"0327284d-faec-5191-bd89-acc5b4fafda9",
            //                     "price":0.5,
            //                     "order_price":0.5,
            //                     "order_qty":0.01,
            //                     "order_type":"Market",
            //                     "fee_rate":0.00075,
            //                     "exec_price":9709.5,
            //                     "exec_type":"Trade",
            //                     "exec_qty":0.01,
            //                     "exec_fee":0.07282125,
            //                     "exec_value":97.095,
            //                     "leaves_qty":0,
            //                     "closed_size":0.01,
            //                     "last_liquidity_ind":"RemovedLiquidity",
            //                     "trade_time":1591648052,
            //                     "trade_time_ms":1591648052861
            //                 }
            //             ]
            //         },
            //         "time_now":"1591736501.979264",
            //         "rate_limit_status":119,
            //         "rate_limit_reset_ms":1591736501974,
            //         "rate_limit":120
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const trades = this.safeValue2 (result, 'trade_list', 'data', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'coin': currency['id'],
                // 'currency': currency['id'], // alias
                // 'start_date': this.iso8601 (since),
                // 'end_date': this.iso8601 (till),
                'wallet_fund_type': 'Deposit', // Deposit, Withdraw, RealisedPNL, Commission, Refund, Prize, ExchangeOrderWithdraw, ExchangeOrderDeposit
                // 'page': 1,
                // 'limit': 20, // max 50
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['coin'] = currency['id'];
            }
            if (since !== undefined) {
                request['start_date'] = this.ymd (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.v2PrivateGetWalletFundRecords (this.extend (request, params));
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": {
            //             "data": [
            //                 {
            //                     "id": 234467,
            //                     "user_id": 1,
            //                     "coin": "BTC",
            //                     "wallet_id": 27913,
            //                     "type": "Realized P&L",
            //                     "amount": "-0.00000006",
            //                     "tx_id": "",
            //                     "address": "BTCUSD",
            //                     "wallet_balance": "0.03000330",
            //                     "exec_time": "2019-12-09T00:00:25.000Z",
            //                     "cross_seq": 0
            //                 }
            //             ]
            //         },
            //         "ext_info": null,
            //         "time_now": "1577481867.115552",
            //         "rate_limit_status": 119,
            //         "rate_limit_reset_ms": 1577481867122,
            //         "rate_limit": 120
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseTransactions (data, currency, since, limit, { 'type': 'deposit' });
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'coin': currency['id'],
                // 'start_date': this.iso8601 (since),
                // 'end_date': this.iso8601 (till),
                // 'status': 'Pending', // ToBeConfirmed, UnderReview, Pending, Success, CancelByUser, Reject, Expire
                // 'page': 1,
                // 'limit': 20, // max 50
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['coin'] = currency['id'];
            }
            if (since !== undefined) {
                request['start_date'] = this.ymd (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.v2PrivateGetWalletWithdrawList (this.extend (request, params));
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": {
            //             "data": [
            //                 {
            //                     "id": 137,
            //                     "user_id": 1,
            //                     "coin": "XRP", // Coin Enum
            //                     "status": "Pending", // Withdraw Status Enum
            //                     "amount": "20.00000000",
            //                     "fee": "0.25000000",
            //                     "address": "rH7H595XYEVTEHU2FySYsWnmfACBnZS9zM",
            //                     "tx_id": "",
            //                     "submited_at": "2019-06-11T02:20:24.000Z",
            //                     "updated_at": "2019-06-11T02:20:24.000Z"
            //                 },
            //             ],
            //             "current_page": 1,
            //             "last_page": 1
            //         },
            //         "ext_info": null,
            //         "time_now": "1577482295.125488",
            //         "rate_limit_status": 119,
            //         "rate_limit_reset_ms": 1577482295132,
            //         "rate_limit": 120
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseTransactions (data, currency, since, limit, { 'type': 'withdrawal' });
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'ToBeConfirmed': 'pending',
                'UnderReview': 'pending',
                'Pending': 'pending',
                'Success': 'ok',
                'CancelByUser': 'canceled',
                'Reject': 'rejected',
                'Expire': 'expired',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchWithdrawals
            //
            //     {
            //         "id": 137,
            //         "user_id": 1,
            //         "coin": "XRP", // Coin Enum
            //         "status": "Pending", // Withdraw Status Enum
            //         "amount": "20.00000000",
            //         "fee": "0.25000000",
            //         "address": "rH7H595XYEVTEHU2FySYsWnmfACBnZS9zM",
            //         "tx_id": "",
            //         "submited_at": "2019-06-11T02:20:24.000Z",
            //         "updated_at": "2019-06-11T02:20:24.000Z"
            //     }
            //
            // fetchDeposits ledger entries
            //
            //     {
            //         "id": 234467,
            //         "user_id": 1,
            //         "coin": "BTC",
            //         "wallet_id": 27913,
            //         "type": "Realized P&L",
            //         "amount": "-0.00000006",
            //         "tx_id": "",
            //         "address": "BTCUSD",
            //         "wallet_balance": "0.03000330",
            //         "exec_time": "2019-12-09T00:00:25.000Z",
            //         "cross_seq": 0
            //     }
            //
            const currencyId = this.safeString (transaction, 'coin');
            const code = this.safeCurrencyCode (currencyId, currency);
            const timestamp = this.parse8601 (this.safeString2 (transaction, 'submited_at', 'exec_time'));
            const updated = this.parse8601 (this.safeString (transaction, 'updated_at'));
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const address = this.safeString (transaction, 'address');
            const feeCost = this.safeNumber (transaction, 'fee');
            const type = this.safeStringLower (transaction, 'type');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': code,
                };
            }
            return {
                'info': transaction,
                'id': this.safeString (transaction, 'id'),
                'txid': this.safeString (transaction, 'tx_id'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'addressTo': undefined,
                'addressFrom': undefined,
                'tag': undefined,
                'tagTo': undefined,
                'tagFrom': undefined,
                'type': type,
                'amount': this.safeNumber (transaction, 'amount'),
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'coin': currency['id'],
                // 'currency': currency['id'], // alias
                // 'start_date': this.iso8601 (since),
                // 'end_date': this.iso8601 (till),
                // 'wallet_fund_type': 'Deposit', // Withdraw, RealisedPNL, Commission, Refund, Prize, ExchangeOrderWithdraw, ExchangeOrderDeposit
                // 'page': 1,
                // 'limit': 20, // max 50
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['coin'] = currency['id'];
            }
            if (since !== undefined) {
                request['start_date'] = this.ymd (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.v2PrivateGetWalletFundRecords (this.extend (request, params));
            //
            //     {
            //         "ret_code": 0,
            //         "ret_msg": "ok",
            //         "ext_code": "",
            //         "result": {
            //             "data": [
            //                 {
            //                     "id": 234467,
            //                     "user_id": 1,
            //                     "coin": "BTC",
            //                     "wallet_id": 27913,
            //                     "type": "Realized P&L",
            //                     "amount": "-0.00000006",
            //                     "tx_id": "",
            //                     "address": "BTCUSD",
            //                     "wallet_balance": "0.03000330",
            //                     "exec_time": "2019-12-09T00:00:25.000Z",
            //                     "cross_seq": 0
            //                 }
            //             ]
            //         },
            //         "ext_info": null,
            //         "time_now": "1577481867.115552",
            //         "rate_limit_status": 119,
            //         "rate_limit_reset_ms": 1577481867122,
            //         "rate_limit": 120
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseLedger (data, currency, since, limit);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //     {
            //         "id": 234467,
            //         "user_id": 1,
            //         "coin": "BTC",
            //         "wallet_id": 27913,
            //         "type": "Realized P&L",
            //         "amount": "-0.00000006",
            //         "tx_id": "",
            //         "address": "BTCUSD",
            //         "wallet_balance": "0.03000330",
            //         "exec_time": "2019-12-09T00:00:25.000Z",
            //         "cross_seq": 0
            //     }
            //
            const currencyId = this.safeString (item, 'coin');
            const code = this.safeCurrencyCode (currencyId, currency);
            const amount = this.safeNumber (item, 'amount');
            const after = this.safeNumber (item, 'wallet_balance');
            const direction = (amount < 0) ? 'out' : 'in';
            let before = undefined;
            if (after !== undefined && amount !== undefined) {
                const difference = (direction === 'out') ? amount : -amount;
                before = this.sum (after, difference);
            }
            const timestamp = this.parse8601 (this.safeString (item, 'exec_time'));
            const type = this.parseLedgerEntryType (this.safeString (item, 'type'));
            const id = this.safeString (item, 'id');
            const referenceId = this.safeString (item, 'tx_id');
            return {
                'id': id,
                'currency': code,
                'account': this.safeString (item, 'wallet_id'),
                'referenceAccount': undefined,
                'referenceId': referenceId,
                'status': undefined,
                'amount': amount,
                'before': before,
                'after': after,
                'fee': undefined,
                'direction': direction,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'type': type,
                'info': item,
            };
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'Deposit': 'transaction',
                'Withdraw': 'transaction',
                'RealisedPNL': 'trade',
                'Commission': 'fee',
                'Refund': 'cashback',
                'Prize': 'prize', // ?
                'ExchangeOrderWithdraw': 'transaction',
                'ExchangeOrderDeposit': 'transaction',
            };
            return this.safeString (types, type, type);
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (Array.isArray (symbols)) {
                const length = symbols.length;
                if (length !== 1) {
                    throw new ArgumentsRequired (this.id + ' fetchPositions takes an array with exactly one symbol');
                }
                request['symbol'] = this.marketId (symbols[0]);
            }
            const defaultType = this.safeString (this.options, 'defaultType', 'linear');
            const type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            let response = undefined;
            if (type === 'linear') {
                response = await this.privateLinearGetPositionList (this.extend (request, params));
            } else if (type === 'inverse') {
                response = await this.v2PrivateGetPositionList (this.extend (request, params));
            } else if (type === 'inverseFuture') {
                response = await this.futuresPrivateGetPositionList (this.extend (request, params));
            }
            if ((typeof response === 'string') && this.isJsonEncodedObject (response)) {
                response = JSON.parse (response);
            }
            //
            //     {
            //         ret_code: 0,
            //         ret_msg: 'OK',
            //         ext_code: '',
            //         ext_info: '',
            //         result: [] or {} depending on the request
            //     }
            //
            return this.safeValue (response, 'result');
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const type = this.safeString (api, 0);
            const section = this.safeString (api, 1);
            let url = this.implodeHostname (this.urls['api'][type]);
            let request = '/' + type + '/' + section + '/' + path;
            // public v2
            if (section === 'public') {
                if (Object.keys (params).length) {
                    request += '?' + this.rawencode (params);
                }
            } else if (type === 'public') {
                if (Object.keys (params).length) {
                    request += '?' + this.rawencode (params);
                }
            } else {
                this.checkRequiredCredentials ();
                const timestamp = this.nonce ();
                const query = this.extend (params, {
                    'api_key': this.apiKey,
                    'recv_window': this.options['recvWindow'],
                    'timestamp': timestamp,
                });
                const sortedQuery = this.keysort (query);
                const auth = this.rawencode (sortedQuery);
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                if (method === 'POST') {
                    body = this.json (this.extend (query, {
                        'sign': signature,
                    }));
                    headers = {
                        'Content-Type': 'application/json',
                    };
                } else {
                    request += '?' + this.urlencode (sortedQuery) + '&sign=' + signature;
                }
            }
            url += request;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (!response) {
                return; // fallback to default error handler
            }
            //
            //     {
            //         ret_code: 10001,
            //         ret_msg: 'ReadMapCB: expect { or n, but found \u0000, error ' +
            //         'found in #0 byte of ...||..., bigger context ' +
            //         '...||...',
            //         ext_code: '',
            //         ext_info: '',
            //         result: null,
            //         time_now: '1583934106.590436'
            //     }
            //
            const errorCode = this.safeString (response, 'ret_code');
            if (errorCode !== '0') {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], body, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],57:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const huobipro = require ('./huobipro.js');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class cdax extends huobipro {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'cdax',
                'name': 'CDAX',
                'countries': [ 'RU' ],
                'hostname': 'cdax.io',
                'pro': false,
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/102157692-fd406280-3e90-11eb-8d46-4511b617cd17.jpg',
                    'api': {
                        'market': 'https://{hostname}/api',
                        'public': 'https://{hostname}/api',
                        'private': 'https://{hostname}/api',
                        'v2Public': 'https://{hostname}/api',
                        'v2Private': 'https://{hostname}/api',
                    },
                    'www': 'https://cdax.io',
                    'referral': 'https://cdax.io/invite?invite_code=esc74',
                    'doc': 'https://github.com/cloudapidoc/API_Docs',
                    'fees': 'https://cdax.io/about/fee',
                },
            });
        }
    };
    
    },{"./huobipro.js":89}],58:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, AuthenticationError, NullResponse, InvalidOrder, NotSupported, InsufficientFunds, InvalidNonce, OrderNotFound, RateLimitExceeded, DDoSProtection } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class cex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'cex',
                'name': 'CEX.IO',
                'countries': [ 'GB', 'EU', 'CY', 'RU' ],
                'rateLimit': 1500,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchMarkets': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                },
                'timeframes': {
                    '1m': '1m',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766442-8ddc33b0-5ed8-11e7-8b98-f786aef0f3c9.jpg',
                    'api': 'https://cex.io/api',
                    'www': 'https://cex.io',
                    'doc': 'https://cex.io/cex-api',
                    'fees': [
                        'https://cex.io/fee-schedule',
                        'https://cex.io/limits-commissions',
                    ],
                    'referral': 'https://cex.io/r/0/up105393824/0/',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'uid': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'currency_profile',
                            'currency_limits/',
                            'last_price/{pair}/',
                            'last_prices/{currencies}/',
                            'ohlcv/hd/{yyyymmdd}/{pair}',
                            'order_book/{pair}/',
                            'ticker/{pair}/',
                            'tickers/{currencies}/',
                            'trade_history/{pair}/',
                        ],
                        'post': [
                            'convert/{pair}',
                            'price_stats/{pair}',
                        ],
                    },
                    'private': {
                        'post': [
                            'active_orders_status/',
                            'archived_orders/{pair}/',
                            'balance/',
                            'cancel_order/',
                            'cancel_orders/{pair}/',
                            'cancel_replace_order/{pair}/',
                            'close_position/{pair}/',
                            'get_address/',
                            'get_myfee/',
                            'get_order/',
                            'get_order_tx/',
                            'open_orders/{pair}/',
                            'open_orders/',
                            'open_position/{pair}/',
                            'open_positions/{pair}/',
                            'place_order/{pair}/',
                            'raw_tx_history',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.0016'),
                        'taker': this.parseNumber ('0.0025'),
                    },
                    'funding': {
                        'withdraw': {},
                        'deposit': {
                            // 'USD': amount => amount * 0.035 + 0.25,
                            // 'EUR': amount => amount * 0.035 + 0.24,
                            // 'RUB': amount => amount * 0.05 + 15.57,
                            // 'GBP': amount => amount * 0.035 + 0.2,
                            'BTC': 0.0,
                            'ETH': 0.0,
                            'BCH': 0.0,
                            'DASH': 0.0,
                            'BTG': 0.0,
                            'ZEC': 0.0,
                            'XRP': 0.0,
                            'XLM': 0.0,
                        },
                    },
                },
                'exceptions': {
                    'exact': {},
                    'broad': {
                        'Insufficient funds': InsufficientFunds,
                        'Nonce must be incremented': InvalidNonce,
                        'Invalid Order': InvalidOrder,
                        'Order not found': OrderNotFound,
                        'limit exceeded': RateLimitExceeded, // {"error":"rate limit exceeded"}
                        'Invalid API key': AuthenticationError,
                        'There was an error while placing your order': InvalidOrder,
                        'Sorry, too many clients already': DDoSProtection,
                    },
                },
                'options': {
                    'fetchOHLCVWarning': true,
                    'createMarketBuyOrderRequiresPrice': true,
                    'order': {
                        'status': {
                            'c': 'canceled',
                            'd': 'closed',
                            'cd': 'canceled',
                            'a': 'open',
                        },
                    },
                },
            });
        }
    
        async fetchCurrenciesFromCache (params = {}) {
            // this method is now redundant
            // currencies are now fetched before markets
            const options = this.safeValue (this.options, 'fetchCurrencies', {});
            const timestamp = this.safeInteger (options, 'timestamp');
            const expires = this.safeInteger (options, 'expires', 1000);
            const now = this.milliseconds ();
            if ((timestamp === undefined) || ((now - timestamp) > expires)) {
                const response = await this.publicGetCurrencyProfile (params);
                this.options['fetchCurrencies'] = this.extend (options, {
                    'response': response,
                    'timestamp': now,
                });
            }
            return this.safeValue (this.options['fetchCurrencies'], 'response');
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.fetchCurrenciesFromCache (params);
            this.options['currencies'] = {
                'timestamp': this.milliseconds (),
                'response': response,
            };
            //
            //     {
            //         "e":"currency_profile",
            //         "ok":"ok",
            //         "data":{
            //             "symbols":[
            //                 {
            //                     "code":"GHS",
            //                     "contract":true,
            //                     "commodity":true,
            //                     "fiat":false,
            //                     "description":"CEX.IO doesn't provide cloud mining services anymore.",
            //                     "precision":8,
            //                     "scale":0,
            //                     "minimumCurrencyAmount":"0.00000001",
            //                     "minimalWithdrawalAmount":-1
            //                 },
            //                 {
            //                     "code":"BTC",
            //                     "contract":false,
            //                     "commodity":false,
            //                     "fiat":false,
            //                     "description":"",
            //                     "precision":8,
            //                     "scale":0,
            //                     "minimumCurrencyAmount":"0.00000001",
            //                     "minimalWithdrawalAmount":0.002
            //                 },
            //                 {
            //                     "code":"ETH",
            //                     "contract":false,
            //                     "commodity":false,
            //                     "fiat":false,
            //                     "description":"",
            //                     "precision":8,
            //                     "scale":2,
            //                     "minimumCurrencyAmount":"0.00000100",
            //                     "minimalWithdrawalAmount":0.01
            //                 }
            //             ],
            //             "pairs":[
            //                 {
            //                     "symbol1":"BTC",
            //                     "symbol2":"USD",
            //                     "pricePrecision":1,
            //                     "priceScale":"/1000000",
            //                     "minLotSize":0.002,
            //                     "minLotSizeS2":20
            //                 },
            //                 {
            //                     "symbol1":"ETH",
            //                     "symbol2":"USD",
            //                     "pricePrecision":2,
            //                     "priceScale":"/10000",
            //                     "minLotSize":0.1,
            //                     "minLotSizeS2":20
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const currencies = this.safeValue (data, 'symbols', []);
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                const id = this.safeString (currency, 'code');
                const code = this.safeCurrencyCode (id);
                const precision = this.safeInteger (currency, 'precision');
                const active = true;
                result[code] = {
                    'id': id,
                    'code': code,
                    'name': id,
                    'active': active,
                    'precision': precision,
                    'fee': undefined,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (currency, 'minimumCurrencyAmount'),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'minimalWithdrawalAmount'),
                            'max': undefined,
                        },
                    },
                    'info': currency,
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const currenciesResponse = await this.fetchCurrenciesFromCache (params);
            const currenciesData = this.safeValue (currenciesResponse, 'data', {});
            const currencies = this.safeValue (currenciesData, 'symbols', []);
            const currenciesById = this.indexBy (currencies, 'code');
            const pairs = this.safeValue (currenciesData, 'pairs', []);
            const response = await this.publicGetCurrencyLimits (params);
            //
            //     {
            //         "e":"currency_limits",
            //         "ok":"ok",
            //         "data": {
            //             "pairs":[
            //                 {
            //                     "symbol1":"BTC",
            //                     "symbol2":"USD",
            //                     "minLotSize":0.002,
            //                     "minLotSizeS2":20,
            //                     "maxLotSize":30,
            //                     "minPrice":"1500",
            //                     "maxPrice":"35000"
            //                 },
            //                 {
            //                     "symbol1":"BCH",
            //                     "symbol2":"EUR",
            //                     "minLotSize":0.1,
            //                     "minLotSizeS2":20,
            //                     "maxLotSize":null,
            //                     "minPrice":"25",
            //                     "maxPrice":"8192"
            //                 }
            //             ]
            //         }
            //     }
            //
            const result = [];
            const markets = this.safeValue (response['data'], 'pairs');
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const baseId = this.safeString (market, 'symbol1');
                const quoteId = this.safeString (market, 'symbol2');
                const id = baseId + '/' + quoteId;
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const baseCurrency = this.safeValue (currenciesById, baseId, {});
                const quoteCurrency = this.safeValue (currenciesById, quoteId, {});
                let pricePrecision = this.safeInteger (quoteCurrency, 'precision', 8);
                for (let j = 0; j < pairs.length; j++) {
                    const pair = pairs[j];
                    if ((pair['symbol1'] === baseId) && (pair['symbol2'] === quoteId)) {
                        // we might need to account for `priceScale` here
                        pricePrecision = this.safeInteger (pair, 'pricePrecision', pricePrecision);
                    }
                }
                const baseCcyPrecision = this.safeInteger (baseCurrency, 'precision', 8);
                const baseCcyScale = this.safeInteger (baseCurrency, 'scale', 0);
                const amountPrecision = baseCcyPrecision - baseCcyScale;
                const precision = {
                    'amount': amountPrecision,
                    'price': pricePrecision,
                };
                result.push ({
                    'id': id,
                    'info': market,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'minLotSize'),
                            'max': this.safeNumber (market, 'maxLotSize'),
                        },
                        'price': {
                            'min': this.safeNumber (market, 'minPrice'),
                            'max': this.safeNumber (market, 'maxPrice'),
                        },
                        'cost': {
                            'min': this.safeNumber (market, 'minLotSizeS2'),
                            'max': undefined,
                        },
                    },
                    'active': undefined,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostBalance (params);
            const result = { 'info': response };
            const ommited = [ 'username', 'timestamp' ];
            const balances = this.omit (response, ommited);
            const currencyIds = Object.keys (balances);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const balance = this.safeValue (balances, currencyId, {});
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                // https://github.com/ccxt/ccxt/issues/5484
                account['used'] = this.safeString (balance, 'orders', '0');
                const code = this.safeCurrencyCode (currencyId);
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
            };
            if (limit !== undefined) {
                request['depth'] = limit;
            }
            const response = await this.publicGetOrderBookPair (this.extend (request, params));
            const timestamp = this.safeTimestamp (response, 'timestamp');
            return this.parseOrderBook (response, symbol, timestamp);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1591403940,
            //         0.024972,
            //         0.024972,
            //         0.024969,
            //         0.024969,
            //         0.49999900
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (since === undefined) {
                since = this.milliseconds () - 86400000; // yesterday
            } else {
                if (this.options['fetchOHLCVWarning']) {
                    throw new ExchangeError (this.id + " fetchOHLCV warning: CEX can return historical candles for a certain date only, this might produce an empty or null reply. Set exchange.options['fetchOHLCVWarning'] = false or add ({ 'options': { 'fetchOHLCVWarning': false }}) to constructor params to suppress this warning message.");
                }
            }
            let ymd = this.ymd (since);
            ymd = ymd.split ('-');
            ymd = ymd.join ('');
            const request = {
                'pair': market['id'],
                'yyyymmdd': ymd,
            };
            try {
                const response = await this.publicGetOhlcvHdYyyymmddPair (this.extend (request, params));
                //
                //     {
                //         "time":20200606,
                //         "data1m":"[[1591403940,0.024972,0.024972,0.024969,0.024969,0.49999900]]",
                //     }
                //
                const key = 'data' + this.timeframes[timeframe];
                const data = this.safeString (response, key);
                const ohlcvs = JSON.parse (data);
                return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
            } catch (e) {
                if (e instanceof NullResponse) {
                    return [];
                }
            }
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.safeTimestamp (ticker, 'timestamp');
            const volume = this.safeNumber (ticker, 'volume');
            const high = this.safeNumber (ticker, 'high');
            const low = this.safeNumber (ticker, 'low');
            const bid = this.safeNumber (ticker, 'bid');
            const ask = this.safeNumber (ticker, 'ask');
            const last = this.safeNumber (ticker, 'last');
            let symbol = undefined;
            if (market) {
                symbol = market['symbol'];
            }
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': high,
                'low': low,
                'bid': bid,
                'bidVolume': undefined,
                'ask': ask,
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': volume,
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const currencies = Object.keys (this.currencies);
            const request = {
                'currencies': currencies.join ('/'),
            };
            const response = await this.publicGetTickersCurrencies (this.extend (request, params));
            const tickers = response['data'];
            const result = {};
            for (let t = 0; t < tickers.length; t++) {
                const ticker = tickers[t];
                const symbol = ticker['pair'].replace (':', '/');
                const market = this.markets[symbol];
                result[symbol] = this.parseTicker (ticker, market);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const ticker = await this.publicGetTickerPair (this.extend (request, params));
            return this.parseTicker (ticker, market);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeTimestamp (trade, 'date');
            const id = this.safeString (trade, 'tid');
            const type = undefined;
            const side = this.safeString (trade, 'type');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'order': undefined,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetTradeHistoryPair (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            // for market buy it requires the amount of quote currency to spend
            if ((type === 'market') && (side === 'buy')) {
                if (this.options['createMarketBuyOrderRequiresPrice']) {
                    if (price === undefined) {
                        throw new InvalidOrder (this.id + " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");
                    } else {
                        amount = amount * price;
                    }
                }
            }
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
                'type': side,
                'amount': amount,
            };
            if (type === 'limit') {
                request['price'] = price;
            } else {
                request['order_type'] = type;
            }
            const response = await this.privatePostPlaceOrderPair (this.extend (request, params));
            //
            //     {
            //         "id": "12978363524",
            //         "time": 1586610022259,
            //         "type": "buy",
            //         "price": "0.033934",
            //         "amount": "0.10722802",
            //         "pending": "0.10722802",
            //         "complete": false
            //     }
            //
            const placedAmount = this.safeNumber (response, 'amount');
            const remaining = this.safeNumber (response, 'pending');
            const timestamp = this.safeValue (response, 'time');
            const complete = this.safeValue (response, 'complete');
            const status = complete ? 'closed' : 'open';
            let filled = undefined;
            if ((placedAmount !== undefined) && (remaining !== undefined)) {
                filled = Math.max (placedAmount - remaining, 0);
            }
            return {
                'id': this.safeString (response, 'id'),
                'info': response,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'type': type,
                'side': this.safeString (response, 'type'),
                'symbol': symbol,
                'status': status,
                'price': this.safeNumber (response, 'price'),
                'amount': placedAmount,
                'cost': undefined,
                'average': undefined,
                'remaining': remaining,
                'filled': filled,
                'fee': undefined,
                'trades': undefined,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            return await this.privatePostCancelOrder (this.extend (request, params));
        }
    
        parseOrder (order, market = undefined) {
            // Depending on the call, 'time' can be a unix int, unix string or ISO string
            // Yes, really
            let timestamp = this.safeValue (order, 'time');
            if (typeof timestamp === 'string' && timestamp.indexOf ('T') >= 0) {
                // ISO8601 string
                timestamp = this.parse8601 (timestamp);
            } else {
                // either integer or string integer
                timestamp = parseInt (timestamp);
            }
            let symbol = undefined;
            if (market === undefined) {
                const baseId = this.safeString (order, 'symbol1');
                const quoteId = this.safeString (order, 'symbol2');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                symbol = base + '/' + quote;
                if (symbol in this.markets) {
                    market = this.market (symbol);
                }
            }
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const price = this.safeNumber (order, 'price');
            let amount = this.safeNumber (order, 'amount');
            // sell orders can have a negative amount
            // https://github.com/ccxt/ccxt/issues/5338
            if (amount !== undefined) {
                amount = Math.abs (amount);
            }
            const remaining = this.safeNumber2 (order, 'pending', 'remains');
            const filled = amount - remaining;
            let fee = undefined;
            let cost = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
                const taCost = this.safeNumber (order, 'ta:' + market['quote']);
                const ttaCost = this.safeNumber (order, 'tta:' + market['quote']);
                cost = this.sum (taCost, ttaCost);
                const baseFee = 'fa:' + market['base'];
                const baseTakerFee = 'tfa:' + market['base'];
                const quoteFee = 'fa:' + market['quote'];
                const quoteTakerFee = 'tfa:' + market['quote'];
                let feeRate = this.safeNumber (order, 'tradingFeeMaker');
                if (!feeRate) {
                    feeRate = this.safeNumber (order, 'tradingFeeTaker', feeRate);
                }
                if (feeRate) {
                    feeRate /= 100.0; // convert to mathematically-correct percentage coefficients: 1.0 = 100%
                }
                if ((baseFee in order) || (baseTakerFee in order)) {
                    const baseFeeCost = this.safeNumber2 (order, baseFee, baseTakerFee);
                    fee = {
                        'currency': market['base'],
                        'rate': feeRate,
                        'cost': baseFeeCost,
                    };
                } else if ((quoteFee in order) || (quoteTakerFee in order)) {
                    const quoteFeeCost = this.safeNumber2 (order, quoteFee, quoteTakerFee);
                    fee = {
                        'currency': market['quote'],
                        'rate': feeRate,
                        'cost': quoteFeeCost,
                    };
                }
            }
            if (!cost) {
                cost = price * filled;
            }
            const side = order['type'];
            let trades = undefined;
            const orderId = order['id'];
            if ('vtx' in order) {
                trades = [];
                for (let i = 0; i < order['vtx'].length; i++) {
                    const item = order['vtx'][i];
                    const tradeSide = this.safeString (item, 'type');
                    if (tradeSide === 'cancel') {
                        // looks like this might represent the cancelled part of an order
                        //   { id: '4426729543',
                        //     type: 'cancel',
                        //     time: '2017-09-22T00:24:30.476Z',
                        //     user: 'up106404164',
                        //     c: 'user:up106404164:a:BCH',
                        //     d: 'order:4426728375:a:BCH',
                        //     a: '0.09935956',
                        //     amount: '0.09935956',
                        //     balance: '0.42580261',
                        //     symbol: 'BCH',
                        //     order: '4426728375',
                        //     buy: null,
                        //     sell: null,
                        //     pair: null,
                        //     pos: null,
                        //     cs: '0.42580261',
                        //     ds: 0 }
                        continue;
                    }
                    const tradePrice = this.safeNumber (item, 'price');
                    if (tradePrice === undefined) {
                        // this represents the order
                        //   {
                        //     "a": "0.47000000",
                        //     "c": "user:up106404164:a:EUR",
                        //     "d": "order:6065499239:a:EUR",
                        //     "cs": "1432.93",
                        //     "ds": "476.72",
                        //     "id": "6065499249",
                        //     "buy": null,
                        //     "pos": null,
                        //     "pair": null,
                        //     "sell": null,
                        //     "time": "2018-04-22T13:07:22.152Z",
                        //     "type": "buy",
                        //     "user": "up106404164",
                        //     "order": "6065499239",
                        //     "amount": "-715.97000000",
                        //     "symbol": "EUR",
                        //     "balance": "1432.93000000" }
                        continue;
                    }
                    // todo: deal with these
                    if (tradeSide === 'costsNothing') {
                        continue;
                    }
                    // --
                    // if (side !== tradeSide)
                    //     throw new Error (JSON.stringify (order, null, 2));
                    // if (orderId !== item['order'])
                    //     throw new Error (JSON.stringify (order, null, 2));
                    // --
                    // partial buy trade
                    //   {
                    //     "a": "0.01589885",
                    //     "c": "user:up106404164:a:BTC",
                    //     "d": "order:6065499239:a:BTC",
                    //     "cs": "0.36300000",
                    //     "ds": 0,
                    //     "id": "6067991213",
                    //     "buy": "6065499239",
                    //     "pos": null,
                    //     "pair": null,
                    //     "sell": "6067991206",
                    //     "time": "2018-04-22T23:09:11.773Z",
                    //     "type": "buy",
                    //     "user": "up106404164",
                    //     "order": "6065499239",
                    //     "price": 7146.5,
                    //     "amount": "0.01589885",
                    //     "symbol": "BTC",
                    //     "balance": "0.36300000",
                    //     "symbol2": "EUR",
                    //     "fee_amount": "0.19" }
                    // --
                    // trade with zero amount, but non-zero fee
                    //   {
                    //     "a": "0.00000000",
                    //     "c": "user:up106404164:a:EUR",
                    //     "d": "order:5840654423:a:EUR",
                    //     "cs": 559744,
                    //     "ds": 0,
                    //     "id": "5840654429",
                    //     "buy": "5807238573",
                    //     "pos": null,
                    //     "pair": null,
                    //     "sell": "5840654423",
                    //     "time": "2018-03-15T03:20:14.010Z",
                    //     "type": "sell",
                    //     "user": "up106404164",
                    //     "order": "5840654423",
                    //     "price": 730,
                    //     "amount": "0.00000000",
                    //     "symbol": "EUR",
                    //     "balance": "5597.44000000",
                    //     "symbol2": "BCH",
                    //     "fee_amount": "0.01" }
                    // --
                    // trade which should have an amount of exactly 0.002BTC
                    //   {
                    //     "a": "16.70000000",
                    //     "c": "user:up106404164:a:GBP",
                    //     "d": "order:9927386681:a:GBP",
                    //     "cs": "86.90",
                    //     "ds": 0,
                    //     "id": "9927401610",
                    //     "buy": "9927401601",
                    //     "pos": null,
                    //     "pair": null,
                    //     "sell": "9927386681",
                    //     "time": "2019-08-21T15:25:37.777Z",
                    //     "type": "sell",
                    //     "user": "up106404164",
                    //     "order": "9927386681",
                    //     "price": 8365,
                    //     "amount": "16.70000000",
                    //     "office": "UK",
                    //     "symbol": "GBP",
                    //     "balance": "86.90000000",
                    //     "symbol2": "BTC",
                    //     "fee_amount": "0.03"
                    //   }
                    const tradeTimestamp = this.parse8601 (this.safeString (item, 'time'));
                    const tradeAmount = this.safeNumber (item, 'amount');
                    const feeCost = this.safeNumber (item, 'fee_amount');
                    let absTradeAmount = (tradeAmount < 0) ? -tradeAmount : tradeAmount;
                    let tradeCost = undefined;
                    if (tradeSide === 'sell') {
                        tradeCost = absTradeAmount;
                        absTradeAmount = this.sum (feeCost, tradeCost) / tradePrice;
                    } else {
                        tradeCost = absTradeAmount * tradePrice;
                    }
                    trades.push ({
                        'id': this.safeString (item, 'id'),
                        'timestamp': tradeTimestamp,
                        'datetime': this.iso8601 (tradeTimestamp),
                        'order': orderId,
                        'symbol': symbol,
                        'price': tradePrice,
                        'amount': absTradeAmount,
                        'cost': tradeCost,
                        'side': tradeSide,
                        'fee': {
                            'cost': feeCost,
                            'currency': market['quote'],
                        },
                        'info': item,
                        'type': undefined,
                        'takerOrMaker': undefined,
                    });
                }
            }
            return {
                'id': orderId,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': (price === undefined) ? 'market' : 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'trades': trades,
                'fee': fee,
                'info': order,
                'average': undefined,
            };
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let method = 'privatePostOpenOrders';
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
                method += 'Pair';
            }
            const orders = await this[method] (this.extend (request, params));
            for (let i = 0; i < orders.length; i++) {
                orders[i] = this.extend (orders[i], { 'status': 'open' });
            }
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const method = 'privatePostArchivedOrdersPair';
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchClosedOrders() requires a symbol argument');
            }
            const market = this.market (symbol);
            const request = { 'pair': market['id'] };
            const response = await this[method] (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id.toString (),
            };
            const response = await this.privatePostGetOrderTx (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            //
            //     {
            //         "id": "5442731603",
            //         "type": "sell",
            //         "time": 1516132358071,
            //         "lastTxTime": 1516132378452,
            //         "lastTx": "5442734452",
            //         "pos": null,
            //         "user": "up106404164",
            //         "status": "d",
            //         "symbol1": "ETH",
            //         "symbol2": "EUR",
            //         "amount": "0.50000000",
            //         "kind": "api",
            //         "price": "923.3386",
            //         "tfacf": "1",
            //         "fa:EUR": "0.55",
            //         "ta:EUR": "369.77",
            //         "remains": "0.00000000",
            //         "tfa:EUR": "0.22",
            //         "tta:EUR": "91.95",
            //         "a:ETH:cds": "0.50000000",
            //         "a:EUR:cds": "461.72",
            //         "f:EUR:cds": "0.77",
            //         "tradingFeeMaker": "0.15",
            //         "tradingFeeTaker": "0.23",
            //         "tradingFeeStrategy": "userVolumeAmount",
            //         "tradingFeeUserVolumeAmount": "2896912572",
            //         "orderId": "5442731603",
            //         "next": false,
            //         "vtx": [
            //             {
            //                 "id": "5442734452",
            //                 "type": "sell",
            //                 "time": "2018-01-16T19:52:58.452Z",
            //                 "user": "up106404164",
            //                 "c": "user:up106404164:a:EUR",
            //                 "d": "order:5442731603:a:EUR",
            //                 "a": "104.53000000",
            //                 "amount": "104.53000000",
            //                 "balance": "932.71000000",
            //                 "symbol": "EUR",
            //                 "order": "5442731603",
            //                 "buy": "5442734443",
            //                 "sell": "5442731603",
            //                 "pair": null,
            //                 "pos": null,
            //                 "office": null,
            //                 "cs": "932.71",
            //                 "ds": 0,
            //                 "price": 923.3386,
            //                 "symbol2": "ETH",
            //                 "fee_amount": "0.16"
            //             },
            //             {
            //                 "id": "5442731609",
            //                 "type": "sell",
            //                 "time": "2018-01-16T19:52:38.071Z",
            //                 "user": "up106404164",
            //                 "c": "user:up106404164:a:EUR",
            //                 "d": "order:5442731603:a:EUR",
            //                 "a": "91.73000000",
            //                 "amount": "91.73000000",
            //                 "balance": "563.49000000",
            //                 "symbol": "EUR",
            //                 "order": "5442731603",
            //                 "buy": "5442618127",
            //                 "sell": "5442731603",
            //                 "pair": null,
            //                 "pos": null,
            //                 "office": null,
            //                 "cs": "563.49",
            //                 "ds": 0,
            //                 "price": 924.0092,
            //                 "symbol2": "ETH",
            //                 "fee_amount": "0.22"
            //             },
            //             {
            //                 "id": "5442731604",
            //                 "type": "sell",
            //                 "time": "2018-01-16T19:52:38.071Z",
            //                 "user": "up106404164",
            //                 "c": "order:5442731603:a:ETH",
            //                 "d": "user:up106404164:a:ETH",
            //                 "a": "0.50000000",
            //                 "amount": "-0.50000000",
            //                 "balance": "15.80995000",
            //                 "symbol": "ETH",
            //                 "order": "5442731603",
            //                 "buy": null,
            //                 "sell": null,
            //                 "pair": null,
            //                 "pos": null,
            //                 "office": null,
            //                 "cs": "0.50000000",
            //                 "ds": "15.80995000"
            //             }
            //         ]
            //     }
            //
            return this.parseOrder (data);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'limit': limit,
                'pair': market['id'],
                'dateFrom': since,
            };
            const response = await this.privatePostArchivedOrdersPair (this.extend (request, params));
            const results = [];
            for (let i = 0; i < response.length; i++) {
                // cancelled (unfilled):
                //    { id: '4005785516',
                //     type: 'sell',
                //     time: '2017-07-18T19:08:34.223Z',
                //     lastTxTime: '2017-07-18T19:08:34.396Z',
                //     lastTx: '4005785522',
                //     pos: null,
                //     status: 'c',
                //     symbol1: 'ETH',
                //     symbol2: 'GBP',
                //     amount: '0.20000000',
                //     price: '200.5625',
                //     remains: '0.20000000',
                //     'a:ETH:cds': '0.20000000',
                //     tradingFeeMaker: '0',
                //     tradingFeeTaker: '0.16',
                //     tradingFeeUserVolumeAmount: '10155061217',
                //     orderId: '4005785516' }
                // --
                // cancelled (partially filled buy):
                //    { id: '4084911657',
                //     type: 'buy',
                //     time: '2017-08-05T03:18:39.596Z',
                //     lastTxTime: '2019-03-19T17:37:46.404Z',
                //     lastTx: '8459265833',
                //     pos: null,
                //     status: 'cd',
                //     symbol1: 'BTC',
                //     symbol2: 'GBP',
                //     amount: '0.05000000',
                //     price: '2241.4692',
                //     tfacf: '1',
                //     remains: '0.03910535',
                //     'tfa:GBP': '0.04',
                //     'tta:GBP': '24.39',
                //     'a:BTC:cds': '0.01089465',
                //     'a:GBP:cds': '112.26',
                //     'f:GBP:cds': '0.04',
                //     tradingFeeMaker: '0',
                //     tradingFeeTaker: '0.16',
                //     tradingFeeUserVolumeAmount: '13336396963',
                //     orderId: '4084911657' }
                // --
                // cancelled (partially filled sell):
                //    { id: '4426728375',
                //     type: 'sell',
                //     time: '2017-09-22T00:24:20.126Z',
                //     lastTxTime: '2017-09-22T00:24:30.476Z',
                //     lastTx: '4426729543',
                //     pos: null,
                //     status: 'cd',
                //     symbol1: 'BCH',
                //     symbol2: 'BTC',
                //     amount: '0.10000000',
                //     price: '0.11757182',
                //     tfacf: '1',
                //     remains: '0.09935956',
                //     'tfa:BTC': '0.00000014',
                //     'tta:BTC': '0.00007537',
                //     'a:BCH:cds': '0.10000000',
                //     'a:BTC:cds': '0.00007537',
                //     'f:BTC:cds': '0.00000014',
                //     tradingFeeMaker: '0',
                //     tradingFeeTaker: '0.18',
                //     tradingFeeUserVolumeAmount: '3466715450',
                //     orderId: '4426728375' }
                // --
                // filled:
                //    { id: '5342275378',
                //     type: 'sell',
                //     time: '2018-01-04T00:28:12.992Z',
                //     lastTxTime: '2018-01-04T00:28:12.992Z',
                //     lastTx: '5342275393',
                //     pos: null,
                //     status: 'd',
                //     symbol1: 'BCH',
                //     symbol2: 'BTC',
                //     amount: '0.10000000',
                //     kind: 'api',
                //     price: '0.17',
                //     remains: '0.00000000',
                //     'tfa:BTC': '0.00003902',
                //     'tta:BTC': '0.01699999',
                //     'a:BCH:cds': '0.10000000',
                //     'a:BTC:cds': '0.01699999',
                //     'f:BTC:cds': '0.00003902',
                //     tradingFeeMaker: '0.15',
                //     tradingFeeTaker: '0.23',
                //     tradingFeeUserVolumeAmount: '1525951128',
                //     orderId: '5342275378' }
                // --
                // market order (buy):
                //    { "id": "6281946200",
                //     "pos": null,
                //     "time": "2018-05-23T11:55:43.467Z",
                //     "type": "buy",
                //     "amount": "0.00000000",
                //     "lastTx": "6281946210",
                //     "status": "d",
                //     "amount2": "20.00",
                //     "orderId": "6281946200",
                //     "remains": "0.00000000",
                //     "symbol1": "ETH",
                //     "symbol2": "EUR",
                //     "tfa:EUR": "0.05",
                //     "tta:EUR": "19.94",
                //     "a:ETH:cds": "0.03764100",
                //     "a:EUR:cds": "20.00",
                //     "f:EUR:cds": "0.05",
                //     "lastTxTime": "2018-05-23T11:55:43.467Z",
                //     "tradingFeeTaker": "0.25",
                //     "tradingFeeUserVolumeAmount": "55998097" }
                // --
                // market order (sell):
                //   { "id": "6282200948",
                //     "pos": null,
                //     "time": "2018-05-23T12:42:58.315Z",
                //     "type": "sell",
                //     "amount": "-0.05000000",
                //     "lastTx": "6282200958",
                //     "status": "d",
                //     "orderId": "6282200948",
                //     "remains": "0.00000000",
                //     "symbol1": "ETH",
                //     "symbol2": "EUR",
                //     "tfa:EUR": "0.07",
                //     "tta:EUR": "26.49",
                //     "a:ETH:cds": "0.05000000",
                //     "a:EUR:cds": "26.49",
                //     "f:EUR:cds": "0.07",
                //     "lastTxTime": "2018-05-23T12:42:58.315Z",
                //     "tradingFeeTaker": "0.25",
                //     "tradingFeeUserVolumeAmount": "56294576" }
                const order = response[i];
                const status = this.parseOrderStatus (this.safeString (order, 'status'));
                const baseId = this.safeString (order, 'symbol1');
                const quoteId = this.safeString (order, 'symbol2');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const side = this.safeString (order, 'type');
                const baseAmount = this.safeNumber (order, 'a:' + baseId + ':cds');
                const quoteAmount = this.safeNumber (order, 'a:' + quoteId + ':cds');
                const fee = this.safeNumber (order, 'f:' + quoteId + ':cds');
                const amount = this.safeNumber (order, 'amount');
                const price = this.safeNumber (order, 'price');
                const remaining = this.safeNumber (order, 'remains');
                const filled = amount - remaining;
                let orderAmount = undefined;
                let cost = undefined;
                let average = undefined;
                let type = undefined;
                if (!price) {
                    type = 'market';
                    orderAmount = baseAmount;
                    cost = quoteAmount;
                    average = orderAmount / cost;
                } else {
                    const ta = this.safeNumber (order, 'ta:' + quoteId, 0);
                    const tta = this.safeNumber (order, 'tta:' + quoteId, 0);
                    const fa = this.safeNumber (order, 'fa:' + quoteId, 0);
                    const tfa = this.safeNumber (order, 'tfa:' + quoteId, 0);
                    if (side === 'sell') {
                        cost = this.sum (this.sum (ta, tta), this.sum (fa, tfa));
                    } else {
                        cost = this.sum (ta, tta) - this.sum (fa, tfa);
                    }
                    type = 'limit';
                    orderAmount = amount;
                    average = cost / filled;
                }
                const time = this.safeString (order, 'time');
                const lastTxTime = this.safeString (order, 'lastTxTime');
                const timestamp = this.parse8601 (time);
                results.push ({
                    'id': this.safeString (order, 'id'),
                    'timestamp': timestamp,
                    'datetime': this.iso8601 (timestamp),
                    'lastUpdated': this.parse8601 (lastTxTime),
                    'status': status,
                    'symbol': symbol,
                    'side': side,
                    'price': price,
                    'amount': orderAmount,
                    'average': average,
                    'type': type,
                    'filled': filled,
                    'cost': cost,
                    'remaining': remaining,
                    'fee': {
                        'cost': fee,
                        'currency': quote,
                    },
                    'info': order,
                });
            }
            return results;
        }
    
        parseOrderStatus (status) {
            return this.safeString (this.options['order']['status'], status, status);
        }
    
        async editOrder (id, symbol, type, side, amount = undefined, price = undefined, params = {}) {
            if (amount === undefined) {
                throw new ArgumentsRequired (this.id + ' editOrder() requires a amount argument');
            }
            if (price === undefined) {
                throw new ArgumentsRequired (this.id + ' editOrder() requires a price argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            // see: https://cex.io/rest-api#/definitions/CancelReplaceOrderRequest
            const request = {
                'pair': market['id'],
                'type': side,
                'amount': amount,
                'price': price,
                'order_id': id,
            };
            const response = await this.privatePostCancelReplaceOrderPair (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        async fetchDepositAddress (code, params = {}) {
            if (code === 'XRP' || code === 'XLM') {
                // https://github.com/ccxt/ccxt/pull/2327#issuecomment-375204856
                throw new NotSupported (this.id + ' fetchDepositAddress does not support XRP and XLM addresses yet (awaiting docs from CEX.io)');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privatePostGetAddress (this.extend (request, params));
            const address = this.safeString (response, 'data');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': response,
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const auth = nonce + this.uid + this.apiKey;
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                body = this.json (this.extend ({
                    'key': this.apiKey,
                    'signature': signature.toUpperCase (),
                    'nonce': nonce,
                }, query));
                headers = {
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (Array.isArray (response)) {
                return response; // public endpoints may return []-arrays
            }
            if (body === 'true') {
                return;
            }
            if (response === undefined) {
                throw new NullResponse (this.id + ' returned ' + this.json (response));
            }
            if ('e' in response) {
                if ('ok' in response) {
                    if (response['ok'] === 'ok') {
                        return;
                    }
                }
            }
            if ('error' in response) {
                const message = this.safeString (response, 'error');
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],59:[function(require,module,exports){
    'use strict';
    
    // ----------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, AuthenticationError, RateLimitExceeded, InvalidNonce } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    // ----------------------------------------------------------------------------
    
    module.exports = class coinbase extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinbase',
                'name': 'Coinbase',
                'countries': [ 'US' ],
                'rateLimit': 400, // 10k calls per hour
                'version': 'v2',
                'userAgent': this.userAgents['chrome'],
                'headers': {
                    'CB-VERSION': '2018-05-30',
                },
                'has': {
                    'CORS': true,
                    'cancelOrder': false,
                    'createDepositAddress': true,
                    'createOrder': false,
                    'deposit': false,
                    'fetchBalance': true,
                    'fetchClosedOrders': false,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': false,
                    'fetchMarkets': true,
                    'fetchMyTrades': false,
                    'fetchOHLCV': false,
                    'fetchOpenOrders': false,
                    'fetchOrder': false,
                    'fetchOrderBook': false,
                    'fetchL2OrderBook': false,
                    'fetchLedger': true,
                    'fetchOrders': false,
                    'fetchTicker': true,
                    'fetchTickers': false,
                    'fetchTime': true,
                    'fetchBidsAsks': false,
                    'fetchTrades': false,
                    'withdraw': false,
                    'fetchTransactions': false,
                    'fetchDeposits': true,
                    'fetchWithdrawals': true,
                    'fetchMySells': true,
                    'fetchMyBuys': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/40811661-b6eceae2-653a-11e8-829e-10bfadb078cf.jpg',
                    'api': 'https://api.coinbase.com',
                    'www': 'https://www.coinbase.com',
                    'doc': 'https://developers.coinbase.com/api/v2',
                    'fees': 'https://support.coinbase.com/customer/portal/articles/2109597-buy-sell-bank-transfer-fees',
                    'referral': 'https://www.coinbase.com/join/58cbe25a355148797479dbd2',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'currencies',
                            'time',
                            'exchange-rates',
                            'users/{user_id}',
                            'prices/{symbol}/buy',
                            'prices/{symbol}/sell',
                            'prices/{symbol}/spot',
                        ],
                    },
                    'private': {
                        'get': [
                            'accounts',
                            'accounts/{account_id}',
                            'accounts/{account_id}/addresses',
                            'accounts/{account_id}/addresses/{address_id}',
                            'accounts/{account_id}/addresses/{address_id}/transactions',
                            'accounts/{account_id}/transactions',
                            'accounts/{account_id}/transactions/{transaction_id}',
                            'accounts/{account_id}/buys',
                            'accounts/{account_id}/buys/{buy_id}',
                            'accounts/{account_id}/sells',
                            'accounts/{account_id}/sells/{sell_id}',
                            'accounts/{account_id}/deposits',
                            'accounts/{account_id}/deposits/{deposit_id}',
                            'accounts/{account_id}/withdrawals',
                            'accounts/{account_id}/withdrawals/{withdrawal_id}',
                            'payment-methods',
                            'payment-methods/{payment_method_id}',
                            'user',
                            'user/auth',
                        ],
                        'post': [
                            'accounts',
                            'accounts/{account_id}/primary',
                            'accounts/{account_id}/addresses',
                            'accounts/{account_id}/transactions',
                            'accounts/{account_id}/transactions/{transaction_id}/complete',
                            'accounts/{account_id}/transactions/{transaction_id}/resend',
                            'accounts/{account_id}/buys',
                            'accounts/{account_id}/buys/{buy_id}/commit',
                            'accounts/{account_id}/sells',
                            'accounts/{account_id}/sells/{sell_id}/commit',
                            'accounts/{account_id}/deposists',
                            'accounts/{account_id}/deposists/{deposit_id}/commit',
                            'accounts/{account_id}/withdrawals',
                            'accounts/{account_id}/withdrawals/{withdrawal_id}/commit',
                        ],
                        'put': [
                            'accounts/{account_id}',
                            'user',
                        ],
                        'delete': [
                            'accounts/{id}',
                            'accounts/{account_id}/transactions/{transaction_id}',
                        ],
                    },
                },
                'exceptions': {
                    'exact': {
                        'two_factor_required': AuthenticationError, // 402 When sending money over 2fa limit
                        'param_required': ExchangeError, // 400 Missing parameter
                        'validation_error': ExchangeError, // 400 Unable to validate POST/PUT
                        'invalid_request': ExchangeError, // 400 Invalid request
                        'personal_details_required': AuthenticationError, // 400 User’s personal detail required to complete this request
                        'identity_verification_required': AuthenticationError, // 400 Identity verification is required to complete this request
                        'jumio_verification_required': AuthenticationError, // 400 Document verification is required to complete this request
                        'jumio_face_match_verification_required': AuthenticationError, // 400 Document verification including face match is required to complete this request
                        'unverified_email': AuthenticationError, // 400 User has not verified their email
                        'authentication_error': AuthenticationError, // 401 Invalid auth (generic)
                        'invalid_token': AuthenticationError, // 401 Invalid Oauth token
                        'revoked_token': AuthenticationError, // 401 Revoked Oauth token
                        'expired_token': AuthenticationError, // 401 Expired Oauth token
                        'invalid_scope': AuthenticationError, // 403 User hasn’t authenticated necessary scope
                        'not_found': ExchangeError, // 404 Resource not found
                        'rate_limit_exceeded': RateLimitExceeded, // 429 Rate limit exceeded
                        'internal_server_error': ExchangeError, // 500 Internal server error
                    },
                    'broad': {
                        'request timestamp expired': InvalidNonce, // {"errors":[{"id":"authentication_error","message":"request timestamp expired"}]}
                    },
                },
                'commonCurrencies': {
                    'CGLD': 'CELO',
                },
                'options': {
                    'fetchCurrencies': {
                        'expires': 5000,
                    },
                    'accounts': [
                        'wallet',
                        'fiat',
                        // 'vault',
                    ],
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     {
            //         "data": {
            //             "epoch": 1589295679,
            //             "iso": "2020-05-12T15:01:19Z"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return this.safeTimestamp (data, 'epoch');
        }
    
        async fetchAccounts (params = {}) {
            await this.loadMarkets ();
            const request = {
                'limit': 100,
            };
            const response = await this.privateGetAccounts (this.extend (request, params));
            //
            //     {
            //         "id": "XLM",
            //         "name": "XLM Wallet",
            //         "primary": false,
            //         "type": "wallet",
            //         "currency": {
            //             "code": "XLM",
            //             "name": "Stellar Lumens",
            //             "color": "#000000",
            //             "sort_index": 127,
            //             "exponent": 7,
            //             "type": "crypto",
            //             "address_regex": "^G[A-Z2-7]{55}$",
            //             "asset_id": "13b83335-5ede-595b-821e-5bcdfa80560f",
            //             "destination_tag_name": "XLM Memo ID",
            //             "destination_tag_regex": "^[ -~]{1,28}$"
            //         },
            //         "balance": {
            //             "amount": "0.0000000",
            //             "currency": "XLM"
            //         },
            //         "created_at": null,
            //         "updated_at": null,
            //         "resource": "account",
            //         "resource_path": "/v2/accounts/XLM",
            //         "allow_deposits": true,
            //         "allow_withdrawals": true
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const account = data[i];
                const currency = this.safeValue (account, 'currency', {});
                const currencyId = this.safeString (currency, 'code');
                const code = this.safeCurrencyCode (currencyId);
                result.push ({
                    'id': this.safeString (account, 'id'),
                    'type': this.safeString (account, 'type'),
                    'code': code,
                    'info': account,
                });
            }
            return result;
        }
    
        async createDepositAddress (code, params = {}) {
            let accountId = this.safeString (params, 'account_id');
            params = this.omit (params, 'account_id');
            if (accountId === undefined) {
                await this.loadAccounts ();
                for (let i = 0; i < this.accounts.length; i++) {
                    const account = this.accounts[i];
                    if (account['code'] === code && account['type'] === 'wallet') {
                        accountId = account['id'];
                        break;
                    }
                }
            }
            if (accountId === undefined) {
                throw new ExchangeError (this.id + ' createDepositAddress could not find the account with matching currency code, specify an `account_id` extra param');
            }
            const request = {
                'account_id': accountId,
            };
            const response = await this.privatePostAccountsAccountIdAddresses (this.extend (request, params));
            //
            //     {
            //         "data": {
            //             "id": "05b1ebbf-9438-5dd4-b297-2ddedc98d0e4",
            //             "address": "coinbasebase",
            //             "address_info": {
            //                 "address": "coinbasebase",
            //                 "destination_tag": "287594668"
            //             },
            //             "name": null,
            //             "created_at": "2019-07-01T14:39:29Z",
            //             "updated_at": "2019-07-01T14:39:29Z",
            //             "network": "eosio",
            //             "uri_scheme": "eosio",
            //             "resource": "address",
            //             "resource_path": "/v2/accounts/14cfc769-e852-52f3-b831-711c104d194c/addresses/05b1ebbf-9438-5dd4-b297-2ddedc98d0e4",
            //             "warnings": [
            //                 {
            //                     "title": "Only send EOS (EOS) to this address",
            //                     "details": "Sending any other cryptocurrency will result in permanent loss.",
            //                     "image_url": "https://dynamic-assets.coinbase.com/deaca3d47b10ed4a91a872e9618706eec34081127762d88f2476ac8e99ada4b48525a9565cf2206d18c04053f278f693434af4d4629ca084a9d01b7a286a7e26/asset_icons/1f8489bb280fb0a0fd643c1161312ba49655040e9aaaced5f9ad3eeaf868eadc.png"
            //                 },
            //                 {
            //                     "title": "Both an address and EOS memo are required to receive EOS",
            //                     "details": "If you send funds without an EOS memo or with an incorrect EOS memo, your funds cannot be credited to your account.",
            //                     "image_url": "https://www.coinbase.com/assets/receive-warning-2f3269d83547a7748fb39d6e0c1c393aee26669bfea6b9f12718094a1abff155.png"
            //                 }
            //             ],
            //             "warning_title": "Only send EOS (EOS) to this address",
            //             "warning_details": "Sending any other cryptocurrency will result in permanent loss.",
            //             "destination_tag": "287594668",
            //             "deposit_uri": "eosio:coinbasebase?dt=287594668",
            //             "callback_url": null
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const tag = this.safeString (data, 'destination_tag');
            const address = this.safeString (data, 'address');
            return {
                'currency': code,
                'tag': tag,
                'address': address,
                'info': response,
            };
        }
    
        async fetchMySells (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // they don't have an endpoint for all historical trades
            const request = await this.prepareAccountRequest (limit, params);
            await this.loadMarkets ();
            const query = this.omit (params, [ 'account_id', 'accountId' ]);
            const sells = await this.privateGetAccountsAccountIdSells (this.extend (request, query));
            return this.parseTrades (sells['data'], undefined, since, limit);
        }
    
        async fetchMyBuys (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // they don't have an endpoint for all historical trades
            const request = await this.prepareAccountRequest (limit, params);
            await this.loadMarkets ();
            const query = this.omit (params, [ 'account_id', 'accountId' ]);
            const buys = await this.privateGetAccountsAccountIdBuys (this.extend (request, query));
            return this.parseTrades (buys['data'], undefined, since, limit);
        }
    
        async fetchTransactionsWithMethod (method, code = undefined, since = undefined, limit = undefined, params = {}) {
            const request = await this.prepareAccountRequestWithCurrencyCode (code, limit, params);
            await this.loadMarkets ();
            const query = this.omit (params, [ 'account_id', 'accountId' ]);
            const response = await this[method] (this.extend (request, query));
            return this.parseTransactions (response['data'], undefined, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            // fiat only, for crypto transactions use fetchLedger
            return await this.fetchTransactionsWithMethod ('privateGetAccountsAccountIdWithdrawals', code, since, limit, params);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            // fiat only, for crypto transactions use fetchLedger
            return await this.fetchTransactionsWithMethod ('privateGetAccountsAccountIdDeposits', code, since, limit, params);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'created': 'pending',
                'completed': 'ok',
                'canceled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, market = undefined) {
            //
            // fiat deposit
            //
            //     {
            //         "id": "f34c19f3-b730-5e3d-9f72",
            //         "status": "completed",
            //         "payment_method": {
            //             "id": "a022b31d-f9c7-5043-98f2",
            //             "resource": "payment_method",
            //             "resource_path": "/v2/payment-methods/a022b31d-f9c7-5043-98f2"
            //         },
            //         "transaction": {
            //             "id": "04ed4113-3732-5b0c-af86-b1d2146977d0",
            //             "resource": "transaction",
            //             "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/04ed4113-3732-5b0c-af86"
            //         },
            //         "user_reference": "2VTYTH",
            //         "created_at": "2017-02-09T07:01:18Z",
            //         "updated_at": "2017-02-09T07:01:26Z",
            //         "resource": "deposit",
            //         "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/deposits/f34c19f3-b730-5e3d-9f72",
            //         "committed": true,
            //         "payout_at": "2017-02-12T07:01:17Z",
            //         "instant": false,
            //         "fee": { "amount": "0.00", "currency": "EUR" },
            //         "amount": { "amount": "114.02", "currency": "EUR" },
            //         "subtotal": { "amount": "114.02", "currency": "EUR" },
            //         "hold_until": null,
            //         "hold_days": 0,
            //         "hold_business_days": 0,
            //         "next_step": null
            //     }
            //
            // fiat_withdrawal
            //
            //     {
            //         "id": "cfcc3b4a-eeb6-5e8c-8058",
            //         "status": "completed",
            //         "payment_method": {
            //             "id": "8b94cfa4-f7fd-5a12-a76a",
            //             "resource": "payment_method",
            //             "resource_path": "/v2/payment-methods/8b94cfa4-f7fd-5a12-a76a"
            //         },
            //         "transaction": {
            //             "id": "fcc2550b-5104-5f83-a444",
            //             "resource": "transaction",
            //             "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/fcc2550b-5104-5f83-a444"
            //         },
            //         "user_reference": "MEUGK",
            //         "created_at": "2018-07-26T08:55:12Z",
            //         "updated_at": "2018-07-26T08:58:18Z",
            //         "resource": "withdrawal",
            //         "resource_path": "/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/withdrawals/cfcc3b4a-eeb6-5e8c-8058",
            //         "committed": true,
            //         "payout_at": "2018-07-31T08:55:12Z",
            //         "instant": false,
            //         "fee": { "amount": "0.15", "currency": "EUR" },
            //         "amount": { "amount": "13130.69", "currency": "EUR" },
            //         "subtotal": { "amount": "13130.84", "currency": "EUR" },
            //         "idem": "e549dee5-63ed-4e79-8a96",
            //         "next_step": null
            //     }
            //
            const subtotalObject = this.safeValue (transaction, 'subtotal', {});
            const feeObject = this.safeValue (transaction, 'fee', {});
            const id = this.safeString (transaction, 'id');
            const timestamp = this.parse8601 (this.safeValue (transaction, 'created_at'));
            const updated = this.parse8601 (this.safeValue (transaction, 'updated_at'));
            const type = this.safeString (transaction, 'resource');
            const amount = this.safeNumber (subtotalObject, 'amount');
            const currencyId = this.safeString (subtotalObject, 'currency');
            const currency = this.safeCurrencyCode (currencyId);
            const feeCost = this.safeNumber (feeObject, 'amount');
            const feeCurrencyId = this.safeString (feeObject, 'currency');
            const feeCurrency = this.safeCurrencyCode (feeCurrencyId);
            const fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            };
            let status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            if (status === undefined) {
                const committed = this.safeValue (transaction, 'committed');
                status = committed ? 'ok' : 'pending';
            }
            return {
                'info': transaction,
                'id': id,
                'txid': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': undefined,
                'tag': undefined,
                'type': type,
                'amount': amount,
                'currency': currency,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        parseTrade (trade, market = undefined) {
            //
            //     {
            //         "id": "67e0eaec-07d7-54c4-a72c-2e92826897df",
            //         "status": "completed",
            //         "payment_method": {
            //             "id": "83562370-3e5c-51db-87da-752af5ab9559",
            //             "resource": "payment_method",
            //             "resource_path": "/v2/payment-methods/83562370-3e5c-51db-87da-752af5ab9559"
            //         },
            //         "transaction": {
            //             "id": "441b9494-b3f0-5b98-b9b0-4d82c21c252a",
            //             "resource": "transaction",
            //             "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/transactions/441b9494-b3f0-5b98-b9b0-4d82c21c252a"
            //         },
            //         "amount": { "amount": "1.00000000", "currency": "BTC" },
            //         "total": { "amount": "10.25", "currency": "USD" },
            //         "subtotal": { "amount": "10.10", "currency": "USD" },
            //         "created_at": "2015-01-31T20:49:02Z",
            //         "updated_at": "2015-02-11T16:54:02-08:00",
            //         "resource": "buy",
            //         "resource_path": "/v2/accounts/2bbf394c-193b-5b2a-9155-3b4732659ede/buys/67e0eaec-07d7-54c4-a72c-2e92826897df",
            //         "committed": true,
            //         "instant": false,
            //         "fee": { "amount": "0.15", "currency": "USD" },
            //         "payout_at": "2015-02-18T16:54:00-08:00"
            //     }
            //
            let symbol = undefined;
            const totalObject = this.safeValue (trade, 'total', {});
            const amountObject = this.safeValue (trade, 'amount', {});
            const subtotalObject = this.safeValue (trade, 'subtotal', {});
            const feeObject = this.safeValue (trade, 'fee', {});
            const id = this.safeString (trade, 'id');
            const timestamp = this.parse8601 (this.safeValue (trade, 'created_at'));
            if (market === undefined) {
                const baseId = this.safeString (amountObject, 'currency');
                const quoteId = this.safeString (totalObject, 'currency');
                if ((baseId !== undefined) && (quoteId !== undefined)) {
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            const orderId = undefined;
            const side = this.safeString (trade, 'resource');
            const type = undefined;
            const costString = this.safeString (subtotalObject, 'amount');
            const amountString = this.safeString (amountObject, 'amount');
            const cost = this.parseNumber (costString);
            const amount = this.parseNumber (amountString);
            const price = this.parseNumber (Precise.stringDiv (costString, amountString));
            const feeCost = this.safeNumber (feeObject, 'amount');
            const feeCurrencyId = this.safeString (feeObject, 'currency');
            const feeCurrency = this.safeCurrencyCode (feeCurrencyId);
            const fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            };
            return {
                'info': trade,
                'id': id,
                'order': orderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.fetchCurrenciesFromCache (params);
            const currencies = this.safeValue (response, 'currencies', {});
            const exchangeRates = this.safeValue (response, 'exchangeRates', {});
            const data = this.safeValue (currencies, 'data', []);
            const dataById = this.indexBy (data, 'id');
            const rates = this.safeValue (this.safeValue (exchangeRates, 'data', {}), 'rates', {});
            const baseIds = Object.keys (rates);
            const result = [];
            for (let i = 0; i < baseIds.length; i++) {
                const baseId = baseIds[i];
                const base = this.safeCurrencyCode (baseId);
                const type = (baseId in dataById) ? 'fiat' : 'crypto';
                // https://github.com/ccxt/ccxt/issues/6066
                if (type === 'crypto') {
                    for (let j = 0; j < data.length; j++) {
                        const quoteCurrency = data[j];
                        const quoteId = this.safeString (quoteCurrency, 'id');
                        const quote = this.safeCurrencyCode (quoteId);
                        const symbol = base + '/' + quote;
                        const id = baseId + '-' + quoteId;
                        result.push ({
                            'id': id,
                            'symbol': symbol,
                            'base': base,
                            'quote': quote,
                            'baseId': baseId,
                            'quoteId': quoteId,
                            'active': undefined,
                            'info': quoteCurrency,
                            'precision': {
                                'amount': undefined,
                                'price': undefined,
                            },
                            'limits': {
                                'amount': {
                                    'min': undefined,
                                    'max': undefined,
                                },
                                'price': {
                                    'min': undefined,
                                    'max': undefined,
                                },
                                'cost': {
                                    'min': this.safeNumber (quoteCurrency, 'min_size'),
                                    'max': undefined,
                                },
                            },
                        });
                    }
                }
            }
            return result;
        }
    
        async fetchCurrenciesFromCache (params = {}) {
            const options = this.safeValue (this.options, 'fetchCurrencies', {});
            const timestamp = this.safeInteger (options, 'timestamp');
            const expires = this.safeInteger (options, 'expires', 1000);
            const now = this.milliseconds ();
            if ((timestamp === undefined) || ((now - timestamp) > expires)) {
                const currencies = await this.publicGetCurrencies (params);
                const exchangeRates = await this.publicGetExchangeRates (params);
                this.options['fetchCurrencies'] = this.extend (options, {
                    'currencies': currencies,
                    'exchangeRates': exchangeRates,
                    'timestamp': now,
                });
            }
            return this.safeValue (this.options, 'fetchCurrencies', {});
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.fetchCurrenciesFromCache (params);
            const currencies = this.safeValue (response, 'currencies', {});
            //
            //     {
            //         "data":[
            //             {"id":"AED","name":"United Arab Emirates Dirham","min_size":"0.01000000"},
            //             {"id":"AFN","name":"Afghan Afghani","min_size":"0.01000000"},
            //             {"id":"ALL","name":"Albanian Lek","min_size":"0.01000000"},
            //             {"id":"AMD","name":"Armenian Dram","min_size":"0.01000000"},
            //             {"id":"ANG","name":"Netherlands Antillean Gulden","min_size":"0.01000000"},
            //             // ...
            //         ],
            //     }
            //
            const exchangeRates = this.safeValue (response, 'exchangeRates', {});
            //
            //     {
            //         "data":{
            //             "currency":"USD",
            //             "rates":{
            //                 "AED":"3.67",
            //                 "AFN":"78.21",
            //                 "ALL":"110.42",
            //                 "AMD":"474.18",
            //                 "ANG":"1.75",
            //                 // ...
            //             },
            //         }
            //     }
            //
            const data = this.safeValue (currencies, 'data', []);
            const dataById = this.indexBy (data, 'id');
            const rates = this.safeValue (this.safeValue (exchangeRates, 'data', {}), 'rates', {});
            const keys = Object.keys (rates);
            const result = {};
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const type = (key in dataById) ? 'fiat' : 'crypto';
                const currency = this.safeValue (dataById, key, {});
                const id = this.safeString (currency, 'id', key);
                const name = this.safeString (currency, 'name');
                const code = this.safeCurrencyCode (id);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency, // the original payload
                    'type': type,
                    'name': name,
                    'active': true,
                    'fee': undefined,
                    'precision': undefined,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (currency, 'min_size'),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const timestamp = this.seconds ();
            const market = this.market (symbol);
            const request = this.extend ({
                'symbol': market['id'],
            }, params);
            const buy = await this.publicGetPricesSymbolBuy (request);
            const sell = await this.publicGetPricesSymbolSell (request);
            const spot = await this.publicGetPricesSymbolSpot (request);
            const ask = this.safeNumber (buy['data'], 'amount');
            const bid = this.safeNumber (sell['data'], 'amount');
            const last = this.safeNumber (spot['data'], 'amount');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'bid': bid,
                'ask': ask,
                'last': last,
                'high': undefined,
                'low': undefined,
                'bidVolume': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': undefined,
                'info': {
                    'buy': buy,
                    'sell': sell,
                    'spot': spot,
                },
            };
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const request = {
                'limit': 100,
            };
            const response = await this.privateGetAccounts (this.extend (request, params));
            const balances = this.safeValue (response, 'data');
            const accounts = this.safeValue (params, 'type', this.options['accounts']);
            const result = { 'info': response };
            for (let b = 0; b < balances.length; b++) {
                const balance = balances[b];
                const type = this.safeString (balance, 'type');
                if (this.inArray (type, accounts)) {
                    const value = this.safeValue (balance, 'balance');
                    if (value !== undefined) {
                        const currencyId = this.safeString (value, 'currency');
                        const code = this.safeCurrencyCode (currencyId);
                        const total = this.safeString (value, 'amount');
                        const free = total;
                        let account = this.safeValue (result, code);
                        if (account === undefined) {
                            account = this.account ();
                            account['free'] = free;
                            account['total'] = total;
                        } else {
                            account['free'] = Precise.stringAdd (account['free'], total);
                            account['total'] = Precise.stringAdd (account['total'], total);
                        }
                        result[code] = account;
                    }
                }
            }
            return this.parseBalance (result);
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            const request = await this.prepareAccountRequestWithCurrencyCode (code, limit, params);
            const query = this.omit (params, ['account_id', 'accountId']);
            // for pagination use parameter 'starting_after'
            // the value for the next page can be obtained from the result of the previous call in the 'pagination' field
            // eg: instance.last_json_response.pagination.next_starting_after
            const response = await this.privateGetAccountsAccountIdTransactions (this.extend (request, query));
            return this.parseLedger (response['data'], currency, since, limit);
        }
    
        parseLedgerEntryStatus (status) {
            const types = {
                'completed': 'ok',
            };
            return this.safeString (types, status, status);
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'buy': 'trade',
                'sell': 'trade',
                'fiat_deposit': 'transaction',
                'fiat_withdrawal': 'transaction',
                'exchange_deposit': 'transaction', // fiat withdrawal (from coinbase to coinbasepro)
                'exchange_withdrawal': 'transaction', // fiat deposit (to coinbase from coinbasepro)
                'send': 'transaction', // crypto deposit OR withdrawal
                'pro_deposit': 'transaction', // crypto withdrawal (from coinbase to coinbasepro)
                'pro_withdrawal': 'transaction', // crypto deposit (to coinbase from coinbasepro)
            };
            return this.safeString (types, type, type);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            // crypto deposit transaction
            //
            //     {
            //         id: '34e4816b-4c8c-5323-a01c-35a9fa26e490',
            //         type: 'send',
            //         status: 'completed',
            //         amount: { amount: '28.31976528', currency: 'BCH' },
            //         native_amount: { amount: '2799.65', currency: 'GBP' },
            //         description: null,
            //         created_at: '2019-02-28T12:35:20Z',
            //         updated_at: '2019-02-28T12:43:24Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/c01d7364-edd7-5f3a-bd1d-de53d4cbb25e/transactions/34e4816b-4c8c-5323-a01c-35a9fa26e490',
            //         instant_exchange: false,
            //         network: {
            //             status: 'confirmed',
            //             hash: '56222d865dae83774fccb2efbd9829cf08c75c94ce135bfe4276f3fb46d49701',
            //             transaction_url: 'https://bch.btc.com/56222d865dae83774fccb2efbd9829cf08c75c94ce135bfe4276f3fb46d49701'
            //         },
            //         from: { resource: 'bitcoin_cash_network', currency: 'BCH' },
            //         details: { title: 'Received Bitcoin Cash', subtitle: 'From Bitcoin Cash address' }
            //     }
            //
            // crypto withdrawal transaction
            //
            //     {
            //         id: '459aad99-2c41-5698-ac71-b6b81a05196c',
            //         type: 'send',
            //         status: 'completed',
            //         amount: { amount: '-0.36775642', currency: 'BTC' },
            //         native_amount: { amount: '-1111.65', currency: 'GBP' },
            //         description: null,
            //         created_at: '2019-03-20T08:37:07Z',
            //         updated_at: '2019-03-20T08:49:33Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/459aad99-2c41-5698-ac71-b6b81a05196c',
            //         instant_exchange: false,
            //         network: {
            //             status: 'confirmed',
            //             hash: '2732bbcf35c69217c47b36dce64933d103895277fe25738ffb9284092701e05b',
            //             transaction_url: 'https://blockchain.info/tx/2732bbcf35c69217c47b36dce64933d103895277fe25738ffb9284092701e05b',
            //             transaction_fee: { amount: '0.00000000', currency: 'BTC' },
            //             transaction_amount: { amount: '0.36775642', currency: 'BTC' },
            //             confirmations: 15682
            //         },
            //         to: {
            //             resource: 'bitcoin_address',
            //             address: '1AHnhqbvbYx3rnZx8uC7NbFZaTe4tafFHX',
            //             currency: 'BTC',
            //             address_info: { address: '1AHnhqbvbYx3rnZx8uC7NbFZaTe4tafFHX' }
            //         },
            //         idem: 'da0a2f14-a2af-4c5a-a37e-d4484caf582bsend',
            //         application: {
            //             id: '5756ab6e-836b-553b-8950-5e389451225d',
            //             resource: 'application',
            //             resource_path: '/v2/applications/5756ab6e-836b-553b-8950-5e389451225d'
            //         },
            //         details: { title: 'Sent Bitcoin', subtitle: 'To Bitcoin address' }
            //     }
            //
            // withdrawal transaction from coinbase to coinbasepro
            //
            //     {
            //         id: '5b1b9fb8-5007-5393-b923-02903b973fdc',
            //         type: 'pro_deposit',
            //         status: 'completed',
            //         amount: { amount: '-0.00001111', currency: 'BCH' },
            //         native_amount: { amount: '0.00', currency: 'GBP' },
            //         description: null,
            //         created_at: '2019-02-28T13:31:58Z',
            //         updated_at: '2019-02-28T13:31:58Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/c01d7364-edd7-5f3a-bd1d-de53d4cbb25e/transactions/5b1b9fb8-5007-5393-b923-02903b973fdc',
            //         instant_exchange: false,
            //         application: {
            //             id: '5756ab6e-836b-553b-8950-5e389451225d',
            //             resource: 'application',
            //             resource_path: '/v2/applications/5756ab6e-836b-553b-8950-5e389451225d'
            //         },
            //         details: { title: 'Transferred Bitcoin Cash', subtitle: 'To Coinbase Pro' }
            //     }
            //
            // withdrawal transaction from coinbase to gdax
            //
            //     {
            //         id: 'badb7313-a9d3-5c07-abd0-00f8b44199b1',
            //         type: 'exchange_deposit',
            //         status: 'completed',
            //         amount: { amount: '-0.43704149', currency: 'BCH' },
            //         native_amount: { amount: '-51.90', currency: 'GBP' },
            //         description: null,
            //         created_at: '2019-03-19T10:30:40Z',
            //         updated_at: '2019-03-19T10:30:40Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/c01d7364-edd7-5f3a-bd1d-de53d4cbb25e/transactions/badb7313-a9d3-5c07-abd0-00f8b44199b1',
            //         instant_exchange: false,
            //         details: { title: 'Transferred Bitcoin Cash', subtitle: 'To GDAX' }
            //     }
            //
            // deposit transaction from gdax to coinbase
            //
            //     {
            //         id: '9c4b642c-8688-58bf-8962-13cef64097de',
            //         type: 'exchange_withdrawal',
            //         status: 'completed',
            //         amount: { amount: '0.57729420', currency: 'BTC' },
            //         native_amount: { amount: '4418.72', currency: 'GBP' },
            //         description: null,
            //         created_at: '2018-02-17T11:33:33Z',
            //         updated_at: '2018-02-17T11:33:33Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/9c4b642c-8688-58bf-8962-13cef64097de',
            //         instant_exchange: false,
            //         details: { title: 'Transferred Bitcoin', subtitle: 'From GDAX' }
            //     }
            //
            // deposit transaction from coinbasepro to coinbase
            //
            //     {
            //         id: '8d6dd0b9-3416-568a-889d-8f112fae9e81',
            //         type: 'pro_withdrawal',
            //         status: 'completed',
            //         amount: { amount: '0.40555386', currency: 'BTC' },
            //         native_amount: { amount: '1140.27', currency: 'GBP' },
            //         description: null,
            //         created_at: '2019-03-04T19:41:58Z',
            //         updated_at: '2019-03-04T19:41:58Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/8d6dd0b9-3416-568a-889d-8f112fae9e81',
            //         instant_exchange: false,
            //         application: {
            //             id: '5756ab6e-836b-553b-8950-5e389451225d',
            //             resource: 'application',
            //             resource_path: '/v2/applications/5756ab6e-836b-553b-8950-5e389451225d'
            //         },
            //         details: { title: 'Transferred Bitcoin', subtitle: 'From Coinbase Pro' }
            //     }
            //
            // sell trade
            //
            //     {
            //         id: 'a9409207-df64-585b-97ab-a50780d2149e',
            //         type: 'sell',
            //         status: 'completed',
            //         amount: { amount: '-9.09922880', currency: 'BTC' },
            //         native_amount: { amount: '-7285.73', currency: 'GBP' },
            //         description: null,
            //         created_at: '2017-03-27T15:38:34Z',
            //         updated_at: '2017-03-27T15:38:34Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/transactions/a9409207-df64-585b-97ab-a50780d2149e',
            //         instant_exchange: false,
            //         sell: {
            //             id: 'e3550b4d-8ae6-5de3-95fe-1fb01ba83051',
            //             resource: 'sell',
            //             resource_path: '/v2/accounts/c6afbd34-4bd0-501e-8616-4862c193cd84/sells/e3550b4d-8ae6-5de3-95fe-1fb01ba83051'
            //         },
            //         details: {
            //             title: 'Sold Bitcoin',
            //             subtitle: 'Using EUR Wallet',
            //             payment_method_name: 'EUR Wallet'
            //         }
            //     }
            //
            // buy trade
            //
            //     {
            //         id: '63eeed67-9396-5912-86e9-73c4f10fe147',
            //         type: 'buy',
            //         status: 'completed',
            //         amount: { amount: '2.39605772', currency: 'ETH' },
            //         native_amount: { amount: '98.31', currency: 'GBP' },
            //         description: null,
            //         created_at: '2017-03-27T09:07:56Z',
            //         updated_at: '2017-03-27T09:07:57Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/8902f85d-4a69-5d74-82fe-8e390201bda7/transactions/63eeed67-9396-5912-86e9-73c4f10fe147',
            //         instant_exchange: false,
            //         buy: {
            //             id: '20b25b36-76c6-5353-aa57-b06a29a39d82',
            //             resource: 'buy',
            //             resource_path: '/v2/accounts/8902f85d-4a69-5d74-82fe-8e390201bda7/buys/20b25b36-76c6-5353-aa57-b06a29a39d82'
            //         },
            //         details: {
            //             title: 'Bought Ethereum',
            //             subtitle: 'Using EUR Wallet',
            //             payment_method_name: 'EUR Wallet'
            //         }
            //     }
            //
            // fiat deposit transaction
            //
            //     {
            //         id: '04ed4113-3732-5b0c-af86-b1d2146977d0',
            //         type: 'fiat_deposit',
            //         status: 'completed',
            //         amount: { amount: '114.02', currency: 'EUR' },
            //         native_amount: { amount: '97.23', currency: 'GBP' },
            //         description: null,
            //         created_at: '2017-02-09T07:01:21Z',
            //         updated_at: '2017-02-09T07:01:22Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/04ed4113-3732-5b0c-af86-b1d2146977d0',
            //         instant_exchange: false,
            //         fiat_deposit: {
            //             id: 'f34c19f3-b730-5e3d-9f72-96520448677a',
            //             resource: 'fiat_deposit',
            //             resource_path: '/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/deposits/f34c19f3-b730-5e3d-9f72-96520448677a'
            //         },
            //         details: {
            //             title: 'Deposited funds',
            //             subtitle: 'From SEPA Transfer (GB47 BARC 20..., reference CBADVI)',
            //             payment_method_name: 'SEPA Transfer (GB47 BARC 20..., reference CBADVI)'
            //         }
            //     }
            //
            // fiat withdrawal transaction
            //
            //     {
            //         id: '957d98e2-f80e-5e2f-a28e-02945aa93079',
            //         type: 'fiat_withdrawal',
            //         status: 'completed',
            //         amount: { amount: '-11000.00', currency: 'EUR' },
            //         native_amount: { amount: '-9698.22', currency: 'GBP' },
            //         description: null,
            //         created_at: '2017-12-06T13:19:19Z',
            //         updated_at: '2017-12-06T13:19:19Z',
            //         resource: 'transaction',
            //         resource_path: '/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/transactions/957d98e2-f80e-5e2f-a28e-02945aa93079',
            //         instant_exchange: false,
            //         fiat_withdrawal: {
            //             id: 'f4bf1fd9-ab3b-5de7-906d-ed3e23f7a4e7',
            //             resource: 'fiat_withdrawal',
            //             resource_path: '/v2/accounts/91cd2d36-3a91-55b6-a5d4-0124cf105483/withdrawals/f4bf1fd9-ab3b-5de7-906d-ed3e23f7a4e7'
            //         },
            //         details: {
            //             title: 'Withdrew funds',
            //             subtitle: 'To HSBC BANK PLC (GB74 MIDL...)',
            //             payment_method_name: 'HSBC BANK PLC (GB74 MIDL...)'
            //         }
            //     }
            //
            const amountInfo = this.safeValue (item, 'amount', {});
            let amount = this.safeNumber (amountInfo, 'amount');
            let direction = undefined;
            if (amount < 0) {
                direction = 'out';
                amount = -amount;
            } else {
                direction = 'in';
            }
            const currencyId = this.safeString (amountInfo, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            //
            // the address and txid do not belong to the unified ledger structure
            //
            //     let address = undefined;
            //     if (item['to']) {
            //         address = this.safeString (item['to'], 'address');
            //     }
            //     let txid = undefined;
            //
            let fee = undefined;
            const networkInfo = this.safeValue (item, 'network', {});
            // txid = network['hash']; // txid does not belong to the unified ledger structure
            const feeInfo = this.safeValue (networkInfo, 'transaction_fee');
            if (feeInfo !== undefined) {
                const feeCurrencyId = this.safeString (feeInfo, 'currency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId, currency);
                const feeAmount = this.safeNumber (feeInfo, 'amount');
                fee = {
                    'cost': feeAmount,
                    'currency': feeCurrencyCode,
                };
            }
            const timestamp = this.parse8601 (this.safeValue (item, 'created_at'));
            const id = this.safeString (item, 'id');
            const type = this.parseLedgerEntryType (this.safeString (item, 'type'));
            const status = this.parseLedgerEntryStatus (this.safeString (item, 'status'));
            const path = this.safeString (item, 'resource_path');
            let accountId = undefined;
            if (path !== undefined) {
                const parts = path.split ('/');
                const numParts = parts.length;
                if (numParts > 3) {
                    accountId = parts[3];
                }
            }
            return {
                'info': item,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'direction': direction,
                'account': accountId,
                'referenceId': undefined,
                'referenceAccount': undefined,
                'type': type,
                'currency': code,
                'amount': amount,
                'before': undefined,
                'after': undefined,
                'status': status,
                'fee': fee,
            };
        }
    
        async findAccountId (code) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            for (let i = 0; i < this.accounts.length; i++) {
                const account = this.accounts[i];
                if (account['code'] === code) {
                    return account['id'];
                }
            }
            return undefined;
        }
    
        prepareAccountRequest (limit = undefined, params = {}) {
            const accountId = this.safeString2 (params, 'account_id', 'accountId');
            if (accountId === undefined) {
                throw new ArgumentsRequired (this.id + ' method requires an account_id (or accountId) parameter');
            }
            const request = {
                'account_id': accountId,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            return request;
        }
    
        async prepareAccountRequestWithCurrencyCode (code = undefined, limit = undefined, params = {}) {
            let accountId = this.safeString2 (params, 'account_id', 'accountId');
            if (accountId === undefined) {
                if (code === undefined) {
                    throw new ArgumentsRequired (this.id + ' method requires an account_id (or accountId) parameter OR a currency code argument');
                }
                accountId = await this.findAccountId (code);
                if (accountId === undefined) {
                    throw new ExchangeError (this.id + ' could not find account id for ' + code);
                }
            }
            const request = {
                'account_id': accountId,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            return request;
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let fullPath = '/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (method === 'GET') {
                if (Object.keys (query).length) {
                    fullPath += '?' + this.urlencode (query);
                }
            }
            const url = this.urls['api'] + fullPath;
            if (api === 'private') {
                const authorization = this.safeString (this.headers, 'Authorization');
                if (authorization !== undefined) {
                    headers = {
                        'Authorization': authorization,
                        'Content-Type': 'application/json',
                    };
                } else if (this.token) {
                    headers = {
                        'Authorization': 'Bearer ' + this.token,
                        'Content-Type': 'application/json',
                    };
                } else {
                    this.checkRequiredCredentials ();
                    const nonce = this.nonce ().toString ();
                    let payload = '';
                    if (method !== 'GET') {
                        if (Object.keys (query).length) {
                            body = this.json (query);
                            payload = body;
                        }
                    }
                    const auth = nonce + method + fullPath + payload;
                    const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                    headers = {
                        'CB-ACCESS-KEY': this.apiKey,
                        'CB-ACCESS-SIGN': signature,
                        'CB-ACCESS-TIMESTAMP': nonce,
                        'Content-Type': 'application/json',
                    };
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            const feedback = this.id + ' ' + body;
            //
            //    {"error": "invalid_request", "error_description": "The request is missing a required parameter, includes an unsupported parameter value, or is otherwise malformed."}
            //
            // or
            //
            //    {
            //      "errors": [
            //        {
            //          "id": "not_found",
            //          "message": "Not found"
            //        }
            //      ]
            //    }
            //
            let errorCode = this.safeString (response, 'error');
            if (errorCode !== undefined) {
                const errorMessage = this.safeString (response, 'error_description');
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], errorMessage, feedback);
                throw new ExchangeError (feedback);
            }
            const errors = this.safeValue (response, 'errors');
            if (errors !== undefined) {
                if (Array.isArray (errors)) {
                    const numErrors = errors.length;
                    if (numErrors > 0) {
                        errorCode = this.safeString (errors[0], 'id');
                        const errorMessage = this.safeString (errors[0], 'message');
                        if (errorCode !== undefined) {
                            this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                            this.throwBroadlyMatchedException (this.exceptions['broad'], errorMessage, feedback);
                            throw new ExchangeError (feedback);
                        }
                    }
                }
            }
            const data = this.safeValue (response, 'data');
            if (data === undefined) {
                throw new ExchangeError (this.id + ' failed due to a malformed response ' + this.json (response));
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],60:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const coinbasepro = require ('./coinbasepro.js');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class coinbaseprime extends coinbasepro {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinbaseprime',
                'name': 'Coinbase Prime',
                'pro': true,
                'hostname': 'exchange.coinbase.com',
                'urls': {
                    'test': {
                        'public': 'https://public.sandbox.exchange.coinbase.com',
                        'private': 'https://public.sandbox.exchange.coinbase.com',
                    },
                    'logo': 'https://user-images.githubusercontent.com/1294454/44539184-29f26e00-a70c-11e8-868f-e907fc236a7c.jpg',
                    'api': {
                        'public': 'https://api.{hostname}',
                        'private': 'https://api.{hostname}',
                    },
                    'www': 'https://exchange.coinbase.com',
                    'doc': 'https://docs.exchange.coinbase.com',
                },
            });
        }
    };
    
    },{"./coinbasepro.js":61}],61:[function(require,module,exports){
    'use strict';
    
    // ----------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { InsufficientFunds, ArgumentsRequired, ExchangeError, InvalidOrder, InvalidAddress, AuthenticationError, NotSupported, OrderNotFound, OnMaintenance, PermissionDenied, RateLimitExceeded } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    // ----------------------------------------------------------------------------
    
    module.exports = class coinbasepro extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinbasepro',
                'name': 'Coinbase Pro',
                'countries': [ 'US' ],
                'rateLimit': 1000,
                'userAgent': this.userAgents['chrome'],
                'pro': true,
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'CORS': true,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'deposit': true,
                    'fetchAccounts': true,
                    'fetchBalance': true,
                    'fetchCurrencies': true,
                    'fetchClosedOrders': true,
                    'fetchDepositAddress': false, // the exchange does not have this method, only createDepositAddress, see https://github.com/ccxt/ccxt/pull/7405
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchOrderTrades': true,
                    'fetchTime': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'fetchTransactions': true,
                    'withdraw': true,
                    'fetchDeposits': true,
                    'fetchWithdrawals': true,
                },
                'timeframes': {
                    '1m': 60,
                    '5m': 300,
                    '15m': 900,
                    '1h': 3600,
                    '6h': 21600,
                    '1d': 86400,
                },
                'hostname': 'pro.coinbase.com',
                'urls': {
                    'test': {
                        'public': 'https://api-public.sandbox.pro.coinbase.com',
                        'private': 'https://api-public.sandbox.pro.coinbase.com',
                    },
                    'logo': 'https://user-images.githubusercontent.com/1294454/41764625-63b7ffde-760a-11e8-996d-a6328fa9347a.jpg',
                    'api': {
                        'public': 'https://api.{hostname}',
                        'private': 'https://api.{hostname}',
                    },
                    'www': 'https://pro.coinbase.com/',
                    'doc': 'https://docs.pro.coinbase.com',
                    'fees': [
                        'https://docs.pro.coinbase.com/#fees',
                        'https://support.pro.coinbase.com/customer/en/portal/articles/2945310-fees',
                    ],
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'password': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'currencies',
                            'products',
                            'products/{id}',
                            'products/{id}/book',
                            'products/{id}/candles',
                            'products/{id}/stats',
                            'products/{id}/ticker',
                            'products/{id}/trades',
                            'time',
                        ],
                    },
                    'private': {
                        'get': [
                            'accounts',
                            'accounts/{id}',
                            'accounts/{id}/holds',
                            'accounts/{id}/ledger',
                            'accounts/{id}/transfers',
                            'coinbase-accounts',
                            'fills',
                            'funding',
                            'fees',
                            'margin/profile_information',
                            'margin/buying_power',
                            'margin/withdrawal_power',
                            'margin/withdrawal_power_all',
                            'margin/exit_plan',
                            'margin/liquidation_history',
                            'margin/position_refresh_amounts',
                            'margin/status',
                            'oracle',
                            'orders',
                            'orders/{id}',
                            'orders/client:{client_oid}',
                            'otc/orders',
                            'payment-methods',
                            'position',
                            'profiles',
                            'profiles/{id}',
                            'reports/{report_id}',
                            'transfers',
                            'transfers/{transfer_id}',
                            'users/self/exchange-limits',
                            'users/self/hold-balances',
                            'users/self/trailing-volume',
                            'withdrawals/fee-estimate',
                        ],
                        'post': [
                            'conversions',
                            'deposits/coinbase-account',
                            'deposits/payment-method',
                            'coinbase-accounts/{id}/addresses',
                            'funding/repay',
                            'orders',
                            'position/close',
                            'profiles/margin-transfer',
                            'profiles/transfer',
                            'reports',
                            'withdrawals/coinbase',
                            'withdrawals/coinbase-account',
                            'withdrawals/crypto',
                            'withdrawals/payment-method',
                        ],
                        'delete': [
                            'orders',
                            'orders/client:{client_oid}',
                            'orders/{id}',
                        ],
                    },
                },
                'commonCurrencies': {
                    'CGLD': 'CELO',
                },
                'precisionMode': TICK_SIZE,
                'fees': {
                    'trading': {
                        'tierBased': true, // complicated tier system per coin
                        'percentage': true,
                        'maker': 0.5 / 100, // highest fee of all tiers
                        'taker': 0.5 / 100, // highest fee of all tiers
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                        'withdraw': {
                            'BCH': 0,
                            'BTC': 0,
                            'LTC': 0,
                            'ETH': 0,
                            'EUR': 0.15,
                            'USD': 25,
                        },
                        'deposit': {
                            'BCH': 0,
                            'BTC': 0,
                            'LTC': 0,
                            'ETH': 0,
                            'EUR': 0.15,
                            'USD': 10,
                        },
                    },
                },
                'exceptions': {
                    'exact': {
                        'Insufficient funds': InsufficientFunds,
                        'NotFound': OrderNotFound,
                        'Invalid API Key': AuthenticationError,
                        'invalid signature': AuthenticationError,
                        'Invalid Passphrase': AuthenticationError,
                        'Invalid order id': InvalidOrder,
                        'Private rate limit exceeded': RateLimitExceeded,
                        'Trading pair not available': PermissionDenied,
                        'Product not found': InvalidOrder,
                    },
                    'broad': {
                        'Order already done': OrderNotFound,
                        'order not found': OrderNotFound,
                        'price too small': InvalidOrder,
                        'price too precise': InvalidOrder,
                        'under maintenance': OnMaintenance,
                        'size is too small': InvalidOrder,
                        'Cancel only mode': OnMaintenance, // https://github.com/ccxt/ccxt/issues/7690
                    },
                },
            });
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     [
            //         {
            //             id: 'XTZ',
            //             name: 'Tezos',
            //             min_size: '0.000001',
            //             status: 'online',
            //             message: '',
            //             max_precision: '0.000001',
            //             convertible_to: [],
            //             details: {
            //                 type: 'crypto',
            //                 symbol: 'Τ',
            //                 network_confirmations: 60,
            //                 sort_order: 53,
            //                 crypto_address_link: 'https://tzstats.com/{{address}}',
            //                 crypto_transaction_link: 'https://tzstats.com/{{txId}}',
            //                 push_payment_methods: [ 'crypto' ],
            //                 group_types: [],
            //                 display_name: '',
            //                 processing_time_seconds: 0,
            //                 min_withdrawal_amount: 1
            //             }
            //         }
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'id');
                const name = this.safeString (currency, 'name');
                const code = this.safeCurrencyCode (id);
                const details = this.safeValue (currency, 'details', {});
                const precision = this.safeNumber (currency, 'max_precision');
                const status = this.safeString (currency, 'status');
                const active = (status === 'online');
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'type': this.safeString (details, 'type'),
                    'name': name,
                    'active': active,
                    'fee': undefined,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (details, 'min_size'),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': this.safeNumber (details, 'min_withdrawal_amount'),
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetProducts (params);
            //
            //     [
            //         {
            //             "id":"ZEC-BTC",
            //             "base_currency":"ZEC",
            //             "quote_currency":"BTC",
            //             "base_min_size":"0.01000000",
            //             "base_max_size":"1500.00000000",
            //             "quote_increment":"0.00000100",
            //             "base_increment":"0.00010000",
            //             "display_name":"ZEC/BTC",
            //             "min_market_funds":"0.001",
            //             "max_market_funds":"30",
            //             "margin_enabled":false,
            //             "post_only":false,
            //             "limit_only":false,
            //             "cancel_only":false,
            //             "trading_disabled":false,
            //             "status":"online",
            //             "status_message":""
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'id');
                const baseId = this.safeString (market, 'base_currency');
                const quoteId = this.safeString (market, 'quote_currency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const priceLimits = {
                    'min': this.safeNumber (market, 'quote_increment'),
                    'max': undefined,
                };
                const precision = {
                    'amount': this.safeNumber (market, 'base_increment'),
                    'price': this.safeNumber (market, 'quote_increment'),
                };
                const status = this.safeString (market, 'status');
                const active = (status === 'online');
                result.push (this.extend (this.fees['trading'], {
                    'id': id,
                    'symbol': symbol,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'base': base,
                    'quote': quote,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'base_min_size'),
                            'max': this.safeNumber (market, 'base_max_size'),
                        },
                        'price': priceLimits,
                        'cost': {
                            'min': this.safeNumber (market, 'min_market_funds'),
                            'max': this.safeNumber (market, 'max_market_funds'),
                        },
                    },
                    'active': active,
                    'info': market,
                }));
            }
            return result;
        }
    
        async fetchAccounts (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccounts (params);
            //
            //     [
            //         {
            //             id: '4aac9c60-cbda-4396-9da4-4aa71e95fba0',
            //             currency: 'BTC',
            //             balance: '0.0000000000000000',
            //             available: '0',
            //             hold: '0.0000000000000000',
            //             profile_id: 'b709263e-f42a-4c7d-949a-a95c83d065da'
            //         },
            //         {
            //             id: 'f75fa69a-1ad1-4a80-bd61-ee7faa6135a3',
            //             currency: 'USDC',
            //             balance: '0.0000000000000000',
            //             available: '0',
            //             hold: '0.0000000000000000',
            //             profile_id: 'b709263e-f42a-4c7d-949a-a95c83d065da'
            //         },
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const account = response[i];
                const accountId = this.safeString (account, 'id');
                const currencyId = this.safeString (account, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                result.push ({
                    'id': accountId,
                    'type': undefined,
                    'currency': code,
                    'info': account,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccounts (params);
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'hold');
                account['total'] = this.safeString (balance, 'balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            // level 1 - only the best bid and ask
            // level 2 - top 50 bids and asks (aggregated)
            // level 3 - full order book (non aggregated)
            const request = {
                'id': this.marketId (symbol),
                'level': 2, // 1 best bidask, 2 aggregated, 3 full
            };
            const response = await this.publicGetProductsIdBook (this.extend (request, params));
            //
            //     {
            //         "sequence":1924393896,
            //         "bids":[
            //             ["0.01825","24.34811287",2],
            //             ["0.01824","72.5463",3],
            //             ["0.01823","424.54298049",6],
            //         ],
            //         "asks":[
            //             ["0.01826","171.10414904",4],
            //             ["0.01827","22.60427028",1],
            //             ["0.01828","397.46018784",7],
            //         ]
            //     }
            //
            const orderbook = this.parseOrderBook (response, symbol);
            orderbook['nonce'] = this.safeInteger (response, 'sequence');
            return orderbook;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // publicGetProductsIdTicker
            //
            //     {
            //         "trade_id":843439,
            //         "price":"0.997999",
            //         "size":"80.29769",
            //         "time":"2020-01-28T02:13:33.012523Z",
            //         "bid":"0.997094",
            //         "ask":"0.998",
            //         "volume":"1903188.03750000"
            //     }
            //
            // publicGetProductsIdStats
            //
            //     {
            //         "open": "34.19000000",
            //         "high": "95.70000000",
            //         "low": "7.06000000",
            //         "volume": "2.41000000"
            //     }
            //
            const timestamp = this.parse8601 (this.safeValue (ticker, 'time'));
            const bid = this.safeNumber (ticker, 'bid');
            const ask = this.safeNumber (ticker, 'ask');
            const last = this.safeNumber (ticker, 'price');
            const symbol = (market === undefined) ? undefined : market['symbol'];
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': bid,
                'bidVolume': undefined,
                'ask': ask,
                'askVolume': undefined,
                'vwap': undefined,
                'open': this.safeNumber (ticker, 'open'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'],
            };
            // publicGetProductsIdTicker or publicGetProductsIdStats
            const method = this.safeString (this.options, 'fetchTickerMethod', 'publicGetProductsIdTicker');
            const response = await this[method] (this.extend (request, params));
            //
            // publicGetProductsIdTicker
            //
            //     {
            //         "trade_id":843439,
            //         "price":"0.997999",
            //         "size":"80.29769",
            //         "time":"2020-01-28T02:13:33.012523Z",
            //         "bid":"0.997094",
            //         "ask":"0.998",
            //         "volume":"1903188.03750000"
            //     }
            //
            // publicGetProductsIdStats
            //
            //     {
            //         "open": "34.19000000",
            //         "high": "95.70000000",
            //         "low": "7.06000000",
            //         "volume": "2.41000000"
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            //
            //     {
            //         type: 'match',
            //         trade_id: 82047307,
            //         maker_order_id: '0f358725-2134-435e-be11-753912a326e0',
            //         taker_order_id: '252b7002-87a3-425c-ac73-f5b9e23f3caf',
            //         order_id: 'd50ec984-77a8-460a-b958-66f114b0de9b',
            //         side: 'sell',
            //         size: '0.00513192',
            //         price: '9314.78',
            //         product_id: 'BTC-USD',
            //         profile_id: '6244401d-c078-40d9-b305-7ad3551bc3b0',
            //         sequence: 12038915443,
            //         time: '2020-01-31T20:03:41.158814Z'
            //         created_at: '2014-11-07T22:19:28.578544Z',
            //         liquidity: 'T',
            //         fee: '0.00025',
            //         settled: true,
            //         usd_volume: '0.0924556000000000',
            //         user_id: '595eb864313c2b02ddf2937d'
            //     }
            //
            const timestamp = this.parse8601 (this.safeString2 (trade, 'time', 'created_at'));
            const marketId = this.safeString (trade, 'product_id');
            const symbol = this.safeSymbol (marketId, market, '-');
            let feeRate = undefined;
            let feeCurrency = undefined;
            let takerOrMaker = undefined;
            let cost = undefined;
            if (market !== undefined) {
                const feeCurrencyId = this.safeStringLower (market, 'quoteId');
                const costField = feeCurrencyId + '_value';
                cost = this.safeNumber (trade, costField);
                feeCurrency = market['quote'];
                const liquidity = this.safeString (trade, 'liquidity');
                if (liquidity !== undefined) {
                    takerOrMaker = (liquidity === 'T') ? 'taker' : 'maker';
                    feeRate = market[takerOrMaker];
                }
            }
            const feeCost = this.safeNumber2 (trade, 'fill_fees', 'fee');
            const fee = {
                'cost': feeCost,
                'currency': feeCurrency,
                'rate': feeRate,
            };
            const type = undefined;
            const id = this.safeString (trade, 'trade_id');
            let side = (trade['side'] === 'buy') ? 'sell' : 'buy';
            const orderId = this.safeString (trade, 'order_id');
            // Coinbase Pro returns inverted side to fetchMyTrades vs fetchTrades
            const makerOrderId = this.safeString (trade, 'maker_order_id');
            const takerOrderId = this.safeString (trade, 'taker_order_id');
            if ((orderId !== undefined) || ((makerOrderId !== undefined) && (takerOrderId !== undefined))) {
                side = (trade['side'] === 'buy') ? 'buy' : 'sell';
            }
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'size');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            return {
                'id': id,
                'order': orderId,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'price': price,
                'amount': amount,
                'fee': fee,
                'cost': cost,
            };
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // as of 2018-08-23
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_id': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetFills (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'], // fixes issue #2
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 100
            }
            const response = await this.publicGetProductsIdTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1591514160,
            //         0.02507,
            //         0.02507,
            //         0.02507,
            //         0.02507,
            //         0.02816506
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 0),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const granularity = this.timeframes[timeframe];
            const request = {
                'id': market['id'],
                'granularity': granularity,
            };
            if (since !== undefined) {
                request['start'] = this.iso8601 (since);
                if (limit === undefined) {
                    // https://docs.pro.coinbase.com/#get-historic-rates
                    limit = 300; // max = 300
                } else {
                    limit = Math.min (300, limit);
                }
                request['end'] = this.iso8601 (this.sum ((limit - 1) * granularity * 1000, since));
            }
            const response = await this.publicGetProductsIdCandles (this.extend (request, params));
            //
            //     [
            //         [1591514160,0.02507,0.02507,0.02507,0.02507,0.02816506],
            //         [1591514100,0.02507,0.02507,0.02507,0.02507,1.63830323],
            //         [1591514040,0.02505,0.02507,0.02505,0.02507,0.19918178]
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     {
            //         "iso":"2020-05-12T08:00:51.504Z",
            //         "epoch":1589270451.504
            //     }
            //
            return this.safeTimestamp (response, 'epoch');
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'pending': 'open',
                'active': 'open',
                'open': 'open',
                'done': 'closed',
                'canceled': 'canceled',
                'canceling': 'open',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "id": "d0c5340b-6d6c-49d9-b567-48c4bfca13d2",
            //         "price": "0.10000000",
            //         "size": "0.01000000",
            //         "product_id": "BTC-USD",
            //         "side": "buy",
            //         "stp": "dc",
            //         "type": "limit",
            //         "time_in_force": "GTC",
            //         "post_only": false,
            //         "created_at": "2016-12-08T20:02:28.53864Z",
            //         "fill_fees": "0.0000000000000000",
            //         "filled_size": "0.00000000",
            //         "executed_value": "0.0000000000000000",
            //         "status": "pending",
            //         "settled": false
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const marketId = this.safeString (order, 'product_id');
            market = this.safeMarket (marketId, market, '-');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const price = this.safeNumber (order, 'price');
            const filled = this.safeNumber (order, 'filled_size');
            const amount = this.safeNumber (order, 'size', filled);
            const cost = this.safeNumber (order, 'executed_value');
            const feeCost = this.safeNumber (order, 'fill_fees');
            let fee = undefined;
            if (feeCost !== undefined) {
                let feeCurrencyCode = undefined;
                if (market !== undefined) {
                    feeCurrencyCode = market['quote'];
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                    'rate': undefined,
                };
            }
            const id = this.safeString (order, 'id');
            const type = this.safeString (order, 'type');
            const side = this.safeString (order, 'side');
            const timeInForce = this.safeString (order, 'time_in_force');
            const postOnly = this.safeValue (order, 'post_only');
            const stopPrice = this.safeNumber (order, 'stop_price');
            const clientOrderId = this.safeString (order, 'client_oid');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': market['symbol'],
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'fee': fee,
                'average': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client_oid');
            let method = undefined;
            if (clientOrderId === undefined) {
                method = 'privateGetOrdersId';
                request['id'] = id;
            } else {
                method = 'privateGetOrdersClientClientOid';
                request['client_oid'] = clientOrderId;
                params = this.omit (params, [ 'clientOrderId', 'client_oid' ]);
            }
            const response = await this[method] (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const request = {
                'order_id': id,
            };
            const response = await this.privateGetFills (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': 'all',
            };
            return await this.fetchOpenOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['product_id'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 100
            }
            const response = await this.privateGetOrders (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': 'done',
            };
            return await this.fetchOpenOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                // common params --------------------------------------------------
                // 'client_oid': clientOrderId,
                'type': type,
                'side': side,
                'product_id': market['id'],
                // 'size': this.amountToPrecision (symbol, amount),
                // 'stp': 'dc', // self-trade prevention, dc = decrease and cancel, co = cancel oldest, cn = cancel newest, cb = cancel both
                // 'stop': 'loss', // "loss" = stop loss below price, "entry" = take profit above price
                // 'stop_price': this.priceToPrecision (symbol, price),
                // limit order params ---------------------------------------------
                // 'price': this.priceToPrecision (symbol, price),
                // 'size': this.amountToPrecision (symbol, amount),
                // 'time_in_force': 'GTC', // GTC, GTT, IOC, or FOK
                // 'cancel_after' [optional]* min, hour, day, requires time_in_force to be GTT
                // 'post_only': false, // invalid when time_in_force is IOC or FOK
                // market order params --------------------------------------------
                // 'size': this.amountToPrecision (symbol, amount),
                // 'funds': this.costToPrecision (symbol, amount),
            };
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client_oid');
            if (clientOrderId !== undefined) {
                request['client_oid'] = clientOrderId;
                params = this.omit (params, [ 'clientOrderId', 'client_oid' ]);
            }
            const stopPrice = this.safeNumber2 (params, 'stopPrice', 'stop_price');
            if (stopPrice !== undefined) {
                request['stop_price'] = this.priceToPrecision (symbol, stopPrice);
                params = this.omit (params, [ 'stopPrice', 'stop_price' ]);
            }
            const timeInForce = this.safeString2 (params, 'timeInForce', 'time_in_force');
            if (timeInForce !== undefined) {
                request['time_in_force'] = timeInForce;
                params = this.omit (params, [ 'timeInForce', 'time_in_force' ]);
            }
            if (type === 'limit') {
                request['price'] = this.priceToPrecision (symbol, price);
                request['size'] = this.amountToPrecision (symbol, amount);
            } else if (type === 'market') {
                let cost = this.safeNumber2 (params, 'cost', 'funds');
                if (cost === undefined) {
                    if (price !== undefined) {
                        cost = amount * price;
                    }
                } else {
                    params = this.omit (params, [ 'cost', 'funds' ]);
                }
                if (cost !== undefined) {
                    request['funds'] = this.costToPrecision (symbol, cost);
                } else {
                    request['size'] = this.amountToPrecision (symbol, amount);
                }
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            //
            //     {
            //         "id": "d0c5340b-6d6c-49d9-b567-48c4bfca13d2",
            //         "price": "0.10000000",
            //         "size": "0.01000000",
            //         "product_id": "BTC-USD",
            //         "side": "buy",
            //         "stp": "dc",
            //         "type": "limit",
            //         "time_in_force": "GTC",
            //         "post_only": false,
            //         "created_at": "2016-12-08T20:02:28.53864Z",
            //         "fill_fees": "0.0000000000000000",
            //         "filled_size": "0.00000000",
            //         "executed_value": "0.0000000000000000",
            //         "status": "pending",
            //         "settled": false
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'product_id': market['id'], // the request will be more performant if you include it
            };
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client_oid');
            let method = undefined;
            if (clientOrderId === undefined) {
                method = 'privateDeleteOrdersId';
                request['id'] = id;
            } else {
                method = 'privateDeleteOrdersClientClientOid';
                request['client_oid'] = clientOrderId;
                params = this.omit (params, [ 'clientOrderId', 'client_oid' ]);
            }
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['product_id'] = market['symbol']; // the request will be more performant if you include it
            }
            return await this[method] (this.extend (request, params));
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['product_id'] = market['symbol']; // the request will be more performant if you include it
            }
            return await this.privateDeleteOrders (this.extend (request, params));
        }
    
        async fetchPaymentMethods (params = {}) {
            return await this.privateGetPaymentMethods (params);
        }
    
        async deposit (code, amount, address, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'amount': amount,
            };
            let method = 'privatePostDeposits';
            if ('payment_method_id' in params) {
                // deposit from a payment_method, like a bank account
                method += 'PaymentMethod';
            } else if ('coinbase_account_id' in params) {
                // deposit into Coinbase Pro account from a Coinbase account
                method += 'CoinbaseAccount';
            } else {
                // deposit methodotherwise we did not receive a supported deposit location
                // relevant docs link for the Googlers
                // https://docs.pro.coinbase.com/#deposits
                throw new NotSupported (this.id + ' deposit() requires one of `coinbase_account_id` or `payment_method_id` extra params');
            }
            const response = await this[method] (this.extend (request, params));
            if (!response) {
                throw new ExchangeError (this.id + ' deposit() error: ' + this.json (response));
            }
            return {
                'info': response,
                'id': response['id'],
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'amount': amount,
            };
            let method = 'privatePostWithdrawals';
            if ('payment_method_id' in params) {
                method += 'PaymentMethod';
            } else if ('coinbase_account_id' in params) {
                method += 'CoinbaseAccount';
            } else {
                method += 'Crypto';
                request['crypto_address'] = address;
                if (tag !== undefined) {
                    request['destination_tag'] = tag;
                }
            }
            const response = await this[method] (this.extend (request, params));
            if (!response) {
                throw new ExchangeError (this.id + ' withdraw() error: ' + this.json (response));
            }
            return {
                'info': response,
                'id': response['id'],
            };
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            let currency = undefined;
            let id = this.safeString (params, 'id'); // account id
            if (id === undefined) {
                if (code !== undefined) {
                    currency = this.currency (code);
                    const accountsByCurrencyCode = this.indexBy (this.accounts, 'currency');
                    const account = this.safeValue (accountsByCurrencyCode, code);
                    if (account === undefined) {
                        throw new ExchangeError (this.id + ' fetchTransactions() could not find account id for ' + code);
                    }
                    id = account['id'];
                }
            }
            const request = {};
            if (id !== undefined) {
                request['id'] = id;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            let response = undefined;
            if (id === undefined) {
                response = await this.privateGetTransfers (this.extend (request, params));
                for (let i = 0; i < response.length; i++) {
                    const account_id = this.safeString (response[i], 'account_id');
                    const account = this.safeValue (this.accountsById, account_id);
                    const code = this.safeString (account, 'currency');
                    response[i]['currency'] = code;
                }
            } else {
                response = await this.privateGetAccountsIdTransfers (this.extend (request, params));
                for (let i = 0; i < response.length; i++) {
                    response[i]['currency'] = code;
                }
            }
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            return this.fetchTransactions (code, since, limit, this.extend ({ 'type': 'deposit' }, params));
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            return this.fetchTransactions (code, since, limit, this.extend ({ 'type': 'withdraw' }, params));
        }
    
        parseTransactionStatus (transaction) {
            const canceled = this.safeValue (transaction, 'canceled_at');
            if (canceled) {
                return 'canceled';
            }
            const processed = this.safeValue (transaction, 'processed_at');
            const completed = this.safeValue (transaction, 'completed_at');
            if (completed) {
                return 'ok';
            } else if (processed && !completed) {
                return 'failed';
            } else {
                return 'pending';
            }
        }
    
        parseTransaction (transaction, currency = undefined) {
            const details = this.safeValue (transaction, 'details', {});
            const id = this.safeString (transaction, 'id');
            const txid = this.safeString (details, 'crypto_transaction_hash');
            const timestamp = this.parse8601 (this.safeString (transaction, 'created_at'));
            const updated = this.parse8601 (this.safeString (transaction, 'processed_at'));
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const status = this.parseTransactionStatus (transaction);
            let amount = this.safeNumber (transaction, 'amount');
            let type = this.safeString (transaction, 'type');
            let address = this.safeString (details, 'crypto_address');
            const tag = this.safeString (details, 'destination_tag');
            address = this.safeString (transaction, 'crypto_address', address);
            let fee = undefined;
            if (type === 'withdraw') {
                type = 'withdrawal';
                address = this.safeString (details, 'sent_to_address', address);
                const feeCost = this.safeNumber (details, 'fee');
                if (feeCost !== undefined) {
                    if (amount !== undefined) {
                        amount -= feeCost;
                    }
                    fee = {
                        'cost': feeCost,
                        'currency': code,
                    };
                }
            }
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'tag': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            let accounts = this.safeValue (this.options, 'coinbaseAccounts');
            if (accounts === undefined) {
                accounts = await this.privateGetCoinbaseAccounts ();
                this.options['coinbaseAccounts'] = accounts; // cache it
                this.options['coinbaseAccountsByCurrencyId'] = this.indexBy (accounts, 'currency');
            }
            const currencyId = currency['id'];
            const account = this.safeValue (this.options['coinbaseAccountsByCurrencyId'], currencyId);
            if (account === undefined) {
                // eslint-disable-next-line quotes
                throw new InvalidAddress (this.id + " fetchDepositAddress() could not find currency code " + code + " with id = " + currencyId + " in this.options['coinbaseAccountsByCurrencyId']");
            }
            const request = {
                'id': account['id'],
            };
            const response = await this.privatePostCoinbaseAccountsIdAddresses (this.extend (request, params));
            const address = this.safeString (response, 'address');
            const tag = this.safeString (response, 'destination_tag');
            return {
                'currency': code,
                'address': this.checkAddress (address),
                'tag': tag,
                'info': response,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (method === 'GET') {
                if (Object.keys (query).length) {
                    request += '?' + this.urlencode (query);
                }
            }
            const url = this.implodeHostname (this.urls['api'][api]) + request;
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                let payload = '';
                if (method !== 'GET') {
                    if (Object.keys (query).length) {
                        body = this.json (query);
                        payload = body;
                    }
                }
                const what = nonce + method + request + payload;
                const secret = this.base64ToBinary (this.secret);
                const signature = this.hmac (this.encode (what), secret, 'sha256', 'base64');
                headers = {
                    'CB-ACCESS-KEY': this.apiKey,
                    'CB-ACCESS-SIGN': signature,
                    'CB-ACCESS-TIMESTAMP': nonce,
                    'CB-ACCESS-PASSPHRASE': this.password,
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if ((code === 400) || (code === 404)) {
                if (body[0] === '{') {
                    const message = this.safeString (response, 'message');
                    const feedback = this.id + ' ' + message;
                    this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                    this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                    throw new ExchangeError (feedback); // unknown message
                }
                throw new ExchangeError (this.id + ' ' + body);
            }
        }
    
        async request (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined, config = {}, context = {}) {
            const response = await this.fetch2 (path, api, method, params, headers, body, config, context);
            if (typeof response !== 'string') {
                if ('message' in response) {
                    throw new ExchangeError (this.id + ' ' + this.json (response));
                }
            }
            return response;
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],62:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { BadSymbol, ExchangeError } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coincheck extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coincheck',
                'name': 'coincheck',
                'countries': [ 'JP', 'ID' ],
                'rateLimit': 1500,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMyTrades': true,
                    'fetchOrderBook': true,
                    'fetchOpenOrders': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87182088-1d6d6380-c2ec-11ea-9c64-8ab9f9b289f5.jpg',
                    'api': 'https://coincheck.com/api',
                    'www': 'https://coincheck.com',
                    'doc': 'https://coincheck.com/documents/exchange/api',
                    'fees': [
                        'https://coincheck.com/exchange/fee',
                        'https://coincheck.com/info/fee',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            'exchange/orders/rate',
                            'order_books',
                            'rate/{pair}',
                            'ticker',
                            'trades',
                        ],
                    },
                    'private': {
                        'get': [
                            'accounts',
                            'accounts/balance',
                            'accounts/leverage_balance',
                            'bank_accounts',
                            'deposit_money',
                            'exchange/orders/opens',
                            'exchange/orders/transactions',
                            'exchange/orders/transactions_pagination',
                            'exchange/leverage/positions',
                            'lending/borrows/matches',
                            'send_money',
                            'withdraws',
                        ],
                        'post': [
                            'bank_accounts',
                            'deposit_money/{id}/fast',
                            'exchange/orders',
                            'exchange/transfers/to_leverage',
                            'exchange/transfers/from_leverage',
                            'lending/borrows',
                            'lending/borrows/{id}/repay',
                            'send_money',
                            'withdraws',
                        ],
                        'delete': [
                            'bank_accounts/{id}',
                            'exchange/orders/{id}',
                            'withdraws/{id}',
                        ],
                    },
                },
                'markets': {
                    'BTC/JPY': { 'id': 'btc_jpy', 'symbol': 'BTC/JPY', 'base': 'BTC', 'quote': 'JPY', 'baseId': 'btc', 'quoteId': 'jpy' }, // the only real pair
                    // 'ETH/JPY': { 'id': 'eth_jpy', 'symbol': 'ETH/JPY', 'base': 'ETH', 'quote': 'JPY', 'baseId': 'eth', 'quoteId': 'jpy' },
                    'ETC/JPY': { 'id': 'etc_jpy', 'symbol': 'ETC/JPY', 'base': 'ETC', 'quote': 'JPY', 'baseId': 'etc', 'quoteId': 'jpy' },
                    // 'DAO/JPY': { 'id': 'dao_jpy', 'symbol': 'DAO/JPY', 'base': 'DAO', 'quote': 'JPY', 'baseId': 'dao', 'quoteId': 'jpy' },
                    // 'LSK/JPY': { 'id': 'lsk_jpy', 'symbol': 'LSK/JPY', 'base': 'LSK', 'quote': 'JPY', 'baseId': 'lsk', 'quoteId': 'jpy' },
                    'FCT/JPY': { 'id': 'fct_jpy', 'symbol': 'FCT/JPY', 'base': 'FCT', 'quote': 'JPY', 'baseId': 'fct', 'quoteId': 'jpy' },
                    'MONA/JPY': { 'id': 'mona_jpy', 'symbol': 'MONA/JPY', 'base': 'MONA', 'quote': 'JPY', 'baseId': 'mona', 'quoteId': 'jpy' },
                    // 'XMR/JPY': { 'id': 'xmr_jpy', 'symbol': 'XMR/JPY', 'base': 'XMR', 'quote': 'JPY', 'baseId': 'xmr', 'quoteId': 'jpy' },
                    // 'REP/JPY': { 'id': 'rep_jpy', 'symbol': 'REP/JPY', 'base': 'REP', 'quote': 'JPY', 'baseId': 'rep', 'quoteId': 'jpy' },
                    // 'XRP/JPY': { 'id': 'xrp_jpy', 'symbol': 'XRP/JPY', 'base': 'XRP', 'quote': 'JPY', 'baseId': 'xrp', 'quoteId': 'jpy' },
                    // 'ZEC/JPY': { 'id': 'zec_jpy', 'symbol': 'ZEC/JPY', 'base': 'ZEC', 'quote': 'JPY', 'baseId': 'zec', 'quoteId': 'jpy' },
                    // 'XEM/JPY': { 'id': 'xem_jpy', 'symbol': 'XEM/JPY', 'base': 'XEM', 'quote': 'JPY', 'baseId': 'xem', 'quoteId': 'jpy' },
                    // 'LTC/JPY': { 'id': 'ltc_jpy', 'symbol': 'LTC/JPY', 'base': 'LTC', 'quote': 'JPY', 'baseId': 'ltc', 'quoteId': 'jpy' },
                    // 'DASH/JPY': { 'id': 'dash_jpy', 'symbol': 'DASH/JPY', 'base': 'DASH', 'quote': 'JPY', 'baseId': 'dash', 'quoteId': 'jpy' },
                    // 'ETH/BTC': { 'id': 'eth_btc', 'symbol': 'ETH/BTC', 'base': 'ETH', 'quote': 'BTC', 'baseId': 'eth', 'quoteId': 'btc' },
                    'ETC/BTC': { 'id': 'etc_btc', 'symbol': 'ETC/BTC', 'base': 'ETC', 'quote': 'BTC', 'baseId': 'etc', 'quoteId': 'btc' },
                    // 'LSK/BTC': { 'id': 'lsk_btc', 'symbol': 'LSK/BTC', 'base': 'LSK', 'quote': 'BTC', 'baseId': 'lsk', 'quoteId': 'btc' },
                    // 'FCT/BTC': { 'id': 'fct_btc', 'symbol': 'FCT/BTC', 'base': 'FCT', 'quote': 'BTC', 'baseId': 'fct', 'quoteId': 'btc' },
                    // 'XMR/BTC': { 'id': 'xmr_btc', 'symbol': 'XMR/BTC', 'base': 'XMR', 'quote': 'BTC', 'baseId': 'xmr', 'quoteId': 'btc' },
                    // 'REP/BTC': { 'id': 'rep_btc', 'symbol': 'REP/BTC', 'base': 'REP', 'quote': 'BTC', 'baseId': 'rep', 'quoteId': 'btc' },
                    // 'XRP/BTC': { 'id': 'xrp_btc', 'symbol': 'XRP/BTC', 'base': 'XRP', 'quote': 'BTC', 'baseId': 'xrp', 'quoteId': 'btc' },
                    // 'ZEC/BTC': { 'id': 'zec_btc', 'symbol': 'ZEC/BTC', 'base': 'ZEC', 'quote': 'BTC', 'baseId': 'zec', 'quoteId': 'btc' },
                    // 'XEM/BTC': { 'id': 'xem_btc', 'symbol': 'XEM/BTC', 'base': 'XEM', 'quote': 'BTC', 'baseId': 'xem', 'quoteId': 'btc' },
                    // 'LTC/BTC': { 'id': 'ltc_btc', 'symbol': 'LTC/BTC', 'base': 'LTC', 'quote': 'BTC', 'baseId': 'ltc', 'quoteId': 'btc' },
                    // 'DASH/BTC': { 'id': 'dash_btc', 'symbol': 'DASH/BTC', 'base': 'DASH', 'quote': 'BTC', 'baseId': 'dash', 'quoteId': 'btc' },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': this.parseNumber ('0'),
                        'taker': this.parseNumber ('0'),
                    },
                },
            });
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const balances = await this.privateGetAccountsBalance (params);
            const result = { 'info': balances };
            const codes = Object.keys (this.currencies);
            for (let i = 0; i < codes.length; i++) {
                const code = codes[i];
                const currency = this.currency (code);
                const currencyId = currency['id'];
                if (currencyId in balances) {
                    const account = this.account ();
                    const reserved = currencyId + '_reserved';
                    account['free'] = this.safeString (balances, currencyId);
                    account['used'] = this.safeString (balances, reserved);
                    result[code] = account;
                }
            }
            return this.parseBalance (result);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            // Only BTC/JPY is meaningful
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const response = await this.privateGetExchangeOrdersOpens (params);
            const rawOrders = this.safeValue (response, 'orders', []);
            const parsedOrders = this.parseOrders (rawOrders, market, since, limit);
            const result = [];
            for (let i = 0; i < parsedOrders.length; i++) {
                result.push (this.extend (parsedOrders[i], { 'status': 'open' }));
            }
            return result;
        }
    
        parseOrder (order, market = undefined) {
            //
            // fetchOpenOrders
            //
            //     {                        id:  202835,
            //                      order_type: "buy",
            //                            rate:  26890,
            //                            pair: "btc_jpy",
            //                  pending_amount: "0.5527",
            //       pending_market_buy_amount:  null,
            //                  stop_loss_rate:  null,
            //                      created_at: "2015-01-10T05:55:38.000Z" }
            //
            // todo: add formats for fetchOrder, fetchClosedOrders here
            //
            const id = this.safeString (order, 'id');
            const side = this.safeString (order, 'order_type');
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const amount = this.safeNumber (order, 'pending_amount');
            const remaining = this.safeNumber (order, 'pending_amount');
            const price = this.safeNumber (order, 'rate');
            const status = undefined;
            const marketId = this.safeString (order, 'pair');
            const symbol = this.safeSymbol (marketId, market, '_');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'amount': amount,
                'remaining': remaining,
                'filled': undefined,
                'side': side,
                'type': undefined,
                'timeInForce': undefined,
                'postOnly': undefined,
                'status': status,
                'symbol': symbol,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'fee': undefined,
                'info': order,
                'average': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetOrderBooks (this.extend (request, params));
            return this.parseOrderBook (response, symbol);
        }
    
        async fetchTicker (symbol, params = {}) {
            if (symbol !== 'BTC/JPY') {
                throw new BadSymbol (this.id + ' fetchTicker () supports BTC/JPY only');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const ticker = await this.publicGetTicker (this.extend (request, params));
            const timestamp = this.safeTimestamp (ticker, 'timestamp');
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.parse8601 (this.safeString (trade, 'created_at'));
            const id = this.safeString (trade, 'id');
            const priceString = this.safeString (trade, 'rate');
            const marketId = this.safeString (trade, 'pair');
            market = this.safeValue (this.markets_by_id, marketId, market);
            let symbol = undefined;
            let baseId = undefined;
            let quoteId = undefined;
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                    baseId = market['baseId'];
                    quoteId = market['quoteId'];
                    symbol = market['symbol'];
                } else {
                    const ids = marketId.split ('_');
                    baseId = ids[0];
                    quoteId = ids[1];
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if (symbol === undefined) {
                if (market !== undefined) {
                    symbol = market['symbol'];
                }
            }
            let takerOrMaker = undefined;
            let amountString = undefined;
            let cost = undefined;
            let side = undefined;
            let fee = undefined;
            let orderId = undefined;
            if ('liquidity' in trade) {
                if (this.safeString (trade, 'liquidity') === 'T') {
                    takerOrMaker = 'taker';
                } else if (this.safeString (trade, 'liquidity') === 'M') {
                    takerOrMaker = 'maker';
                }
                const funds = this.safeValue (trade, 'funds', {});
                amountString = this.safeString (funds, baseId);
                cost = this.safeNumber (funds, quoteId);
                fee = {
                    'currency': this.safeString (trade, 'fee_currency'),
                    'cost': this.safeNumber (trade, 'fee'),
                };
                side = this.safeString (trade, 'side');
                orderId = this.safeString (trade, 'order_id');
            } else {
                amountString = this.safeString (trade, 'amount');
                side = this.safeString (trade, 'order_type');
            }
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            return {
                'id': id,
                'info': trade,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'order': orderId,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const response = await this.privateGetExchangeOrdersTransactions (this.extend ({}, params));
            const transactions = this.safeValue (response, 'transactions', []);
            return this.parseTrades (transactions, market, since, limit);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetTrades (this.extend (request, params));
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
            };
            if (type === 'market') {
                const order_type = type + '_' + side;
                request['order_type'] = order_type;
                const prefix = (side === 'buy') ? (order_type + '_') : '';
                request[prefix + 'amount'] = amount;
            } else {
                request['order_type'] = side;
                request['rate'] = price;
                request['amount'] = amount;
            }
            const response = await this.privatePostExchangeOrders (this.extend (request, params));
            const id = this.safeString (response, 'id');
            return {
                'info': response,
                'id': id,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const request = {
                'id': id,
            };
            return await this.privateDeleteExchangeOrdersId (this.extend (request, params));
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                let queryString = '';
                if (method === 'GET') {
                    if (Object.keys (query).length) {
                        url += '?' + this.urlencode (this.keysort (query));
                    }
                } else {
                    if (Object.keys (query).length) {
                        body = this.urlencode (this.keysort (query));
                        queryString = body;
                    }
                }
                const auth = nonce + url + queryString;
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'ACCESS-KEY': this.apiKey,
                    'ACCESS-NONCE': nonce,
                    'ACCESS-SIGNATURE': this.hmac (this.encode (auth), this.encode (this.secret)),
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const success = this.safeValue (response, 'success', true);
            if (!success) {
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],63:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AuthenticationError, InvalidNonce, InsufficientFunds, InvalidOrder, OrderNotFound, DDoSProtection } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinegg extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinegg',
                'name': 'CoinEgg',
                'countries': [ 'CN', 'UK' ],
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': false,
                    'fetchOpenOrders': 'emulated',
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': false,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/36770310-adfa764e-1c5a-11e8-8e09-449daac3d2fb.jpg',
                    'api': {
                        'web': 'https://trade.coinegg.com/web',
                        'rest': 'https://api.coinegg.com/api/v1',
                    },
                    'www': 'https://www.coinegg.com',
                    'doc': 'https://www.coinegg.com/explain.api.html',
                    'fees': 'https://www.coinegg.com/fee.html',
                    'referral': 'https://www.coinegg.com/user/register?invite=523218',
                },
                'api': {
                    'web': {
                        'get': [
                            'symbol/ticker?right_coin={quote}',
                            '{quote}/trends',
                            '{quote}/{base}/order',
                            '{quote}/{base}/trades',
                            '{quote}/{base}/depth.js',
                        ],
                    },
                    'public': {
                        'get': [
                            'ticker/region/{quote}',
                            'depth/region/{quote}',
                            'orders/region/{quote}',
                        ],
                    },
                    'private': {
                        'post': [
                            'balance',
                            'trade_add/region/{quote}',
                            'trade_cancel/region/{quote}',
                            'trade_view/region/{quote}',
                            'trade_list/region/{quote}',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': 0.1 / 100,
                        'taker': 0.1 / 100,
                    },
                    'funding': {
                        'withdraw': {
                            'BTC': 0.008,
                            'BCH': 0.002,
                            'LTC': 0.001,
                            'ETH': 0.01,
                            'ETC': 0.01,
                            'NEO': 0,
                            'QTUM': '1%',
                            'XRP': '1%',
                            'DOGE': '1%',
                            'LSK': '1%',
                            'XAS': '1%',
                            'BTS': '1%',
                            'GAME': '1%',
                            'GOOC': '1%',
                            'NXT': '1%',
                            'IFC': '1%',
                            'DNC': '1%',
                            'BLK': '1%',
                            'VRC': '1%',
                            'XPM': '1%',
                            'VTC': '1%',
                            'TFC': '1%',
                            'PLC': '1%',
                            'EAC': '1%',
                            'PPC': '1%',
                            'FZ': '1%',
                            'ZET': '1%',
                            'RSS': '1%',
                            'PGC': '1%',
                            'SKT': '1%',
                            'JBC': '1%',
                            'RIO': '1%',
                            'LKC': '1%',
                            'ZCC': '1%',
                            'MCC': '1%',
                            'QEC': '1%',
                            'MET': '1%',
                            'YTC': '1%',
                            'HLB': '1%',
                            'MRYC': '1%',
                            'MTC': '1%',
                            'KTC': 0,
                        },
                    },
                },
                'exceptions': {
                    '103': AuthenticationError,
                    '104': AuthenticationError,
                    '105': AuthenticationError,
                    '106': InvalidNonce,
                    '200': InsufficientFunds,
                    '201': InvalidOrder,
                    '202': InvalidOrder,
                    '203': OrderNotFound,
                    '402': DDoSProtection,
                },
                'errorMessages': {
                    '100': 'Required parameters can not be empty',
                    '101': 'Illegal parameter',
                    '102': 'coin does not exist',
                    '103': 'Key does not exist',
                    '104': 'Signature does not match',
                    '105': 'Insufficient permissions',
                    '106': 'Request expired(nonce error)',
                    '200': 'Lack of balance',
                    '201': 'Too small for the number of trading',
                    '202': 'Price must be in 0 - 1000000',
                    '203': 'Order does not exist',
                    '204': 'Pending order amount must be above 0.001 BTC',
                    '205': 'Restrict pending order prices',
                    '206': 'Decimal place error',
                    '401': 'System error',
                    '402': 'Requests are too frequent',
                    '403': 'Non-open API',
                    '404': 'IP restriction does not request the resource',
                    '405': 'Currency transactions are temporarily closed',
                },
                'options': {
                    'quoteIds': [ 'btc', 'eth', 'usc', 'usdt' ],
                },
                'commonCurrencies': {
                    'JBC': 'JubaoCoin',
                    'SBTC': 'Super Bitcoin',
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const quoteIds = this.options['quoteIds'];
            const result = [];
            for (let b = 0; b < quoteIds.length; b++) {
                const quoteId = quoteIds[b];
                const response = await this.webGetSymbolTickerRightCoinQuote ({
                    'quote': quoteId,
                });
                const tickers = this.safeValue (response, 'data', []);
                for (let i = 0; i < tickers.length; i++) {
                    const ticker = tickers[i];
                    const id = ticker['symbol'];
                    const baseId = id.split ('_')[0];
                    let base = baseId.toUpperCase ();
                    let quote = quoteId.toUpperCase ();
                    base = this.safeCurrencyCode (base);
                    quote = this.safeCurrencyCode (quote);
                    const symbol = base + '/' + quote;
                    const precision = {
                        'amount': 8,
                        'price': 8,
                    };
                    result.push ({
                        'id': id,
                        'symbol': symbol,
                        'base': base,
                        'quote': quote,
                        'baseId': baseId,
                        'quoteId': quoteId,
                        'active': true,
                        'precision': precision,
                        'limits': {
                            'amount': {
                                'min': Math.pow (10, -precision['amount']),
                                'max': Math.pow (10, precision['amount']),
                            },
                            'price': {
                                'min': Math.pow (10, -precision['price']),
                                'max': Math.pow (10, precision['price']),
                            },
                            'cost': {
                                'min': undefined,
                                'max': undefined,
                            },
                        },
                        'info': ticker,
                    });
                }
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            const symbol = market['symbol'];
            const timestamp = this.milliseconds ();
            const last = this.safeNumber (ticker, 'last');
            const percentage = this.safeNumber (ticker, 'change');
            let open = undefined;
            let change = undefined;
            let average = undefined;
            if (percentage !== undefined) {
                const relativeChange = percentage / 100;
                open = last / this.sum (1, relativeChange);
                change = last - open;
                average = this.sum (last, open) / 2;
            }
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': average,
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': this.safeNumber (ticker, 'quoteVol'),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'coin': market['baseId'],
                'quote': market['quoteId'],
            };
            const response = await this.publicGetTickerRegionQuote (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'coin': market['baseId'],
                'quote': market['quoteId'],
            };
            const response = await this.publicGetDepthRegionQuote (this.extend (request, params));
            return this.parseOrderBook (response, symbol);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeTimestamp (trade, 'date');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const symbol = market['symbol'];
            const type = 'limit';
            const side = this.safeString (trade, 'type');
            const id = this.safeString (trade, 'tid');
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': undefined,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'coin': market['baseId'],
                'quote': market['quoteId'],
            };
            const response = await this.publicGetOrdersRegionQuote (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostBalance (params);
            const result = { 'info': response };
            const data = this.safeValue (response, 'data', {});
            const balances = this.omit (data, 'uid');
            const keys = Object.keys (balances);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const [ currencyId, accountType ] = key.split ('_');
                const code = this.safeCurrencyCode (currencyId);
                if (!(code in result)) {
                    result[code] = this.account ();
                }
                const type = (accountType === 'lock') ? 'used' : 'free';
                result[code][type] = this.safeString (balances, key);
            }
            return this.parseBalance (result);
        }
    
        parseOrder (order, market = undefined) {
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const timestamp = this.parse8601 (this.safeString (order, 'datetime'));
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount_original');
            const remaining = this.safeNumber (order, 'amount_outstanding');
            let status = this.safeString (order, 'status');
            if (status === 'cancelled') {
                status = 'canceled';
            } else {
                status = remaining ? 'open' : 'closed';
            }
            const info = this.safeValue (order, 'info', order);
            const type = 'limit';
            const side = this.safeString (order, 'type');
            const id = this.safeString (order, 'id');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'amount': amount,
                'filled': undefined,
                'remaining': remaining,
                'trades': undefined,
                'fee': undefined,
                'info': info,
                'average': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'coin': market['baseId'],
                'quote': market['quoteId'],
                'type': side,
                'amount': amount,
                'price': price,
            };
            const response = await this.privatePostTradeAddRegionQuote (this.extend (request, params));
            const id = this.safeString (response, 'id');
            const order = this.parseOrder ({
                'id': id,
                'datetime': this.ymdhms (this.milliseconds ()),
                'amount_original': amount,
                'amount_outstanding': amount,
                'price': price,
                'type': side,
                'info': response,
            }, market);
            return order;
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': id,
                'coin': market['baseId'],
                'quote': market['quoteId'],
            };
            return await this.privatePostTradeCancelRegionQuote (this.extend (request, params));
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': id,
                'coin': market['baseId'],
                'quote': market['quoteId'],
            };
            const response = await this.privatePostTradeViewRegionQuote (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'coin': market['baseId'],
                'quote': market['quoteId'],
            };
            if (since !== undefined) {
                request['since'] = since / 1000;
            }
            const response = await this.privatePostTradeListRegionQuote (this.extend (request, params));
            const data = this.safeValue (response, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'type': 'open',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let apiType = 'rest';
            if (api === 'web') {
                apiType = api;
            }
            let url = this.urls['api'][apiType] + '/' + this.implodeParams (path, params);
            let query = this.omit (params, this.extractParams (path));
            if (api === 'public' || api === 'web') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                query = this.urlencode (this.extend ({
                    'key': this.apiKey,
                    'nonce': this.nonce (),
                }, query));
                const secret = this.hash (this.encode (this.secret));
                const signature = this.hmac (this.encode (query), this.encode (secret));
                query += '&' + 'signature=' + signature;
                if (method === 'GET') {
                    url += '?' + query;
                } else {
                    headers = {
                        'Content-type': 'application/x-www-form-urlencoded',
                    };
                    body = query;
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            // private endpoints return the following structure:
            // {"result":true,"data":{...}} - success
            // {"result":false,"code":"103"} - failure
            // {"code":0,"msg":"Suceess","data":{"uid":"2716039","btc_balance":"0.00000000","btc_lock":"0.00000000","xrp_balance":"0.00000000","xrp_lock":"0.00000000"}}
            const result = this.safeValue (response, 'result');
            if (result === undefined) {
                // public endpoint ← this comment left here by the contributor, in fact a missing result does not necessarily mean a public endpoint...
                // we should just check the code and don't rely on the result at all here...
                return;
            }
            if (result === true) {
                // success
                return;
            }
            const errorCode = this.safeString (response, 'code');
            const errorMessages = this.errorMessages;
            const message = this.safeString (errorMessages, errorCode, 'Unknown Error');
            const feedback = this.id + ' ' + message;
            this.throwExactlyMatchedException (this.exceptions, errorCode, feedback);
            throw new ExchangeError (this.id + ' ' + message);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],64:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, InsufficientFunds, OrderNotFound, InvalidOrder, AuthenticationError, PermissionDenied, ExchangeNotAvailable, RequestTimeout } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinex',
                'name': 'CoinEx',
                'version': 'v1',
                'countries': [ 'CN' ],
                'rateLimit': 1000,
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1min',
                    '3m': '3min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '1hour',
                    '2h': '2hour',
                    '4h': '4hour',
                    '6h': '6hour',
                    '12h': '12hour',
                    '1d': '1day',
                    '3d': '3day',
                    '1w': '1week',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87182089-1e05fa00-c2ec-11ea-8da9-cc73b45abbbc.jpg',
                    'api': {
                        'public': 'https://api.coinex.com',
                        'private': 'https://api.coinex.com',
                        'perpetualPublic': 'https://api.coinex.com/perpetual',
                        'perpetualPrivate': 'https://api.coinex.com/perpetual',
                    },
                    'www': 'https://www.coinex.com',
                    'doc': 'https://github.com/coinexcom/coinex_exchange_api/wiki',
                    'fees': 'https://www.coinex.com/fees',
                    'referral': 'https://www.coinex.com/register?refer_code=yw5fz',
                },
                'api': {
                    'public': {
                        'get': [
                            'common/currency/rate',
                            'common/asset/config',
                            'market/info',
                            'market/list',
                            'market/ticker',
                            'market/ticker/all',
                            'market/depth',
                            'market/deals',
                            'market/kline',
                        ],
                    },
                    'private': {
                        'get': [
                            'balance/coin/deposit',
                            'balance/coin/withdraw',
                            'balance/info',
                            'future/account',
                            'future/config',
                            'future/limitprice',
                            'future/loan/history',
                            'future/market',
                            'margin/account',
                            'margin/config',
                            'margin/loan/history',
                            'margin/market',
                            'order',
                            'order/deals',
                            'order/finished',
                            'order/finished/{id}',
                            'order/pending',
                            'order/status',
                            'order/status/batch',
                            'order/user/deals',
                            'sub_account/balance',
                            'sub_account/transfer/history',
                        ],
                        'post': [
                            'balance/coin/withdraw',
                            'future/flat',
                            'future/loan',
                            'future/transfer',
                            'margin/flat',
                            'margin/loan',
                            'margin/transfer',
                            'order/batchlimit',
                            'order/ioc',
                            'order/limit',
                            'order/market',
                            'sub_account/transfer',
                        ],
                        'delete': [
                            'balance/coin/withdraw',
                            'order/pending/batch',
                            'order/pending',
                        ],
                    },
                    'perpetualPublic': {
                        'get': [
                            'ping',
                            'time',
                            'market/list',
                            'market/limit_config',
                            'market/ticker',
                            'market/ticker/all',
                            'market/depth',
                            'market/deals',
                            'market/funding_history',
                            'market/user_deals',
                            'market/kline',
                        ],
                    },
                    'perpetualPrivate': {
                        'get': [
                            'asset/query',
                            'order/pending',
                            'order/finished',
                            'order/stop_pending',
                            'order/status',
                            'position/pending',
                            'position/funding',
                        ],
                        'post': [
                            'market/adjust_leverage',
                            'market/position_expect',
                            'order/put_limit',
                            'order/put_market',
                            'order/put_stop_limit',
                            'order/cancel',
                            'order/cancel_all',
                            'order/cancel_stop',
                            'order/cancel_stop_all',
                            'order/close_limit',
                            'order/close_market',
                            'position/adjust_margin',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': 0.001,
                        'taker': 0.001,
                    },
                    'funding': {
                        'withdraw': {
                            'BCH': 0.0,
                            'BTC': 0.001,
                            'LTC': 0.001,
                            'ETH': 0.001,
                            'ZEC': 0.0001,
                            'DASH': 0.0001,
                        },
                    },
                },
                'limits': {
                    'amount': {
                        'min': 0.001,
                        'max': undefined,
                    },
                },
                'precision': {
                    'amount': 8,
                    'price': 8,
                },
                'options': {
                    'createMarketBuyOrderRequiresPrice': true,
                },
                'commonCurrencies': {
                    'ACM': 'Actinium',
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarketInfo (params);
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "WAVESBTC": {
            //                 "name": "WAVESBTC",
            //                 "min_amount": "1",
            //                 "maker_fee_rate": "0.001",
            //                 "taker_fee_rate": "0.001",
            //                 "pricing_name": "BTC",
            //                 "pricing_decimal": 8,
            //                 "trading_name": "WAVES",
            //                 "trading_decimal": 8
            //             }
            //         }
            //     }
            //
            const markets = this.safeValue (response, 'data', {});
            const result = [];
            const keys = Object.keys (markets);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const market = markets[key];
                const id = this.safeString (market, 'name');
                const tradingName = this.safeString (market, 'trading_name');
                const baseId = tradingName;
                const quoteId = this.safeString (market, 'pricing_name');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                let symbol = base + '/' + quote;
                if (tradingName === id) {
                    symbol = id;
                }
                const precision = {
                    'amount': this.safeInteger (market, 'trading_decimal'),
                    'price': this.safeInteger (market, 'pricing_decimal'),
                };
                const active = undefined;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'taker': this.safeNumber (market, 'taker_fee_rate'),
                    'maker': this.safeNumber (market, 'maker_fee_rate'),
                    'info': market,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'min_amount'),
                            'max': undefined,
                        },
                        'price': {
                            'min': Math.pow (10, -precision['price']),
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.safeInteger (ticker, 'date');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            ticker = this.safeValue (ticker, 'ticker', {});
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber2 (ticker, 'vol', 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetMarketTicker (this.extend (request, params));
            return this.parseTicker (response['data'], market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetMarketTickerAll (params);
            const data = this.safeValue (response, 'data');
            const timestamp = this.safeInteger (data, 'date');
            const tickers = this.safeValue (data, 'ticker');
            const marketIds = Object.keys (tickers);
            const result = {};
            for (let i = 0; i < marketIds.length; i++) {
                const marketId = marketIds[i];
                const market = this.safeMarket (marketId);
                const symbol = market['symbol'];
                const ticker = this.parseTicker ({
                    'date': timestamp,
                    'ticker': tickers[marketId],
                }, market);
                ticker['symbol'] = symbol;
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = 20, params = {}) {
            await this.loadMarkets ();
            if (limit === undefined) {
                limit = 20; // default
            }
            const request = {
                'market': this.marketId (symbol),
                'merge': '0.0000000001',
                'limit': limit.toString (),
            };
            const response = await this.publicGetMarketDepth (this.extend (request, params));
            return this.parseOrderBook (response['data'], symbol);
        }
    
        parseTrade (trade, market = undefined) {
            // this method parses both public and private trades
            let timestamp = this.safeTimestamp (trade, 'create_time');
            if (timestamp === undefined) {
                timestamp = this.safeInteger (trade, 'date_ms');
            }
            const tradeId = this.safeString (trade, 'id');
            const orderId = this.safeString (trade, 'order_id');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const marketId = this.safeString (trade, 'market');
            const symbol = this.safeSymbol (marketId, market);
            let cost = this.safeNumber (trade, 'deal_money');
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'fee_asset');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            const takerOrMaker = this.safeString (trade, 'role');
            const side = this.safeString (trade, 'type');
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': tradeId,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetMarketDeals (this.extend (request, params));
            return this.parseTrades (response['data'], market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1591484400,
            //         "0.02505349",
            //         "0.02506988",
            //         "0.02507000",
            //         "0.02505304",
            //         "343.19716223",
            //         "8.6021323866383196",
            //         "ETHBTC"
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '5m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                'type': this.timeframes[timeframe],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetMarketKline (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             [1591484400, "0.02505349", "0.02506988", "0.02507000", "0.02505304", "343.19716223", "8.6021323866383196", "ETHBTC"],
            //             [1591484700, "0.02506990", "0.02508109", "0.02508109", "0.02506979", "91.59841581", "2.2972047780447000", "ETHBTC"],
            //             [1591485000, "0.02508106", "0.02507996", "0.02508106", "0.02507500", "65.15307697", "1.6340597822306000", "ETHBTC"],
            //         ],
            //         "message": "OK"
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetBalanceInfo (params);
            //
            //     {
            //       "code": 0,
            //       "data": {
            //         "BCH": {                     # BCH account
            //           "available": "13.60109",   # Available BCH
            //           "frozen": "0.00000"        # Frozen BCH
            //         },
            //         "BTC": {                     # BTC account
            //           "available": "32590.16",   # Available BTC
            //           "frozen": "7000.00"        # Frozen BTC
            //         },
            //         "ETH": {                     # ETH account
            //           "available": "5.06000",    # Available ETH
            //           "frozen": "0.00000"        # Frozen ETH
            //         }
            //       },
            //       "message": "Ok"
            //     }
            //
            const result = { 'info': response };
            const balances = this.safeValue (response, 'data', {});
            const currencyIds = Object.keys (balances);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const balance = this.safeValue (balances, currencyId, {});
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'frozen');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'not_deal': 'open',
                'part_deal': 'open',
                'done': 'closed',
                'cancel': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // fetchOrder
            //
            //     {
            //         "amount": "0.1",
            //         "asset_fee": "0.22736197736197736197",
            //         "avg_price": "196.85000000000000000000",
            //         "create_time": 1537270135,
            //         "deal_amount": "0.1",
            //         "deal_fee": "0",
            //         "deal_money": "19.685",
            //         "fee_asset": "CET",
            //         "fee_discount": "0.5",
            //         "id": 1788259447,
            //         "left": "0",
            //         "maker_fee_rate": "0",
            //         "market": "ETHUSDT",
            //         "order_type": "limit",
            //         "price": "170.00000000",
            //         "status": "done",
            //         "taker_fee_rate": "0.0005",
            //         "type": "sell",
            //     }
            //
            const timestamp = this.safeTimestamp (order, 'create_time');
            const price = this.safeNumber (order, 'price');
            const cost = this.safeNumber (order, 'deal_money');
            const amount = this.safeNumber (order, 'amount');
            const filled = this.safeNumber (order, 'deal_amount');
            const average = this.safeNumber (order, 'avg_price');
            let symbol = undefined;
            const marketId = this.safeString (order, 'market');
            market = this.safeMarket (marketId, market);
            const feeCurrencyId = this.safeString (order, 'fee_asset');
            let feeCurrency = this.safeCurrencyCode (feeCurrencyId);
            if (market !== undefined) {
                symbol = market['symbol'];
                if (feeCurrency === undefined) {
                    feeCurrency = market['quote'];
                }
            }
            const remaining = this.safeNumber (order, 'left');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const type = this.safeString (order, 'order_type');
            const side = this.safeString (order, 'type');
            return this.safeOrder ({
                'id': this.safeString (order, 'id'),
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'average': average,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'trades': undefined,
                'fee': {
                    'currency': feeCurrency,
                    'cost': this.safeNumber (order, 'deal_fee'),
                },
                'info': order,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const method = 'privatePostOrder' + this.capitalize (type);
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                'type': side,
            };
            // for market buy it requires the amount of quote currency to spend
            if ((type === 'market') && (side === 'buy')) {
                if (this.options['createMarketBuyOrderRequiresPrice']) {
                    if (price === undefined) {
                        throw new InvalidOrder (this.id + " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false to supply the cost in the amount argument (the exchange-specific behaviour)");
                    } else {
                        request['amount'] = this.costToPrecision (symbol, amount * price);
                    }
                } else {
                    request['amount'] = this.costToPrecision (symbol, amount);
                }
            } else {
                request['amount'] = this.amountToPrecision (symbol, amount);
            }
            if ((type === 'limit') || (type === 'ioc')) {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this[method] (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': id,
                'market': market['id'],
            };
            const response = await this.privateDeleteOrderPending (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': id,
                'market': market['id'],
            };
            const response = await this.privateGetOrder (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "amount": "0.1",
            //             "asset_fee": "0.22736197736197736197",
            //             "avg_price": "196.85000000000000000000",
            //             "create_time": 1537270135,
            //             "deal_amount": "0.1",
            //             "deal_fee": "0",
            //             "deal_money": "19.685",
            //             "fee_asset": "CET",
            //             "fee_discount": "0.5",
            //             "id": 1788259447,
            //             "left": "0",
            //             "maker_fee_rate": "0",
            //             "market": "ETHUSDT",
            //             "order_type": "limit",
            //             "price": "170.00000000",
            //             "status": "done",
            //             "taker_fee_rate": "0.0005",
            //             "type": "sell",
            //         },
            //         "message": "Ok"
            //     }
            //
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async fetchOrdersByStatus (status, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (limit === undefined) {
                limit = 100;
            }
            const request = {
                'page': 1,
                'limit': limit,
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['market'] = market['id'];
            }
            const method = 'privateGetOrder' + this.capitalize (status);
            const response = await this[method] (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            const orders = this.safeValue (data, 'data', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStatus ('pending', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStatus ('finished', symbol, since, limit, params);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (limit === undefined) {
                limit = 100;
            }
            const request = {
                'page': 1,
                'limit': limit,
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['market'] = market['id'];
            }
            const response = await this.privateGetOrderUserDeals (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            const trades = this.safeValue (data, 'data', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            if (tag) {
                address = address + ':' + tag;
            }
            const request = {
                'coin_type': currency['id'],
                'coin_address': address, // must be authorized, inter-user transfer by a registered mobile phone number or an email address is supported
                'actual_amount': parseFloat (amount), // the actual amount without fees, https://www.coinex.com/fees
                'transfer_method': 'onchain', // onchain, local
            };
            const response = await this.privatePostBalanceCoinWithdraw (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "actual_amount": "1.00000000",
            //             "amount": "1.00000000",
            //             "coin_address": "1KAv3pazbTk2JnQ5xTo6fpKK7p1it2RzD4",
            //             "coin_type": "BCH",
            //             "coin_withdraw_id": 206,
            //             "confirmations": 0,
            //             "create_time": 1524228297,
            //             "status": "audit",
            //             "tx_fee": "0",
            //             "tx_id": ""
            //         },
            //         "message": "Ok"
            //     }
            //
            const transaction = this.safeValue (response, 'data', {});
            return this.parseTransaction (transaction, currency);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'audit': 'pending',
                'pass': 'pending',
                'processing': 'pending',
                'confirming': 'pending',
                'not_pass': 'failed',
                'cancel': 'canceled',
                'finish': 'ok',
                'fail': 'failed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         "actual_amount": "120.00000000",
            //         "actual_amount_display": "120",
            //         "add_explorer": "XXX",
            //         "amount": "120.00000000",
            //         "amount_display": "120",
            //         "coin_address": "XXXXXXXX",
            //         "coin_address_display": "XXXXXXXX",
            //         "coin_deposit_id": 1866,
            //         "coin_type": "USDT",
            //         "confirmations": 0,
            //         "create_time": 1539595701,
            //         "explorer": "",
            //         "remark": "",
            //         "status": "finish",
            //         "status_display": "finish",
            //         "transfer_method": "local",
            //         "tx_id": "",
            //         "tx_id_display": "XXXXXXXXXX"
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         "actual_amount": "0.10000000",
            //         "amount": "0.10000000",
            //         "coin_address": "15sr1VdyXQ6sVLqeJUJ1uPzLpmQtgUeBSB",
            //         "coin_type": "BCH",
            //         "coin_withdraw_id": 203,
            //         "confirmations": 11,
            //         "create_time": 1515806440,
            //         "status": "finish",
            //         "tx_fee": "0",
            //         "tx_id": "896371d0e23d64d1cac65a0b7c9e9093d835affb572fec89dd4547277fbdd2f6"
            //     }
            //
            const id = this.safeString2 (transaction, 'coin_withdraw_id', 'coin_deposit_id');
            const address = this.safeString (transaction, 'coin_address');
            let tag = this.safeString (transaction, 'remark'); // set but unused
            if (tag !== undefined) {
                if (tag.length < 1) {
                    tag = undefined;
                }
            }
            let txid = this.safeValue (transaction, 'tx_id');
            if (txid !== undefined) {
                if (txid.length < 1) {
                    txid = undefined;
                }
            }
            const currencyId = this.safeString (transaction, 'coin_type');
            const code = this.safeCurrencyCode (currencyId, currency);
            const timestamp = this.safeTimestamp (transaction, 'create_time');
            const type = ('coin_withdraw_id' in transaction) ? 'withdraw' : 'deposit';
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            let amount = this.safeNumber (transaction, 'amount');
            let feeCost = this.safeNumber (transaction, 'tx_fee');
            if (type === 'deposit') {
                feeCost = 0;
            }
            const fee = {
                'cost': feeCost,
                'currency': code,
            };
            // https://github.com/ccxt/ccxt/issues/8321
            if (amount !== undefined) {
                amount = amount - feeCost;
            }
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'tag': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': fee,
            };
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchWithdrawals() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'coin_type': currency['id'],
            };
            if (limit !== undefined) {
                request['Limit'] = limit;
            }
            const response = await this.privateGetBalanceCoinWithdraw (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "has_next": true,
            //             "curr_page": 1,
            //             "count": 10,
            //             "data": [
            //                 {
            //                     "coin_withdraw_id": 203,
            //                     "create_time": 1513933541,
            //                     "actual_amount": "0.00100000",
            //                     "actual_amount_display": "***",
            //                     "amount": "0.00100000",
            //                     "amount_display": "******",
            //                     "coin_address": "1GVVx5UBddLKrckTprNi4VhHSymeQ8tsLF",
            //                     "app_coin_address_display": "**********",
            //                     "coin_address_display": "****************",
            //                     "add_explorer": "https://explorer.viawallet.com/btc/address/1GVVx5UBddLKrckTprNi4VhHSymeQ8tsLF",
            //                     "coin_type": "BTC",
            //                     "confirmations": 6,
            //                     "explorer": "https://explorer.viawallet.com/btc/tx/1GVVx5UBddLKrckTprNi4VhHSymeQ8tsLF",
            //                     "fee": "0",
            //                     "remark": "",
            //                     "smart_contract_name": "BTC",
            //                     "status": "finish",
            //                     "status_display": "finish",
            //                     "transfer_method": "onchain",
            //                     "tx_fee": "0",
            //                     "tx_id": "896371d0e23d64d1cac65a0b7c9e9093d835affb572fec89dd4547277fbdd2f6"
            //                 }, /* many more data points */
            //             ],
            //             "total": ***,
            //             "total_page":***
            //         },
            //         "message": "Success"
            //     }
            //
            let data = this.safeValue (response, 'data');
            if (!Array.isArray (data)) {
                data = this.safeValue (data, 'data', []);
            }
            return this.parseTransactions (data, currency, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchDeposits() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'coin_type': currency['id'],
            };
            if (limit !== undefined) {
                request['Limit'] = limit;
            }
            const response = await this.privateGetBalanceCoinDeposit (this.extend (request, params));
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "actual_amount": "4.65397682",
            //                 "actual_amount_display": "4.65397682",
            //                 "add_explorer": "https://etherscan.io/address/0x361XXXXXX",
            //                 "amount": "4.65397682",
            //                 "amount_display": "4.65397682",
            //                 "coin_address": "0x36dabcdXXXXXX",
            //                 "coin_address_display": "0x361X*****XXXXX",
            //                 "coin_deposit_id": 966191,
            //                 "coin_type": "ETH",
            //                 "confirmations": 30,
            //                 "create_time": 1531661445,
            //                 "explorer": "https://etherscan.io/tx/0x361XXXXXX",
            //                 "remark": "",
            //                 "status": "finish",
            //                 "status_display": "finish",
            //                 "transfer_method": "onchain",
            //                 "tx_id": "0x361XXXXXX",
            //                 "tx_id_display": "0x361XXXXXX"
            //             }
            //         ],
            //         "message": "Ok"
            //     }
            //
            let data = this.safeValue (response, 'data');
            if (!Array.isArray (data)) {
                data = this.safeValue (data, 'data', []);
            }
            return this.parseTransactions (data, currency, since, limit);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            path = this.implodeParams (path, params);
            let url = this.urls['api'][api] + '/' + this.version + '/' + path;
            let query = this.omit (params, this.extractParams (path));
            if (api === 'public' || api === 'perpetualPublic') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                query = this.extend ({
                    'access_id': this.apiKey,
                    'tonce': nonce.toString (),
                }, query);
                query = this.keysort (query);
                const urlencoded = this.rawencode (query);
                const signature = this.hash (this.encode (urlencoded + '&secret_key=' + this.secret));
                headers = {
                    'Authorization': signature.toUpperCase (),
                    'Content-Type': 'application/json',
                };
                if ((method === 'GET') || (method === 'DELETE')) {
                    url += '?' + urlencoded;
                } else {
                    body = this.json (query);
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const code = this.safeString (response, 'code');
            const data = this.safeValue (response, 'data');
            const message = this.safeString (response, 'message');
            if ((code !== '0') || (data === undefined) || ((message !== 'Success') && (message !== 'Succeeded') && (message !== 'Ok') && !data)) {
                const responseCodes = {
                    // https://github.com/coinexcom/coinex_exchange_api/wiki/013error_code
                    '23': PermissionDenied, // IP Prohibited
                    '24': AuthenticationError,
                    '25': AuthenticationError,
                    '34': AuthenticationError, // Access id is expires
                    '35': ExchangeNotAvailable, // Service unavailable
                    '36': RequestTimeout, // Service timeout
                    '107': InsufficientFunds,
                    '600': OrderNotFound,
                    '601': InvalidOrder,
                    '602': InvalidOrder,
                    '606': InvalidOrder,
                };
                const ErrorClass = this.safeValue (responseCodes, code, ExchangeError);
                throw new ErrorClass (response['message']);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],65:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AuthenticationError, RateLimitExceeded, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinfalcon extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinfalcon',
                'name': 'CoinFalcon',
                'countries': [ 'GB' ],
                'rateLimit': 1000,
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/41822275-ed982188-77f5-11e8-92bb-496bcd14ca52.jpg',
                    'api': 'https://coinfalcon.com',
                    'www': 'https://coinfalcon.com',
                    'doc': 'https://docs.coinfalcon.com',
                    'fees': 'https://coinfalcon.com/fees',
                    'referral': 'https://coinfalcon.com/?ref=CFJSVGTUPASB',
                },
                'api': {
                    'public': {
                        'get': [
                            'markets',
                            'markets/{market}',
                            'markets/{market}/orders',
                            'markets/{market}/trades',
                        ],
                    },
                    'private': {
                        'get': [
                            'user/accounts',
                            'user/orders',
                            'user/orders/{id}',
                            'user/orders/{id}/trades',
                            'user/trades',
                            'user/fees',
                            'account/withdrawals/{id}',
                            'account/withdrawals',
                            'account/deposit/{id}',
                            'account/deposits',
                            'account/deposit_address',
                        ],
                        'post': [
                            'user/orders',
                            'account/withdraw',
                        ],
                        'delete': [
                            'user/orders/{id}',
                            'account/withdrawals/{id}',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'maker': 0.0,
                        'taker': 0.002, // tiered fee starts at 0.2%
                    },
                },
                'precision': {
                    'amount': 8,
                    'price': 8,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarkets (params);
            const markets = this.safeValue (response, 'data');
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const [ baseId, quoteId ] = market['name'].split ('-');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeInteger (market, 'size_precision'),
                    'price': this.safeInteger (market, 'price_precision'),
                };
                result.push ({
                    'id': market['name'],
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision['amount']),
                            'max': undefined,
                        },
                        'price': {
                            'min': Math.pow (10, -precision['price']),
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'info': market,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            const marketId = this.safeString (ticker, 'name');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = this.milliseconds ();
            const last = this.safeNumber (ticker, 'last_price');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': undefined,
                'low': undefined,
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': this.safeNumber (ticker, 'change_in_24h'),
                'percentage': undefined,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': this.safeNumber (ticker, 'volume'),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const tickers = await this.fetchTickers (params);
            return tickers[symbol];
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetMarkets (params);
            const tickers = this.safeValue (response, 'data');
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const ticker = this.parseTicker (tickers[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'market': this.marketId (symbol),
                'level': '3',
            };
            const response = await this.publicGetMarketsMarketOrders (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            return this.parseOrderBook (data, symbol, undefined, 'bids', 'asks', 'price', 'size');
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.parse8601 (this.safeString (trade, 'created_at'));
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'size');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const symbol = market['symbol'];
            const tradeId = this.safeString (trade, 'id');
            const side = this.safeString (trade, 'side');
            const orderId = this.safeString (trade, 'order_id');
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyCode = this.safeString (trade, 'fee_currency_code');
                fee = {
                    'cost': feeCost,
                    'currency': this.safeCurrencyCode (feeCurrencyCode),
                };
            }
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': tradeId,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            if (since !== undefined) {
                request['start_time'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetUserTrades (this.extend (request, params));
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            if (since !== undefined) {
                request['since'] = this.iso8601 (since);
            }
            const response = await this.publicGetMarketsMarketTrades (this.extend (request, params));
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetUserAccounts (params);
            const result = { 'info': response };
            const balances = this.safeValue (response, 'data');
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency_code');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available_balance');
                account['used'] = this.safeString (balance, 'hold_balance');
                account['total'] = this.safeString (balance, 'balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'fulfilled': 'closed',
                'canceled': 'canceled',
                'pending': 'open',
                'open': 'open',
                'partially_filled': 'open',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "id":"8bdd79f4-8414-40a2-90c3-e9f4d6d1eef4"
            //         "market":"IOT-BTC"
            //         "price":"0.0000003"
            //         "size":"4.0"
            //         "size_filled":"3.0"
            //         "fee":"0.0075"
            //         "fee_currency_code":"iot"
            //         "funds":"0.0"
            //         "status":"canceled"
            //         "order_type":"buy"
            //         "post_only":false
            //         "operation_type":"market_order"
            //         "created_at":"2018-01-12T21:14:06.747828Z"
            //     }
            //
            const marketId = this.safeString (order, 'market');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'size');
            const filled = this.safeNumber (order, 'size_filled');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            let type = this.safeString (order, 'operation_type');
            if (type !== undefined) {
                type = type.split ('_');
                type = type[0];
            }
            const side = this.safeString (order, 'order_type');
            const postOnly = this.safeValue (order, 'post_only');
            return this.safeOrder ({
                'id': this.safeString (order, 'id'),
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'trades': undefined,
                'fee': undefined,
                'info': order,
                'lastTradeTimestamp': undefined,
                'average': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            // price/size must be string
            const request = {
                'market': market['id'],
                'size': this.amountToPrecision (symbol, amount),
                'order_type': side,
            };
            if (type === 'limit') {
                price = this.priceToPrecision (symbol, price);
                request['price'] = price.toString ();
            }
            request['operation_type'] = type + '_order';
            const response = await this.privatePostUserOrders (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privateDeleteUserOrdersId (this.extend (request, params));
            const market = this.market (symbol);
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privateGetUserOrdersId (this.extend (request, params));
            const data = this.safeValue (response, 'data', {});
            return this.parseOrder (data);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['market'] = market['id'];
            }
            if (since !== undefined) {
                request['since_time'] = this.iso8601 (since);
            }
            // TODO: test status=all if it works for closed orders too
            const response = await this.privateGetUserOrders (this.extend (request, params));
            const data = this.safeValue (response, 'data', []);
            const orders = this.filterByArray (data, 'status', [ 'pending', 'open', 'partially_filled' ], false);
            return this.parseOrders (orders, market, since, limit);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/api/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    request += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                if (method === 'GET') {
                    if (Object.keys (query).length) {
                        request += '?' + this.urlencode (query);
                    }
                } else {
                    body = this.json (query);
                }
                const seconds = this.seconds ().toString ();
                let payload = [ seconds, method, request ].join ('|');
                if (body) {
                    payload += '|' + body;
                }
                const signature = this.hmac (this.encode (payload), this.encode (this.secret));
                headers = {
                    'CF-API-KEY': this.apiKey,
                    'CF-API-TIMESTAMP': seconds,
                    'CF-API-SIGNATURE': signature,
                    'Content-Type': 'application/json',
                };
            }
            const url = this.urls['api'] + request;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (code < 400) {
                return;
            }
            const ErrorClass = this.safeValue ({
                '401': AuthenticationError,
                '429': RateLimitExceeded,
            }, code, ExchangeError);
            throw new ErrorClass (body);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],66:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { InsufficientFunds, ExchangeError, InvalidNonce, InvalidOrder, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinfloor extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinfloor',
                'name': 'coinfloor',
                'rateLimit': 1000,
                'countries': [ 'UK' ],
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchLedger': true,
                    'fetchOpenOrders': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87153925-ef265e80-c2c0-11ea-91b5-020c804b90e0.jpg',
                    'api': 'https://webapi.coinfloor.co.uk/v2/bist',
                    'www': 'https://www.coinfloor.co.uk',
                    'doc': [
                        'https://github.com/coinfloor/api',
                        'https://www.coinfloor.co.uk/api',
                    ],
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': false,
                    'password': true,
                    'uid': true,
                },
                'api': {
                    'public': {
                        'get': [
                            '{id}/ticker/',
                            '{id}/order_book/',
                            '{id}/transactions/',
                        ],
                    },
                    'private': {
                        'post': [
                            '{id}/balance/',
                            '{id}/user_transactions/',
                            '{id}/open_orders/',
                            '{symbol}/cancel_order/',
                            '{id}/buy/',
                            '{id}/sell/',
                            '{id}/buy_market/',
                            '{id}/sell_market/',
                            '{id}/estimate_sell_market/',
                            '{id}/estimate_buy_market/',
                        ],
                    },
                },
                'markets': {
                    'BTC/GBP': { 'id': 'XBT/GBP', 'symbol': 'BTC/GBP', 'base': 'BTC', 'quote': 'GBP', 'baseId': 'XBT', 'quoteId': 'GBP', 'precision': { 'price': 0, 'amount': 4 }},
                    'BTC/EUR': { 'id': 'XBT/EUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'baseId': 'XBT', 'quoteId': 'EUR', 'precision': { 'price': 0, 'amount': 4 }},
                },
                'exceptions': {
                    'exact': {
                        'You have insufficient funds.': InsufficientFunds,
                        'Tonce is out of sequence.': InvalidNonce,
                    },
                },
            });
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            let query = params;
            const symbol = this.safeString (params, 'symbol');
            if (symbol !== undefined) {
                market = this.market (params['symbol']);
                query = this.omit (params, 'symbol');
            }
            const marketId = this.safeString (params, 'id');
            if (marketId in this.markets_by_id) {
                market = this.markets_by_id[marketId];
            }
            if (market === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchBalance() requires a symbol param');
            }
            const request = {
                'id': market['id'],
            };
            const response = await this.privatePostIdBalance (this.extend (request, query));
            const result = {
                'info': response,
            };
            // base/quote used for keys e.g. "xbt_reserved"
            const base = market['base'];
            const quote = market['quote'];
            const baseIdLower = this.safeStringLower (market, 'baseId');
            const quoteIdLower = this.safeStringLower (market, 'quoteId');
            result[base] = {
                'free': this.safeString (response, baseIdLower + '_available'),
                'used': this.safeString (response, baseIdLower + '_reserved'),
                'total': this.safeString (response, baseIdLower + '_balance'),
            };
            result[quote] = {
                'free': this.safeString (response, quoteIdLower + '_available'),
                'used': this.safeString (response, quoteIdLower + '_reserved'),
                'total': this.safeString (response, quoteIdLower + '_balance'),
            };
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': this.marketId (symbol),
            };
            const response = await this.publicGetIdOrderBook (this.extend (request, params));
            return this.parseOrderBook (response, symbol);
        }
    
        parseTicker (ticker, market = undefined) {
            // rewrite to get the timestamp from HTTP headers
            const timestamp = this.milliseconds ();
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const vwap = this.safeNumber (ticker, 'vwap');
            const baseVolume = this.safeNumber (ticker, 'volume');
            let quoteVolume = undefined;
            if (vwap !== undefined) {
                quoteVolume = baseVolume * vwap;
            }
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'],
            };
            const response = await this.publicGetIdTicker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeTimestamp (trade, 'date');
            const id = this.safeString (trade, 'tid');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'info': trade,
                'id': id,
                'order': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': undefined,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'],
            };
            const response = await this.publicGetIdTransactions (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            // code is actually a market symbol in this situation, not a currency code
            await this.loadMarkets ();
            let market = undefined;
            if (code !== undefined) {
                market = this.market (code);
                if (market === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchTransactions() requires a code argument (a market symbol)');
                }
            }
            const request = {
                'id': market['id'],
                'limit': limit,
            };
            const response = await this.privatePostIdUserTransactions (this.extend (request, params));
            return this.parseLedger (response, undefined, since, undefined);
        }
    
        parseLedgerEntryStatus (status) {
            const types = {
                'completed': 'ok',
            };
            return this.safeString (types, status, status);
        }
    
        parseLedgerEntryType (type) {
            const types = {
                '0': 'transaction', // deposit
                '1': 'transaction', // withdrawal
                '2': 'trade',
            };
            return this.safeString (types, type, type);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            // trade
            //
            //     {
            //         "datetime": "2017-07-25 06:41:24",
            //         "id": 1500964884381265,
            //         "type": 2,
            //         "xbt": "0.1000",
            //         "xbt_eur": "2322.00",
            //         "eur": "-232.20",
            //         "fee": "0.00",
            //         "order_id": 84696745
            //     }
            //
            // transaction (withdrawal)
            //
            //     {
            //         "datetime": "2017-07-25 13:19:46",
            //         "id": 97669,
            //         "type": 1,
            //         "xbt": "-3.0000",
            //         "xbt_eur": null,
            //         "eur": "0",
            //         "fee": "0.0000",
            //         "order_id": null
            //     }
            //
            // transaction (deposit)
            //
            //     {
            //         "datetime": "2017-07-27 16:44:55",
            //         "id": 98277,
            //         "type": 0,
            //         "xbt": "0",
            //         "xbt_eur": null,
            //         "eur": "4970.04",
            //         "fee": "0.00",
            //         "order_id": null
            //     }
            //
            const keys = Object.keys (item);
            let baseId = undefined;
            let quoteId = undefined;
            let baseAmount = undefined;
            let quoteAmount = undefined;
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                if (key.indexOf ('_') > 0) {
                    const parts = key.split ('_');
                    const numParts = parts.length;
                    if (numParts === 2) {
                        const tmpBaseAmount = this.safeNumber (item, parts[0]);
                        const tmpQuoteAmount = this.safeNumber (item, parts[1]);
                        if (tmpBaseAmount !== undefined && tmpQuoteAmount !== undefined) {
                            baseId = parts[0];
                            quoteId = parts[1];
                            baseAmount = tmpBaseAmount;
                            quoteAmount = tmpQuoteAmount;
                        }
                    }
                }
            }
            const base = this.safeCurrencyCode (baseId);
            const quote = this.safeCurrencyCode (quoteId);
            const type = this.parseLedgerEntryType (this.safeString (item, 'type'));
            const referenceId = this.safeString (item, 'id');
            const timestamp = this.parse8601 (this.safeString (item, 'datetime'));
            let fee = undefined;
            const feeCost = this.safeNumber (item, 'fee');
            const result = {
                'id': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'amount': undefined,
                'direction': undefined,
                'currency': undefined,
                'type': type,
                'referenceId': referenceId,
                'referenceAccount': undefined,
                'before': undefined,
                'after': undefined,
                'status': 'ok',
                'fee': fee,
                'info': item,
            };
            if (type === 'trade') {
                //
                // it's a trade so let's make multiple entries, we have several options:
                //
                // if fee is always in quote currency (the exchange uses this)
                // https://github.com/coinfloor/API/blob/master/IMPL-GUIDE.md#how-fees-affect-trade-quantities
                //
                if (feeCost !== undefined) {
                    fee = {
                        'cost': feeCost,
                        'currency': quote,
                    };
                }
                return [
                    this.extend (result, { 'currency': base, 'amount': Math.abs (baseAmount), 'direction': (baseAmount > 0) ? 'in' : 'out' }),
                    this.extend (result, { 'currency': quote, 'amount': Math.abs (quoteAmount), 'direction': (quoteAmount > 0) ? 'in' : 'out', 'fee': fee }),
                ];
                //
                // if fee is base or quote depending on buy/sell side
                //
                //     const baseFee = (baseAmount > 0) ? { 'currency': base, 'cost': feeCost } : undefined;
                //     const quoteFee = (quoteAmount > 0) ? { 'currency': quote, 'cost': feeCost } : undefined;
                //     return [
                //         this.extend (result, { 'currency': base, 'amount': baseAmount, 'direction': (baseAmount > 0) ? 'in' : 'out', 'fee': baseFee }),
                //         this.extend (result, { 'currency': quote, 'amount': quoteAmount, 'direction': (quoteAmount > 0) ? 'in' : 'out', 'fee': quoteFee }),
                //     ];
                //
                // fee as the 3rd item
                //
                //     return [
                //         this.extend (result, { 'currency': base, 'amount': baseAmount, 'direction': (baseAmount > 0) ? 'in' : 'out' }),
                //         this.extend (result, { 'currency': quote, 'amount': quoteAmount, 'direction': (quoteAmount > 0) ? 'in' : 'out' }),
                //         this.extend (result, { 'currency': feeCurrency, 'amount': feeCost, 'direction': 'out', 'type': 'fee' }),
                //     ];
                //
            } else {
                //
                // it's a regular transaction (deposit or withdrawal)
                //
                const amount = (baseAmount === 0) ? quoteAmount : baseAmount;
                const code = (baseAmount === 0) ? quote : base;
                const direction = (amount > 0) ? 'in' : 'out';
                if (feeCost !== undefined) {
                    fee = {
                        'cost': feeCost,
                        'currency': code,
                    };
                }
                return this.extend (result, {
                    'currency': code,
                    'amount': Math.abs (amount),
                    'direction': direction,
                    'fee': fee,
                });
            }
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': this.marketId (symbol),
            };
            let method = 'privatePostId' + this.capitalize (side);
            if (type === 'market') {
                request['quantity'] = amount;
                method += 'Market';
            } else {
                request['price'] = price;
                request['amount'] = amount;
            }
            //
            //     {
            //         "id":31950584,
            //         "datetime":"2020-05-21 08:38:18",
            //         "type":1,
            //         "price":"9100",
            //         "amount":"0.0026"
            //     }
            //
            const response = await this[method] (this.extend (request, params));
            const timestamp = this.parse8601 (this.safeString (response, 'datetime'));
            return {
                'id': this.safeString (response, 'id'),
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'type': type,
                'price': this.safeNumber (response, 'price'),
                'remaining': this.safeNumber (response, 'amount'),
                'info': response,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'id': id,
            };
            const response = await this.privatePostSymbolCancelOrder (request);
            if (response === 'false') {
                // unfortunately the exchange does not give much info in the response
                throw new InvalidOrder (this.id + ' cancel was rejected');
            }
            return response;
        }
    
        parseOrder (order, market = undefined) {
            const timestamp = this.parse8601 (this.safeString (order, 'datetime'));
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount');
            let side = undefined;
            const status = this.safeString (order, 'status');
            const rawType = this.safeString (order, 'type');
            if (rawType === '0') {
                side = 'buy';
            } else if (rawType === '1') {
                side = 'sell';
            }
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const id = this.safeString (order, 'id');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': undefined,
                'filled': undefined,
                'remaining': amount,
                'cost': undefined,
                'fee': undefined,
                'average': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol param');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'],
            };
            const response = await this.privatePostIdOpenOrders (this.extend (request, params));
            //   {
            //     "amount": "1.0000",
            //     "datetime": "2019-07-12 13:28:16",
            //     "id": 233123443,
            //     "price": "1000.00",
            //     "type": 0
            //   }
            return this.parseOrders (response, market, since, limit, { 'status': 'open' });
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (code < 400) {
                return;
            }
            if (response === undefined) {
                return;
            }
            const message = this.safeString (response, 'error_msg');
            const feedback = this.id + ' ' + body;
            this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
            throw new ExchangeError (feedback);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            // curl -k -u '[User ID]/[API key]:[Passphrase]' https://webapi.coinfloor.co.uk:8090/bist/XBT/GBP/balance/
            let url = this.urls['api'] + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                body = this.urlencode (this.extend ({ 'nonce': nonce }, query));
                const auth = this.uid + '/' + this.apiKey + ':' + this.password;
                const signature = this.decode (this.stringToBase64 (auth));
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Authorization': 'Basic ' + signature,
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],67:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError } = require ('./base/errors');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinmarketcap extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinmarketcap',
                'name': 'CoinMarketCap',
                'rateLimit': 10000,
                'version': 'v1',
                'countries': [ 'US' ],
                'has': {
                    'cancelOrder': false,
                    'CORS': true,
                    'createLimitOrder': false,
                    'createMarketOrder': false,
                    'createOrder': false,
                    'editOrder': false,
                    'privateAPI': false,
                    'fetchBalance': false,
                    'fetchCurrencies': true,
                    'fetchL2OrderBook': false,
                    'fetchMarkets': true,
                    'fetchOHLCV': false,
                    'fetchOrderBook': false,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': false,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87182086-1cd4cd00-c2ec-11ea-9ec4-d0cf2a2abf62.jpg',
                    'api': {
                        'public': 'https://api.coinmarketcap.com',
                        'files': 'https://files.coinmarketcap.com',
                        'charts': 'https://graph.coinmarketcap.com',
                    },
                    'www': 'https://coinmarketcap.com',
                    'doc': 'https://coinmarketcap.com/api',
                },
                'requiredCredentials': {
                    'apiKey': false,
                    'secret': false,
                },
                'api': {
                    'files': {
                        'get': [
                            'generated/stats/global.json',
                        ],
                    },
                    'graphs': {
                        'get': [
                            'currencies/{name}/',
                        ],
                    },
                    'public': {
                        'get': [
                            'ticker/',
                            'ticker/{id}/',
                            'global/',
                        ],
                    },
                },
                'currencyCodes': [
                    'AUD',
                    'BRL',
                    'CAD',
                    'CHF',
                    'CNY',
                    'EUR',
                    'GBP',
                    'HKD',
                    'IDR',
                    'INR',
                    'JPY',
                    'KRW',
                    'MXN',
                    'RUB',
                    'USD',
                    'BTC',
                    'ETH',
                    'LTC',
                ],
            });
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            throw new ExchangeError ('Fetching order books is not supported by the API of ' + this.id);
        }
    
        currencyCode (base, name) {
            const currencies = {
                'ACChain': 'ACChain',
                'AdCoin': 'AdCoin',
                'BatCoin': 'BatCoin',
                'BigONE Token': 'BigONE Token', // conflict with Harmony (ONE)
                'Bitgem': 'Bitgem',
                'BlazeCoin': 'BlazeCoin',
                'BlockCAT': 'BlockCAT',
                'Blocktrade Token': 'Blocktrade Token',
                'BOX Token': 'BOX Token', // conflict with BOX (ContentBox)
                'Catcoin': 'Catcoin',
                'CanYaCoin': 'CanYaCoin', // conflict with CAN (Content and AD Network)
                'CryptoBossCoin': 'CryptoBossCoin', // conflict with CBC (CashBet Coin)
                'Comet': 'Comet', // conflict with CMT (CyberMiles)
                'CPChain': 'CPChain',
                'CrowdCoin': 'CrowdCoin', // conflict with CRC CryCash
                'Cryptaur': 'Cryptaur', // conflict with CPT = Contents Protocol https://github.com/ccxt/ccxt/issues/4920 and https://github.com/ccxt/ccxt/issues/6081
                'Cubits': 'Cubits', // conflict with QBT (Qbao)
                'DAO.Casino': 'DAO.Casino', // conflict with BET (BetaCoin)
                'DefiBox': 'DefiBox', // conflict with BOX (ContentBox)
                'E-Dinar Coin': 'E-Dinar Coin', // conflict with EDR Endor Protocol and EDRCoin
                'EDRcoin': 'EDRcoin', // conflict with EDR Endor Protocol and E-Dinar Coin
                'ENTCash': 'ENTCash', // conflict with ENT (Eternity)
                'FairCoin': 'FairCoin', // conflict with FAIR (FairGame) https://github.com/ccxt/ccxt/pull/5865
                'Fabric Token': 'Fabric Token',
                // 'GET Protocol': 'GET Protocol',
                'GHOSTPRISM': 'GHOSTPRISM', // conflict with GHOST
                'Global Tour Coin': 'Global Tour Coin', // conflict with GTC (Game.com)
                'GuccioneCoin': 'GuccioneCoin', // conflict with GCC (Global Cryptocurrency)
                'HarmonyCoin': 'HarmonyCoin', // conflict with HMC (Hi Mutual Society)
                'Harvest Masternode Coin': 'Harvest Masternode Coin', // conflict with HC (HyperCash)
                'HOT Token': 'HOT Token',
                'Hydro Protocol': 'Hydro Protocol', // conflict with HOT (Holo)
                'Huncoin': 'Huncoin', // conflict with HNC (Helleniccoin)
                'iCoin': 'iCoin',
                'Infinity Economics': 'Infinity Economics', // conflict with XIN (Mixin)
                'IQ.cash': 'IQ.cash', // conflict with IQ (Everipedia)
                'KingN Coin': 'KingN Coin', // conflict with KNC (Kyber Network)
                'LiteBitcoin': 'LiteBitcoin', // conflict with LBTC (LightningBitcoin)
                'Maggie': 'Maggie',
                'Menlo One': 'Menlo One', // conflict with Harmony (ONE)
                'Mobilian Coin': 'Mobilian Coin', // conflict with Membrana (MBN)
                'Monarch': 'Monarch', // conflict with MyToken (MT)
                'MTC Mesh Network': 'MTC Mesh Network', // conflict with MTC Docademic doc.com Token https://github.com/ccxt/ccxt/issues/6081 https://github.com/ccxt/ccxt/issues/3025
                'IOTA': 'IOTA', // a special case, most exchanges list it as IOTA, therefore we change just the Coinmarketcap instead of changing them all
                'NetCoin': 'NetCoin',
                'PCHAIN': 'PCHAIN', // conflict with PAI (Project Pai)
                'Penta': 'Penta', // conflict with PNT (pNetwork)
                'Plair': 'Plair', // conflict with PLA (PLANET)
                'PlayChip': 'PlayChip', // conflict with PLA (PLANET)
                'Polcoin': 'Polcoin',
                'PutinCoin': 'PutinCoin', // conflict with PUT (Profile Utility Token)
                'Rcoin': 'Rcoin', // conflict with RCN (Ripio Credit Network)
                // https://github.com/ccxt/ccxt/issues/6081
                // https://github.com/ccxt/ccxt/issues/3365
                // https://github.com/ccxt/ccxt/issues/2873
                'SBTCT': 'SiamBitcoin', // conflict with sBTC
                'Super Bitcoin': 'Super Bitcoin', // conflict with sBTC
                'TerraCredit': 'TerraCredit', // conflict with CREDIT (PROXI)
                'Themis': 'Themis', // conflict with GET (Guaranteed Entrance Token, GET Protocol)
                'UNI COIN': 'UNI COIN', // conflict with UNI (Uniswap)
                'UNICORN Token': 'UNICORN Token', // conflict with UNI (Uniswap)
                'Universe': 'Universe', // conflict with UNI (Uniswap)
            };
            return this.safeValue (currencies, name, base);
        }
    
        async fetchMarkets (params = {}) {
            const request = {
                'limit': 0,
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const currencies = this.currencyCodes;
                for (let j = 0; j < currencies.length; j++) {
                    const quote = currencies[j];
                    const quoteId = quote.toLowerCase ();
                    const baseId = market['id'];
                    const base = this.currencyCode (market['symbol'], market['name']);
                    const symbol = base + '/' + quote;
                    const id = baseId + '/' + quoteId;
                    result.push ({
                        'id': id,
                        'symbol': symbol,
                        'base': base,
                        'quote': quote,
                        'baseId': baseId,
                        'quoteId': quoteId,
                        'info': market,
                        'active': undefined,
                        'precision': this.precision,
                        'limits': this.limits,
                    });
                }
            }
            return result;
        }
    
        async fetchGlobal (currency = 'USD') {
            await this.loadMarkets ();
            const request = {};
            if (currency) {
                request['convert'] = currency;
            }
            return await this.publicGetGlobal (request);
        }
    
        parseTicker (ticker, market = undefined) {
            let timestamp = this.safeTimestamp (ticker, 'last_updated');
            if (timestamp === undefined) {
                timestamp = this.milliseconds ();
            }
            const change = this.safeNumber (ticker, 'percent_change_24h');
            let last = undefined;
            let symbol = undefined;
            let volume = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
                const priceKey = 'price_' + market['quoteId'];
                last = this.safeNumber (ticker, priceKey);
                const volumeKey = '24h_volume_' + market['quoteId'];
                volume = this.safeNumber (ticker, volumeKey);
            }
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': undefined,
                'low': undefined,
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': change,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': volume,
                'info': ticker,
            };
        }
    
        async fetchTickers (currency = 'USD', params = {}) {
            await this.loadMarkets ();
            const request = {
                'limit': 10000,
            };
            if (currency) {
                request['convert'] = currency;
            }
            const response = await this.publicGetTicker (this.extend (request, params));
            const result = {};
            for (let t = 0; t < response.length; t++) {
                const ticker = response[t];
                const currencyId = currency.toLowerCase ();
                const id = ticker['id'] + '/' + currencyId;
                let symbol = id;
                let market = undefined;
                if (id in this.markets_by_id) {
                    market = this.markets_by_id[id];
                    symbol = market['symbol'];
                }
                result[symbol] = this.parseTicker (ticker, market);
            }
            return result;
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'convert': market['quote'],
                'id': market['baseId'],
            };
            const response = await this.publicGetTickerId (this.extend (request, params));
            const ticker = response[0];
            return this.parseTicker (ticker, market);
        }
    
        async fetchCurrencies (params = {}) {
            const request = {
                'limit': 0,
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'symbol');
                const name = this.safeString (currency, 'name');
                // todo: will need to rethink the fees
                // to add support for multiple withdrawal/deposit methods and
                // differentiated fees for each particular method
                const code = this.currencyCode (id, name);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'name': name,
                    'active': true,
                    'fee': undefined,
                    'precision': undefined,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (Object.keys (query).length) {
                url += '?' + this.urlencode (query);
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const error = this.safeValue (response, 'error', false);
            if (error) {
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/errors":9}],68:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, InvalidOrder, OrderNotFound, RateLimitExceeded, InsufficientFunds } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinmate extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinmate',
                'name': 'CoinMate',
                'countries': [ 'GB', 'CZ', 'EU' ], // UK, Czech Republic
                'rateLimit': 1000,
                'has': {
                    'cancelOrder': true,
                    'CORS': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'fetchTransactions': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87460806-1c9f3f00-c616-11ea-8c46-a77018a8f3f4.jpg',
                    'api': 'https://coinmate.io/api',
                    'www': 'https://coinmate.io',
                    'fees': 'https://coinmate.io/fees',
                    'doc': [
                        'https://coinmate.docs.apiary.io',
                        'https://coinmate.io/developers',
                    ],
                    'referral': 'https://coinmate.io?referral=YTFkM1RsOWFObVpmY1ZjMGREQmpTRnBsWjJJNVp3PT0',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'uid': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'orderBook',
                            'ticker',
                            'transactions',
                            'tradingPairs',
                        ],
                    },
                    'private': {
                        'post': [
                            'balances',
                            'bitcoinCashWithdrawal',
                            'bitcoinCashDepositAddresses',
                            'bitcoinDepositAddresses',
                            'bitcoinWithdrawal',
                            'bitcoinWithdrawalFees',
                            'buyInstant',
                            'buyLimit',
                            'cancelOrder',
                            'cancelOrderWithInfo',
                            'createVoucher',
                            'dashDepositAddresses',
                            'dashWithdrawal',
                            'ethereumWithdrawal',
                            'ethereumDepositAddresses',
                            'litecoinWithdrawal',
                            'litecoinDepositAddresses',
                            'openOrders',
                            'order',
                            'orderHistory',
                            'orderById',
                            'pusherAuth',
                            'redeemVoucher',
                            'replaceByBuyLimit',
                            'replaceByBuyInstant',
                            'replaceBySellLimit',
                            'replaceBySellInstant',
                            'rippleDepositAddresses',
                            'rippleWithdrawal',
                            'sellInstant',
                            'sellLimit',
                            'transactionHistory',
                            'traderFees',
                            'tradeHistory',
                            'transfer',
                            'transferHistory',
                            'unconfirmedBitcoinDeposits',
                            'unconfirmedBitcoinCashDeposits',
                            'unconfirmedDashDeposits',
                            'unconfirmedEthereumDeposits',
                            'unconfirmedLitecoinDeposits',
                            'unconfirmedRippleDeposits',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'maker': 0.12 / 100,
                        'taker': 0.25 / 100,
                        'tiers': {
                            'taker': [
                                [0, 0.25 / 100],
                                [10000, 0.23 / 100],
                                [100000, 0.21 / 100],
                                [250000, 0.20 / 100],
                                [500000, 0.15 / 100],
                                [1000000, 0.13 / 100],
                                [3000000, 0.10 / 100],
                                [15000000, 0.05 / 100],
                            ],
                            'maker': [
                                [0, 0.12 / 100],
                                [10000, 0.11 / 100],
                                [1000000, 0.10 / 100],
                                [250000, 0.08 / 100],
                                [500000, 0.05 / 100],
                                [1000000, 0.03 / 100],
                                [3000000, 0.02 / 100],
                                [15000000, 0],
                            ],
                        },
                    },
                    'promotional': {
                        'trading': {
                            'maker': 0.05 / 100,
                            'taker': 0.15 / 100,
                            'tiers': {
                                'taker': [
                                    [0, 0.15 / 100],
                                    [10000, 0.14 / 100],
                                    [100000, 0.13 / 100],
                                    [250000, 0.12 / 100],
                                    [500000, 0.11 / 100],
                                    [1000000, 0.1 / 100],
                                    [3000000, 0.08 / 100],
                                    [15000000, 0.05 / 100],
                                ],
                                'maker': [
                                    [0, 0.05 / 100],
                                    [10000, 0.04 / 100],
                                    [1000000, 0.03 / 100],
                                    [250000, 0.02 / 100],
                                    [500000, 0],
                                    [1000000, 0],
                                    [3000000, 0],
                                    [15000000, 0],
                                ],
                            },
                        },
                    },
                },
                'options': {
                    'promotionalMarkets': ['ETH/EUR', 'ETH/CZK', 'ETH/BTC', 'XRP/EUR', 'XRP/CZK', 'XRP/BTC', 'DASH/EUR', 'DASH/CZK', 'DASH/BTC', 'BCH/EUR', 'BCH/CZK', 'BCH/BTC'],
                },
                'exceptions': {
                    'exact': {
                        'No order with given ID': OrderNotFound,
                    },
                    'broad': {
                        'Not enough account balance available': InsufficientFunds,
                        'Incorrect order ID': InvalidOrder,
                        'Minimum Order Size ': InvalidOrder,
                        'TOO MANY REQUESTS': RateLimitExceeded,
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetTradingPairs (params);
            //
            //     {
            //         "error":false,
            //         "errorMessage":null,
            //         "data": [
            //             {
            //                 "name":"BTC_EUR",
            //                 "firstCurrency":"BTC",
            //                 "secondCurrency":"EUR",
            //                 "priceDecimals":2,
            //                 "lotDecimals":8,
            //                 "minAmount":0.0002,
            //                 "tradesWebSocketChannelId":"trades-BTC_EUR",
            //                 "orderBookWebSocketChannelId":"order_book-BTC_EUR",
            //                 "tradeStatisticsWebSocketChannelId":"statistics-BTC_EUR"
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data');
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const market = data[i];
                const id = this.safeString (market, 'name');
                const baseId = this.safeString (market, 'firstCurrency');
                const quoteId = this.safeString (market, 'secondCurrency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const promotionalMarkets = this.safeValue (this.options, 'promotionalMarkets', []);
                let fees = this.safeValue (this.fees, 'trading');
                if (this.inArray (symbol, promotionalMarkets)) {
                    const promotionalFees = this.safeValue (this.fees, 'promotional', {});
                    fees = this.safeValue (promotionalFees, 'trading', fees);
                }
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': undefined,
                    'maker': fees['maker'],
                    'taker': fees['taker'],
                    'info': market,
                    'precision': {
                        'price': this.safeInteger (market, 'priceDecimals'),
                        'amount': this.safeInteger (market, 'lotDecimals'),
                    },
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'minAmount'),
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostBalances (params);
            const balances = this.safeValue (response, 'data');
            const result = { 'info': response };
            const currencyIds = Object.keys (balances);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const balance = this.safeValue (balances, currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'reserved');
                account['total'] = this.safeString (balance, 'balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'currencyPair': this.marketId (symbol),
                'groupByPriceLimit': 'False',
            };
            const response = await this.publicGetOrderBook (this.extend (request, params));
            const orderbook = response['data'];
            const timestamp = this.safeTimestamp (orderbook, 'timestamp');
            return this.parseOrderBook (orderbook, symbol, timestamp, 'bids', 'asks', 'price', 'amount');
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const request = {
                'currencyPair': this.marketId (symbol),
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const ticker = this.safeValue (response, 'data');
            const timestamp = this.safeTimestamp (ticker, 'timestamp');
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'vwap': undefined,
                'askVolume': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'amount'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'limit': 1000,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['timestampFrom'] = since;
            }
            if (code !== undefined) {
                const currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            const response = await this.privatePostTransferHistory (this.extend (request, params));
            const items = response['data'];
            return this.parseTransactions (items, undefined, since, limit);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                // any other types ?
                'COMPLETED': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (item, currency = undefined) {
            //
            // deposits
            //
            //     {
            //         transactionId: 1862815,
            //         timestamp: 1516803982388,
            //         amountCurrency: 'LTC',
            //         amount: 1,
            //         fee: 0,
            //         walletType: 'LTC',
            //         transferType: 'DEPOSIT',
            //         transferStatus: 'COMPLETED',
            //         txid:
            //         'ccb9255dfa874e6c28f1a64179769164025329d65e5201849c2400abd6bce245',
            //         destination: 'LQrtSKA6LnhcwRrEuiborQJnjFF56xqsFn',
            //         destinationTag: null
            //     }
            //
            // withdrawals
            //
            //     {
            //         transactionId: 2140966,
            //         timestamp: 1519314282976,
            //         amountCurrency: 'EUR',
            //         amount: 8421.7228,
            //         fee: 16.8772,
            //         walletType: 'BANK_WIRE',
            //         transferType: 'WITHDRAWAL',
            //         transferStatus: 'COMPLETED',
            //         txid: null,
            //         destination: null,
            //         destinationTag: null
            //     }
            //
            const timestamp = this.safeInteger (item, 'timestamp');
            const amount = this.safeNumber (item, 'amount');
            const fee = this.safeNumber (item, 'fee');
            const txid = this.safeString (item, 'txid');
            const address = this.safeString (item, 'destination');
            const tag = this.safeString (item, 'destinationTag');
            const currencyId = this.safeString (item, 'amountCurrency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const type = this.safeStringLower (item, 'transferType');
            const status = this.parseTransactionStatus (this.safeString (item, 'transferStatus'));
            const id = this.safeString (item, 'transactionId');
            return {
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'currency': code,
                'amount': amount,
                'type': type,
                'txid': txid,
                'address': address,
                'tag': tag,
                'status': status,
                'fee': {
                    'cost': fee,
                    'currency': code,
                },
                'info': item,
            };
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (limit === undefined) {
                limit = 1000;
            }
            const request = {
                'limit': limit,
            };
            if (symbol !== undefined) {
                const market = this.market (symbol);
                request['currencyPair'] = market['id'];
            }
            if (since !== undefined) {
                request['timestampFrom'] = since;
            }
            const response = await this.privatePostTradeHistory (this.extend (request, params));
            const items = response['data'];
            return this.parseTrades (items, undefined, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchMyTrades (private)
            //
            //     {
            //         transactionId: 2671819,
            //         createdTimestamp: 1529649127605,
            //         currencyPair: 'LTC_BTC',
            //         type: 'BUY',
            //         orderType: 'LIMIT',
            //         orderId: 101810227,
            //         amount: 0.01,
            //         price: 0.01406,
            //         fee: 0,
            //         feeType: 'MAKER'
            //     }
            //
            // fetchTrades (public)
            //
            //     {
            //         "timestamp":1561598833416,
            //         "transactionId":"4156303",
            //         "price":10950.41,
            //         "amount":0.004,
            //         "currencyPair":"BTC_EUR",
            //         "tradeType":"BUY"
            //     }
            //
            const marketId = this.safeString (trade, 'currencyPair');
            market = this.safeMarket (marketId, market, '_');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const side = this.safeStringLower2 (trade, 'type', 'tradeType');
            const type = this.safeStringLower (trade, 'orderType');
            const orderId = this.safeString (trade, 'orderId');
            const id = this.safeString (trade, 'transactionId');
            const timestamp = this.safeInteger2 (trade, 'timestamp', 'createdTimestamp');
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': market['quote'],
                };
            }
            let takerOrMaker = this.safeString (trade, 'feeType');
            takerOrMaker = (takerOrMaker === 'MAKER') ? 'maker' : 'taker';
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': market['symbol'],
                'type': type,
                'side': side,
                'order': orderId,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currencyPair': market['id'],
                'minutesIntoHistory': 10,
            };
            const response = await this.publicGetTransactions (this.extend (request, params));
            //
            //     {
            //         "error":false,
            //         "errorMessage":null,
            //         "data":[
            //             {
            //                 "timestamp":1561598833416,
            //                 "transactionId":"4156303",
            //                 "price":10950.41,
            //                 "amount":0.004,
            //                 "currencyPair":"BTC_EUR",
            //                 "tradeType":"BUY"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const response = await this.privatePostOpenOrders (this.extend ({}, params));
            const extension = { 'status': 'open' };
            return this.parseOrders (response['data'], undefined, since, limit, extension);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currencyPair': market['id'],
            };
            // offset param that appears in other parts of the API doesn't appear to be supported here
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privatePostOrderHistory (this.extend (request, params));
            return this.parseOrders (response['data'], market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'FILLED': 'closed',
                'CANCELLED': 'canceled',
                'PARTIALLY_FILLED': 'open',
                'OPEN': 'open',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrderType (type) {
            const types = {
                'LIMIT': 'limit',
                'MARKET': 'market',
            };
            return this.safeString (types, type, type);
        }
    
        parseOrder (order, market = undefined) {
            //
            // limit sell
            //
            //     {
            //         id: 781246605,
            //         timestamp: 1584480015133,
            //         trailingUpdatedTimestamp: null,
            //         type: 'SELL',
            //         currencyPair: 'ETH_BTC',
            //         price: 0.0345,
            //         amount: 0.01,
            //         stopPrice: null,
            //         originalStopPrice: null,
            //         marketPriceAtLastUpdate: null,
            //         marketPriceAtOrderCreation: null,
            //         orderTradeType: 'LIMIT',
            //         hidden: false,
            //         trailing: false,
            //         clientOrderId: null
            //     }
            //
            // limit buy
            //
            //     {
            //         id: 67527001,
            //         timestamp: 1517931722613,
            //         trailingUpdatedTimestamp: null,
            //         type: 'BUY',
            //         price: 5897.24,
            //         remainingAmount: 0.002367,
            //         originalAmount: 0.1,
            //         stopPrice: null,
            //         originalStopPrice: null,
            //         marketPriceAtLastUpdate: null,
            //         marketPriceAtOrderCreation: null,
            //         status: 'CANCELLED',
            //         orderTradeType: 'LIMIT',
            //         hidden: false,
            //         avgPrice: null,
            //         trailing: false,
            //     }
            //
            const id = this.safeString (order, 'id');
            const timestamp = this.safeInteger (order, 'timestamp');
            const side = this.safeStringLower (order, 'type');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'originalAmount');
            let remaining = this.safeNumber (order, 'remainingAmount');
            if (remaining === undefined) {
                remaining = this.safeNumber (order, 'amount');
            }
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const type = this.parseOrderType (this.safeString (order, 'orderTradeType'));
            const average = this.safeNumber (order, 'avgPrice');
            const marketId = this.safeString (order, 'currencyPair');
            const symbol = this.safeSymbol (marketId, market, '_');
            const clientOrderId = this.safeString (order, 'clientOrderId');
            const stopPrice = this.safeNumber (order, 'stopPrice');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': undefined,
                'remaining': remaining,
                'status': status,
                'trades': undefined,
                'info': order,
                'fee': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            let method = 'privatePost' + this.capitalize (side);
            const request = {
                'currencyPair': this.marketId (symbol),
            };
            if (type === 'market') {
                if (side === 'buy') {
                    request['total'] = this.amountToPrecision (symbol, amount); // amount in fiat
                } else {
                    request['amount'] = this.amountToPrecision (symbol, amount); // amount in fiat
                }
                method += 'Instant';
            } else {
                request['amount'] = this.amountToPrecision (symbol, amount); // amount in crypto
                request['price'] = this.priceToPrecision (symbol, price);
                method += this.capitalize (type);
            }
            const response = await this[method] (this.extend (request, params));
            const id = this.safeString (response, 'data');
            return {
                'info': response,
                'id': id,
            };
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderId': id,
            };
            let market = undefined;
            if (symbol) {
                market = this.market (symbol);
            }
            const response = await this.privatePostOrderById (this.extend (request, params));
            const data = this.safeValue (response, 'data');
            return this.parseOrder (data, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            //   {"error":false,"errorMessage":null,"data":{"success":true,"remainingAmount":0.01}}
            const request = { 'orderId': id };
            const response = await this.privatePostCancelOrderWithInfo (this.extend (request, params));
            return {
                'info': response,
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + path;
            if (api === 'public') {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const auth = nonce + this.uid + this.apiKey;
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                body = this.urlencode (this.extend ({
                    'clientId': this.uid,
                    'nonce': nonce,
                    'publicKey': this.apiKey,
                    'signature': signature.toUpperCase (),
                }, params));
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response !== undefined) {
                if ('error' in response) {
                    // {"error":true,"errorMessage":"Minimum Order Size 0.01 ETH","data":null}
                    if (response['error']) {
                        const message = this.safeString (response, 'errorMessage');
                        const feedback = this.id + ' ' + message;
                        this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                        this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                        throw new ExchangeError (this.id + ' ' + this.json (response));
                    }
                }
            }
            if (code > 400) {
                if (body) {
                    const feedback = this.id + ' ' + body;
                    this.throwExactlyMatchedException (this.exceptions['exact'], body, feedback);
                    this.throwBroadlyMatchedException (this.exceptions['broad'], body, feedback);
                    throw new ExchangeError (feedback); // unknown message
                }
                throw new ExchangeError (this.id + ' ' + body);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],69:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { BadSymbol, BadRequest, ExchangeError, ArgumentsRequired, OrderNotFound, OnMaintenance } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinone extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinone',
                'name': 'CoinOne',
                'countries': [ 'KR' ], // Korea
                // 'enableRateLimit': false,
                'rateLimit': 667,
                'version': 'v2',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchCurrencies': false,
                    'fetchDepositAddresses': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    // https://github.com/ccxt/ccxt/pull/7067
                    // the endpoint that should return closed orders actually returns trades
                    'fetchClosedOrders': false,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/38003300-adc12fba-323f-11e8-8525-725f53c4a659.jpg',
                    'api': 'https://api.coinone.co.kr',
                    'www': 'https://coinone.co.kr',
                    'doc': 'https://doc.coinone.co.kr',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'orderbook/',
                            'trades/',
                            'ticker/',
                        ],
                    },
                    'private': {
                        'post': [
                            'account/deposit_address/',
                            'account/btc_deposit_address/',
                            'account/balance/',
                            'account/daily_balance/',
                            'account/user_info/',
                            'account/virtual_account/',
                            'order/cancel_all/',
                            'order/cancel/',
                            'order/limit_buy/',
                            'order/limit_sell/',
                            'order/complete_orders/',
                            'order/limit_orders/',
                            'order/order_info/',
                            'transaction/auth_number/',
                            'transaction/history/',
                            'transaction/krw/history/',
                            'transaction/btc/',
                            'transaction/coin/',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'taker': 0.002,
                        'maker': 0.002,
                    },
                },
                'precision': {
                    'price': 4,
                    'amount': 4,
                    'cost': 8,
                },
                'exceptions': {
                    '405': OnMaintenance, // {"errorCode":"405","status":"maintenance","result":"error"}
                    '104': OrderNotFound, // {"errorCode":"104","errorMsg":"Order id is not exist","result":"error"}
                    '108': BadSymbol, // {"errorCode":"108","errorMsg":"Unknown CryptoCurrency","result":"error"}
                    '107': BadRequest, // {"errorCode":"107","errorMsg":"Parameter error","result":"error"}
                },
                'commonCurrencies': {
                    'SOC': 'Soda Coin',
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const request = {
                'currency': 'all',
            };
            const response = await this.publicGetTicker (request);
            const result = [];
            const quoteId = 'krw';
            const quote = this.safeCurrencyCode (quoteId);
            const baseIds = Object.keys (response);
            for (let i = 0; i < baseIds.length; i++) {
                const baseId = baseIds[i];
                const ticker = this.safeValue (response, baseId, {});
                const currency = this.safeValue (ticker, 'currency');
                if (currency === undefined) {
                    continue;
                }
                const base = this.safeCurrencyCode (baseId);
                result.push ({
                    'info': ticker,
                    'id': baseId,
                    'symbol': base + '/' + quote,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostAccountBalance (params);
            const result = { 'info': response };
            const balances = this.omit (response, [
                'errorCode',
                'result',
                'normalWallets',
            ]);
            const currencyIds = Object.keys (balances);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const balance = balances[currencyId];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'avail');
                account['total'] = this.safeString (balance, 'balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
                'format': 'json',
            };
            const response = await this.publicGetOrderbook (this.extend (request, params));
            const timestamp = this.safeTimestamp (response, 'timestamp');
            return this.parseOrderBook (response, symbol, timestamp, 'bid', 'ask', 'price', 'qty');
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'currency': 'all',
                'format': 'json',
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const result = {};
            const ids = Object.keys (response);
            const timestamp = this.safeTimestamp (response, 'timestamp');
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                let symbol = id;
                let market = undefined;
                if (id in this.markets_by_id) {
                    market = this.markets_by_id[id];
                    symbol = market['symbol'];
                    const ticker = response[id];
                    result[symbol] = this.parseTicker (ticker, market);
                    result[symbol]['timestamp'] = timestamp;
                }
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
                'format': 'json',
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.safeTimestamp (ticker, 'timestamp');
            const open = this.safeNumber (ticker, 'first');
            const last = this.safeNumber (ticker, 'last');
            const previousClose = this.safeNumber (ticker, 'yesterday_last');
            const symbol = this.safeSymbol (undefined, market);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': previousClose,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
                'info': ticker,
            }, market);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "timestamp": "1416893212",
            //         "price": "420000.0",
            //         "qty": "0.1",
            //         "is_ask": "1"
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "timestamp": "1416561032",
            //         "price": "419000.0",
            //         "type": "bid",
            //         "qty": "0.001",
            //         "feeRate": "-0.0015",
            //         "fee": "-0.0000015",
            //         "orderId": "E84A1AC2-8088-4FA0-B093-A3BCDB9B3C85"
            //     }
            //
            const timestamp = this.safeTimestamp (trade, 'timestamp');
            const symbol = (market !== undefined) ? market['symbol'] : undefined;
            const is_ask = this.safeString (trade, 'is_ask');
            let side = this.safeString (trade, 'type');
            if (is_ask !== undefined) {
                if (is_ask === '1') {
                    side = 'sell';
                } else if (is_ask === '0') {
                    side = 'buy';
                }
            } else {
                if (side === 'ask') {
                    side = 'sell';
                } else if (side === 'bid') {
                    side = 'buy';
                }
            }
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'qty');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const orderId = this.safeString (trade, 'orderId');
            let feeCost = this.safeNumber (trade, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                feeCost = Math.abs (feeCost);
                let feeRate = this.safeNumber (trade, 'feeRate');
                feeRate = Math.abs (feeRate);
                let feeCurrencyCode = undefined;
                if (market !== undefined) {
                    feeCurrencyCode = (side === 'sell') ? market['quote'] : market['base'];
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                    'rate': feeRate,
                };
            }
            return {
                'id': this.safeString (trade, 'id'),
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'order': orderId,
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
                'format': 'json',
            };
            const response = await this.publicGetTrades (this.extend (request, params));
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "timestamp": "1416895635",
            //         "currency": "btc",
            //         "completeOrders": [
            //             {
            //                 "timestamp": "1416893212",
            //                 "price": "420000.0",
            //                 "qty": "0.1",
            //                 "is_ask": "1"
            //             }
            //         ]
            //     }
            //
            const completeOrders = this.safeValue (response, 'completeOrders', []);
            return this.parseTrades (completeOrders, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            if (type !== 'limit') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            await this.loadMarkets ();
            const request = {
                'price': price,
                'currency': this.marketId (symbol),
                'qty': amount,
            };
            const method = 'privatePostOrder' + this.capitalize (type) + this.capitalize (side);
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "orderId": "8a82c561-40b4-4cb3-9bc0-9ac9ffc1d63b"
            //     }
            //
            return this.parseOrder (response);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'order_id': id,
                'currency': market['id'],
            };
            const response = await this.privatePostOrderOrderInfo (this.extend (request, params));
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "status": "live",
            //         "info": {
            //             "orderId": "32FF744B-D501-423A-8BA1-05BB6BE7814A",
            //             "currency": "BTC",
            //             "type": "bid",
            //             "price": "2922000.0",
            //             "qty": "115.4950",
            //             "remainQty": "45.4950",
            //             "feeRate": "0.0003",
            //             "fee": "0",
            //             "timestamp": "1499340941"
            //         }
            //     }
            //
            const info = this.safeValue (response, 'info', {});
            info['status'] = this.safeString (info, 'status');
            return this.parseOrder (info, market);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'live': 'open',
                'partially_filled': 'open',
                'filled': 'closed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "orderId": "8a82c561-40b4-4cb3-9bc0-9ac9ffc1d63b"
            //     }
            //
            // fetchOrder
            //
            //     {
            //         "status": "live", // injected in fetchOrder
            //         "orderId": "32FF744B-D501-423A-8BA1-05BB6BE7814A",
            //         "currency": "BTC",
            //         "type": "bid",
            //         "price": "2922000.0",
            //         "qty": "115.4950",
            //         "remainQty": "45.4950",
            //         "feeRate": "0.0003",
            //         "fee": "0",
            //         "timestamp": "1499340941"
            //     }
            //
            // fetchOpenOrders
            //
            //     {
            //         "index": "0",
            //         "orderId": "68665943-1eb5-4e4b-9d76-845fc54f5489",
            //         "timestamp": "1449037367",
            //         "price": "444000.0",
            //         "qty": "0.3456",
            //         "type": "ask",
            //         "feeRate": "-0.0015"
            //     }
            //
            const id = this.safeString (order, 'orderId');
            const price = this.safeNumber (order, 'price');
            const timestamp = this.safeTimestamp (order, 'timestamp');
            let side = this.safeString (order, 'type');
            if (side === 'ask') {
                side = 'sell';
            } else if (side === 'bid') {
                side = 'buy';
            }
            const remaining = this.safeNumber (order, 'remainQty');
            const amount = this.safeNumber (order, 'qty');
            let status = this.safeString (order, 'status');
            // https://github.com/ccxt/ccxt/pull/7067
            if (status === 'live') {
                if ((remaining !== undefined) && (amount !== undefined)) {
                    if (remaining < amount) {
                        status = 'canceled';
                    }
                }
            }
            status = this.parseOrderStatus (status);
            let symbol = undefined;
            let base = undefined;
            let quote = undefined;
            const marketId = this.safeStringLower (order, 'currency');
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    base = this.safeCurrencyCode (marketId);
                    quote = 'KRW';
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
                base = market['base'];
                quote = market['quote'];
            }
            let fee = undefined;
            const feeCost = this.safeNumber (order, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyCode = (side === 'sell') ? quote : base;
                fee = {
                    'cost': feeCost,
                    'rate': this.safeNumber (order, 'feeRate'),
                    'currency': feeCurrencyCode,
                };
            }
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'average': undefined,
                'amount': amount,
                'filled': undefined,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // The returned amount might not be same as the ordered amount. If an order is partially filled, the returned amount means the remaining amount.
            // For the same reason, the returned amount and remaining are always same, and the returned filled and cost are always zero.
            if (symbol === undefined) {
                throw new ExchangeError (this.id + ' allows fetching closed orders with a specific symbol');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
            };
            const response = await this.privatePostOrderLimitOrders (this.extend (request, params));
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "limitOrders": [
            //             {
            //                 "index": "0",
            //                 "orderId": "68665943-1eb5-4e4b-9d76-845fc54f5489",
            //                 "timestamp": "1449037367",
            //                 "price": "444000.0",
            //                 "qty": "0.3456",
            //                 "type": "ask",
            //                 "feeRate": "-0.0015"
            //             }
            //         ]
            //     }
            //
            const limitOrders = this.safeValue (response, 'limitOrders', []);
            return this.parseOrders (limitOrders, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
            };
            const response = await this.privatePostOrderCompleteOrders (this.extend (request, params));
            //
            // despite the name of the endpoint it returns trades which may have a duplicate orderId
            // https://github.com/ccxt/ccxt/pull/7067
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0",
            //         "completeOrders": [
            //             {
            //                 "timestamp": "1416561032",
            //                 "price": "419000.0",
            //                 "type": "bid",
            //                 "qty": "0.001",
            //                 "feeRate": "-0.0015",
            //                 "fee": "-0.0000015",
            //                 "orderId": "E84A1AC2-8088-4FA0-B093-A3BCDB9B3C85"
            //             }
            //         ]
            //     }
            //
            const completeOrders = this.safeValue (response, 'completeOrders', []);
            return this.parseTrades (completeOrders, market, since, limit);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                // eslint-disable-next-line quotes
                throw new ArgumentsRequired (this.id + " cancelOrder() requires a symbol argument. To cancel the order, pass a symbol argument and {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument of cancelOrder.");
            }
            const price = this.safeNumber (params, 'price');
            const qty = this.safeNumber (params, 'qty');
            const isAsk = this.safeInteger (params, 'is_ask');
            if ((price === undefined) || (qty === undefined) || (isAsk === undefined)) {
                // eslint-disable-next-line quotes
                throw new ArgumentsRequired (this.id + " cancelOrder() requires {'price': 12345, 'qty': 1.2345, 'is_ask': 0} in the params argument.");
            }
            await this.loadMarkets ();
            const request = {
                'order_id': id,
                'price': price,
                'qty': qty,
                'is_ask': isAsk,
                'currency': this.marketId (symbol),
            };
            const response = await this.privatePostOrderCancel (this.extend (request, params));
            //
            //     {
            //         "result": "success",
            //         "errorCode": "0"
            //     }
            //
            return response;
        }
    
        async fetchDepositAddresses (codes = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostAccountDepositAddress (params);
            //
            //     {
            //         result: 'success',
            //         errorCode: '0',
            //         walletAddress: {
            //             matic: null,
            //             btc: "mnobqu4i6qMCJWDpf5UimRmr8JCvZ8FLcN",
            //             xrp: null,
            //             xrp_tag: '-1',
            //             kava: null,
            //             kava_memo: null,
            //         }
            //     }
            //
            const walletAddress = this.safeValue (response, 'walletAddress', {});
            const keys = Object.keys (walletAddress);
            const result = {};
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const value = walletAddress[key];
                if ((!value) || (value === '-1')) {
                    continue;
                }
                const parts = key.split ('_');
                const currencyId = this.safeValue (parts, 0);
                const secondPart = this.safeValue (parts, 1);
                const code = this.safeCurrencyCode (currencyId);
                let depositAddress = this.safeValue (result, code);
                if (depositAddress === undefined) {
                    depositAddress = {
                        'currency': code,
                        'address': undefined,
                        'tag': undefined,
                        'info': value,
                    };
                }
                const address = this.safeString (depositAddress, 'address', value);
                this.checkAddress (address);
                depositAddress['address'] = address;
                depositAddress['info'] = address;
                if ((secondPart === 'tag' || secondPart === 'memo')) {
                    depositAddress['tag'] = value;
                    depositAddress['info'] = [ address, value ];
                }
                result[code] = depositAddress;
            }
            return result;
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const request = this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            let url = this.urls['api'] + '/';
            if (api === 'public') {
                url += request;
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                url += this.version + '/' + request;
                const nonce = this.nonce ().toString ();
                const json = this.json (this.extend ({
                    'access_token': this.apiKey,
                    'nonce': nonce,
                }, params));
                const payload = this.stringToBase64 (json);
                body = this.decode (payload);
                const secret = this.secret.toUpperCase ();
                const signature = this.hmac (payload, this.encode (secret), 'sha512');
                headers = {
                    'Content-Type': 'application/json',
                    'X-COINONE-PAYLOAD': payload,
                    'X-COINONE-SIGNATURE': signature,
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            if ('result' in response) {
                const result = response['result'];
                if (result !== 'success') {
                    //
                    //    {  "errorCode": "405",  "status": "maintenance",  "result": "error"}
                    //
                    const errorCode = this.safeString (response, 'errorCode');
                    const feedback = this.id + ' ' + body;
                    this.throwExactlyMatchedException (this.exceptions, errorCode, feedback);
                    throw new ExchangeError (feedback);
                }
            } else {
                throw new ExchangeError (this.id + ' ' + body);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],70:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, AuthenticationError } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class coinspot extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'coinspot',
                'name': 'CoinSpot',
                'countries': [ 'AU' ], // Australia
                'rateLimit': 1000,
                'has': {
                    'cancelOrder': false,
                    'CORS': false,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/28208429-3cacdf9a-6896-11e7-854e-4c79a772a30f.jpg',
                    'api': {
                        'public': 'https://www.coinspot.com.au/pubapi',
                        'private': 'https://www.coinspot.com.au/api',
                    },
                    'www': 'https://www.coinspot.com.au',
                    'doc': 'https://www.coinspot.com.au/api',
                    'referral': 'https://www.coinspot.com.au/register?code=PJURCU',
                },
                'api': {
                    'public': {
                        'get': [
                            'latest',
                        ],
                    },
                    'private': {
                        'post': [
                            'orders',
                            'orders/history',
                            'my/coin/deposit',
                            'my/coin/send',
                            'quote/buy',
                            'quote/sell',
                            'my/balances',
                            'my/orders',
                            'my/buy',
                            'my/sell',
                            'my/buy/cancel',
                            'my/sell/cancel',
                            'ro/my/balances',
                            'ro/my/balances/{cointype}',
                            'ro/my/deposits',
                            'ro/my/withdrawals',
                            'ro/my/transactions',
                            'ro/my/transactions/{cointype}',
                            'ro/my/transactions/open',
                            'ro/my/transactions/{cointype}/open',
                            'ro/my/sendreceive',
                            'ro/my/affiliatepayments',
                            'ro/my/referralpayments',
                        ],
                    },
                },
                'markets': {
                    'BTC/AUD': { 'id': 'btc', 'symbol': 'BTC/AUD', 'base': 'BTC', 'quote': 'AUD', 'baseId': 'btc', 'quoteId': 'aud' },
                    'ETH/AUD': { 'id': 'eth', 'symbol': 'ETH/AUD', 'base': 'ETH', 'quote': 'AUD', 'baseId': 'eth', 'quoteId': 'aud' },
                    'XRP/AUD': { 'id': 'xrp', 'symbol': 'XRP/AUD', 'base': 'XRP', 'quote': 'AUD', 'baseId': 'xrp', 'quoteId': 'aud' },
                    'LTC/AUD': { 'id': 'ltc', 'symbol': 'LTC/AUD', 'base': 'LTC', 'quote': 'AUD', 'baseId': 'ltc', 'quoteId': 'aud' },
                    'DOGE/AUD': { 'id': 'doge', 'symbol': 'DOGE/AUD', 'base': 'DOGE', 'quote': 'AUD', 'baseId': 'doge', 'quoteId': 'aud' },
                    'RFOX/AUD': { 'id': 'rfox', 'symbol': 'RFOX/AUD', 'base': 'RFOX', 'quote': 'AUD', 'baseId': 'rfox', 'quoteId': 'aud' },
                    'POWR/AUD': { 'id': 'powr', 'symbol': 'POWR/AUD', 'base': 'POWR', 'quote': 'AUD', 'baseId': 'powr', 'quoteId': 'aud' },
                    'NEO/AUD': { 'id': 'neo', 'symbol': 'NEO/AUD', 'base': 'NEO', 'quote': 'AUD', 'baseId': 'neo', 'quoteId': 'aud' },
                    'TRX/AUD': { 'id': 'trx', 'symbol': 'TRX/AUD', 'base': 'TRX', 'quote': 'AUD', 'baseId': 'trx', 'quoteId': 'aud' },
                    'EOS/AUD': { 'id': 'eos', 'symbol': 'EOS/AUD', 'base': 'EOS', 'quote': 'AUD', 'baseId': 'eos', 'quoteId': 'aud' },
                    'XLM/AUD': { 'id': 'xlm', 'symbol': 'XLM/AUD', 'base': 'XLM', 'quote': 'AUD', 'baseId': 'xlm', 'quoteId': 'aud' },
                    'RHOC/AUD': { 'id': 'rhoc', 'symbol': 'RHOC/AUD', 'base': 'RHOC', 'quote': 'AUD', 'baseId': 'rhoc', 'quoteId': 'aud' },
                    'GAS/AUD': { 'id': 'gas', 'symbol': 'GAS/AUD', 'base': 'GAS', 'quote': 'AUD', 'baseId': 'gas', 'quoteId': 'aud' },
                },
                'commonCurrencies': {
                    'DRK': 'DASH',
                },
                'options': {
                    'fetchBalance': 'private_post_my_balances',
                },
            });
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const method = this.safeString (this.options, 'fetchBalance', 'private_post_my_balances');
            const response = await this[method] (params);
            //
            // read-write api keys
            //
            //     ...
            //
            // read-only api keys
            //
            //     {
            //         "status":"ok",
            //         "balances":[
            //             {
            //                 "LTC":{"balance":0.1,"audbalance":16.59,"rate":165.95}
            //             }
            //         ]
            //     }
            //
            const result = { 'info': response };
            const balances = this.safeValue2 (response, 'balance', 'balances');
            if (Array.isArray (balances)) {
                for (let i = 0; i < balances.length; i++) {
                    const currencies = balances[i];
                    const currencyIds = Object.keys (currencies);
                    for (let j = 0; j < currencyIds.length; j++) {
                        const currencyId = currencyIds[j];
                        const balance = currencies[currencyId];
                        const code = this.safeCurrencyCode (currencyId);
                        const account = this.account ();
                        account['total'] = this.safeString (balance, 'balance');
                        result[code] = account;
                    }
                }
            } else {
                const currencyIds = Object.keys (balances);
                for (let i = 0; i < currencyIds.length; i++) {
                    const currencyId = currencyIds[i];
                    const code = this.safeCurrencyCode (currencyId);
                    const account = this.account ();
                    account['total'] = this.safeString (balances, currencyId);
                    result[code] = account;
                }
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'cointype': market['id'],
            };
            const orderbook = await this.privatePostOrders (this.extend (request, params));
            return this.parseOrderBook (orderbook, symbol, undefined, 'buyorders', 'sellorders', 'rate', 'amount');
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetLatest (params);
            let id = this.marketId (symbol);
            id = id.toLowerCase ();
            const ticker = response['prices'][id];
            const timestamp = this.milliseconds ();
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': undefined,
                'low': undefined,
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'cointype': market['id'],
            };
            const response = await this.privatePostOrdersHistory (this.extend (request, params));
            //
            //     {
            //         "status":"ok",
            //         "orders":[
            //             {"amount":0.00102091,"rate":21549.09999991,"total":21.99969168,"coin":"BTC","solddate":1604890646143,"market":"BTC/AUD"},
            //         ],
            //     }
            //
            const trades = this.safeValue (response, 'orders', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     {
            //         "amount":0.00102091,
            //         "rate":21549.09999991,
            //         "total":21.99969168,
            //         "coin":"BTC",
            //         "solddate":1604890646143,
            //         "market":"BTC/AUD"
            //     }
            //
            const priceString = this.safeString (trade, 'rate');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            let cost = this.safeNumber (trade, 'total');
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            const timestamp = this.safeInteger (trade, 'solddate');
            const marketId = this.safeString (trade, 'market');
            const symbol = this.safeSymbol (marketId, market, '/');
            return {
                'info': trade,
                'id': undefined,
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'order': undefined,
                'type': undefined,
                'side': undefined,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const method = 'privatePostMy' + this.capitalize (side);
            if (type === 'market') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            const request = {
                'cointype': this.marketId (symbol),
                'amount': amount,
                'rate': price,
            };
            return await this[method] (this.extend (request, params));
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const side = this.safeString (params, 'side');
            if (side !== 'buy' && side !== 'sell') {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a side parameter, "buy" or "sell"');
            }
            params = this.omit (params, 'side');
            const method = 'privatePostMy' + this.capitalize (side) + 'Cancel';
            const request = {
                'id': id,
            };
            return await this[method] (this.extend (request, params));
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            if (!this.apiKey) {
                throw new AuthenticationError (this.id + ' requires apiKey for all requests');
            }
            const url = this.urls['api'][api] + '/' + path;
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                body = this.json (this.extend ({ 'nonce': nonce }, params));
                headers = {
                    'Content-Type': 'application/json',
                    'key': this.apiKey,
                    'sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],71:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, BadRequest, InvalidNonce, RequestTimeout, ExchangeNotAvailable, InsufficientFunds, OrderNotFound, InvalidOrder, DDoSProtection, AuthenticationError, BadSymbol } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class crex24 extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'crex24',
                'name': 'CREX24',
                'countries': [ 'EE' ], // Estonia
                'rateLimit': 500,
                'version': 'v2',
                // new metainfo interface
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchBidsAsks': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTradingFee': false, // actually, true, but will be implemented later
                    'fetchTradingFees': false, // actually, true, but will be implemented later
                    'fetchFundingFees': true,
                    'fetchTransactions': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '3m': '3m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '4h': '4h',
                    '1d': '1d',
                    '1w': '1w',
                    '1M': '1mo',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/47813922-6f12cc00-dd5d-11e8-97c6-70f957712d47.jpg',
                    'api': 'https://api.crex24.com',
                    'www': 'https://crex24.com',
                    'referral': 'https://crex24.com/?refid=slxsjsjtil8xexl9hksr',
                    'doc': 'https://docs.crex24.com/trade-api/v2',
                    'fees': 'https://crex24.com/fees',
                },
                'api': {
                    'public': {
                        'get': [
                            'currencies',
                            'instruments',
                            'tickers',
                            'recentTrades',
                            'orderBook',
                            'ohlcv',
                            'tradingFeeSchedules',
                            'withdrawalFees',
                            'currencyTransport',
                            'currenciesWithdrawalFees',
                        ],
                    },
                    'trading': {
                        'get': [
                            'orderStatus',
                            'orderTrades',
                            'activeOrders',
                            'orderHistory',
                            'tradeHistory',
                            'tradingFee',
                            'tradeFee', // The support of this method has been dropped on February 18, 2020. Please, use tradingFee method instead. https://docs.crex24.com/trade-api/v2/#trade-fee-and-rebate-discontinued
                        ],
                        'post': [
                            'placeOrder',
                            'modifyOrder',
                            'cancelOrdersById',
                            'cancelOrdersByInstrument',
                            'cancelAllOrders',
                        ],
                    },
                    'account': {
                        'get': [
                            'balance',
                            'depositAddress',
                            'moneyTransfers',
                            'moneyTransferStatus',
                            'previewWithdrawal',
                        ],
                        'post': [
                            'withdraw',
                        ],
                    },
                },
                'precisionMode': TICK_SIZE,
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': 0.001,
                        'maker': -0.0001,
                    },
                    // should be deleted, these are outdated and inaccurate
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                        'withdraw': {},
                        'deposit': {},
                    },
                },
                'commonCurrencies': {
                    'ACM': 'Actinium',
                    'BCC': 'BCH',
                    'BIT': 'BitMoney',
                    'BULL': 'BuySell',
                    'CREDIT': 'TerraCredit',
                    'EPS': 'Epanus',  // conflict with EPS Ellipsis https://github.com/ccxt/ccxt/issues/8909
                    'FUND': 'FUNDChains',
                    'GHOST': 'GHOSTPRISM',
                    'GTC': 'GastroCoin', // conflict with Gitcoin and Game.com
                    'IQ': 'IQ.Cash',
                    'PUT': 'PutinCoin',
                    'SBTC': 'SBTCT', // SiamBitcoin
                    'UNI': 'Universe',
                    'YOYO': 'YOYOW',
                },
                // exchange-specific options
                'options': {
                    'fetchOrdersMethod': 'tradingGetOrderHistory', // or 'tradingGetActiveOrders'
                    'fetchClosedOrdersMethod': 'tradingGetOrderHistory', // or 'tradingGetActiveOrders'
                    'fetchTickersMethod': 'publicGetTicker24hr',
                    'defaultTimeInForce': 'GTC', // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel
                    'hasAlreadyAuthenticatedSuccessfully': false,
                    'warnOnFetchOpenOrdersWithoutSymbol': true,
                    'parseOrderToPrecision': false, // force amounts and costs in parseOrder to precision
                    'newOrderRespType': 'RESULT', // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
                },
                'exceptions': {
                    'exact': {
                        "Parameter 'filter' contains invalid value.": BadRequest, // eslint-disable-quotes
                        "Mandatory parameter 'instrument' is missing.": BadRequest, // eslint-disable-quotes
                        "The value of parameter 'till' must be greater than or equal to the value of parameter 'from'.": BadRequest, // eslint-disable-quotes
                        'Failed to verify request signature.': AuthenticationError, // eslint-disable-quotes
                        "Nonce error. Make sure that the value passed in the 'X-CREX24-API-NONCE' header is greater in each consecutive request than in the previous one for the corresponding API-Key provided in 'X-CREX24-API-KEY' header.": InvalidNonce,
                        'Market orders are not supported by the instrument currently.': InvalidOrder,
                        "Parameter 'instrument' contains invalid value.": BadSymbol,
                    },
                    'broad': {
                        'try again later': ExchangeNotAvailable, // {"errorDescription":"Failed to process the request. Please, try again later."}
                        'API Key': AuthenticationError, // "API Key '9edc48de-d5b0-4248-8e7e-f59ffcd1c7f1' doesn't exist."
                        'Insufficient funds': InsufficientFunds, // "Insufficient funds: new order requires 10 ETH which is more than the available balance."
                        'has been delisted.': BadSymbol, // {"errorDescription":"Instrument '$PAC-BTC' has been delisted."}
                        'is currently suspended.': BadSymbol, // {"errorDescription":"Trading in BITG-BTC is currently suspended."}
                        'Mandatory parameter': BadRequest, // {"errorDescription":"Mandatory parameter 'feeCurrency' is missing."}
                    },
                },
            });
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetInstruments (params);
            //
            //         [ {
            //             "symbol": "$PAC-BTC",
            //             "baseCurrency": "$PAC",
            //             "quoteCurrency": "BTC",
            //             "feeCurrency": "BTC",
            //             "feeSchedule": "OriginalSchedule",
            //             "tickSize": 0.00000001,
            //             "minPrice": 0.00000001,
            //             "maxPrice": 10000000000.0,
            //             "volumeIncrement": 0.00000001,
            //             "minVolume": 1.0,
            //             "maxVolume": 1000000000.0,
            //             "minQuoteVolume": 0.000000000000001,
            //             "maxQuoteVolume": 100000000000.0,
            //             "supportedOrderTypes": [
            //               "limit"
            //             ],
            //             "state": "delisted"
            //           },
            //           {
            //             "symbol": "1INCH-USDT",
            //             "baseCurrency": "1INCH",
            //             "quoteCurrency": "USDT",
            //             "feeCurrency": "USDT",
            //             "feeSchedule": "FeeSchedule10",
            //             "tickSize": 0.0001,
            //             "minPrice": 0.0001,
            //             "maxPrice": 10000000000.0,
            //             "volumeIncrement": 0.00000001,
            //             "minVolume": 0.01,
            //             "maxVolume": 1000000000.0,
            //             "minQuoteVolume": 0.000000000000001,
            //             "maxQuoteVolume": 100000000000.0,
            //             "supportedOrderTypes": [
            //               "limit"
            //             ],
            //             "state": "active"
            //           }, ]
            //
            const response2 = await this.publicGetTradingFeeSchedules (params);
            //
            //     [
            //         {
            //             "name": "FeeSchedule05",
            //             "feeRates": [
            //                 {
            //                     "volumeThreshold": 0.0,
            //                     "maker": 0.0005,
            //                     "taker": 0.0005
            //                 },
            //                 {
            //                     "volumeThreshold": 5.0,
            //                     "maker": 0.0004,
            //                     "taker": 0.0004
            //                 },
            //                 {
            //                     "volumeThreshold": 15.0,
            //                     "maker": 0.0003,
            //                     "taker": 0.0003
            //                 },
            //                 {
            //                     "volumeThreshold": 30.0,
            //                     "maker": 0.0002,
            //                     "taker": 0.0002
            //                 },
            //                 {
            //                     "volumeThreshold": 50.0,
            //                     "maker": 0.0001,
            //                     "taker": 0.0001
            //                 }
            //             ]
            //         },
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'symbol');
                const baseId = this.safeString (market, 'baseCurrency');
                const quoteId = this.safeString (market, 'quoteCurrency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const tickSize = this.safeNumber (market, 'tickSize');
                const minPrice = this.safeNumber (market, 'minPrice');
                const maxPrice = this.safeNumber (market, 'maxPrice');
                const minAmount = this.safeNumber (market, 'minVolume');
                const maxAmount = this.safeNumber (market, 'maxVolume');
                const minCost = this.safeNumber (market, 'minQuoteVolume');
                const maxCost = this.safeNumber (market, 'maxQuoteVolume');
                const precision = {
                    'amount': minAmount,
                    'price': tickSize,
                };
                let maker = undefined;
                let taker = undefined;
                const feeSchedule = this.safeString (market, 'feeSchedule');
                for (let j = 0; j < response2.length; j++) {
                    const feeScheduleName = this.safeString (response2[j], 'name');
                    if (feeScheduleName === feeSchedule) {
                        const feeRates = this.safeValue (response2[j], 'feeRates', []);
                        for (let k = 0; k < feeRates.length; k++) {
                            const volumeThreshold = this.safeNumber (feeRates[k], 'volumeThreshold');
                            if (volumeThreshold === 0) {
                                maker = this.safeNumber (feeRates[k], 'maker');
                                taker = this.safeNumber (feeRates[k], 'taker');
                                break;
                            }
                        }
                        break;
                    }
                }
                const active = (market['state'] === 'active');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'info': market,
                    'active': active,
                    'precision': precision,
                    'maker': maker,
                    'taker': taker,
                    'limits': {
                        'amount': {
                            'min': minAmount,
                            'max': maxAmount,
                        },
                        'price': {
                            'min': minPrice,
                            'max': maxPrice,
                        },
                        'cost': {
                            'min': minCost,
                            'max': maxCost,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     [ {                   symbol: "$PAC",
            //                             name: "PACCoin",
            //                           isFiat:  false,
            //                  depositsAllowed:  true,
            //         depositConfirmationCount:  8,
            //                       minDeposit:  0,
            //               withdrawalsAllowed:  true,
            //              withdrawalPrecision:  8,
            //                    minWithdrawal:  4,
            //                    maxWithdrawal:  1000000000,
            //                flatWithdrawalFee:  2,
            //                       isDelisted:  false       },
            //       {                   symbol: "ZZC",
            //                             name: "Zozo",
            //                           isFiat:  false,
            //                  depositsAllowed:  false,
            //         depositConfirmationCount:  8,
            //                       minDeposit:  0,
            //               withdrawalsAllowed:  false,
            //              withdrawalPrecision:  8,
            //                    minWithdrawal:  0.2,
            //                    maxWithdrawal:  1000000000,
            //                flatWithdrawalFee:  0.1,
            //                       isDelisted:  false       } ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'symbol');
                const code = this.safeCurrencyCode (id);
                const withdrawalPrecision = this.safeInteger (currency, 'withdrawalPrecision');
                const precision = Math.pow (10, -withdrawalPrecision);
                const address = this.safeValue (currency, 'BaseAddress');
                const active = (currency['depositsAllowed'] && currency['withdrawalsAllowed'] && !currency['isDelisted']);
                const type = currency['isFiat'] ? 'fiat' : 'crypto';
                result[code] = {
                    'id': id,
                    'code': code,
                    'address': address,
                    'info': currency,
                    'type': type,
                    'name': this.safeString (currency, 'name'),
                    'active': active,
                    'fee': this.safeNumber (currency, 'flatWithdrawalFee'), // todo: redesign
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision),
                            'max': Math.pow (10, precision),
                        },
                        'deposit': {
                            'min': this.safeNumber (currency, 'minDeposit'),
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'minWithdrawal'),
                            'max': this.safeNumber (currency, 'maxWithdrawal'),
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchFundingFees (codes = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetCurrenciesWithdrawalFees (params);
            //
            //     [
            //         {
            //             currency: '1INCH',
            //             fees: [
            //                 { feeCurrency: 'BTC', amount: 0.00032 },
            //                 { feeCurrency: 'ETH', amount: 0.0054 },
            //                 { feeCurrency: 'DOGE', amount: 63.06669 },
            //                 { feeCurrency: 'LTC', amount: 0.0912 },
            //                 { feeCurrency: 'BCH', amount: 0.02364 },
            //                 { feeCurrency: 'USDT', amount: 12.717 },
            //                 { feeCurrency: 'USDC', amount: 12.7367 },
            //                 { feeCurrency: 'TRX', amount: 205.99108 },
            //                 { feeCurrency: 'EOS', amount: 3.30141 }
            //             ]
            //         }
            //     ]
            //
            const withdrawFees = {};
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const currencyId = this.safeString (entry, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const networkList = this.safeValue (entry, 'fees');
                withdrawFees[code] = {};
                for (let j = 0; j < networkList.length; j++) {
                    const networkEntry = networkList[j];
                    const networkId = this.safeString (networkEntry, 'feeCurrency');
                    const networkCode = this.safeCurrencyCode (networkId);
                    const fee = this.safeNumber (networkEntry, 'amount');
                    withdrawFees[code][networkCode] = fee;
                }
            }
            return {
                'withdraw': withdrawFees,
                'deposit': {},
                'info': response,
            };
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'currency': 'ETH', // comma-separated list of currency ids
                // 'nonZeroOnly': 'false', // true by default
            };
            const response = await this.accountGetBalance (this.extend (request, params));
            //
            //     [
            //         {
            //           "currency": "ETH",
            //           "available": 0.0,
            //           "reserved": 0.0
            //         }
            //     ]
            //
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'reserved');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default = maximum = 100
            }
            const response = await this.publicGetOrderBook (this.extend (request, params));
            //
            //     {  buyLevels: [ { price: 0.03099, volume: 0.00610063 },
            //                     { price: 0.03097, volume: 1.33455158 },
            //                     { price: 0.03096, volume: 0.0830889 },
            //                     { price: 0.03095, volume: 0.0820356 },
            //                     { price: 0.03093, volume: 0.5499419 },
            //                     { price: 0.03092, volume: 0.23317494 },
            //                     { price: 0.03091, volume: 0.62105322 },
            //                     { price: 0.00620041, volume: 0.003 }    ],
            //       sellLevels: [ { price: 0.03117, volume: 5.47492315 },
            //                     { price: 0.03118, volume: 1.97744139 },
            //                     { price: 0.03119, volume: 0.012 },
            //                     { price: 0.03121, volume: 0.741242 },
            //                     { price: 0.03122, volume: 0.96178089 },
            //                     { price: 0.03123, volume: 0.152326 },
            //                     { price: 0.03124, volume: 2.63462933 },
            //                     { price: 0.069, volume: 0.004 }            ] }
            //
            return this.parseOrderBook (response, symbol, undefined, 'buyLevels', 'sellLevels', 'price', 'volume');
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //       {    instrument: "ZZC-USD",
            //                  last:  0.065,
            //         percentChange:  0,
            //                   low:  0.065,
            //                  high:  0.065,
            //            baseVolume:  0,
            //           quoteVolume:  0,
            //           volumeInBtc:  0,
            //           volumeInUsd:  0,
            //                   ask:  0.5,
            //                   bid:  0.0007,
            //             timestamp: "2018-10-31T09:21:25Z" }   ]
            //
            const timestamp = this.parse8601 (this.safeString (ticker, 'timestamp'));
            const marketId = this.safeString (ticker, 'instrument');
            const symbol = this.safeSymbol (marketId, market, '-');
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined, // previous day close
                'change': undefined,
                'percentage': this.safeNumber (ticker, 'percentChange'),
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'baseVolume'),
                'quoteVolume': this.safeNumber (ticker, 'quoteVolume'),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument': market['id'],
            };
            const response = await this.publicGetTickers (this.extend (request, params));
            //
            //     [ {    instrument: "$PAC-BTC",
            //                  last:  3.3e-7,
            //         percentChange:  3.125,
            //                   low:  2.7e-7,
            //                  high:  3.3e-7,
            //            baseVolume:  191700.79823187,
            //           quoteVolume:  0.0587930939346704,
            //           volumeInBtc:  0.0587930939346704,
            //           volumeInUsd:  376.2006339435353,
            //                   ask:  3.3e-7,
            //                   bid:  3.1e-7,
            //             timestamp: "2018-10-31T09:21:25Z" }   ]
            //
            const numTickers = response.length;
            if (numTickers < 1) {
                throw new ExchangeError (this.id + ' fetchTicker could not load quotes for symbol ' + symbol);
            }
            return this.parseTicker (response[0], market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (symbols !== undefined) {
                const ids = this.marketIds (symbols);
                request['instrument'] = ids.join (',');
            }
            const response = await this.publicGetTickers (this.extend (request, params));
            //
            //     [ {    instrument: "$PAC-BTC",
            //                  last:  3.3e-7,
            //         percentChange:  3.125,
            //                   low:  2.7e-7,
            //                  high:  3.3e-7,
            //            baseVolume:  191700.79823187,
            //           quoteVolume:  0.0587930939346704,
            //           volumeInBtc:  0.0587930939346704,
            //           volumeInUsd:  376.2006339435353,
            //                   ask:  3.3e-7,
            //                   bid:  3.1e-7,
            //             timestamp: "2018-10-31T09:21:25Z" },
            //       {    instrument: "ZZC-USD",
            //                  last:  0.065,
            //         percentChange:  0,
            //                   low:  0.065,
            //                  high:  0.065,
            //            baseVolume:  0,
            //           quoteVolume:  0,
            //           volumeInBtc:  0,
            //           volumeInUsd:  0,
            //                   ask:  0.5,
            //                   bid:  0.0007,
            //             timestamp: "2018-10-31T09:21:25Z" }   ]
            //
            return this.parseTickers (response, symbols);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //       {     price:  0.03105,
            //            volume:  0.11,
            //              side: "sell",
            //         timestamp: "2018-10-31T04:19:35Z" }  ]
            //
            // private fetchMyTrades
            //
            //     {
            //         "id": 3005866,
            //         "orderId": 468533093,
            //         "timestamp": "2018-06-02T16:26:27Z",
            //         "instrument": "BCH-ETH",
            //         "side": "buy",
            //         "price": 1.78882,
            //         "volume": 0.027,
            //         "fee": 0.0000483,
            //         "feeCurrency": "ETH"
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (trade, 'timestamp'));
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'volume');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const id = this.safeString (trade, 'id');
            const side = this.safeString (trade, 'side');
            const orderId = this.safeString (trade, 'orderId');
            const marketId = this.safeString (trade, 'instrument');
            const symbol = this.safeSymbol (marketId, market, '-');
            let fee = undefined;
            const feeCurrencyId = this.safeString (trade, 'feeCurrency');
            const feeCode = this.safeCurrencyCode (feeCurrencyId);
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': feeCode,
                };
            }
            const takerOrMaker = undefined;
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': undefined,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'price': price,
                'cost': cost,
                'amount': amount,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // min 1, max 1000, default 100
            }
            const response = await this.publicGetRecentTrades (this.extend (request, params));
            //
            //     [ {     price:  0.03117,
            //            volume:  0.02597403,
            //              side: "buy",
            //         timestamp: "2018-10-31T09:37:46Z" },
            //       {     price:  0.03105,
            //            volume:  0.11,
            //              side: "sell",
            //         timestamp: "2018-10-31T04:19:35Z" }  ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         timestamp: '2019-09-21T10:36:00Z',
            //         open: 0.02152,
            //         high: 0.02156,
            //         low: 0.02152,
            //         close: 0.02156,
            //         volume: 0.01741259
            //     }
            //
            return [
                this.parse8601 (this.safeString (ohlcv, 'timestamp')),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'granularity': this.timeframes[timeframe],
                'instrument': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // Accepted values: 1 - 1000. If the parameter is not specified, the number of results is limited to 100
            }
            const response = await this.publicGetOhlcv (this.extend (request, params));
            //
            //     [
            //         {
            //             "timestamp": "2020-06-06T17:36:00Z",
            //             "open": 0.025,
            //             "high": 0.025,
            //             "low": 0.02499,
            //             "close": 0.02499,
            //             "volume": 0.00643127
            //         }
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'submitting': 'open', // A newly created limit order has a status "submitting" until it has been processed.
                // This status changes during the lifetime of an order and can have different values depending on the value of the parameter Time In Force.
                'unfilledActive': 'open', // order is active, no trades have been made
                'partiallyFilledActive': 'open', // part of the order has been filled, the other part is active
                'filled': 'closed', // order has been filled entirely
                'partiallyFilledCancelled': 'canceled', // part of the order has been filled, the other part has been cancelled either by the trader or by the system (see the value of cancellationReason of an Order for more details on the reason of cancellation)
                'unfilledCancelled': 'canceled', // order has been cancelled, no trades have taken place (see the value of cancellationReason of an Order for more details on the reason of cancellation)
            };
            return (status in statuses) ? statuses[status] : status;
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "id": 469594855,
            //         "timestamp": "2018-06-08T16:59:44Z",
            //         "instrument": "BTS-BTC",
            //         "side": "buy",
            //         "type": "limit",
            //         "status": "submitting",
            //         "cancellationReason": null,
            //         "timeInForce": "GTC",
            //         "volume": 4.0,
            //         "price": 0.000025,
            //         "stopPrice": null,
            //         "remainingVolume": 4.0,
            //         "lastUpdate": null,
            //         "parentOrderId": null,
            //         "childOrderId": null
            //     }
            //
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const marketId = this.safeString (order, 'instrument');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = this.parse8601 (this.safeString (order, 'timestamp'));
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'volume');
            const remaining = this.safeNumber (order, 'remainingVolume');
            const lastTradeTimestamp = this.parse8601 (this.safeString (order, 'lastUpdate'));
            const id = this.safeString (order, 'id');
            const type = this.safeString (order, 'type');
            const side = this.safeString (order, 'side');
            const fee = undefined;
            const trades = undefined;
            const average = undefined;
            const timeInForce = this.safeString (order, 'timeInForce');
            const stopPrice = this.safeNumber (order, 'stopPrice');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': undefined,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': trades,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument': market['id'],
                'volume': this.amountToPrecision (symbol, amount),
                // The value must comply with the list of order types supported by the instrument (see the value of parameter supportedOrderTypes of the Instrument)
                // If the parameter is not specified, the default value "limit" is used
                // More about order types in the corresponding section of documentation
                'type': type, // 'limit', 'market', 'stopLimit', in fact as of 2018-10-31, only 'limit' orders are supported for all markets
                'side': side, // 'buy' or 'sell'
                // "GTC" - Good-Til-Cancelled
                // "IOC" - Immediate-Or-Cancel (currently not supported by the exchange API, reserved for future use)
                // "FOK" - Fill-Or-Kill (currently not supported by the exchange API, reserved for future use)
                // 'timeInForce': 'GTC', // IOC', 'FOK'
                // 'strictValidation': false, // false - prices will be rounded to meet the requirement, true - execution of the method will be aborted and an error message will be returned
            };
            let priceIsRequired = false;
            let stopPriceIsRequired = false;
            if (type === 'limit') {
                priceIsRequired = true;
            } else if (type === 'stopLimit') {
                priceIsRequired = true;
                stopPriceIsRequired = true;
            }
            if (priceIsRequired) {
                if (price === undefined) {
                    throw new InvalidOrder (this.id + ' createOrder() requires a price argument for a ' + type + ' order');
                }
                request['price'] = this.priceToPrecision (symbol, price);
            }
            if (stopPriceIsRequired) {
                const stopPrice = this.safeNumber (params, 'stopPrice');
                if (stopPrice === undefined) {
                    throw new InvalidOrder (this.id + ' createOrder() requires a stopPrice extra param for a ' + type + ' order');
                } else {
                    request['stopPrice'] = this.priceToPrecision (symbol, stopPrice);
                }
                params = this.omit (params, 'stopPrice');
            }
            const response = await this.tradingPostPlaceOrder (this.extend (request, params));
            //
            //     {
            //         "id": 469594855,
            //         "timestamp": "2018-06-08T16:59:44Z",
            //         "instrument": "BTS-BTC",
            //         "side": "buy",
            //         "type": "limit",
            //         "status": "submitting",
            //         "cancellationReason": null,
            //         "timeInForce": "GTC",
            //         "volume": 4.0,
            //         "price": 0.000025,
            //         "stopPrice": null,
            //         "remainingVolume": 4.0,
            //         "lastUpdate": null,
            //         "parentOrderId": null,
            //         "childOrderId": null
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.tradingGetOrderStatus (this.extend (request, params));
            //
            //     [
            //         {
            //           "id": 466747915,
            //           "timestamp": "2018-05-26T06:43:49Z",
            //           "instrument": "UNI-BTC",
            //           "side": "sell",
            //           "type": "limit",
            //           "status": "partiallyFilledActive",
            //           "cancellationReason": null,
            //           "timeInForce": "GTC",
            //           "volume": 5700.0,
            //           "price": 0.000005,
            //           "stopPrice": null,
            //           "remainingVolume": 1.948051948052,
            //           "lastUpdate": null,
            //           "parentOrderId": null,
            //           "childOrderId": null
            //         }
            //     ]
            //
            const numOrders = response.length;
            if (numOrders < 1) {
                throw new OrderNotFound (this.id + ' fetchOrder could not fetch order id ' + id);
            }
            return this.parseOrder (response[0]);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (since !== undefined) {
                request['from'] = this.ymdhms (since, 'T');
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (symbol !== undefined) {
                const market = this.market (symbol);
                request['instrument'] = market['id'];
            }
            const method = this.safeString (this.options, 'fetchOrdersMethod', 'tradingGetOrderHistory');
            const response = await this[method] (this.extend (request, params));
            //
            //     [
            //         {
            //             "id": 468535711,
            //             "timestamp": "2018-06-02T16:42:40Z",
            //             "instrument": "BTC-EUR",
            //             "side": "sell",
            //             "type": "limit",
            //             "status": "submitting",
            //             "cancellationReason": null,
            //             "timeInForce": "GTC",
            //             "volume": 0.00770733,
            //             "price": 6724.9,
            //             "stopPrice": null,
            //             "remainingVolume": 0.00770733,
            //             "lastUpdate": "2018-06-02T16:42:40Z",
            //             "parentOrderId": null,
            //             "childOrderId": null
            //         }
            //     ]
            //
            return this.parseOrders (response);
        }
    
        async fetchOrdersByIds (ids = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': ids.join (','),
            };
            const response = await this.tradingGetOrderStatus (this.extend (request, params));
            //
            //     [
            //         {
            //           "id": 466747915,
            //           "timestamp": "2018-05-26T06:43:49Z",
            //           "instrument": "UNI-BTC",
            //           "side": "sell",
            //           "type": "limit",
            //           "status": "partiallyFilledActive",
            //           "cancellationReason": null,
            //           "timeInForce": "GTC",
            //           "volume": 5700.0,
            //           "price": 0.000005,
            //           "stopPrice": null,
            //           "remainingVolume": 1.948051948052,
            //           "lastUpdate": null,
            //           "parentOrderId": null,
            //           "childOrderId": null
            //         }
            //     ]
            //
            return this.parseOrders (response, undefined, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['instrument'] = market['id'];
            }
            const response = await this.tradingGetActiveOrders (this.extend (request, params));
            //
            //     [
            //         {
            //             "id": 466747915,
            //             "timestamp": "2018-05-26T06:43:49Z",
            //             "instrument": "UNI-BTC",
            //             "side": "sell",
            //             "type": "limit",
            //             "status": "partiallyFilledActive",
            //             "cancellationReason": null,
            //             "timeInForce": "GTC",
            //             "volume": 5700.0,
            //             "price": 0.000005,
            //             "stopPrice": null,
            //             "remainingVolume": 1.948051948052,
            //             "lastUpdate": null,
            //             "parentOrderId": null,
            //             "childOrderId": null
            //         },
            //         {
            //             "id": 466748077,
            //             "timestamp": "2018-05-26T06:45:29Z",
            //             "instrument": "PRJ-BTC",
            //             "side": "sell",
            //             "type": "limit",
            //             "status": "partiallyFilledActive",
            //             "cancellationReason": null,
            //             "timeInForce": "GTC",
            //             "volume": 10000.0,
            //             "price": 0.0000007,
            //             "stopPrice": null,
            //             "remainingVolume": 9975.0,
            //             "lastUpdate": null,
            //             "parentOrderId": null,
            //             "childOrderId": null
            //         },
            //         ...
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['instrument'] = market['id'];
            }
            if (since !== undefined) {
                request['from'] = this.ymdhms (since, 'T');
            }
            if (limit !== undefined) {
                request['limit'] = limit; // min 1, max 1000, default 100
            }
            const method = this.safeString (this.options, 'fetchClosedOrdersMethod', 'tradingGetOrderHistory');
            const response = await this[method] (this.extend (request, params));
            //     [
            //         {
            //             "id": 468535711,
            //             "timestamp": "2018-06-02T16:42:40Z",
            //             "instrument": "BTC-EUR",
            //             "side": "sell",
            //             "type": "limit",
            //             "status": "submitting",
            //             "cancellationReason": null,
            //             "timeInForce": "GTC",
            //             "volume": 0.00770733,
            //             "price": 6724.9,
            //             "stopPrice": null,
            //             "remainingVolume": 0.00770733,
            //             "lastUpdate": null,
            //             "parentOrderId": null,
            //             "childOrderId": null
            //         },
            //         {
            //             "id": 468535707,
            //             "timestamp": "2018-06-02T16:42:37Z",
            //             "instrument": "BTG-BTC",
            //             "side": "buy",
            //             "type": "limit",
            //             "status": "unfilledActive",
            //             "cancellationReason": null,
            //             "timeInForce": "GTC",
            //             "volume": 0.0173737,
            //             "price": 0.00589027,
            //             "stopPrice": null,
            //             "remainingVolume": 0.0173737,
            //             "lastUpdate": null,
            //             "parentOrderId": null,
            //             "childOrderId": null
            //         },
            //         ...
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'ids': [
                    parseInt (id),
                ],
            };
            const response = await this.tradingPostCancelOrdersById (this.extend (request, params));
            //
            //     [
            //         465448358,
            //         468364313
            //     ]
            //
            return this.parseOrder (response);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            const response = await this.tradingPostCancelAllOrders (params);
            //
            //     [
            //         465448358,
            //         468364313
            //     ]
            //
            return response;
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['instrument'] = market['id'];
            }
            if (since !== undefined) {
                request['from'] = this.ymdhms (since, 'T');
            }
            if (limit !== undefined) {
                request['limit'] = limit; // min 1, max 1000, default 100
            }
            const response = await this.tradingGetTradeHistory (this.extend (request, params));
            //
            //     [
            //         {
            //             "id": 3005866,
            //             "orderId": 468533093,
            //             "timestamp": "2018-06-02T16:26:27Z",
            //             "instrument": "BCH-ETH",
            //             "side": "buy",
            //             "price": 1.78882,
            //             "volume": 0.027,
            //             "fee": 0.0000483,
            //             "feeCurrency": "ETH"
            //         },
            //         {
            //             "id": 3005812,
            //             "orderId": 468515771,
            //             "timestamp": "2018-06-02T16:16:05Z",
            //             "instrument": "ETC-BTC",
            //             "side": "sell",
            //             "price": 0.00210958,
            //             "volume": 0.05994006,
            //             "fee": -0.000000063224,
            //             "feeCurrency": "BTC"
            //         },
            //         ...
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {};
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (since !== undefined) {
                request['from'] = this.ymd (since, 'T');
            }
            const response = await this.accountGetMoneyTransfers (this.extend (request, params));
            //
            //     [
            //         {
            //           "id": 756446,
            //           "type": "deposit",
            //           "currency": "ETH",
            //           "address": "0x451d5a1b7519aa75164f440df78c74aac96023fe",
            //           "paymentId": null,
            //           "amount": 0.142,
            //           "fee": null,
            //           "txId": "0x2b49098749840a9482c4894be94f94864b498a1306b6874687a5640cc9871918",
            //           "createdAt": "2018-06-02T19:30:28Z",
            //           "processedAt": "2018-06-02T21:10:41Z",
            //           "confirmationsRequired": 12,
            //           "confirmationCount": 12,
            //           "status": "success",
            //           "errorDescription": null
            //         },
            //         {
            //           "id": 754618,
            //           "type": "deposit",
            //           "currency": "BTC",
            //           "address": "1IgNfmERVcier4IhfGEfutkLfu4AcmeiUC",
            //           "paymentId": null,
            //           "amount": 0.09,
            //           "fee": null,
            //           "txId": "6876541687a9187e987c9187654f7198b9718af974641687b19a87987f91874f",
            //           "createdAt": "2018-06-02T16:19:44Z",
            //           "processedAt": "2018-06-02T16:20:50Z",
            //           "confirmationsRequired": 1,
            //           "confirmationCount": 1,
            //           "status": "success",
            //           "errorDescription": null
            //         },
            //         ...
            //     ]
            //
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'type': 'deposit',
            };
            return this.fetchTransactions (code, since, limit, this.extend (request, params));
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'type': 'withdrawal',
            };
            return this.fetchTransactions (code, since, limit, this.extend (request, params));
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'pending': 'pending', // transfer is in progress
                'success': 'ok', // completed successfully
                'failed': 'failed', // aborted at some point (money will be credited back to the account of origin)
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            //     {
            //         "id": 756446,
            //         "type": "deposit",
            //         "currency": "ETH",
            //         "address": "0x451d5a1b7519aa75164f440df78c74aac96023fe",
            //         "paymentId": null,
            //         "amount": 0.142,
            //         "fee": null,
            //         "txId": "0x2b49098749840a9482c4894be94f94864b498a1306b6874687a5640cc9871918",
            //         "createdAt": "2018-06-02T19:30:28Z",
            //         "processedAt": "2018-06-02T21:10:41Z",
            //         "confirmationsRequired": 12,
            //         "confirmationCount": 12,
            //         "status": "success",
            //         "errorDescription": null,
            //     }
            //
            const id = this.safeString (transaction, 'id');
            const address = this.safeString (transaction, 'address');
            const tag = this.safeString (transaction, 'paymentId');
            const txid = this.safeValue (transaction, 'txId');
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const type = this.safeString (transaction, 'type');
            const timestamp = this.parse8601 (this.safeString (transaction, 'createdAt'));
            const updated = this.parse8601 (this.safeString (transaction, 'processedAt'));
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const amount = this.safeNumber (transaction, 'amount');
            const feeCost = this.safeNumber (transaction, 'fee');
            const fee = {
                'cost': feeCost,
                'currency': code,
            };
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'tag': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.accountGetDepositAddress (this.extend (request, params));
            //
            //     {
            //         "currency": "BTS",
            //         "address": "crex24",
            //         "paymentId": "0fg4da4186741579"
            //     }
            //
            const address = this.safeString (response, 'address');
            const tag = this.safeString (response, 'paymentId');
            return {
                'currency': code,
                'address': this.checkAddress (address),
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'address': address,
                'amount': parseFloat (this.currencyToPrecision (code, amount)),
                // sets whether the specified amount includes fee, can have either of the two values
                // true - balance will be decreased by amount, whereas [amount - fee] will be transferred to the specified address
                // false - amount will be deposited to the specified address, whereas the balance will be decreased by [amount + fee]
                // 'includeFee': false, // the default value is false
                'feeCurrency': currency['id'], // https://github.com/ccxt/ccxt/issues/7544
            };
            if (tag !== undefined) {
                request['paymentId'] = tag;
            }
            const response = await this.accountPostWithdraw (this.extend (request, params));
            return this.parseTransaction (response);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + this.version + '/' + api + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (method === 'GET') {
                if (Object.keys (query).length) {
                    request += '?' + this.urlencode (query);
                }
            }
            const url = this.urls['api'] + request;
            if ((api === 'trading') || (api === 'account')) {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const secret = this.base64ToBinary (this.secret);
                let auth = request + nonce;
                headers = {
                    'X-CREX24-API-KEY': this.apiKey,
                    'X-CREX24-API-NONCE': nonce,
                };
                if (method === 'POST') {
                    headers['Content-Type'] = 'application/json';
                    body = this.json (params);
                    auth += body;
                }
                headers['X-CREX24-API-SIGN'] = this.hmac (this.encode (auth), secret, 'sha512', 'base64');
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (!this.isJsonEncodedObject (body)) {
                return; // fallback to default error handler
            }
            if ((code >= 200) && (code < 300)) {
                return; // no error
            }
            const message = this.safeString (response, 'errorDescription');
            const feedback = this.id + ' ' + body;
            this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
            this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
            if (code === 400) {
                throw new BadRequest (feedback);
            } else if (code === 401) {
                throw new AuthenticationError (feedback);
            } else if (code === 403) {
                throw new AuthenticationError (feedback);
            } else if (code === 429) {
                throw new DDoSProtection (feedback);
            } else if (code === 500) {
                throw new ExchangeError (feedback);
            } else if (code === 503) {
                throw new ExchangeNotAvailable (feedback);
            } else if (code === 504) {
                throw new RequestTimeout (feedback);
            }
            throw new ExchangeError (feedback); // unknown message
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],72:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, ExchangeNotAvailable, InsufficientFunds, OrderNotFound, InvalidOrder, DDoSProtection, InvalidNonce, AuthenticationError, BadRequest } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class currencycom extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'currencycom',
                'name': 'Currency.com',
                'countries': [ 'BY' ], // Belarus
                'rateLimit': 500,
                'certified': true,
                'pro': true,
                'version': 'v1',
                // new metainfo interface
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchAccounts': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTradingFees': true,
                    'fetchTrades': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '3m': '3m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '4h': '4h',
                    '1d': '1d',
                    '1w': '1w',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/83718672-36745c00-a63e-11ea-81a9-677b1f789a4d.jpg',
                    'api': {
                        'public': 'https://api-adapter.backend.currency.com/api',
                        'private': 'https://api-adapter.backend.currency.com/api',
                    },
                    'test': {
                        'public': 'https://demo-api-adapter.backend.currency.com/api',
                        'private': 'https://demo-api-adapter.backend.currency.com/api',
                    },
                    'www': 'https://www.currency.com',
                    'referral': 'https://currency.com/trading/signup?c=362jaimv&pid=referral',
                    'doc': [
                        'https://currency.com/api',
                    ],
                    'fees': 'https://currency.com/fees-charges',
                },
                'api': {
                    'public': {
                        'get': [
                            'time',
                            'exchangeInfo',
                            'depth',
                            'aggTrades',
                            'klines',
                            'ticker/24hr',
                        ],
                    },
                    'private': {
                        'get': [
                            'leverageSettings',
                            'openOrders',
                            'tradingPositions',
                            'account',
                            'myTrades',
                        ],
                        'post': [
                            'order',
                            'updateTradingPosition',
                            'updateTradingOrder',
                            'closeTradingPosition',
                        ],
                        'delete': [
                            'order',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'tierBased': false,
                        'percentage': true,
                        'taker': this.parseNumber ('0.002'),
                        'maker': this.parseNumber ('0.002'),
                    },
                },
                'precisionMode': TICK_SIZE,
                // exchange-specific options
                'options': {
                    'defaultTimeInForce': 'GTC', // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel, 'FOK' = Fill Or Kill
                    'warnOnFetchOpenOrdersWithoutSymbol': true,
                    'recvWindow': 5 * 1000, // 5 sec, default
                    'timeDifference': 0, // the difference between system clock and Binance clock
                    'adjustForTimeDifference': false, // controls the adjustment logic upon instantiation
                    'parseOrderToPrecision': false, // force amounts and costs in parseOrder to precision
                    'newOrderRespType': {
                        'market': 'FULL', // 'ACK' for order id, 'RESULT' for full order or 'FULL' for order with fills
                        'limit': 'RESULT', // we change it from 'ACK' by default to 'RESULT'
                        'stop': 'RESULT',
                    },
                },
                'exceptions': {
                    'broad': {
                        'FIELD_VALIDATION_ERROR Cancel is available only for LIMIT order': InvalidOrder,
                        'API key does not exist': AuthenticationError,
                        'Order would trigger immediately.': InvalidOrder,
                        'Account has insufficient balance for requested action.': InsufficientFunds,
                        'Rest API trading is not enabled.': ExchangeNotAvailable,
                    },
                    'exact': {
                        '-1000': ExchangeNotAvailable, // {"code":-1000,"msg":"An unknown error occured while processing the request."}
                        '-1013': InvalidOrder, // createOrder -> 'invalid quantity'/'invalid price'/MIN_NOTIONAL
                        '-1021': InvalidNonce, // 'your time is ahead of server'
                        '-1022': AuthenticationError, // {"code":-1022,"msg":"Signature for this request is not valid."}
                        '-1100': InvalidOrder, // createOrder(symbol, 1, asdf) -> 'Illegal characters found in parameter 'price'
                        '-1104': ExchangeError, // Not all sent parameters were read, read 8 parameters but was sent 9
                        '-1025': AuthenticationError, // {"code":-1025,"msg":"Invalid API-key, IP, or permissions for action"}
                        '-1128': BadRequest, // {"code":-1128,"msg":"Combination of optional parameters invalid."}
                        '-2010': ExchangeError, // generic error code for createOrder -> 'Account has insufficient balance for requested action.', {"code":-2010,"msg":"Rest API trading is not enabled."}, etc...
                        '-2011': OrderNotFound, // cancelOrder(1, 'BTC/USDT') -> 'UNKNOWN_ORDER'
                        '-2013': OrderNotFound, // fetchOrder (1, 'BTC/USDT') -> 'Order does not exist'
                        '-2014': AuthenticationError, // { "code":-2014, "msg": "API-key format invalid." }
                        '-2015': AuthenticationError, // "Invalid API-key, IP, or permissions for action."
                    },
                },
                'commonCurrencies': {
                    'BNS': 'Bank of Nova Scotia',
                    'EDU': 'New Oriental Education & Technology Group Inc',
                    'ETN': 'Eaton',
                    'IQ': 'iQIYI',
                    'PLAY': "Dave & Buster's Entertainment",
                },
            });
        }
    
        nonce () {
            return this.milliseconds () - this.options['timeDifference'];
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     {
            //         "serverTime": 1590998366609
            //     }
            //
            return this.safeInteger (response, 'serverTime');
        }
    
        async loadTimeDifference (params = {}) {
            const response = await this.publicGetTime (params);
            const after = this.milliseconds ();
            this.options['timeDifference'] = parseInt (after - response['serverTime']);
            return this.options['timeDifference'];
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetExchangeInfo (params);
            //
            //     {
            //         "timezone":"UTC",
            //         "serverTime":1603252990096,
            //         "rateLimits":[
            //             {"rateLimitType":"REQUEST_WEIGHT","interval":"MINUTE","intervalNum":1,"limit":1200},
            //             {"rateLimitType":"ORDERS","interval":"SECOND","intervalNum":1,"limit":10},
            //             {"rateLimitType":"ORDERS","interval":"DAY","intervalNum":1,"limit":864000},
            //         ],
            //         "exchangeFilters":[],
            //         "symbols":[
            //             {
            //                 "symbol":"EVK",
            //                 "name":"Evonik",
            //                 "status":"BREAK",
            //                 "baseAsset":"EVK",
            //                 "baseAssetPrecision":3,
            //                 "quoteAsset":"EUR",
            //                 "quoteAssetId":"EUR",
            //                 "quotePrecision":3,
            //                 "orderTypes":["LIMIT","MARKET"],
            //                 "filters":[
            //                     {"filterType":"LOT_SIZE","minQty":"1","maxQty":"27000","stepSize":"1"},
            //                     {"filterType":"MIN_NOTIONAL","minNotional":"23"}
            //                 ],
            //                 "marketType":"SPOT",
            //                 "country":"DE",
            //                 "sector":"Basic Materials",
            //                 "industry":"Diversified Chemicals",
            //                 "tradingHours":"UTC; Mon 07:02 - 15:30; Tue 07:02 - 15:30; Wed 07:02 - 15:30; Thu 07:02 - 15:30; Fri 07:02 - 15:30",
            //                 "tickSize":0.005,
            //                 "tickValue":0.11125,
            //                 "exchangeFee":0.05
            //             },
            //             {
            //                 "symbol":"BTC/USD_LEVERAGE",
            //                 "name":"Bitcoin / USD",
            //                 "status":"TRADING",
            //                 "baseAsset":"BTC",
            //                 "baseAssetPrecision":3,
            //                 "quoteAsset":"USD",
            //                 "quoteAssetId":"USD_LEVERAGE",
            //                 "quotePrecision":3,
            //                 "orderTypes":["LIMIT","MARKET","STOP"],
            //                 "filters":[
            //                     {"filterType":"LOT_SIZE","minQty":"0.001","maxQty":"100","stepSize":"0.001"},
            //                     {"filterType":"MIN_NOTIONAL","minNotional":"13"}
            //                 ],
            //                 "marketType":"LEVERAGE",
            //                 "longRate":-0.01,
            //                 "shortRate":0.01,
            //                 "swapChargeInterval":480,
            //                 "country":"",
            //                 "sector":"",
            //                 "industry":"",
            //                 "tradingHours":"UTC; Mon - 21:00, 21:05 -; Tue - 21:00, 21:05 -; Wed - 21:00, 21:05 -; Thu - 21:00, 21:05 -; Fri - 21:00, 22:01 -; Sat - 21:00, 21:05 -; Sun - 20:00, 21:05 -",
            //                 "tickSize":0.05,
            //                 "tickValue":610.20875,
            //                 "makerFee":-0.025,
            //                 "takerFee":0.075
            //             },
            //         ]
            //     }
            //
            if (this.options['adjustForTimeDifference']) {
                await this.loadTimeDifference ();
            }
            const markets = this.safeValue (response, 'symbols');
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'symbol');
                const baseId = this.safeString (market, 'baseAsset');
                const quoteId = this.safeString (market, 'quoteAsset');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                let symbol = base + '/' + quote;
                if (id.indexOf ('/') >= 0) {
                    symbol = id;
                }
                const filters = this.safeValue (market, 'filters', []);
                const filtersByType = this.indexBy (filters, 'filterType');
                const precision = {
                    'amount': 1 / Math.pow (1, this.safeInteger (market, 'baseAssetPrecision')),
                    'price': this.safeNumber (market, 'tickSize'),
                };
                const status = this.safeString (market, 'status');
                const active = (status === 'TRADING');
                let type = this.safeStringLower (market, 'marketType');
                if (type === 'leverage') {
                    type = 'margin';
                }
                const spot = (type === 'spot');
                const margin = (type === 'margin');
                const entry = {
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'type': type,
                    'spot': spot,
                    'margin': margin,
                    'info': market,
                    'active': active,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision['amount']),
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': -Math.log10 (precision['amount']),
                            'max': undefined,
                        },
                    },
                };
                const exchangeFee = this.safeNumber2 (market, 'exchangeFee', 'tradingFee');
                const makerFee = this.safeNumber (market, 'makerFee', exchangeFee);
                const takerFee = this.safeNumber (market, 'takerFee', exchangeFee);
                if (makerFee !== undefined) {
                    entry['maker'] = makerFee / 100;
                }
                if (takerFee !== undefined) {
                    entry['taker'] = takerFee / 100;
                }
                if ('PRICE_FILTER' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'PRICE_FILTER', {});
                    entry['precision']['price'] = this.safeNumber (filter, 'tickSize');
                    // PRICE_FILTER reports zero values for maxPrice
                    // since they updated filter types in November 2018
                    // https://github.com/ccxt/ccxt/issues/4286
                    // therefore limits['price']['max'] doesn't have any meaningful value except undefined
                    entry['limits']['price'] = {
                        'min': this.safeNumber (filter, 'minPrice'),
                        'max': undefined,
                    };
                    const maxPrice = this.safeNumber (filter, 'maxPrice');
                    if ((maxPrice !== undefined) && (maxPrice > 0)) {
                        entry['limits']['price']['max'] = maxPrice;
                    }
                }
                if ('LOT_SIZE' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'LOT_SIZE', {});
                    entry['precision']['amount'] = this.safeNumber (filter, 'stepSize');
                    entry['limits']['amount'] = {
                        'min': this.safeNumber (filter, 'minQty'),
                        'max': this.safeNumber (filter, 'maxQty'),
                    };
                }
                if ('MARKET_LOT_SIZE' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'MARKET_LOT_SIZE', {});
                    entry['limits']['market'] = {
                        'min': this.safeNumber (filter, 'minQty'),
                        'max': this.safeNumber (filter, 'maxQty'),
                    };
                }
                if ('MIN_NOTIONAL' in filtersByType) {
                    const filter = this.safeValue (filtersByType, 'MIN_NOTIONAL', {});
                    entry['limits']['cost']['min'] = this.safeNumber (filter, 'minNotional');
                }
                result.push (entry);
            }
            return result;
        }
    
        async fetchAccounts (params = {}) {
            const response = await this.privateGetAccount (params);
            //
            //     {
            //         "makerCommission":0.20,
            //         "takerCommission":0.20,
            //         "buyerCommission":0.20,
            //         "sellerCommission":0.20,
            //         "canTrade":true,
            //         "canWithdraw":true,
            //         "canDeposit":true,
            //         "updateTime":1591056268,
            //         "balances":[
            //             {
            //                 "accountId":5470306579272968,
            //                 "collateralCurrency":true,
            //                 "asset":"ETH",
            //                 "free":0.0,
            //                 "locked":0.0,
            //                 "default":false,
            //             },
            //         ]
            //     }
            //
            const accounts = this.safeValue (response, 'balances', []);
            const result = [];
            for (let i = 0; i < accounts.length; i++) {
                const account = accounts[i];
                const accountId = this.safeInteger (account, 'accountId');
                const currencyId = this.safeString (account, 'asset');
                const currencyCode = this.safeCurrencyCode (currencyId);
                result.push ({
                    'id': accountId,
                    'type': undefined,
                    'currency': currencyCode,
                    'info': response,
                });
            }
            return result;
        }
    
        async fetchTradingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccount (params);
            return {
                'info': response,
                'maker': this.safeNumber (response, 'makerCommission'),
                'taker': this.safeNumber (response, 'takerCommission'),
            };
        }
    
        parseBalanceResponse (response) {
            //
            //     {
            //         "makerCommission":0.20,
            //         "takerCommission":0.20,
            //         "buyerCommission":0.20,
            //         "sellerCommission":0.20,
            //         "canTrade":true,
            //         "canWithdraw":true,
            //         "canDeposit":true,
            //         "updateTime":1591056268,
            //         "balances":[
            //             {
            //                 "accountId":5470306579272968,
            //                 "collateralCurrency":true,
            //                 "asset":"ETH",
            //                 "free":0.0,
            //                 "locked":0.0,
            //                 "default":false,
            //             },
            //         ]
            //     }
            //
            const result = { 'info': response };
            const balances = this.safeValue (response, 'balances', []);
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'asset');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'free');
                account['used'] = this.safeString (balance, 'locked');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccount (params);
            //
            //     {
            //         "makerCommission":0.20,
            //         "takerCommission":0.20,
            //         "buyerCommission":0.20,
            //         "sellerCommission":0.20,
            //         "canTrade":true,
            //         "canWithdraw":true,
            //         "canDeposit":true,
            //         "updateTime":1591056268,
            //         "balances":[
            //             {
            //                 "accountId":5470306579272968,
            //                 "collateralCurrency":true,
            //                 "asset":"ETH",
            //                 "free":0.0,
            //                 "locked":0.0,
            //                 "default":false,
            //             },
            //         ]
            //     }
            //
            return this.parseBalanceResponse (response);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 100, max 1000, valid limits 5, 10, 20, 50, 100, 500, 1000, 5000
            }
            const response = await this.publicGetDepth (this.extend (request, params));
            //
            //     {
            //         "lastUpdateId":1590999849037,
            //         "asks":[
            //             [0.02495,60.0000],
            //             [0.02496,120.0000],
            //             [0.02497,240.0000],
            //         ],
            //         "bids":[
            //             [0.02487,60.0000],
            //             [0.02486,120.0000],
            //             [0.02485,240.0000],
            //         ]
            //     }
            //
            const orderbook = this.parseOrderBook (response, symbol);
            orderbook['nonce'] = this.safeInteger (response, 'lastUpdateId');
            return orderbook;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker
            //
            //     {
            //         "symbol":"ETH/BTC",
            //         "priceChange":"0.00030",
            //         "priceChangePercent":"1.21",
            //         "weightedAvgPrice":"0.02481",
            //         "prevClosePrice":"0.02447",
            //         "lastPrice":"0.02477",
            //         "lastQty":"60.0",
            //         "bidPrice":"0.02477",
            //         "askPrice":"0.02484",
            //         "openPrice":"0.02447",
            //         "highPrice":"0.02524",
            //         "lowPrice":"0.02438",
            //         "volume":"11.97",
            //         "quoteVolume":"0.298053",
            //         "openTime":1590969600000,
            //         "closeTime":1591000072693
            //     }
            //
            // fetchTickers
            //
            //     {
            //         "symbol":"EVK",
            //         "highPrice":"22.57",
            //         "lowPrice":"22.16",
            //         "volume":"1",
            //         "quoteVolume":"22.2",
            //         "openTime":1590699364000,
            //         "closeTime":1590785764000
            //     }
            //
            const timestamp = this.safeInteger (ticker, 'closeTime');
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber (ticker, 'lastPrice');
            const open = this.safeNumber (ticker, 'openPrice');
            let average = undefined;
            if ((open !== undefined) && (last !== undefined)) {
                average = this.sum (open, last) / 2;
            }
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'highPrice'),
                'low': this.safeNumber (ticker, 'lowPrice'),
                'bid': this.safeNumber (ticker, 'bidPrice'),
                'bidVolume': this.safeNumber (ticker, 'bidQty'),
                'ask': this.safeNumber (ticker, 'askPrice'),
                'askVolume': this.safeNumber (ticker, 'askQty'),
                'vwap': this.safeNumber (ticker, 'weightedAvgPrice'),
                'open': open,
                'close': last,
                'last': last,
                'previousClose': this.safeNumber (ticker, 'prevClosePrice'), // previous day close
                'change': this.safeNumber (ticker, 'priceChange'),
                'percentage': this.safeNumber (ticker, 'priceChangePercent'),
                'average': average,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': this.safeNumber (ticker, 'quoteVolume'),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTicker24hr (this.extend (request, params));
            //
            //     {
            //         "symbol":"ETH/BTC",
            //         "priceChange":"0.00030",
            //         "priceChangePercent":"1.21",
            //         "weightedAvgPrice":"0.02481",
            //         "prevClosePrice":"0.02447",
            //         "lastPrice":"0.02477",
            //         "lastQty":"60.0",
            //         "bidPrice":"0.02477",
            //         "askPrice":"0.02484",
            //         "openPrice":"0.02447",
            //         "highPrice":"0.02524",
            //         "lowPrice":"0.02438",
            //         "volume":"11.97",
            //         "quoteVolume":"0.298053",
            //         "openTime":1590969600000,
            //         "closeTime":1591000072693
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTicker24hr (params);
            //
            //     [
            //         {
            //             "symbol":"EVK",
            //             "highPrice":"22.57",
            //             "lowPrice":"22.16",
            //             "volume":"1",
            //             "quoteVolume":"22.2",
            //             "openTime":1590699364000,
            //             "closeTime":1590785764000
            //         }
            //     ]
            //
            return this.parseTickers (response, symbols);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1590971040000,
            //         "0.02454",
            //         "0.02456",
            //         "0.02452",
            //         "0.02456",
            //         249
            //     ]
            //
            return [
                this.safeInteger (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'interval': this.timeframes[timeframe],
            };
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.publicGetKlines (this.extend (request, params));
            //
            //     [
            //         [1590971040000,"0.02454","0.02456","0.02452","0.02456",249],
            //         [1590971100000,"0.02455","0.02457","0.02452","0.02456",300],
            //         [1590971160000,"0.02455","0.02456","0.02453","0.02454",286],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public aggregate trades)
            //
            //     {
            //         "a":1658318071,
            //         "p":"0.02476",
            //         "q":"0.0",
            //         "T":1591001423382,
            //         "m":false
            //     }
            //
            // createOrder fills (private)
            //
            //     {
            //         "price": "9807.05",
            //         "qty": "0.01",
            //         "commission": "0",
            //         "commissionAsset": "dUSD"
            //     }
            //
            // fetchMyTrades
            //
            //     {
            //         "symbol": "BNBBTC",
            //         "id": 28457,
            //         "orderId": 100234,
            //         "price": "4.00000100",
            //         "qty": "12.00000000",
            //         "commission": "10.10000000",
            //         "commissionAsset": "BNB",
            //         "time": 1499865549590,
            //         "isBuyer": true,
            //         "isMaker": false,
            //         "isBestMatch": true
            //     }
            //
            const timestamp = this.safeInteger2 (trade, 'T', 'time');
            const priceString = this.safeString2 (trade, 'p', 'price');
            const amountString = this.safeString2 (trade, 'q', 'qty');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const id = this.safeString2 (trade, 'a', 'id');
            let side = undefined;
            const orderId = this.safeString (trade, 'orderId');
            if ('m' in trade) {
                side = trade['m'] ? 'sell' : 'buy'; // this is reversed intentionally
            } else if ('isBuyerMaker' in trade) {
                side = trade['isBuyerMaker'] ? 'sell' : 'buy';
            } else {
                if ('isBuyer' in trade) {
                    side = (trade['isBuyer']) ? 'buy' : 'sell'; // this is a true side
                }
            }
            let fee = undefined;
            if ('commission' in trade) {
                fee = {
                    'cost': this.safeNumber (trade, 'commission'),
                    'currency': this.safeCurrencyCode (this.safeString (trade, 'commissionAsset')),
                };
            }
            let takerOrMaker = undefined;
            if ('isMaker' in trade) {
                takerOrMaker = trade['isMaker'] ? 'maker' : 'taker';
            }
            const marketId = this.safeString (trade, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': undefined,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                // 'limit': 500, // default 500, max 1000
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.publicGetAggTrades (this.extend (request, params));
            //
            //     [
            //         {
            //             "a":1658318071,
            //             "p":"0.02476",
            //             "q":"0.0",
            //             "T":1591001423382,
            //             "m":false
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'NEW': 'open',
                'PARTIALLY_FILLED': 'open',
                'FILLED': 'closed',
                'CANCELED': 'canceled',
                'PENDING_CANCEL': 'canceling', // currently unused
                'REJECTED': 'rejected',
                'EXPIRED': 'expired',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "symbol": "BTC/USD",
            //         "orderId": "00000000-0000-0000-0000-0000000c0263",
            //         "clientOrderId": "00000000-0000-0000-0000-0000000c0263",
            //         "transactTime": 1589878206426,
            //         "price": "9825.66210000",
            //         "origQty": "0.01",
            //         "executedQty": "0.01",
            //         "status": "FILLED",
            //         "timeInForce": "FOK",
            //         "type": "MARKET",
            //         "side": "BUY",
            //         "fills": [
            //             {
            //                 "price": "9807.05",
            //                 "qty": "0.01",
            //                 "commission": "0",
            //                 "commissionAsset": "dUSD"
            //             }
            //         ]
            //     }
            //
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '/');
            let timestamp = undefined;
            if ('time' in order) {
                timestamp = this.safeInteger (order, 'time');
            } else if ('transactTime' in order) {
                timestamp = this.safeInteger (order, 'transactTime');
            }
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'origQty');
            const filled = this.safeNumber (order, 'executedQty');
            const remaining = undefined;
            const cost = this.safeNumber (order, 'cummulativeQuoteQty');
            const id = this.safeString (order, 'orderId');
            const type = this.safeStringLower (order, 'type');
            const side = this.safeStringLower (order, 'side');
            let trades = undefined;
            const fills = this.safeValue (order, 'fills');
            if (fills !== undefined) {
                trades = this.parseTrades (fills, market);
            }
            const timeInForce = this.safeString (order, 'timeInForce');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': cost,
                'average': undefined,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': undefined,
                'trades': trades,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let accountId = undefined;
            if (market['margin']) {
                accountId = this.safeInteger (params, 'accountId');
                if (accountId === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires an accountId parameter for ' + market['type'] + ' market ' + symbol);
                }
            }
            const uppercaseType = type.toUpperCase ();
            const newOrderRespType = this.safeValue (this.options['newOrderRespType'], type, 'RESULT');
            const request = {
                'symbol': market['id'],
                'quantity': this.amountToPrecision (symbol, amount),
                'type': uppercaseType,
                'side': side.toUpperCase (),
                'newOrderRespType': newOrderRespType, // 'RESULT' for full order or 'FULL' for order with fills
                // 'leverage': 1,
                // 'accountId': 5470306579272968, // required for leverage markets
                // 'takeProfit': '123.45',
                // 'stopLoss': '54.321'
                // 'guaranteedStopLoss': '54.321',
            };
            if (uppercaseType === 'LIMIT') {
                request['price'] = this.priceToPrecision (symbol, price);
                request['timeInForce'] = this.options['defaultTimeInForce']; // 'GTC' = Good To Cancel (default), 'IOC' = Immediate Or Cancel, 'FOK' = Fill Or Kill
            } else if (uppercaseType === 'STOP') {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            //
            //     {
            //         "symbol": "BTC/USD",
            //         "orderId": "00000000-0000-0000-0000-0000000c0263",
            //         "clientOrderId": "00000000-0000-0000-0000-0000000c0263",
            //         "transactTime": 1589878206426,
            //         "price": "9825.66210000",
            //         "origQty": "0.01",
            //         "executedQty": "0.01",
            //         "status": "FILLED",
            //         "timeInForce": "FOK",
            //         "type": "MARKET",
            //         "side": "BUY",
            //         "fills": [
            //             {
            //                 "price": "9807.05",
            //                 "qty": "0.01",
            //                 "commission": "0",
            //                 "commissionAsset": "dUSD"
            //             }
            //         ]
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            } else if (this.options['warnOnFetchOpenOrdersWithoutSymbol']) {
                const symbols = this.symbols;
                const numSymbols = symbols.length;
                const fetchOpenOrdersRateLimit = parseInt (numSymbols / 2);
                throw new ExchangeError (this.id + ' fetchOpenOrders() WARNING: fetching open orders without specifying a symbol is rate-limited to one call per ' + fetchOpenOrdersRateLimit.toString () + ' seconds. Do not call this method frequently to avoid ban. Set ' + this.id + '.options["warnOnFetchOpenOrdersWithoutSymbol"] = false to suppress this warning message.');
            }
            const response = await this.privateGetOpenOrders (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const origClientOrderId = this.safeValue (params, 'origClientOrderId');
            const request = {
                'symbol': market['id'],
                // 'orderId': parseInt (id),
                // 'origClientOrderId': id,
            };
            if (origClientOrderId === undefined) {
                request['orderId'] = id;
            } else {
                request['origClientOrderId'] = origClientOrderId;
            }
            const response = await this.privateDeleteOrder (this.extend (request, params));
            //
            //     {
            //         "symbol":"ETH/USD",
            //         "orderId":"00000000-0000-0000-0000-00000024383b",
            //         "clientOrderId":"00000000-0000-0000-0000-00000024383b",
            //         "price":"150",
            //         "origQty":"0.1",
            //         "executedQty":"0.0",
            //         "status":"CANCELED",
            //         "timeInForce":"GTC",
            //         "type":"LIMIT",
            //         "side":"BUY"
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetMyTrades (this.extend (request, params));
            //
            //     [
            //         {
            //             "symbol": "BNBBTC",
            //             "id": 28457,
            //             "orderId": 100234,
            //             "price": "4.00000100",
            //             "qty": "12.00000000",
            //             "commission": "10.10000000",
            //             "commissionAsset": "BNB",
            //             "time": 1499865549590,
            //             "isBuyer": true,
            //             "isMaker": false,
            //             "isBestMatch": true
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/' + this.version + '/' + path;
            if (path === 'historicalTrades') {
                headers = {
                    'X-MBX-APIKEY': this.apiKey,
                };
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                let query = this.urlencode (this.extend ({
                    'timestamp': this.nonce (),
                    'recvWindow': this.options['recvWindow'],
                }, params));
                const signature = this.hmac (this.encode (query), this.encode (this.secret));
                query += '&' + 'signature=' + signature;
                headers = {
                    'X-MBX-APIKEY': this.apiKey,
                };
                if ((method === 'GET') || (method === 'DELETE')) {
                    url += '?' + query;
                } else {
                    body = query;
                    headers['Content-Type'] = 'application/x-www-form-urlencoded';
                }
            } else {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if ((httpCode === 418) || (httpCode === 429)) {
                throw new DDoSProtection (this.id + ' ' + httpCode.toString () + ' ' + reason + ' ' + body);
            }
            // error response in a form: { "code": -1013, "msg": "Invalid quantity." }
            // following block cointains legacy checks against message patterns in "msg" property
            // will switch "code" checks eventually, when we know all of them
            if (httpCode >= 400) {
                if (body.indexOf ('Price * QTY is zero or less') >= 0) {
                    throw new InvalidOrder (this.id + ' order cost = amount * price is zero or less ' + body);
                }
                if (body.indexOf ('LOT_SIZE') >= 0) {
                    throw new InvalidOrder (this.id + ' order amount should be evenly divisible by lot size ' + body);
                }
                if (body.indexOf ('PRICE_FILTER') >= 0) {
                    throw new InvalidOrder (this.id + ' order price is invalid, i.e. exceeds allowed price precision, exceeds min price or max price limits or is invalid float value in general, use this.priceToPrecision (symbol, amount) ' + body);
                }
            }
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //     {"code":-1128,"msg":"Combination of optional parameters invalid."}
            //
            const errorCode = this.safeString (response, 'code');
            if ((errorCode !== undefined) && (errorCode !== '0')) {
                const feedback = this.id + ' ' + this.json (response);
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                const message = this.safeString (response, 'msg');
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],73:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, InsufficientFunds, BadRequest, BadSymbol, InvalidOrder, AuthenticationError, ArgumentsRequired, OrderNotFound, ExchangeNotAvailable } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class delta extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'delta',
                'name': 'Delta Exchange',
                'countries': [ 'VC' ], // Saint Vincent and the Grenadines
                'rateLimit': 300,
                'version': 'v2',
                // new metainfo interface
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchDepositAddress': true,
                    'fetchCurrencies': true,
                    'fetchLedger': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrderBook': true,
                    'fetchStatus': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '3m': '3m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '2h': '2h',
                    '4h': '4h',
                    '6h': '6h',
                    '1d': '1d',
                    '7d': '7d',
                    '1w': '1w',
                    '2w': '2w',
                    '1M': '30d',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/99450025-3be60a00-2931-11eb-9302-f4fd8d8589aa.jpg',
                    'test': {
                        'public': 'https://testnet-api.delta.exchange',
                        'private': 'https://testnet-api.delta.exchange',
                    },
                    'api': {
                        'public': 'https://api.delta.exchange',
                        'private': 'https://api.delta.exchange',
                    },
                    'www': 'https://www.delta.exchange',
                    'doc': [
                        'https://docs.delta.exchange',
                    ],
                    'fees': 'https://www.delta.exchange/fees',
                    'referral': 'https://www.delta.exchange/app/signup/?code=IULYNB',
                },
                'api': {
                    'public': {
                        'get': [
                            'assets',
                            'settings',
                            'indices',
                            'products',
                            'tickers',
                            'tickers/{symbol}',
                            'l2orderbook/{symbol}',
                            'trades/{symbol}',
                            'history/candles',
                            'history/sparklines',
                        ],
                    },
                    'private': {
                        'get': [
                            'orders',
                            'orders/leverage',
                            'positions',
                            'positions/margined',
                            'orders/history',
                            'fills',
                            'fills/history/download/csv',
                            'wallet/balances',
                            'wallet/transactions',
                            'wallet/transactions/download',
                            'deposits/address',
                        ],
                        'post': [
                            'orders',
                            'orders/batch',
                            'orders/leverage',
                            'positions/change_margin',
                        ],
                        'put': [
                            'orders',
                            'orders/batch',
                        ],
                        'delete': [
                            'orders',
                            'orders/all',
                            'orders/batch',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': 0.15 / 100,
                        'maker': 0.10 / 100,
                        'tiers': {
                            'taker': [
                                [0, 0.15 / 100],
                                [100, 0.13 / 100],
                                [250, 0.13 / 100],
                                [1000, 0.1 / 100],
                                [5000, 0.09 / 100],
                                [10000, 0.075 / 100],
                                [20000, 0.065 / 100],
                            ],
                            'maker': [
                                [0, 0.1 / 100],
                                [100, 0.1 / 100],
                                [250, 0.09 / 100],
                                [1000, 0.075 / 100],
                                [5000, 0.06 / 100],
                                [10000, 0.05 / 100],
                                [20000, 0.05 / 100],
                            ],
                        },
                    },
                },
                'precisionMode': TICK_SIZE,
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': false,
                },
                'exceptions': {
                    'exact': {
                        // Margin required to place order with selected leverage and quantity is insufficient.
                        'insufficient_margin': InsufficientFunds, // {"error":{"code":"insufficient_margin","context":{"available_balance":"0.000000000000000000","required_additional_balance":"1.618626000000000000000000000"}},"success":false}
                        'order_size_exceed_available': InvalidOrder, // The order book doesn't have sufficient liquidity, hence the order couldnt be filled, for example, ioc orders
                        'risk_limits_breached': BadRequest, // orders couldn't be placed as it will breach allowed risk limits.
                        'invalid_contract': BadSymbol, // The contract/product is either doesn't exist or has already expired.
                        'immediate_liquidation': InvalidOrder, // Order will cause immediate liquidation.
                        'out_of_bankruptcy': InvalidOrder, // Order prices are out of position bankruptcy limits.
                        'self_matching_disrupted_post_only': InvalidOrder, // Self matching is not allowed during auction.
                        'immediate_execution_post_only': InvalidOrder, // orders couldn't be placed as it includes post only orders which will be immediately executed
                        'bad_schema': BadRequest, // {"error":{"code":"bad_schema","context":{"schema_errors":[{"code":"validation_error","message":"id is required","param":""}]}},"success":false}
                        'invalid_api_key': AuthenticationError, // {"success":false,"error":{"code":"invalid_api_key"}}
                        'invalid_signature': AuthenticationError, // {"success":false,"error":{"code":"invalid_signature"}}
                        'open_order_not_found': OrderNotFound, // {"error":{"code":"open_order_not_found"},"success":false}
                        'unavailable': ExchangeNotAvailable, // {"error":{"code":"unavailable"},"success":false}
                    },
                    'broad': {
                    },
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetSettings (params);
            //
            //     {
            //         "result":{
            //             "server_time":1605472733766141,
            //             "deto_referral_mining_daily_reward":"25000",
            //             "deto_total_reward_pool":"100000000",
            //             "deto_trade_mining_daily_reward":"75000",
            //             "kyc_deposit_limit":"20",
            //             "kyc_withdrawal_limit":"2",
            //             "under_maintenance":"false"
            //         },
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.safeIntegerProduct (result, 'server_time', 0.001);
        }
    
        async fetchStatus (params = {}) {
            const response = await this.publicGetSettings (params);
            const result = this.safeValue (response, 'result', {});
            const underMaintenance = this.safeValue (result, 'under_maintenance');
            const status = (underMaintenance === 'true') ? 'maintenance' : 'ok';
            const updated = this.safeIntegerProduct (result, 'server_time', 0.001);
            this.status = this.extend (this.status, {
                'status': status,
                'updated': updated,
            });
            return this.status;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetAssets (params);
            //
            //     {
            //         "result":[
            //             {
            //                 "base_withdrawal_fee":"0.0005",
            //                 "deposit_status":"enabled",
            //                 "id":2,
            //                 "interest_credit":true,
            //                 "interest_slabs":[
            //                     {"limit":"0.1","rate":"0"},
            //                     {"limit":"1","rate":"0.05"},
            //                     {"limit":"5","rate":"0.075"},
            //                     {"limit":"10","rate":"0.1"},
            //                     {"limit":"9999999999999999","rate":"0"}
            //                 ],
            //                 "kyc_deposit_limit":"10",
            //                 "kyc_withdrawal_limit":"2",
            //                 "min_withdrawal_amount":"0.001",
            //                 "minimum_precision":4,
            //                 "name":"Bitcoin",
            //                 "precision":8,
            //                 "sort_priority":1,
            //                 "symbol":"BTC",
            //                 "variable_withdrawal_fee":"0",
            //                 "withdrawal_status":"enabled"
            //             },
            //         ],
            //         "success":true
            //     }
            //
            const currencies = this.safeValue (response, 'result', []);
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                const id = this.safeString (currency, 'symbol');
                const numericId = this.safeInteger (currency, 'id');
                const code = this.safeCurrencyCode (id);
                const depositStatus = this.safeString (currency, 'deposit_status');
                const withdrawalStatus = this.safeString (currency, 'withdrawal_status');
                const depositsEnabled = (depositStatus === 'enabled');
                const withdrawalsEnabled = (withdrawalStatus === 'enabled');
                const active = depositsEnabled && withdrawalsEnabled;
                const precision = this.safeInteger (currency, 'precision');
                result[code] = {
                    'id': id,
                    'numericId': numericId,
                    'code': code,
                    'name': this.safeString (currency, 'name'),
                    'info': currency, // the original payload
                    'active': active,
                    'fee': this.safeNumber (currency, 'base_withdrawal_fee'),
                    'precision': 1 / Math.pow (10, precision),
                    'limits': {
                        'amount': { 'min': undefined, 'max': undefined },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'min_withdrawal_amount'),
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async loadMarkets (reload = false, params = {}) {
            const markets = await super.loadMarkets (reload, params);
            const currenciesByNumericId = this.safeValue (this.options, 'currenciesByNumericId');
            if ((currenciesByNumericId === undefined) || reload) {
                this.options['currenciesByNumericId'] = this.indexBy (this.currencies, 'numericId');
            }
            const marketsByNumericId = this.safeValue (this.options, 'marketsByNumericId');
            if ((marketsByNumericId === undefined) || reload) {
                this.options['marketsByNumericId'] = this.indexBy (this.markets, 'numericId');
            }
            return markets;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetProducts (params);
            //
            //     {
            //         "meta":{
            //             "after":null,
            //             "before":null,
            //             "limit":100,
            //             "total_count":81
            //         },
            //         "result":[
            //             {
            //                 "annualized_funding":"5.475000000000000000",
            //                 "is_quanto":false,
            //                 "ui_config":{
            //                     "default_trading_view_candle":"15",
            //                     "leverage_slider_values":[1,3,5,10,25,50],
            //                     "price_clubbing_values":[0.001,0.005,0.05,0.1,0.5,1,5],
            //                     "show_bracket_orders":false,
            //                     "sort_priority":29,
            //                     "tags":[]
            //                 },
            //                 "basis_factor_max_limit":"0.15",
            //                 "symbol":"P-LINK-D-151120",
            //                 "id":1584,
            //                 "default_leverage":"5.000000000000000000",
            //                 "maker_commission_rate":"0.0005",
            //                 "contract_unit_currency":"LINK",
            //                 "strike_price":"12.507948",
            //                 "settling_asset":{
            //                     // asset structure
            //                 },
            //                 "auction_start_time":null,
            //                 "auction_finish_time":null,
            //                 "settlement_time":"2020-11-15T12:00:00Z",
            //                 "launch_time":"2020-11-14T11:55:05Z",
            //                 "spot_index":{
            //                     // index structure
            //                 },
            //                 "trading_status":"operational",
            //                 "tick_size":"0.001",
            //                 "position_size_limit":100000,
            //                 "notional_type":"vanilla", // vanilla, inverse
            //                 "price_band":"0.4",
            //                 "barrier_price":null,
            //                 "description":"Daily LINK PUT options quoted in USDT and settled in USDT",
            //                 "insurance_fund_margin_contribution":"1",
            //                 "quoting_asset":{
            //                     // asset structure
            //                 },
            //                 "liquidation_penalty_factor":"0.2",
            //                 "product_specs":{"max_volatility":3,"min_volatility":0.3,"spot_price_band":"0.40"},
            //                 "initial_margin_scaling_factor":"0.0001",
            //                 "underlying_asset":{
            //                     // asset structure
            //                 },
            //                 "state":"live",
            //                 "contract_value":"1",
            //                 "initial_margin":"2",
            //                 "impact_size":5000,
            //                 "settlement_price":null,
            //                 "contract_type":"put_options", // put_options, call_options, move_options, perpetual_futures, interest_rate_swaps, futures, spreads
            //                 "taker_commission_rate":"0.0005",
            //                 "maintenance_margin":"1",
            //                 "short_description":"LINK Daily PUT Options",
            //                 "maintenance_margin_scaling_factor":"0.00005",
            //                 "funding_method":"mark_price",
            //                 "max_leverage_notional":"20000"
            //             },
            //         ],
            //         "success":true
            //     }
            //
            const markets = this.safeValue (response, 'result', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                let type = this.safeString (market, 'contract_type');
                // const settlingAsset = this.safeValue (market, 'settling_asset', {});
                const quotingAsset = this.safeValue (market, 'quoting_asset', {});
                const underlyingAsset = this.safeValue (market, 'underlying_asset', {});
                const baseId = this.safeString (underlyingAsset, 'symbol');
                const quoteId = this.safeString (quotingAsset, 'symbol');
                const id = this.safeString (market, 'symbol');
                const numericId = this.safeInteger (market, 'id');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                let symbol = id;
                let swap = false;
                let future = false;
                let option = false;
                if (type === 'perpetual_futures') {
                    type = 'swap';
                    swap = true;
                    future = false;
                    option = false;
                    if (id.indexOf ('_') < 0) {
                        symbol = base + '/' + quote;
                    }
                } else if ((type === 'call_options') || (type === 'put_options') || (type === 'move_options')) {
                    type = 'option';
                    swap = false;
                    option = true;
                    future = false;
                } else if (type === 'futures') {
                    type = 'future';
                    swap = false;
                    option = false;
                    future = true;
                }
                const precision = {
                    'amount': 1.0, // number of contracts
                    'price': this.safeNumber (market, 'tick_size'),
                };
                const limits = {
                    'amount': {
                        'min': 1.0,
                        'max': this.safeNumber (market, 'position_size_limit'),
                    },
                    'price': {
                        'min': precision['price'],
                        'max': undefined,
                    },
                    'cost': {
                        'min': this.safeNumber (market, 'min_size'),
                        'max': undefined,
                    },
                };
                const state = this.safeString (market, 'state');
                const active = (state === 'live');
                const maker = this.safeNumber (market, 'maker_commission_rate');
                const taker = this.safeNumber (market, 'taker_commission_rate');
                result.push ({
                    'id': id,
                    'numericId': numericId,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'type': type,
                    'option': option,
                    'swap': swap,
                    'future': future,
                    'maker': maker,
                    'taker': taker,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                    'active': active,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker, fetchTickers
            //
            //     {
            //         "close":15837.5,
            //         "high":16354,
            //         "low":15751.5,
            //         "mark_price":"15820.100867",
            //         "open":16140.5,
            //         "product_id":139,
            //         "size":640552,
            //         "spot_price":"15827.050000000001",
            //         "symbol":"BTCUSDT",
            //         "timestamp":1605373550208262,
            //         "turnover":10298630.3735,
            //         "turnover_symbol":"USDT",
            //         "turnover_usd":10298630.3735,
            //         "volume":640.5520000000001
            //     }
            //
            const timestamp = this.safeIntegerProduct (ticker, 'timestamp', 0.001);
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber (ticker, 'close');
            const open = this.safeNumber (ticker, 'open');
            const baseVolume = this.safeNumber (ticker, 'volume');
            const quoteVolume = this.safeNumber (ticker, 'turnover');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': vwap,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTickersSymbol (this.extend (request, params));
            //
            //     {
            //         "result":{
            //             "close":15837.5,
            //             "high":16354,
            //             "low":15751.5,
            //             "mark_price":"15820.100867",
            //             "open":16140.5,
            //             "product_id":139,
            //             "size":640552,
            //             "spot_price":"15827.050000000001",
            //             "symbol":"BTCUSDT",
            //             "timestamp":1605373550208262,
            //             "turnover":10298630.3735,
            //             "turnover_symbol":"USDT",
            //             "turnover_usd":10298630.3735,
            //             "volume":640.5520000000001
            //         },
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseTicker (result, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTickers (params);
            //
            //     {
            //         "result":[
            //             {
            //                 "close":0.003966,
            //                 "high":0.004032,
            //                 "low":0.003606,
            //                 "mark_price":"0.00396328",
            //                 "open":0.003996,
            //                 "product_id":1327,
            //                 "size":6242,
            //                 "spot_price":"0.0039555",
            //                 "symbol":"AAVEBTC",
            //                 "timestamp":1605374143864107,
            //                 "turnover":23.997904999999996,
            //                 "turnover_symbol":"BTC",
            //                 "turnover_usd":387957.4544782897,
            //                 "volume":6242
            //             },
            //         ],
            //         "success":true
            //     }
            //
            const tickers = this.safeValue (response, 'result', []);
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const ticker = this.parseTicker (tickers[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            if (limit !== undefined) {
                request['depth'] = limit;
            }
            const response = await this.publicGetL2orderbookSymbol (this.extend (request, params));
            //
            //     {
            //         "result":{
            //             "buy":[
            //                 {"price":"15814.0","size":912},
            //                 {"price":"15813.5","size":1279},
            //                 {"price":"15813.0","size":1634},
            //             ],
            //             "sell":[
            //                 {"price":"15814.5","size":625},
            //                 {"price":"15815.0","size":982},
            //                 {"price":"15815.5","size":1328},
            //             ],
            //             "symbol":"BTCUSDT"
            //         },
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseOrderBook (result, symbol, undefined, 'buy', 'sell', 'price', 'size');
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     {
            //         "buyer_role":"maker",
            //         "price":"15896.5",
            //         "seller_role":"taker",
            //         "size":241,
            //         "symbol":"BTCUSDT",
            //         "timestamp":1605376684714595
            //     }
            //
            // private fetchMyTrades
            //
            //     {
            //         "commission":"0.008335000000000000",
            //         "created_at":"2020-11-16T19:07:19Z",
            //         "fill_type":"normal",
            //         "id":"e7ff05c233a74245b72381f8dd91d1ce",
            //         "meta_data":{
            //             "effective_commission_rate":"0.0005",
            //             "order_price":"16249",
            //             "order_size":1,
            //             "order_type":"market_order",
            //             "order_unfilled_size":0,
            //             "trading_fee_credits_used":"0"
            //         },
            //         "order_id":"152999629",
            //         "price":"16669",
            //         "product":{
            //             "contract_type":"perpetual_futures",
            //             "contract_unit_currency":"BTC",
            //             "contract_value":"0.001",
            //             "id":139,
            //             "notional_type":"vanilla",
            //             "quoting_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
            //             "settling_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
            //             "symbol":"BTCUSDT",
            //             "tick_size":"0.5",
            //             "underlying_asset":{"minimum_precision":4,"precision":8,"symbol":"BTC"}
            //         },
            //         "product_id":139,
            //         "role":"taker",
            //         "side":"sell",
            //         "size":1
            //     }
            //
            const id = this.safeString (trade, 'id');
            const orderId = this.safeString (trade, 'order_id');
            let timestamp = this.parse8601 (this.safeString (trade, 'created_at'));
            timestamp = this.safeIntegerProduct (trade, 'timestamp', 0.001, timestamp);
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'size');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const product = this.safeValue (trade, 'product', {});
            const marketId = this.safeString (product, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const sellerRole = this.safeString (trade, 'seller_role');
            let side = this.safeString (trade, 'side');
            if (side === undefined) {
                if (sellerRole === 'taker') {
                    side = 'sell';
                } else if (sellerRole === 'maker') {
                    side = 'buy';
                }
            }
            const takerOrMaker = this.safeString (trade, 'role');
            const metaData = this.safeValue (trade, 'meta_data', {});
            let type = this.safeString (metaData, 'order_type');
            if (type !== undefined) {
                type = type.replace ('_order', '');
            }
            const feeCost = this.safeNumber (trade, 'commission');
            let fee = undefined;
            if (feeCost !== undefined) {
                const settlingAsset = this.safeValue (product, 'settling_asset', {});
                const feeCurrencyId = this.safeString (settlingAsset, 'symbol');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'id': id,
                'order': orderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'takerOrMaker': takerOrMaker,
                'fee': fee,
                'info': trade,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTradesSymbol (this.extend (request, params));
            //
            //     {
            //         "result":[
            //             {
            //                 "buyer_role":"maker",
            //                 "price":"15896.5",
            //                 "seller_role":"taker",
            //                 "size":241,
            //                 "symbol":"BTCUSDT",
            //                 "timestamp":1605376684714595
            //             }
            //         ],
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseTrades (result, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "time":1605393120,
            //         "open":15989,
            //         "high":15989,
            //         "low":15987.5,
            //         "close":15987.5,
            //         "volume":565
            //     }
            //
            return [
                this.safeTimestamp (ohlcv, 'time'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'resolution': this.timeframes[timeframe],
            };
            const duration = this.parseTimeframe (timeframe);
            limit = limit ? limit : 2000; // max 2000
            if (since === undefined) {
                const end = this.seconds ();
                request['end'] = end;
                request['start'] = end - limit * duration;
            } else {
                const start = parseInt (since / 1000);
                request['start'] = start;
                request['end'] = this.sum (start, limit * duration);
            }
            const response = await this.publicGetHistoryCandles (this.extend (request, params));
            //
            //     {
            //         "success":true,
            //         "result":[
            //             {"time":1605393120,"open":15989,"high":15989,"low":15987.5,"close":15987.5,"volume":565},
            //             {"time":1605393180,"open":15966,"high":15966,"low":15959,"close":15959,"volume":24},
            //             {"time":1605393300,"open":15973,"high":15973,"low":15973,"close":15973,"volume":1288},
            //         ]
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOHLCVs (result, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetWalletBalances (params);
            //
            //     {
            //         "result":[
            //             {
            //                 "asset_id":1,
            //                 "available_balance":"0",
            //                 "balance":"0",
            //                 "commission":"0",
            //                 "id":154883,
            //                 "interest_credit":"0",
            //                 "order_margin":"0",
            //                 "pending_referral_bonus":"0",
            //                 "pending_trading_fee_credit":"0",
            //                 "position_margin":"0",
            //                 "trading_fee_credit":"0",
            //                 "user_id":22142
            //             },
            //         ],
            //         "success":true
            //     }
            //
            const balances = this.safeValue (response, 'result', []);
            const result = { 'info': response };
            const currenciesByNumericId = this.safeValue (this.options, 'currenciesByNumericId', {});
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'asset_id');
                const currency = this.safeValue (currenciesByNumericId, currencyId);
                const code = (currency === undefined) ? currencyId : currency['code'];
                const account = this.account ();
                account['total'] = this.safeString (balance, 'balance');
                account['free'] = this.safeString (balance, 'available_balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchPosition (symbol, params = undefined) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_id': market['numericId'],
            };
            const response = await this.privateGetPositions (this.extend (request, params));
            //
            //     {
            //         "result":{
            //             "entry_price":null,
            //             "size":0,
            //             "timestamp":1605454074268079
            //         },
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return result;
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetPositionsMargined (params);
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "user_id": 0,
            //                 "size": 0,
            //                 "entry_price": "string",
            //                 "margin": "string",
            //                 "liquidation_price": "string",
            //                 "bankruptcy_price": "string",
            //                 "adl_level": 0,
            //                 "product_id": 0
            //             }
            //         ]
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return result;
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'open': 'open',
                'pending': 'open',
                'closed': 'closed',
                'cancelled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder, cancelOrder, editOrder, fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "average_fill_price":null,
            //         "bracket_order":null,
            //         "bracket_stop_loss_limit_price":null,
            //         "bracket_stop_loss_price":null,
            //         "bracket_take_profit_limit_price":null,
            //         "bracket_take_profit_price":null,
            //         "bracket_trail_amount":null,
            //         "cancellation_reason":null,
            //         "client_order_id":null,
            //         "close_on_trigger":"false",
            //         "commission":"0",
            //         "created_at":"2020-11-16T02:38:26Z",
            //         "id":152870626,
            //         "limit_price":"10000",
            //         "meta_data":{"source":"api"},
            //         "order_type":"limit_order",
            //         "paid_commission":"0",
            //         "product_id":139,
            //         "reduce_only":false,
            //         "side":"buy",
            //         "size":0,
            //         "state":"open",
            //         "stop_order_type":null,
            //         "stop_price":null,
            //         "stop_trigger_method":"mark_price",
            //         "time_in_force":"gtc",
            //         "trail_amount":null,
            //         "unfilled_size":0,
            //         "user_id":22142
            //     }
            //
            const id = this.safeString (order, 'id');
            const clientOrderId = this.safeString (order, 'client_order_id');
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const marketId = this.safeString (order, 'product_id');
            const marketsByNumericId = this.safeValue (this.options, 'marketsByNumericId', {});
            market = this.safeValue (marketsByNumericId, marketId, market);
            const symbol = (market === undefined) ? marketId : market['symbol'];
            const status = this.parseOrderStatus (this.safeString (order, 'state'));
            const side = this.safeString (order, 'side');
            let type = this.safeString (order, 'order_type');
            type = type.replace ('_order', '');
            const price = this.safeNumber (order, 'limit_price');
            const amount = this.safeNumber (order, 'size');
            const remaining = this.safeNumber (order, 'unfilled_size');
            const average = this.safeNumber (order, 'average_fill_price');
            let fee = undefined;
            const feeCost = this.safeNumber (order, 'paid_commission');
            if (feeCost !== undefined) {
                let feeCurrencyCode = undefined;
                if (market !== undefined) {
                    const settlingAsset = this.safeValue (market['info'], 'settling_asset', {});
                    const feeCurrencyId = this.safeString (settlingAsset, 'symbol');
                    feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': undefined,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const orderType = type + '_order';
            const market = this.market (symbol);
            const request = {
                'product_id': market['numericId'],
                // 'limit_price': this.priceToPrecision (symbol, price),
                'size': this.amountToPrecision (symbol, amount),
                'side': side,
                'order_type': orderType,
                // 'client_order_id': 'string',
                // 'time_in_force': 'gtc', // gtc, ioc, fok
                // 'post_only': 'false', // 'true',
                // 'reduce_only': 'false', // 'true',
            };
            if (type === 'limit') {
                request['limit_price'] = this.priceToPrecision (symbol, price);
            }
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client_order_id');
            params = this.omit (params, [ 'clientOrderId', 'client_order_id' ]);
            if (clientOrderId !== undefined) {
                request['client_order_id'] = clientOrderId;
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            //
            //     {
            //         "result":{
            //             "average_fill_price":null,
            //             "bracket_order":null,
            //             "bracket_stop_loss_limit_price":null,
            //             "bracket_stop_loss_price":null,
            //             "bracket_take_profit_limit_price":null,
            //             "bracket_take_profit_price":null,
            //             "bracket_trail_amount":null,
            //             "cancellation_reason":null,
            //             "client_order_id":null,
            //             "close_on_trigger":"false",
            //             "commission":"0",
            //             "created_at":"2020-11-16T02:38:26Z",
            //             "id":152870626,
            //             "limit_price":"10000",
            //             "meta_data":{"source":"api"},
            //             "order_type":"limit_order",
            //             "paid_commission":"0",
            //             "product_id":139,
            //             "reduce_only":false,
            //             "side":"buy",
            //             "size":0,
            //             "state":"open",
            //             "stop_order_type":null,
            //             "stop_price":null,
            //             "stop_trigger_method":"mark_price",
            //             "time_in_force":"gtc",
            //             "trail_amount":null,
            //             "unfilled_size":0,
            //             "user_id":22142
            //         },
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseOrder (result, market);
        }
    
        async editOrder (id, symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': parseInt (id),
                'product_id': market['numericId'],
                // 'limit_price': this.priceToPrecision (symbol, price),
                // 'size': this.amountToPrecision (symbol, amount),
            };
            if (amount !== undefined) {
                request['size'] = parseInt (this.amountToPrecision (symbol, amount));
            }
            if (price !== undefined) {
                request['limit_price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePutOrders (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "id": "ashb1212",
            //             "product_id": 27,
            //             "limit_price": "9200",
            //             "side": "buy",
            //             "size": 100,
            //             "unfilled_size": 50,
            //             "user_id": 1,
            //             "order_type": "limit_order",
            //             "state": "open",
            //             "created_at": "..."
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result');
            return this.parseOrder (result, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': parseInt (id),
                'product_id': market['numericId'],
            };
            const response = await this.privateDeleteOrders (this.extend (request, params));
            //
            //     {
            //         "result":{
            //             "average_fill_price":null,
            //             "bracket_order":null,
            //             "bracket_stop_loss_limit_price":null,
            //             "bracket_stop_loss_price":null,
            //             "bracket_take_profit_limit_price":null,
            //             "bracket_take_profit_price":null,
            //             "bracket_trail_amount":null,
            //             "cancellation_reason":"cancelled_by_user",
            //             "client_order_id":null,
            //             "close_on_trigger":"false",
            //             "commission":"0",
            //             "created_at":"2020-11-16T02:38:26Z",
            //             "id":152870626,
            //             "limit_price":"10000",
            //             "meta_data":{"source":"api"},
            //             "order_type":"limit_order",
            //             "paid_commission":"0",
            //             "product_id":139,
            //             "reduce_only":false,
            //             "side":"buy",
            //             "size":0,
            //             "state":"cancelled",
            //             "stop_order_type":null,
            //             "stop_price":null,
            //             "stop_trigger_method":"mark_price",
            //             "time_in_force":"gtc",
            //             "trail_amount":null,
            //             "unfilled_size":0,
            //             "user_id":22142
            //         },
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result');
            return this.parseOrder (result, market);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelAllOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_id': market['numericId'],
                // 'cancel_limit_orders': 'true',
                // 'cancel_stop_orders': 'true',
            };
            const response = this.privateDeleteOrdersAll (this.extend (request, params));
            //
            //     {
            //         "result":{},
            //         "success":true
            //     }
            //
            return response;
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersWithMethod ('privateGetOrders', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersWithMethod ('privateGetOrdersHistory', symbol, since, limit, params);
        }
    
        async fetchOrdersWithMethod (method, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'product_ids': market['id'], // comma-separated
                // 'contract_types': types, // comma-separated, futures, perpetual_futures, call_options, put_options, interest_rate_swaps, move_options, spreads
                // 'order_types': types, // comma-separated, market, limit, stop_market, stop_limit, all_stop
                // 'start_time': since * 1000,
                // 'end_time': this.microseconds (),
                // 'after': string, // after cursor for pagination
                // 'before': string, // before cursor for pagination
                // 'page_size': limit, // number of records per page
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['product_ids'] = market['numericId']; // accepts a comma-separated list of ids
            }
            if (since !== undefined) {
                request['start_time'] = since.toString () + '000';
            }
            if (limit !== undefined) {
                request['page_size'] = limit;
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "id": "ashb1212",
            //                 "product_id": 27,
            //                 "limit_price": "9200",
            //                 "side": "buy",
            //                 "size": 100,
            //                 "unfilled_size": 50,
            //                 "user_id": 1,
            //                 "order_type": "limit_order",
            //                 "state": "open",
            //                 "created_at": "..."
            //             }
            //         ],
            //         "meta": {
            //             "after": "string",
            //             "before": "string"
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOrders (result, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'product_ids': market['id'], // comma-separated
                // 'contract_types': types, // comma-separated, futures, perpetual_futures, call_options, put_options, interest_rate_swaps, move_options, spreads
                // 'start_time': since * 1000,
                // 'end_time': this.microseconds (),
                // 'after': string, // after cursor for pagination
                // 'before': string, // before cursor for pagination
                // 'page_size': limit, // number of records per page
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['product_ids'] = market['numericId']; // accepts a comma-separated list of ids
            }
            if (since !== undefined) {
                request['start_time'] = since.toString () + '000';
            }
            if (limit !== undefined) {
                request['page_size'] = limit;
            }
            const response = await this.privateGetFills (this.extend (request, params));
            //
            //     {
            //         "meta":{
            //             "after":null,
            //             "before":null,
            //             "limit":10,
            //             "total_count":2
            //         },
            //         "result":[
            //             {
            //                 "commission":"0.008335000000000000",
            //                 "created_at":"2020-11-16T19:07:19Z",
            //                 "fill_type":"normal",
            //                 "id":"e7ff05c233a74245b72381f8dd91d1ce",
            //                 "meta_data":{
            //                     "effective_commission_rate":"0.0005",
            //                     "order_price":"16249",
            //                     "order_size":1,
            //                     "order_type":"market_order",
            //                     "order_unfilled_size":0,
            //                     "trading_fee_credits_used":"0"
            //                 },
            //                 "order_id":"152999629",
            //                 "price":"16669",
            //                 "product":{
            //                     "contract_type":"perpetual_futures",
            //                     "contract_unit_currency":"BTC",
            //                     "contract_value":"0.001",
            //                     "id":139,
            //                     "notional_type":"vanilla",
            //                     "quoting_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
            //                     "settling_asset":{"minimum_precision":2,"precision":6,"symbol":"USDT"},
            //                     "symbol":"BTCUSDT",
            //                     "tick_size":"0.5",
            //                     "underlying_asset":{"minimum_precision":4,"precision":8,"symbol":"BTC"}
            //                 },
            //                 "product_id":139,
            //                 "role":"taker",
            //                 "side":"sell",
            //                 "size":1
            //             }
            //         ],
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseTrades (result, market, since, limit);
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'asset_id': currency['numericId'],
                // 'end_time': this.seconds (),
                // 'after': 'string', // after cursor for pagination
                // 'before': 'string', // before cursor for pagination
                // 'page_size': limit,
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['asset_id'] = currency['numericId'];
            }
            if (limit !== undefined) {
                request['page_size'] = limit;
            }
            const response = await this.privateGetWalletTransactions (this.extend (request, params));
            //
            //     {
            //         "meta":{"after":null,"before":null,"limit":10,"total_count":1},
            //         "result":[
            //             {
            //                 "amount":"29.889184",
            //                 "asset_id":5,
            //                 "balance":"29.889184",
            //                 "created_at":"2020-11-15T21:25:01Z",
            //                 "meta_data":{
            //                     "deposit_id":3884,
            //                     "transaction_id":"0x41a60174849828530abb5008e98fc63c9b598288743ec4ba9620bcce900a3b8d"
            //                 },
            //                 "transaction_type":"deposit",
            //                 "user_id":22142,
            //                 "uuid":"70bb5679da3c4637884e2dc63efaa846"
            //             }
            //         ],
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseLedger (result, currency, since, limit);
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'pnl': 'pnl',
                'deposit': 'transaction',
                'withdrawal': 'transaction',
                'commission': 'fee',
                'conversion': 'trade',
                // 'perpetual_futures_funding': 'perpetual_futures_funding',
                // 'withdrawal_cancellation': 'withdrawal_cancellation',
                'referral_bonus': 'referral',
                'commission_rebate': 'rebate',
                // 'promo_credit': 'promo_credit',
            };
            return this.safeString (types, type, type);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //     {
            //         "amount":"29.889184",
            //         "asset_id":5,
            //         "balance":"29.889184",
            //         "created_at":"2020-11-15T21:25:01Z",
            //         "meta_data":{
            //             "deposit_id":3884,
            //             "transaction_id":"0x41a60174849828530abb5008e98fc63c9b598288743ec4ba9620bcce900a3b8d"
            //         },
            //         "transaction_type":"deposit",
            //         "user_id":22142,
            //         "uuid":"70bb5679da3c4637884e2dc63efaa846"
            //     }
            //
            const id = this.safeString (item, 'uuid');
            let direction = undefined;
            const account = undefined;
            const metaData = this.safeValue (item, 'meta_data', {});
            const referenceId = this.safeString (metaData, 'transaction_id');
            const referenceAccount = undefined;
            let type = this.safeString (item, 'transaction_type');
            if ((type === 'deposit') || (type === 'commission_rebate') || (type === 'referral_bonus') || (type === 'pnl') || (type === 'withdrawal_cancellation') || (type === 'promo_credit')) {
                direction = 'in';
            } else if ((type === 'withdrawal') || (type === 'commission') || (type === 'conversion') || (type === 'perpetual_futures_funding')) {
                direction = 'out';
            }
            type = this.parseLedgerEntryType (type);
            const currencyId = this.safeInteger (item, 'asset_id');
            const currenciesByNumericId = this.safeValue (this.options, 'currenciesByNumericId');
            currency = this.safeValue (currenciesByNumericId, currencyId, currency);
            const code = (currency === undefined) ? undefined : currency['code'];
            const amount = this.safeNumber (item, 'amount');
            const timestamp = this.parse8601 (this.safeString (item, 'created_at'));
            const after = this.safeNumber (item, 'balance');
            const before = Math.max (0, after - amount);
            const status = 'ok';
            return {
                'info': item,
                'id': id,
                'direction': direction,
                'account': account,
                'referenceId': referenceId,
                'referenceAccount': referenceAccount,
                'type': type,
                'currency': code,
                'amount': amount,
                'before': before,
                'after': after,
                'status': status,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': undefined,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset_symbol': currency['id'],
            };
            const response = await this.privateGetDepositsAddress (this.extend (request, params));
            //
            //     {
            //         "success":true,
            //         "result":{
            //             "id":19628,
            //             "user_id":22142,
            //             "address":"0x0eda26523397534f814d553a065d8e46b4188e9a",
            //             "status":"active",
            //             "updated_at":"2020-11-15T20:25:53.000Z",
            //             "created_at":"2020-11-15T20:25:53.000Z",
            //             "asset_symbol":"USDT",
            //             "custodian":"onc"
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const address = this.safeString (result, 'address');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': response,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const requestPath = '/' + this.version + '/' + this.implodeParams (path, params);
            let url = this.urls['api'][api] + requestPath;
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else if (api === 'private') {
                this.checkRequiredCredentials ();
                const timestamp = this.seconds ().toString ();
                headers = {
                    'api-key': this.apiKey,
                    'timestamp': timestamp,
                };
                let auth = method + timestamp + requestPath;
                if ((method === 'GET') || (method === 'DELETE')) {
                    if (Object.keys (query).length) {
                        const queryString = '?' + this.urlencode (query);
                        auth += queryString;
                        url += queryString;
                    }
                } else {
                    body = this.json (query);
                    auth += body;
                    headers['Content-Type'] = 'application/json';
                }
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                headers['signature'] = signature;
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            //
            // {"error":{"code":"insufficient_margin","context":{"available_balance":"0.000000000000000000","required_additional_balance":"1.618626000000000000000000000"}},"success":false}
            //
            const error = this.safeValue (response, 'error', {});
            const errorCode = this.safeString (error, 'code');
            if (errorCode !== undefined) {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], errorCode, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],74:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { TICK_SIZE } = require ('./base/functions/number');
    const { AuthenticationError, ExchangeError, ArgumentsRequired, PermissionDenied, InvalidOrder, OrderNotFound, DDoSProtection, NotSupported, ExchangeNotAvailable, InsufficientFunds, BadRequest, InvalidAddress, OnMaintenance } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class deribit extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'deribit',
                'name': 'Deribit',
                'countries': [ 'NL' ], // Netherlands
                'version': 'v2',
                'userAgent': undefined,
                'rateLimit': 500,
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'CORS': true,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': false,
                    'fetchOrderTrades': true,
                    'fetchStatus': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTransactions': false,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1',
                    '3m': '3',
                    '5m': '5',
                    '10m': '10',
                    '15m': '15',
                    '30m': '30',
                    '1h': '60',
                    '2h': '120',
                    '3h': '180',
                    '6h': '360',
                    '12h': '720',
                    '1d': '1D',
                },
                'urls': {
                    'test': 'https://test.deribit.com',
                    'logo': 'https://user-images.githubusercontent.com/1294454/41933112-9e2dd65a-798b-11e8-8440-5bab2959fcb8.jpg',
                    'api': 'https://www.deribit.com',
                    'www': 'https://www.deribit.com',
                    'doc': [
                        'https://docs.deribit.com/v2',
                        'https://github.com/deribit',
                    ],
                    'fees': 'https://www.deribit.com/pages/information/fees',
                    'referral': {
                        'url': 'https://www.deribit.com/reg-1189.4038',
                        'discount': 0.1,
                    },
                },
                'api': {
                    'public': {
                        'get': [
                            // Authentication
                            'auth',
                            'exchange_token',
                            'fork_token',
                            // Session management
                            'set_heartbeat',
                            'disable_heartbeat',
                            // Supporting
                            'get_time',
                            'hello',
                            'test',
                            // Subscription management
                            'subscribe',
                            'unsubscribe',
                            // Account management
                            'get_announcements',
                            // Market data
                            'get_book_summary_by_currency',
                            'get_book_summary_by_instrument',
                            'get_contract_size',
                            'get_currencies',
                            'get_funding_chart_data',
                            'get_funding_rate_history',
                            'get_funding_rate_value',
                            'get_historical_volatility',
                            'get_index',
                            'get_index_price',
                            'get_index_price_names',
                            'get_instruments',
                            'get_last_settlements_by_currency',
                            'get_last_settlements_by_instrument',
                            'get_last_trades_by_currency',
                            'get_last_trades_by_currency_and_time',
                            'get_last_trades_by_instrument',
                            'get_last_trades_by_instrument_and_time',
                            'get_order_book',
                            'get_trade_volumes',
                            'get_tradingview_chart_data',
                            'ticker',
                        ],
                    },
                    'private': {
                        'get': [
                            // Authentication
                            'logout',
                            // Session management
                            'enable_cancel_on_disconnect',
                            'disable_cancel_on_disconnect',
                            'get_cancel_on_disconnect',
                            // Subscription management
                            'subscribe',
                            'unsubscribe',
                            // Account management
                            'change_api_key_name',
                            'change_scope_in_api_key',
                            'change_subaccount_name',
                            'create_api_key',
                            'create_subaccount',
                            'disable_api_key',
                            'disable_tfa_for_subaccount',
                            'enable_api_key',
                            'get_account_summary',
                            'get_email_language',
                            'get_new_announcements',
                            'get_position',
                            'get_positions',
                            'get_subaccounts',
                            'list_api_keys',
                            'remove_api_key',
                            'reset_api_key',
                            'set_announcement_as_read',
                            'set_api_key_as_default',
                            'set_email_for_subaccount',
                            'set_email_language',
                            'set_password_for_subaccount',
                            'toggle_notifications_from_subaccount',
                            'toggle_subaccount_login',
                            // Block Trade
                            'execute_block_trade',
                            'get_block_trade',
                            'get_last_block_trades_by_currency',
                            'invalidate_block_trade_signature',
                            'verify_block_trade',
                            // Trading
                            'buy',
                            'sell',
                            'edit',
                            'cancel',
                            'cancel_all',
                            'cancel_all_by_currency',
                            'cancel_all_by_instrument',
                            'cancel_by_label',
                            'close_position',
                            'get_margins',
                            'get_open_orders_by_currency',
                            'get_open_orders_by_instrument',
                            'get_order_history_by_currency',
                            'get_order_history_by_instrument',
                            'get_order_margin_by_ids',
                            'get_order_state',
                            'get_stop_order_history',
                            'get_user_trades_by_currency',
                            'get_user_trades_by_currency_and_time',
                            'get_user_trades_by_instrument',
                            'get_user_trades_by_instrument_and_time',
                            'get_user_trades_by_order',
                            'get_settlement_history_by_instrument',
                            'get_settlement_history_by_currency',
                            // Wallet
                            'cancel_transfer_by_id',
                            'cancel_withdrawal',
                            'create_deposit_address',
                            'get_current_deposit_address',
                            'get_deposits',
                            'get_transfers',
                            'get_withdrawals',
                            'submit_transfer_to_subaccount',
                            'submit_transfer_to_user',
                            'withdraw',
                        ],
                    },
                },
                'exceptions': {
                    // 0 or absent Success, No error.
                    '9999': PermissionDenied, // 'api_not_enabled' User didn't enable API for the Account.
                    '10000': AuthenticationError, // 'authorization_required' Authorization issue, invalid or absent signature etc.
                    '10001': ExchangeError, // 'error' Some general failure, no public information available.
                    '10002': InvalidOrder, // 'qty_too_low' Order quantity is too low.
                    '10003': InvalidOrder, // 'order_overlap' Rejection, order overlap is found and self-trading is not enabled.
                    '10004': OrderNotFound, // 'order_not_found' Attempt to operate with order that can't be found by specified id.
                    '10005': InvalidOrder, // 'price_too_low <Limit>' Price is too low, <Limit> defines current limit for the operation.
                    '10006': InvalidOrder, // 'price_too_low4idx <Limit>' Price is too low for current index, <Limit> defines current bottom limit for the operation.
                    '10007': InvalidOrder, // 'price_too_high <Limit>' Price is too high, <Limit> defines current up limit for the operation.
                    '10008': InvalidOrder, // 'price_too_high4idx <Limit>' Price is too high for current index, <Limit> defines current up limit for the operation.
                    '10009': InsufficientFunds, // 'not_enough_funds' Account has not enough funds for the operation.
                    '10010': OrderNotFound, // 'already_closed' Attempt of doing something with closed order.
                    '10011': InvalidOrder, // 'price_not_allowed' This price is not allowed for some reason.
                    '10012': InvalidOrder, // 'book_closed' Operation for instrument which order book had been closed.
                    '10013': PermissionDenied, // 'pme_max_total_open_orders <Limit>' Total limit of open orders has been exceeded, it is applicable for PME users.
                    '10014': PermissionDenied, // 'pme_max_future_open_orders <Limit>' Limit of count of futures' open orders has been exceeded, it is applicable for PME users.
                    '10015': PermissionDenied, // 'pme_max_option_open_orders <Limit>' Limit of count of options' open orders has been exceeded, it is applicable for PME users.
                    '10016': PermissionDenied, // 'pme_max_future_open_orders_size <Limit>' Limit of size for futures has been exceeded, it is applicable for PME users.
                    '10017': PermissionDenied, // 'pme_max_option_open_orders_size <Limit>' Limit of size for options has been exceeded, it is applicable for PME users.
                    '10018': PermissionDenied, // 'non_pme_max_future_position_size <Limit>' Limit of size for futures has been exceeded, it is applicable for non-PME users.
                    '10019': PermissionDenied, // 'locked_by_admin' Trading is temporary locked by admin.
                    '10020': ExchangeError, // 'invalid_or_unsupported_instrument' Instrument name is not valid.
                    '10021': InvalidOrder, // 'invalid_amount' Amount is not valid.
                    '10022': InvalidOrder, // 'invalid_quantity' quantity was not recognized as a valid number (for API v1).
                    '10023': InvalidOrder, // 'invalid_price' price was not recognized as a valid number.
                    '10024': InvalidOrder, // 'invalid_max_show' max_show parameter was not recognized as a valid number.
                    '10025': InvalidOrder, // 'invalid_order_id' Order id is missing or its format was not recognized as valid.
                    '10026': InvalidOrder, // 'price_precision_exceeded' Extra precision of the price is not supported.
                    '10027': InvalidOrder, // 'non_integer_contract_amount' Futures contract amount was not recognized as integer.
                    '10028': DDoSProtection, // 'too_many_requests' Allowed request rate has been exceeded.
                    '10029': OrderNotFound, // 'not_owner_of_order' Attempt to operate with not own order.
                    '10030': ExchangeError, // 'must_be_websocket_request' REST request where Websocket is expected.
                    '10031': ExchangeError, // 'invalid_args_for_instrument' Some of arguments are not recognized as valid.
                    '10032': InvalidOrder, // 'whole_cost_too_low' Total cost is too low.
                    '10033': NotSupported, // 'not_implemented' Method is not implemented yet.
                    '10034': InvalidOrder, // 'stop_price_too_high' Stop price is too high.
                    '10035': InvalidOrder, // 'stop_price_too_low' Stop price is too low.
                    '10036': InvalidOrder, // 'invalid_max_show_amount' Max Show Amount is not valid.
                    '10040': ExchangeNotAvailable, // 'retry' Request can't be processed right now and should be retried.
                    '10041': OnMaintenance, // 'settlement_in_progress' Settlement is in progress. Every day at settlement time for several seconds, the system calculates user profits and updates balances. That time trading is paused for several seconds till the calculation is completed.
                    '10043': InvalidOrder, // 'price_wrong_tick' Price has to be rounded to a certain tick size.
                    '10044': InvalidOrder, // 'stop_price_wrong_tick' Stop Price has to be rounded to a certain tick size.
                    '10045': InvalidOrder, // 'can_not_cancel_liquidation_order' Liquidation order can't be canceled.
                    '10046': InvalidOrder, // 'can_not_edit_liquidation_order' Liquidation order can't be edited.
                    '10047': DDoSProtection, // 'matching_engine_queue_full' Reached limit of pending Matching Engine requests for user.
                    '10048': ExchangeError, // 'not_on_this_server' The requested operation is not available on this server.
                    '11008': InvalidOrder, // 'already_filled' This request is not allowed in regards to the filled order.
                    '11029': BadRequest, // 'invalid_arguments' Some invalid input has been detected.
                    '11030': ExchangeError, // 'other_reject <Reason>' Some rejects which are not considered as very often, more info may be specified in <Reason>.
                    '11031': ExchangeError, // 'other_error <Error>' Some errors which are not considered as very often, more info may be specified in <Error>.
                    '11035': DDoSProtection, // 'no_more_stops <Limit>' Allowed amount of stop orders has been exceeded.
                    '11036': InvalidOrder, // 'invalid_stoppx_for_index_or_last' Invalid StopPx (too high or too low) as to current index or market.
                    '11037': BadRequest, // 'outdated_instrument_for_IV_order' Instrument already not available for trading.
                    '11038': InvalidOrder, // 'no_adv_for_futures' Advanced orders are not available for futures.
                    '11039': InvalidOrder, // 'no_adv_postonly' Advanced post-only orders are not supported yet.
                    '11041': InvalidOrder, // 'not_adv_order' Advanced order properties can't be set if the order is not advanced.
                    '11042': PermissionDenied, // 'permission_denied' Permission for the operation has been denied.
                    '11043': BadRequest, // 'bad_argument' Bad argument has been passed.
                    '11044': InvalidOrder, // 'not_open_order' Attempt to do open order operations with the not open order.
                    '11045': BadRequest, // 'invalid_event' Event name has not been recognized.
                    '11046': BadRequest, // 'outdated_instrument' At several minutes to instrument expiration, corresponding advanced implied volatility orders are not allowed.
                    '11047': BadRequest, // 'unsupported_arg_combination' The specified combination of arguments is not supported.
                    '11048': ExchangeError, // 'wrong_max_show_for_option' Wrong Max Show for options.
                    '11049': BadRequest, // 'bad_arguments' Several bad arguments have been passed.
                    '11050': BadRequest, // 'bad_request' Request has not been parsed properly.
                    '11051': OnMaintenance, // 'system_maintenance' System is under maintenance.
                    '11052': ExchangeError, // 'subscribe_error_unsubscribed' Subscription error. However, subscription may fail without this error, please check list of subscribed channels returned, as some channels can be not subscribed due to wrong input or lack of permissions.
                    '11053': ExchangeError, // 'transfer_not_found' Specified transfer is not found.
                    '11090': InvalidAddress, // 'invalid_addr' Invalid address.
                    '11091': InvalidAddress, // 'invalid_transfer_address' Invalid addres for the transfer.
                    '11092': InvalidAddress, // 'address_already_exist' The address already exists.
                    '11093': DDoSProtection, // 'max_addr_count_exceeded' Limit of allowed addresses has been reached.
                    '11094': ExchangeError, // 'internal_server_error' Some unhandled error on server. Please report to admin. The details of the request will help to locate the problem.
                    '11095': ExchangeError, // 'disabled_deposit_address_creation' Deposit address creation has been disabled by admin.
                    '11096': ExchangeError, // 'address_belongs_to_user' Withdrawal instead of transfer.
                    '12000': AuthenticationError, // 'bad_tfa' Wrong TFA code
                    '12001': DDoSProtection, // 'too_many_subaccounts' Limit of subbacounts is reached.
                    '12002': ExchangeError, // 'wrong_subaccount_name' The input is not allowed as name of subaccount.
                    '12998': AuthenticationError, // 'tfa_over_limit' The number of failed TFA attempts is limited.
                    '12003': AuthenticationError, // 'login_over_limit' The number of failed login attempts is limited.
                    '12004': AuthenticationError, // 'registration_over_limit' The number of registration requests is limited.
                    '12005': AuthenticationError, // 'country_is_banned' The country is banned (possibly via IP check).
                    '12100': ExchangeError, // 'transfer_not_allowed' Transfer is not allowed. Possible wrong direction or other mistake.
                    '12999': AuthenticationError, // 'tfa_used' TFA code is correct but it is already used. Please, use next code.
                    '13000': AuthenticationError, // 'invalid_login' Login name is invalid (not allowed or it contains wrong characters).
                    '13001': AuthenticationError, // 'account_not_activated' Account must be activated.
                    '13002': PermissionDenied, // 'account_blocked' Account is blocked by admin.
                    '13003': AuthenticationError, // 'tfa_required' This action requires TFA authentication.
                    '13004': AuthenticationError, // 'invalid_credentials' Invalid credentials has been used.
                    '13005': AuthenticationError, // 'pwd_match_error' Password confirmation error.
                    '13006': AuthenticationError, // 'security_error' Invalid Security Code.
                    '13007': AuthenticationError, // 'user_not_found' User's security code has been changed or wrong.
                    '13008': ExchangeError, // 'request_failed' Request failed because of invalid input or internal failure.
                    '13009': AuthenticationError, // 'unauthorized' Wrong or expired authorization token or bad signature. For example, please check scope of the token, 'connection' scope can't be reused for other connections.
                    '13010': BadRequest, // 'value_required' Invalid input, missing value.
                    '13011': BadRequest, // 'value_too_short' Input is too short.
                    '13012': PermissionDenied, // 'unavailable_in_subaccount' Subaccount restrictions.
                    '13013': BadRequest, // 'invalid_phone_number' Unsupported or invalid phone number.
                    '13014': BadRequest, // 'cannot_send_sms' SMS sending failed -- phone number is wrong.
                    '13015': BadRequest, // 'invalid_sms_code' Invalid SMS code.
                    '13016': BadRequest, // 'invalid_input' Invalid input.
                    '13017': ExchangeError, // 'subscription_failed' Subscription hailed, invalid subscription parameters.
                    '13018': ExchangeError, // 'invalid_content_type' Invalid content type of the request.
                    '13019': ExchangeError, // 'orderbook_closed' Closed, expired order book.
                    '13020': ExchangeError, // 'not_found' Instrument is not found, invalid instrument name.
                    '13021': PermissionDenied, // 'forbidden' Not enough permissions to execute the request, forbidden.
                    '13025': ExchangeError, // 'method_switched_off_by_admin' API method temporarily switched off by administrator.
                    '-32602': BadRequest, // 'Invalid params' see JSON-RPC spec.
                    '-32601': BadRequest, // 'Method not found' see JSON-RPC spec.
                    '-32700': BadRequest, // 'Parse error' see JSON-RPC spec.
                    '-32000': BadRequest, // 'Missing params' see JSON-RPC spec.
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    'code': 'BTC',
                    'fetchBalance': {
                        'code': 'BTC',
                    },
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetGetTime (params);
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: 1583922446019,
            //         usIn: 1583922446019955,
            //         usOut: 1583922446019956,
            //         usDiff: 1,
            //         testnet: false
            //     }
            //
            return this.safeInteger (response, 'result');
        }
    
        codeFromOptions (methodName, params = {}) {
            const defaultCode = this.safeValue (this.options, 'code', 'BTC');
            const options = this.safeValue (this.options, methodName, {});
            const code = this.safeValue (options, 'code', defaultCode);
            return this.safeValue (params, 'code', code);
        }
    
        async fetchStatus (params = {}) {
            const request = {
                // 'expected_result': false, // true will trigger an error for testing purposes
            };
            await this.publicGetTest (this.extend (request, params));
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: { version: '1.2.26' },
            //         usIn: 1583922623964485,
            //         usOut: 1583922623964487,
            //         usDiff: 2,
            //         testnet: false
            //     }
            //
            this.status = this.extend (this.status, {
                'status': 'ok',
                'updated': this.milliseconds (),
            });
            return this.status;
        }
    
        async fetchMarkets (params = {}) {
            const currenciesResponse = await this.publicGetGetCurrencies (params);
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: [
            //             {
            //                 withdrawal_priorities: [
            //                     { value: 0.15, name: 'very_low' },
            //                     { value: 1.5, name: 'very_high' },
            //                 ],
            //                 withdrawal_fee: 0.0005,
            //                 min_withdrawal_fee: 0.0005,
            //                 min_confirmations: 1,
            //                 fee_precision: 4,
            //                 currency_long: 'Bitcoin',
            //                 currency: 'BTC',
            //                 coin_type: 'BITCOIN'
            //             }
            //         ],
            //         usIn: 1583761588590479,
            //         usOut: 1583761588590544,
            //         usDiff: 65,
            //         testnet: false
            //     }
            //
            const currenciesResult = this.safeValue (currenciesResponse, 'result', []);
            const result = [];
            for (let i = 0; i < currenciesResult.length; i++) {
                const currencyId = this.safeString (currenciesResult[i], 'currency');
                const request = {
                    'currency': currencyId,
                };
                const instrumentsResponse = await this.publicGetGetInstruments (this.extend (request, params));
                //
                //     {
                //         jsonrpc: '2.0',
                //         result: [
                //             {
                //                 tick_size: 0.0005,
                //                 taker_commission: 0.0004,
                //                 strike: 300,
                //                 settlement_period: 'week',
                //                 quote_currency: 'USD',
                //                 option_type: 'call',
                //                 min_trade_amount: 1,
                //                 maker_commission: 0.0004,
                //                 kind: 'option',
                //                 is_active: true,
                //                 instrument_name: 'ETH-13MAR20-300-C',
                //                 expiration_timestamp: 1584086400000,
                //                 creation_timestamp: 1582790403000,
                //                 contract_size: 1,
                //                 base_currency: 'ETH'
                //             },
                //         ],
                //         usIn: 1583761889500586,
                //         usOut: 1583761889505066,
                //         usDiff: 4480,
                //         testnet: false
                //     }
                //
                const instrumentsResult = this.safeValue (instrumentsResponse, 'result', []);
                for (let k = 0; k < instrumentsResult.length; k++) {
                    const market = instrumentsResult[k];
                    const id = this.safeString (market, 'instrument_name');
                    const baseId = this.safeString (market, 'base_currency');
                    const quoteId = this.safeString (market, 'quote_currency');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    const type = this.safeString (market, 'kind');
                    const future = (type === 'future');
                    const option = (type === 'option');
                    const active = this.safeValue (market, 'is_active');
                    const minTradeAmount = this.safeNumber (market, 'min_trade_amount');
                    const tickSize = this.safeNumber (market, 'tick_size');
                    const precision = {
                        'amount': minTradeAmount,
                        'price': tickSize,
                    };
                    result.push ({
                        'id': id,
                        'symbol': id,
                        'base': base,
                        'quote': quote,
                        'active': active,
                        'precision': precision,
                        'taker': this.safeNumber (market, 'taker_commission'),
                        'maker': this.safeNumber (market, 'maker_commission'),
                        'limits': {
                            'amount': {
                                'min': minTradeAmount,
                                'max': undefined,
                            },
                            'price': {
                                'min': tickSize,
                                'max': undefined,
                            },
                            'cost': {
                                'min': undefined,
                                'max': undefined,
                            },
                        },
                        'type': type,
                        'spot': false,
                        'future': future,
                        'option': option,
                        'info': market,
                    });
                }
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const code = this.codeFromOptions ('fetchBalance', params);
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetGetAccountSummary (this.extend (request, params));
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: {
            //             total_pl: 0,
            //             session_upl: 0,
            //             session_rpl: 0,
            //             session_funding: 0,
            //             portfolio_margining_enabled: false,
            //             options_vega: 0,
            //             options_theta: 0,
            //             options_session_upl: 0,
            //             options_session_rpl: 0,
            //             options_pl: 0,
            //             options_gamma: 0,
            //             options_delta: 0,
            //             margin_balance: 0.00062359,
            //             maintenance_margin: 0,
            //             limits: {
            //                 non_matching_engine_burst: 300,
            //                 non_matching_engine: 200,
            //                 matching_engine_burst: 20,
            //                 matching_engine: 2
            //             },
            //             initial_margin: 0,
            //             futures_session_upl: 0,
            //             futures_session_rpl: 0,
            //             futures_pl: 0,
            //             equity: 0.00062359,
            //             deposit_address: '13tUtNsJSZa1F5GeCmwBywVrymHpZispzw',
            //             delta_total: 0,
            //             currency: 'BTC',
            //             balance: 0.00062359,
            //             available_withdrawal_funds: 0.00062359,
            //             available_funds: 0.00062359
            //         },
            //         usIn: 1583775838115975,
            //         usOut: 1583775838116520,
            //         usDiff: 545,
            //         testnet: false
            //     }
            //
            const result = {
                'info': response,
            };
            const balance = this.safeValue (response, 'result', {});
            const currencyId = this.safeString (balance, 'currency');
            const currencyCode = this.safeCurrencyCode (currencyId);
            const account = this.account ();
            account['free'] = this.safeString (balance, 'availableFunds');
            account['used'] = this.safeString (balance, 'maintenanceMargin');
            account['total'] = this.safeString (balance, 'equity');
            result[currencyCode] = account;
            return this.parseBalance (result);
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetCreateDepositAddress (this.extend (request, params));
            //
            //     {
            //         'jsonrpc': '2.0',
            //         'id': 7538,
            //         'result': {
            //             'address': '2N8udZGBc1hLRCFsU9kGwMPpmYUwMFTuCwB',
            //             'creation_timestamp': 1550575165170,
            //             'currency': 'BTC',
            //             'type': 'deposit'
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const address = this.safeString (result, 'address');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': response,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetGetCurrentDepositAddress (this.extend (request, params));
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: {
            //             type: 'deposit',
            //             status: 'ready',
            //             requires_confirmation: true,
            //             currency: 'BTC',
            //             creation_timestamp: 1514694684651,
            //             address: '13tUtNsJSZa1F5GeCmwBywVrymHpZispzw'
            //         },
            //         usIn: 1583785137274288,
            //         usOut: 1583785137274454,
            //         usDiff: 166,
            //         testnet: false
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const address = this.safeString (result, 'address');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': response,
            };
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker /public/ticker
            //
            //     {
            //         timestamp: 1583778859480,
            //         stats: { volume: 60627.57263769, low: 7631.5, high: 8311.5 },
            //         state: 'open',
            //         settlement_price: 7903.21,
            //         open_interest: 111543850,
            //         min_price: 7634,
            //         max_price: 7866.51,
            //         mark_price: 7750.02,
            //         last_price: 7750.5,
            //         instrument_name: 'BTC-PERPETUAL',
            //         index_price: 7748.01,
            //         funding_8h: 0.0000026,
            //         current_funding: 0,
            //         best_bid_price: 7750,
            //         best_bid_amount: 19470,
            //         best_ask_price: 7750.5,
            //         best_ask_amount: 343280
            //     }
            //
            // fetchTicker /public/get_book_summary_by_instrument
            // fetchTickers /public/get_book_summary_by_currency
            //
            //     {
            //         volume: 124.1,
            //         underlying_price: 7856.445926872601,
            //         underlying_index: 'SYN.BTC-10MAR20',
            //         quote_currency: 'USD',
            //         open_interest: 121.8,
            //         mid_price: 0.01975,
            //         mark_price: 0.01984559,
            //         low: 0.0095,
            //         last: 0.0205,
            //         interest_rate: 0,
            //         instrument_name: 'BTC-10MAR20-7750-C',
            //         high: 0.0295,
            //         estimated_delivery_price: 7856.29,
            //         creation_timestamp: 1583783678366,
            //         bid_price: 0.0185,
            //         base_currency: 'BTC',
            //         ask_price: 0.021
            //     },
            //
            const timestamp = this.safeInteger2 (ticker, 'timestamp', 'creation_timestamp');
            const marketId = this.safeString (ticker, 'instrument_name');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber2 (ticker, 'last_price', 'last');
            const stats = this.safeValue (ticker, 'stats', ticker);
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber2 (stats, 'high', 'max_price'),
                'low': this.safeNumber2 (stats, 'low', 'min_price'),
                'bid': this.safeNumber2 (ticker, 'best_bid_price', 'bid_price'),
                'bidVolume': this.safeNumber (ticker, 'best_bid_amount'),
                'ask': this.safeNumber2 (ticker, 'best_ask_price', 'ask_price'),
                'askVolume': this.safeNumber (ticker, 'best_ask_amount'),
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': this.safeNumber (stats, 'volume'),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_name': market['id'],
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: {
            //             timestamp: 1583778859480,
            //             stats: { volume: 60627.57263769, low: 7631.5, high: 8311.5 },
            //             state: 'open',
            //             settlement_price: 7903.21,
            //             open_interest: 111543850,
            //             min_price: 7634,
            //             max_price: 7866.51,
            //             mark_price: 7750.02,
            //             last_price: 7750.5,
            //             instrument_name: 'BTC-PERPETUAL',
            //             index_price: 7748.01,
            //             funding_8h: 0.0000026,
            //             current_funding: 0,
            //             best_bid_price: 7750,
            //             best_bid_amount: 19470,
            //             best_ask_price: 7750.5,
            //             best_ask_amount: 343280
            //         },
            //         usIn: 1583778859483941,
            //         usOut: 1583778859484075,
            //         usDiff: 134,
            //         testnet: false
            //     }
            //
            const result = this.safeValue (response, 'result');
            return this.parseTicker (result, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const code = this.codeFromOptions ('fetchTickers', params);
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.publicGetGetBookSummaryByCurrency (this.extend (request, params));
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: [
            //             {
            //                 volume: 124.1,
            //                 underlying_price: 7856.445926872601,
            //                 underlying_index: 'SYN.BTC-10MAR20',
            //                 quote_currency: 'USD',
            //                 open_interest: 121.8,
            //                 mid_price: 0.01975,
            //                 mark_price: 0.01984559,
            //                 low: 0.0095,
            //                 last: 0.0205,
            //                 interest_rate: 0,
            //                 instrument_name: 'BTC-10MAR20-7750-C',
            //                 high: 0.0295,
            //                 estimated_delivery_price: 7856.29,
            //                 creation_timestamp: 1583783678366,
            //                 bid_price: 0.0185,
            //                 base_currency: 'BTC',
            //                 ask_price: 0.021
            //             },
            //         ],
            //         usIn: 1583783678361966,
            //         usOut: 1583783678372069,
            //         usDiff: 10103,
            //         testnet: false
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            const tickers = {};
            for (let i = 0; i < result.length; i++) {
                const ticker = this.parseTicker (result[i]);
                const symbol = ticker['symbol'];
                tickers[symbol] = ticker;
            }
            return this.filterByArray (tickers, 'symbol', symbols);
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_name': market['id'],
                'resolution': this.timeframes[timeframe],
            };
            const duration = this.parseTimeframe (timeframe);
            const now = this.milliseconds ();
            if (since === undefined) {
                if (limit === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchOHLCV() requires a since argument or a limit argument');
                } else {
                    request['start_timestamp'] = now - (limit - 1) * duration * 1000;
                    request['end_timestamp'] = now;
                }
            } else {
                request['start_timestamp'] = since;
                if (limit === undefined) {
                    request['end_timestamp'] = now;
                } else {
                    request['end_timestamp'] = this.sum (since, limit * duration * 1000);
                }
            }
            const response = await this.publicGetGetTradingviewChartData (this.extend (request, params));
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: {
            //             volume: [ 3.6680847969999992, 22.682721123, 3.011587939, 0 ],
            //             ticks: [ 1583916960000, 1583917020000, 1583917080000, 1583917140000 ],
            //             status: 'ok',
            //             open: [ 7834, 7839, 7833.5, 7833 ],
            //             low: [ 7834, 7833.5, 7832.5, 7833 ],
            //             high: [ 7839.5, 7839, 7833.5, 7833 ],
            //             cost: [ 28740, 177740, 23590, 0 ],
            //             close: [ 7839.5, 7833.5, 7833, 7833 ]
            //         },
            //         usIn: 1583917166709801,
            //         usOut: 1583917166710175,
            //         usDiff: 374,
            //         testnet: false
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const ohlcvs = this.convertTradingViewToOHLCV (result, 'ticks', 'open', 'high', 'low', 'close', 'volume', true);
            return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         'trade_seq': 39201926,
            //         'trade_id':' 64135724',
            //         'timestamp': 1583174775400,
            //         'tick_direction': 1,
            //         'price': 8865.0,
            //         'instrument_name': 'BTC-PERPETUAL',
            //         'index_price': 8863.31,
            //         'direction': 'buy',
            //         'amount': 10.0
            //     }
            //
            // fetchMyTrades, fetchOrderTrades (private)
            //
            //     {
            //         "trade_seq": 3,
            //         "trade_id": "ETH-34066",
            //         "timestamp": 1550219814585,
            //         "tick_direction": 1,
            //         "state": "open",
            //         "self_trade": false,
            //         "reduce_only": false,
            //         "price": 0.04,
            //         "post_only": false,
            //         "order_type": "limit",
            //         "order_id": "ETH-334607",
            //         "matching_id": null,
            //         "liquidity": "M",
            //         "iv": 56.83,
            //         "instrument_name": "ETH-22FEB19-120-C",
            //         "index_price": 121.37,
            //         "fee_currency": "ETH",
            //         "fee": 0.0011,
            //         "direction": "buy",
            //         "amount": 11
            //     }
            //
            const id = this.safeString (trade, 'trade_id');
            const marketId = this.safeString (trade, 'instrument_name');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.safeInteger (trade, 'timestamp');
            const side = this.safeString (trade, 'direction');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const liquidity = this.safeString (trade, 'liquidity');
            let takerOrMaker = undefined;
            if (liquidity !== undefined) {
                // M = maker, T = taker, MT = both
                takerOrMaker = (liquidity === 'M') ? 'maker' : 'taker';
            }
            const feeCost = this.safeNumber (trade, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'fee_currency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': this.safeString (trade, 'order_id'),
                'type': this.safeString (trade, 'order_type'),
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_name': market['id'],
                'include_old': true,
            };
            const method = (since === undefined) ? 'publicGetGetLastTradesByInstrument' : 'publicGetGetLastTradesByInstrumentAndTime';
            if (since !== undefined) {
                request['start_timestamp'] = since;
            }
            if (limit !== undefined) {
                request['count'] = limit; // default 10
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         'jsonrpc': '2.0',
            //         'result': {
            //             'trades': [
            //                 {
            //                     'trade_seq': 39201926,
            //                     'trade_id':' 64135724',
            //                     'timestamp': 1583174775400,
            //                     'tick_direction': 1,
            //                     'price': 8865.0,
            //                     'instrument_name': 'BTC-PERPETUAL',
            //                     'index_price': 8863.31,
            //                     'direction': 'buy',
            //                     'amount': 10.0
            //                 },
            //             ],
            //             'has_more': true,
            //         },
            //         'usIn': 1583779594843931,
            //         'usOut': 1583779594844446,
            //         'usDiff': 515,
            //         'testnet': false
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const trades = this.safeValue (result, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_name': market['id'],
            };
            if (limit !== undefined) {
                request['depth'] = limit;
            }
            const response = await this.publicGetGetOrderBook (this.extend (request, params));
            //
            //     {
            //         jsonrpc: '2.0',
            //         result: {
            //             timestamp: 1583781354740,
            //             stats: { volume: 61249.66735634, low: 7631.5, high: 8311.5 },
            //             state: 'open',
            //             settlement_price: 7903.21,
            //             open_interest: 111536690,
            //             min_price: 7695.13,
            //             max_price: 7929.49,
            //             mark_price: 7813.06,
            //             last_price: 7814.5,
            //             instrument_name: 'BTC-PERPETUAL',
            //             index_price: 7810.12,
            //             funding_8h: 0.0000031,
            //             current_funding: 0,
            //             change_id: 17538025952,
            //             bids: [
            //                 [7814, 351820],
            //                 [7813.5, 207490],
            //                 [7813, 32160],
            //             ],
            //             best_bid_price: 7814,
            //             best_bid_amount: 351820,
            //             best_ask_price: 7814.5,
            //             best_ask_amount: 11880,
            //             asks: [
            //                 [7814.5, 11880],
            //                 [7815, 18100],
            //                 [7815.5, 2640],
            //             ],
            //         },
            //         usIn: 1583781354745804,
            //         usOut: 1583781354745932,
            //         usDiff: 128,
            //         testnet: false
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const timestamp = this.safeInteger (result, 'timestamp');
            const nonce = this.safeInteger (result, 'change_id');
            const orderbook = this.parseOrderBook (result, symbol, timestamp);
            orderbook['nonce'] = nonce;
            return orderbook;
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'open': 'open',
                'cancelled': 'canceled',
                'filled': 'closed',
                'rejected': 'rejected',
                'untriggered': 'open',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTimeInForce (timeInForce) {
            const timeInForces = {
                'good_til_cancelled': 'GTC',
                'fill_or_kill': 'FOK',
                'immediate_or_cancel': 'IOC',
            };
            return this.safeString (timeInForces, timeInForce, timeInForce);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "time_in_force": "good_til_cancelled",
            //         "reduce_only": false,
            //         "profit_loss": 0,
            //         "price": "market_price",
            //         "post_only": false,
            //         "order_type": "market",
            //         "order_state": "filled",
            //         "order_id": "ETH-349249",
            //         "max_show": 40,
            //         "last_update_timestamp": 1550657341322,
            //         "label": "market0000234",
            //         "is_liquidation": false,
            //         "instrument_name": "ETH-PERPETUAL",
            //         "filled_amount": 40,
            //         "direction": "buy",
            //         "creation_timestamp": 1550657341322,
            //         "commission": 0.000139,
            //         "average_price": 143.81,
            //         "api": true,
            //         "amount": 40,
            //         "trades": [], // injected by createOrder
            //     }
            //
            const timestamp = this.safeInteger (order, 'creation_timestamp');
            const lastUpdate = this.safeInteger (order, 'last_update_timestamp');
            const id = this.safeString (order, 'order_id');
            const price = this.safeNumber (order, 'price');
            const average = this.safeNumber (order, 'average_price');
            const amount = this.safeNumber (order, 'amount');
            const filled = this.safeNumber (order, 'filled_amount');
            let lastTradeTimestamp = undefined;
            if (filled !== undefined) {
                if (filled > 0) {
                    lastTradeTimestamp = lastUpdate;
                }
            }
            const status = this.parseOrderStatus (this.safeString (order, 'order_state'));
            const marketId = this.safeString (order, 'instrument_name');
            market = this.safeMarket (marketId, market);
            const side = this.safeStringLower (order, 'direction');
            let feeCost = this.safeNumber (order, 'commission');
            let fee = undefined;
            if (feeCost !== undefined) {
                feeCost = Math.abs (feeCost);
                fee = {
                    'cost': feeCost,
                    'currency': market['base'],
                };
            }
            const type = this.safeString (order, 'order_type');
            // injected in createOrder
            let trades = this.safeValue (order, 'trades');
            if (trades !== undefined) {
                trades = this.parseTrades (trades, market);
            }
            const timeInForce = this.parseTimeInForce (this.safeString (order, 'time_in_force'));
            const stopPrice = this.safeValue (order, 'stop_price');
            const postOnly = this.safeValue (order, 'post_only');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': market['symbol'],
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': fee,
                'trades': trades,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privateGetGetOrderState (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 4316,
            //         "result": {
            //             "time_in_force": "good_til_cancelled",
            //             "reduce_only": false,
            //             "profit_loss": 0.051134,
            //             "price": 118.94,
            //             "post_only": false,
            //             "order_type": "limit",
            //             "order_state": "filled",
            //             "order_id": "ETH-331562",
            //             "max_show": 37,
            //             "last_update_timestamp": 1550219810944,
            //             "label": "",
            //             "is_liquidation": false,
            //             "instrument_name": "ETH-PERPETUAL",
            //             "filled_amount": 37,
            //             "direction": "sell",
            //             "creation_timestamp": 1550219749176,
            //             "commission": 0.000031,
            //             "average_price": 118.94,
            //             "api": false,
            //             "amount": 37
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result');
            return this.parseOrder (result);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_name': market['id'],
                // for perpetual and futures the amount is in USD
                // for options it is in corresponding cryptocurrency contracts, e.g., BTC or ETH
                'amount': this.amountToPrecision (symbol, amount),
                'type': type, // limit, stop_limit, market, stop_market, default is limit
                // 'label': 'string', // user-defined label for the order (maximum 64 characters)
                // 'price': this.priceToPrecision (symbol, 123.45), // only for limit and stop_limit orders
                // 'time_in_force' : 'good_til_cancelled', // fill_or_kill, immediate_or_cancel
                // 'max_show': 123.45, // max amount within an order to be shown to other customers, 0 for invisible order
                // 'post_only': false, // if the new price would cause the order to be filled immediately (as taker), the price will be changed to be just below the spread.
                // 'reject_post_only': false, // if true the order is put to order book unmodified or request is rejected
                // 'reduce_only': false, // if true, the order is intended to only reduce a current position
                // 'stop_price': false, // stop price, required for stop_limit orders
                // 'trigger': 'index_price', // mark_price, last_price, required for stop_limit orders
                // 'advanced': 'usd', // 'implv', advanced option order type, options only
            };
            let priceIsRequired = false;
            let stopPriceIsRequired = false;
            if (type === 'limit') {
                priceIsRequired = true;
            } else if (type === 'stop_limit') {
                priceIsRequired = true;
                stopPriceIsRequired = true;
            }
            if (priceIsRequired) {
                if (price !== undefined) {
                    request['price'] = this.priceToPrecision (symbol, price);
                } else {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a price argument for a ' + type + ' order');
                }
            }
            if (stopPriceIsRequired) {
                const stopPrice = this.safeNumber2 (params, 'stop_price', 'stopPrice');
                if (stopPrice === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a stop_price or stopPrice param for a ' + type + ' order');
                } else {
                    request['stop_price'] = this.priceToPrecision (symbol, stopPrice);
                }
                params = this.omit (params, [ 'stop_price', 'stopPrice' ]);
            }
            const method = 'privateGet' + this.capitalize (side);
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 5275,
            //         "result": {
            //             "trades": [
            //                 {
            //                     "trade_seq": 14151,
            //                     "trade_id": "ETH-37435",
            //                     "timestamp": 1550657341322,
            //                     "tick_direction": 2,
            //                     "state": "closed",
            //                     "self_trade": false,
            //                     "price": 143.81,
            //                     "order_type": "market",
            //                     "order_id": "ETH-349249",
            //                     "matching_id": null,
            //                     "liquidity": "T",
            //                     "label": "market0000234",
            //                     "instrument_name": "ETH-PERPETUAL",
            //                     "index_price": 143.73,
            //                     "fee_currency": "ETH",
            //                     "fee": 0.000139,
            //                     "direction": "buy",
            //                     "amount": 40
            //                 }
            //             ],
            //             "order": {
            //                 "time_in_force": "good_til_cancelled",
            //                 "reduce_only": false,
            //                 "profit_loss": 0,
            //                 "price": "market_price",
            //                 "post_only": false,
            //                 "order_type": "market",
            //                 "order_state": "filled",
            //                 "order_id": "ETH-349249",
            //                 "max_show": 40,
            //                 "last_update_timestamp": 1550657341322,
            //                 "label": "market0000234",
            //                 "is_liquidation": false,
            //                 "instrument_name": "ETH-PERPETUAL",
            //                 "filled_amount": 40,
            //                 "direction": "buy",
            //                 "creation_timestamp": 1550657341322,
            //                 "commission": 0.000139,
            //                 "average_price": 143.81,
            //                 "api": true,
            //                 "amount": 40
            //             }
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const order = this.safeValue (result, 'order');
            const trades = this.safeValue (result, 'trades', []);
            order['trades'] = trades;
            return this.parseOrder (order, market);
        }
    
        async editOrder (id, symbol, type, side, amount = undefined, price = undefined, params = {}) {
            if (amount === undefined) {
                throw new ArgumentsRequired (this.id + ' editOrder() requires an amount argument');
            }
            if (price === undefined) {
                throw new ArgumentsRequired (this.id + ' editOrder() requires a price argument');
            }
            await this.loadMarkets ();
            const request = {
                'order_id': id,
                // for perpetual and futures the amount is in USD
                // for options it is in corresponding cryptocurrency contracts, e.g., BTC or ETH
                'amount': this.amountToPrecision (symbol, amount),
                'price': this.priceToPrecision (symbol, price), // required
                // 'post_only': false, // if the new price would cause the order to be filled immediately (as taker), the price will be changed to be just below the spread.
                // 'reject_post_only': false, // if true the order is put to order book unmodified or request is rejected
                // 'reduce_only': false, // if true, the order is intended to only reduce a current position
                // 'stop_price': false, // stop price, required for stop_limit orders
                // 'advanced': 'usd', // 'implv', advanced option order type, options only
            };
            const response = await this.privateGetEdit (this.extend (request, params));
            const result = this.safeValue (response, 'result', {});
            const order = this.safeValue (result, 'order');
            const trades = this.safeValue (result, 'trades', []);
            order['trades'] = trades;
            return this.parseOrder (order);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privateGetCancel (this.extend (request, params));
            const result = this.safeValue (response, 'result', {});
            return this.parseOrder (result);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let method = undefined;
            if (symbol === undefined) {
                method = 'privateGetCancelAll';
            } else {
                method = 'privateGetCancelAllByInstrument';
                const market = this.market (symbol);
                request['instrument_name'] = market['id'];
            }
            const response = await this[method] (this.extend (request, params));
            return response;
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            let method = undefined;
            if (symbol === undefined) {
                const code = this.codeFromOptions ('fetchOpenOrders', params);
                const currency = this.currency (code);
                request['currency'] = currency['id'];
                method = 'privateGetGetOpenOrdersByCurrency';
            } else {
                market = this.market (symbol);
                request['instrument_name'] = market['id'];
                method = 'privateGetGetOpenOrdersByInstrument';
            }
            const response = await this[method] (this.extend (request, params));
            const result = this.safeValue (response, 'result', []);
            return this.parseOrders (result, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            let method = undefined;
            if (symbol === undefined) {
                const code = this.codeFromOptions ('fetchClosedOrders', params);
                const currency = this.currency (code);
                request['currency'] = currency['id'];
                method = 'privateGetGetOrderHistoryByCurrency';
            } else {
                market = this.market (symbol);
                request['instrument_name'] = market['id'];
                method = 'privateGetGetOrderHistoryByInstrument';
            }
            const response = await this[method] (this.extend (request, params));
            const result = this.safeValue (response, 'result', []);
            return this.parseOrders (result, market, since, limit);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privateGetGetUserTradesByOrder (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 9367,
            //         "result": {
            //             "trades": [
            //                 {
            //                     "trade_seq": 3,
            //                     "trade_id": "ETH-34066",
            //                     "timestamp": 1550219814585,
            //                     "tick_direction": 1,
            //                     "state": "open",
            //                     "self_trade": false,
            //                     "reduce_only": false,
            //                     "price": 0.04,
            //                     "post_only": false,
            //                     "order_type": "limit",
            //                     "order_id": "ETH-334607",
            //                     "matching_id": null,
            //                     "liquidity": "M",
            //                     "iv": 56.83,
            //                     "instrument_name": "ETH-22FEB19-120-C",
            //                     "index_price": 121.37,
            //                     "fee_currency": "ETH",
            //                     "fee": 0.0011,
            //                     "direction": "buy",
            //                     "amount": 11
            //                 },
            //             ],
            //             "has_more": true
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const trades = this.safeValue (result, 'trades', []);
            return this.parseTrades (trades, undefined, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'include_old': true,
            };
            let market = undefined;
            let method = undefined;
            if (symbol === undefined) {
                const code = this.codeFromOptions ('fetchMyTrades', params);
                const currency = this.currency (code);
                request['currency'] = currency['id'];
                if (since === undefined) {
                    method = 'privateGetGetUserTradesByCurrency';
                } else {
                    method = 'privateGetGetUserTradesByCurrencyAndTime';
                    request['start_timestamp'] = since;
                }
            } else {
                market = this.market (symbol);
                request['instrument_name'] = market['id'];
                if (since === undefined) {
                    method = 'privateGetGetUserTradesByInstrument';
                } else {
                    method = 'privateGetGetUserTradesByInstrumentAndTime';
                    request['start_timestamp'] = since;
                }
            }
            if (limit !== undefined) {
                request['count'] = limit; // default 10
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 9367,
            //         "result": {
            //             "trades": [
            //                 {
            //                     "trade_seq": 3,
            //                     "trade_id": "ETH-34066",
            //                     "timestamp": 1550219814585,
            //                     "tick_direction": 1,
            //                     "state": "open",
            //                     "self_trade": false,
            //                     "reduce_only": false,
            //                     "price": 0.04,
            //                     "post_only": false,
            //                     "order_type": "limit",
            //                     "order_id": "ETH-334607",
            //                     "matching_id": null,
            //                     "liquidity": "M",
            //                     "iv": 56.83,
            //                     "instrument_name": "ETH-22FEB19-120-C",
            //                     "index_price": 121.37,
            //                     "fee_currency": "ETH",
            //                     "fee": 0.0011,
            //                     "direction": "buy",
            //                     "amount": 11
            //                 },
            //             ],
            //             "has_more": true
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const trades = this.safeValue (result, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchDeposits() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            if (limit !== undefined) {
                request['count'] = limit;
            }
            const response = await this.privateGetGetDeposits (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 5611,
            //         "result": {
            //             "count": 1,
            //             "data": [
            //                 {
            //                     "address": "2N35qDKDY22zmJq9eSyiAerMD4enJ1xx6ax",
            //                     "amount": 5,
            //                     "currency": "BTC",
            //                     "received_timestamp": 1549295017670,
            //                     "state": "completed",
            //                     "transaction_id": "230669110fdaf0a0dbcdc079b6b8b43d5af29cc73683835b9bc6b3406c065fda",
            //                     "updated_timestamp": 1549295130159
            //                 }
            //             ]
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseTransactions (data, currency, since, limit, params);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchWithdrawals() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            if (limit !== undefined) {
                request['count'] = limit;
            }
            const response = await this.privateGetGetWithdrawals (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 2745,
            //         "result": {
            //             "count": 1,
            //             "data": [
            //                 {
            //                     "address": "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBz",
            //                     "amount": 0.5,
            //                     "confirmed_timestamp": null,
            //                     "created_timestamp": 1550571443070,
            //                     "currency": "BTC",
            //                     "fee": 0.0001,
            //                     "id": 1,
            //                     "priority": 0.15,
            //                     "state": "unconfirmed",
            //                     "transaction_id": null,
            //                     "updated_timestamp": 1550571443070
            //                 }
            //             ]
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const data = this.safeValue (result, 'data', []);
            return this.parseTransactions (data, currency, since, limit, params);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'completed': 'ok',
                'unconfirmed': 'pending',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchWithdrawals
            //
            //     {
            //         "address": "2NBqqD5GRJ8wHy1PYyCXTe9ke5226FhavBz",
            //         "amount": 0.5,
            //         "confirmed_timestamp": null,
            //         "created_timestamp": 1550571443070,
            //         "currency": "BTC",
            //         "fee": 0.0001,
            //         "id": 1,
            //         "priority": 0.15,
            //         "state": "unconfirmed",
            //         "transaction_id": null,
            //         "updated_timestamp": 1550571443070
            //     }
            //
            // fetchDeposits
            //
            //     {
            //         "address": "2N35qDKDY22zmJq9eSyiAerMD4enJ1xx6ax",
            //         "amount": 5,
            //         "currency": "BTC",
            //         "received_timestamp": 1549295017670,
            //         "state": "completed",
            //         "transaction_id": "230669110fdaf0a0dbcdc079b6b8b43d5af29cc73683835b9bc6b3406c065fda",
            //         "updated_timestamp": 1549295130159
            //     }
            //
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const timestamp = this.safeInteger2 (transaction, 'created_timestamp', 'received_timestamp');
            const updated = this.safeInteger (transaction, 'updated_timestamp');
            const status = this.parseTransactionStatus (this.safeString (transaction, 'state'));
            const address = this.safeString (transaction, 'address');
            const feeCost = this.safeNumber (transaction, 'fee');
            let type = 'deposit';
            let fee = undefined;
            if (feeCost !== undefined) {
                type = 'withdrawal';
                fee = {
                    'cost': feeCost,
                    'currency': code,
                };
            }
            return {
                'info': transaction,
                'id': this.safeString (transaction, 'id'),
                'txid': this.safeString (transaction, 'transaction_id'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'addressTo': address,
                'addressFrom': undefined,
                'tag': undefined,
                'tagTo': undefined,
                'tagFrom': undefined,
                'type': type,
                'amount': this.safeNumber (transaction, 'amount'),
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        async fetchPosition (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'instrument_name': market['id'],
            };
            const response = await this.privateGetGetPosition (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 404,
            //         "result": {
            //             "average_price": 0,
            //             "delta": 0,
            //             "direction": "buy",
            //             "estimated_liquidation_price": 0,
            //             "floating_profit_loss": 0,
            //             "index_price": 3555.86,
            //             "initial_margin": 0,
            //             "instrument_name": "BTC-PERPETUAL",
            //             "leverage": 100,
            //             "kind": "future",
            //             "maintenance_margin": 0,
            //             "mark_price": 3556.62,
            //             "open_orders_margin": 0.000165889,
            //             "realized_profit_loss": 0,
            //             "settlement_price": 3555.44,
            //             "size": 0,
            //             "size_currency": 0,
            //             "total_profit_loss": 0
            //         }
            //     }
            //
            // todo unify parsePosition/parsePositions
            const result = this.safeValue (response, 'result');
            return result;
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const code = this.codeFromOptions ('fetchPositions', params);
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetGetPositions (this.extend (request, params));
            //
            //     {
            //         "jsonrpc": "2.0",
            //         "id": 2236,
            //         "result": [
            //             {
            //                 "average_price": 7440.18,
            //                 "delta": 0.006687487,
            //                 "direction": "buy",
            //                 "estimated_liquidation_price": 1.74,
            //                 "floating_profit_loss": 0,
            //                 "index_price": 7466.79,
            //                 "initial_margin": 0.000197283,
            //                 "instrument_name": "BTC-PERPETUAL",
            //                 "kind": "future",
            //                 "leverage": 34,
            //                 "maintenance_margin": 0.000143783,
            //                 "mark_price": 7476.65,
            //                 "open_orders_margin": 0.000197288,
            //                 "realized_funding": -1e-8,
            //                 "realized_profit_loss": -9e-9,
            //                 "settlement_price": 7476.65,
            //                 "size": 50,
            //                 "size_currency": 0.006687487,
            //                 "total_profit_loss": 0.000032781
            //             }
            //         ]
            //     }
            //
            // todo unify parsePosition/parsePositions
            const result = this.safeValue (response, 'result', []);
            return result;
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'address': address, // must be in the address book
                'amount': amount,
                // 'priority': 'high', // low, mid, high, very_high, extreme_high, insane
                // 'tfa': '123456', // if enabled
            };
            if (this.twofa !== undefined) {
                request['tfa'] = this.oath ();
            }
            const response = await this.privateGetWithdraw (this.extend (request, params));
            return {
                'info': response,
                'id': this.safeString (response, 'id'),
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/' + 'api/' + this.version + '/' + api + '/' + path;
            if (api === 'public') {
                if (Object.keys (params).length) {
                    request += '?' + this.urlencode (params);
                }
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const timestamp = this.milliseconds ().toString ();
                const requestBody = '';
                if (Object.keys (params).length) {
                    request += '?' + this.urlencode (params);
                }
                const requestData = method + "\n" + request + "\n" + requestBody + "\n"; // eslint-disable-line quotes
                const auth = timestamp + "\n" + nonce + "\n" + requestData; // eslint-disable-line quotes
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256');
                headers = {
                    'Authorization': 'deri-hmac-sha256 id=' + this.apiKey + ',ts=' + timestamp + ',sig=' + signature + ',' + 'nonce=' + nonce,
                };
            }
            const url = this.urls['api'] + request;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (!response) {
                return; // fallback to default error handler
            }
            //
            //     {
            //         jsonrpc: '2.0',
            //         error: {
            //             message: 'Invalid params',
            //             data: { reason: 'invalid currency', param: 'currency' },
            //             code: -32602
            //         },
            //         testnet: false,
            //         usIn: 1583763842150374,
            //         usOut: 1583763842150410,
            //         usDiff: 36
            //     }
            //
            const error = this.safeValue (response, 'error');
            if (error !== undefined) {
                const errorCode = this.safeString (error, 'code');
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions, errorCode, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],75:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { AccountSuspended, BadRequest, BadResponse, NetworkError, DDoSProtection, AuthenticationError, PermissionDenied, ExchangeError, InsufficientFunds, InvalidOrder, InvalidNonce, OrderNotFound, InvalidAddress, RateLimitExceeded, BadSymbol } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class digifinex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'digifinex',
                'name': 'DigiFinex',
                'countries': [ 'SG' ],
                'version': 'v3',
                'rateLimit': 900, // 300 for posts
                'has': {
                    'cancelOrder': true,
                    'cancelOrders': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchLedger': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchStatus': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1',
                    '5m': '5',
                    '15m': '15',
                    '30m': '30',
                    '1h': '60',
                    '4h': '240',
                    '12h': '720',
                    '1d': '1D',
                    '1w': '1W',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87443315-01283a00-c5fe-11ea-8628-c2a0feaf07ac.jpg',
                    'api': 'https://openapi.digifinex.com',
                    'www': 'https://www.digifinex.com',
                    'doc': [
                        'https://docs.digifinex.com',
                    ],
                    'fees': 'https://digifinex.zendesk.com/hc/en-us/articles/360000328422-Fee-Structure-on-DigiFinex',
                    'referral': 'https://www.digifinex.com/en-ww/from/DhOzBg?channelCode=ljaUPp',
                },
                'api': {
                    'public': {
                        'get': [
                            '{market}/symbols',
                            'kline',
                            'margin/currencies',
                            'margin/symbols',
                            'markets',
                            'order_book',
                            'ping',
                            'spot/symbols',
                            'time',
                            'trades',
                            'trades/symbols',
                            'ticker',
                            'currencies', // todo add fetchCurrencies
                        ],
                    },
                    'private': {
                        'get': [
                            '{market}/financelog',
                            '{market}/mytrades',
                            '{market}/order',
                            '{market}​/order​/detail', // todo add fetchOrder
                            '{market}/order/current',
                            '{market}/order/history',
                            'margin/assets',
                            'margin/financelog',
                            'margin/mytrades',
                            'margin/order',
                            'margin/order/current',
                            'margin/order/history',
                            'margin/positions',
                            'otc/financelog',
                            'spot/assets',
                            'spot/financelog',
                            'spot/mytrades',
                            'spot/order',
                            'spot/order/current',
                            'spot/order/history',
                            'deposit/address', // todo add fetchDepositAddress
                            'deposit/history', // todo add fetchDeposits
                            'withdraw/history', // todo add fetchWithdrawals
                        ],
                        'post': [
                            '{market}/order/cancel',
                            '{market}/order/new',
                            '{market}​/order​/batch_new',
                            'margin/order/cancel',
                            'margin/order/new',
                            'margin/position/close',
                            'spot/order/cancel',
                            'spot/order/new',
                            'transfer',
                            'withdraw/new', // todo add withdraw()
                            'withdraw/cancel',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': this.parseNumber ('0.002'),
                        'taker': this.parseNumber ('0.002'),
                    },
                },
                'exceptions': {
                    'exact': {
                        '10001': [ BadRequest, "Wrong request method, please check it's a GET ot POST request" ],
                        '10002': [ AuthenticationError, 'Invalid ApiKey' ],
                        '10003': [ AuthenticationError, "Sign doesn't match" ],
                        '10004': [ BadRequest, 'Illegal request parameters' ],
                        '10005': [ DDoSProtection, 'Request frequency exceeds the limit' ],
                        '10006': [ PermissionDenied, 'Unauthorized to execute this request' ],
                        '10007': [ PermissionDenied, 'IP address Unauthorized' ],
                        '10008': [ InvalidNonce, 'Timestamp for this request is invalid, timestamp must within 1 minute' ],
                        '10009': [ NetworkError, 'Unexist endpoint, please check endpoint URL' ],
                        '10011': [ AccountSuspended, 'ApiKey expired. Please go to client side to re-create an ApiKey' ],
                        '20001': [ PermissionDenied, 'Trade is not open for this trading pair' ],
                        '20002': [ PermissionDenied, 'Trade of this trading pair is suspended' ],
                        '20003': [ InvalidOrder, 'Invalid price or amount' ],
                        '20007': [ InvalidOrder, 'Price precision error' ],
                        '20008': [ InvalidOrder, 'Amount precision error' ],
                        '20009': [ InvalidOrder, 'Amount is less than the minimum requirement' ],
                        '20010': [ InvalidOrder, 'Cash Amount is less than the minimum requirement' ],
                        '20011': [ InsufficientFunds, 'Insufficient balance' ],
                        '20012': [ BadRequest, 'Invalid trade type, valid value: buy/sell)' ],
                        '20013': [ InvalidOrder, 'No order info found' ],
                        '20014': [ BadRequest, 'Invalid date, Valid format: 2018-07-25)' ],
                        '20015': [ BadRequest, 'Date exceeds the limit' ],
                        '20018': [ PermissionDenied, 'Your trading rights have been banned by the system' ],
                        '20019': [ BadSymbol, 'Wrong trading pair symbol. Correct format:"usdt_btc". Quote asset is in the front' ],
                        '20020': [ DDoSProtection, "You have violated the API operation trading rules and temporarily forbid trading. At present, we have certain restrictions on the user's transaction rate and withdrawal rate." ],
                        '50000': [ ExchangeError, 'Exception error' ],
                        '20021': [ BadRequest, 'Invalid currency' ],
                        '20022': [ BadRequest, 'The ending timestamp must be larger than the starting timestamp' ],
                        '20023': [ BadRequest, 'Invalid transfer type' ],
                        '20024': [ BadRequest, 'Invalid amount' ],
                        '20025': [ BadRequest, 'This currency is not transferable at the moment' ],
                        '20026': [ InsufficientFunds, 'Transfer amount exceed your balance' ],
                        '20027': [ PermissionDenied, 'Abnormal account status' ],
                        '20028': [ PermissionDenied, 'Blacklist for transfer' ],
                        '20029': [ PermissionDenied, 'Transfer amount exceed your daily limit' ],
                        '20030': [ BadRequest, 'You have no position on this trading pair' ],
                        '20032': [ PermissionDenied, 'Withdrawal limited' ],
                        '20033': [ BadRequest, 'Wrong Withdrawal ID' ],
                        '20034': [ PermissionDenied, 'Withdrawal service of this crypto has been closed' ],
                        '20035': [ PermissionDenied, 'Withdrawal limit' ],
                        '20036': [ ExchangeError, 'Withdrawal cancellation failed' ],
                        '20037': [ InvalidAddress, 'The withdrawal address, Tag or chain type is not included in the withdrawal management list' ],
                        '20038': [ InvalidAddress, 'The withdrawal address is not on the white list' ],
                        '20039': [ ExchangeError, "Can't be canceled in current status" ],
                        '20040': [ RateLimitExceeded, 'Withdraw too frequently; limitation: 3 times a minute, 100 times a day' ],
                        '20041': [ PermissionDenied, 'Beyond the daily withdrawal limit' ],
                        '20042': [ BadSymbol, 'Current trading pair does not support API trading' ],
                    },
                    'broad': {
                    },
                },
                'options': {
                    'defaultType': 'spot',
                    'types': [ 'spot', 'margin', 'otc' ],
                },
                'commonCurrencies': {
                    'BHT': 'Black House Test',
                    'EPS': 'Epanus',
                    'MBN': 'Mobilian Coin',
                    'TEL': 'TEL666',
                },
            });
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     {
            //         "data":[
            //             {
            //                 "deposit_status":1,
            //                 "min_deposit_amount":10,
            //                 "withdraw_fee_rate":0,
            //                 "min_withdraw_amount":10,
            //                 "min_withdraw_fee":5,
            //                 "currency":"USDT",
            //                 "withdraw_status":0,
            //                 "chain":"OMNI"
            //             },
            //             {
            //                 "deposit_status":1,
            //                 "min_deposit_amount":10,
            //                 "withdraw_fee_rate":0,
            //                 "min_withdraw_amount":10,
            //                 "min_withdraw_fee":3,
            //                 "currency":"USDT",
            //                 "withdraw_status":1,
            //                 "chain":"ERC20"
            //             },
            //             {
            //                 "deposit_status":0,
            //                 "min_deposit_amount":0,
            //                 "withdraw_fee_rate":0,
            //                 "min_withdraw_amount":0,
            //                 "min_withdraw_fee":0,
            //                 "currency":"DGF13",
            //                 "withdraw_status":0,
            //                 "chain":""
            //             },
            //         ],
            //         "code":200
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const result = {};
            for (let i = 0; i < data.length; i++) {
                const currency = data[i];
                const id = this.safeString (currency, 'currency');
                const code = this.safeCurrencyCode (id);
                const depositStatus = this.safeValue (currency, 'deposit_status', 1);
                const withdrawStatus = this.safeValue (currency, 'withdraw_status', 1);
                const active = depositStatus && withdrawStatus;
                const fee = this.safeNumber (currency, 'withdraw_fee_rate');
                if (code in result) {
                    if (Array.isArray (result[code]['info'])) {
                        result[code]['info'].push (currency);
                    } else {
                        result[code]['info'] = [ result[code]['info'], currency ];
                    }
                } else {
                    result[code] = {
                        'id': id,
                        'code': code,
                        'info': currency,
                        'type': undefined,
                        'name': undefined,
                        'active': active,
                        'fee': fee,
                        'precision': 8, // todo fix hardcoded value
                        'limits': {
                            'amount': {
                                'min': undefined,
                                'max': undefined,
                            },
                            'withdraw': {
                                'min': this.safeNumber (currency, 'min_withdraw_amount'),
                                'max': undefined,
                            },
                        },
                    };
                }
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const options = this.safeValue (this.options, 'fetchMarkets', {});
            const method = this.safeString (options, 'method', 'fetch_markets_v2');
            return await this[method] (params);
        }
    
        async fetchMarketsV2 (params = {}) {
            const response = await this.publicGetTradesSymbols (params);
            //
            //     {
            //         "symbol_list":[
            //             {
            //                 "order_types":["LIMIT","MARKET"],
            //                 "quote_asset":"USDT",
            //                 "minimum_value":2,
            //                 "amount_precision":4,
            //                 "status":"TRADING",
            //                 "minimum_amount":0.0001,
            //                 "symbol":"BTC_USDT",
            //                 "is_allow":1,
            //                 "zone":"MAIN",
            //                 "base_asset":"BTC",
            //                 "price_precision":2
            //             }
            //         ],
            //         "code":0
            //     }
            //
            const markets = this.safeValue (response, 'symbol_list', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'symbol');
                const baseId = this.safeString (market, 'base_asset');
                const quoteId = this.safeString (market, 'quote_asset');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeInteger (market, 'amount_precision'),
                    'price': this.safeInteger (market, 'price_precision'),
                };
                const limits = {
                    'amount': {
                        'min': this.safeNumber (market, 'minimum_amount'),
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': this.safeNumber (market, 'minimum_value'),
                        'max': undefined,
                    },
                };
                //
                // The status is documented in the exchange API docs as follows:
                // TRADING, HALT (delisted), BREAK (trading paused)
                // https://docs.digifinex.vip/en-ww/v3/#/public/spot/symbols
                // However, all spot markets actually have status === 'HALT'
                // despite that they appear to be active on the exchange website.
                // Apparently, we can't trust this status.
                // const status = this.safeString (market, 'status');
                // const active = (status === 'TRADING');
                //
                const isAllowed = this.safeInteger (market, 'is_allow', 1);
                const active = isAllowed ? true : false;
                const type = 'spot';
                const spot = (type === 'spot');
                const margin = (type === 'margin');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'type': type,
                    'spot': spot,
                    'margin': margin,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchMarketsV1 (params = {}) {
            const response = await this.publicGetMarkets (params);
            //
            //     {
            //         "data": [
            //             {
            //                 "volume_precision":4,
            //                 "price_precision":2,
            //                 "market":"btc_usdt",
            //                 "min_amount":2,
            //                 "min_volume":0.0001
            //             },
            //         ],
            //         "date":1564507456,
            //         "code":0
            //     }
            //
            const markets = this.safeValue (response, 'data', []);
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'market');
                const [ baseId, quoteId ] = id.split ('_');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeInteger (market, 'volume_precision'),
                    'price': this.safeInteger (market, 'price_precision'),
                };
                const limits = {
                    'amount': {
                        'min': this.safeNumber (market, 'min_volume'),
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': this.safeNumber (market, 'min_amount'),
                        'max': undefined,
                    },
                };
                const active = undefined;
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            const method = 'privateGet' + this.capitalize (type) + 'Assets';
            const response = await this[method] (params);
            //
            //     {
            //         "code": 0,
            //         "list": [
            //             {
            //                 "currency": "BTC",
            //                 "free": 4723846.89208129,
            //                 "total": 0
            //             }
            //         ]
            //     }
            const balances = this.safeValue (response, 'list', []);
            const result = { 'info': response };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['used'] = this.safeString (balance, 'frozen');
                account['free'] = this.safeString (balance, 'free');
                account['total'] = this.safeString (balance, 'total');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 10, max 150
            }
            const response = await this.publicGetOrderBook (this.extend (request, params));
            //
            //     {
            //         "bids": [
            //             [9605.77,0.0016],
            //             [9605.46,0.0003],
            //             [9602.04,0.0127],
            //         ],
            //         "asks": [
            //             [9627.22,0.025803],
            //             [9627.12,0.168543],
            //             [9626.52,0.0011529],
            //         ],
            //         "date":1564509499,
            //         "code":0
            //     }
            //
            const timestamp = this.safeTimestamp (response, 'date');
            return this.parseOrderBook (response, symbol, timestamp);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTicker (params);
            //
            //    {
            //        "ticker": [{
            //            "vol": 40717.4461,
            //            "change": -1.91,
            //            "base_vol": 392447999.65374,
            //            "sell": 9592.23,
            //            "last": 9592.22,
            //            "symbol": "btc_usdt",
            //            "low": 9476.24,
            //            "buy": 9592.03,
            //            "high": 9793.87
            //        }],
            //        "date": 1589874294,
            //        "code": 0
            //    }
            //
            const result = {};
            const tickers = this.safeValue (response, 'ticker', []);
            const date = this.safeInteger (response, 'date');
            for (let i = 0; i < tickers.length; i++) {
                const rawTicker = this.extend ({
                    'date': date,
                }, tickers[i]);
                const ticker = this.parseTicker (rawTicker);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            //
            //    {
            //        "ticker": [{
            //            "vol": 40717.4461,
            //            "change": -1.91,
            //            "base_vol": 392447999.65374,
            //            "sell": 9592.23,
            //            "last": 9592.22,
            //            "symbol": "btc_usdt",
            //            "low": 9476.24,
            //            "buy": 9592.03,
            //            "high": 9793.87
            //        }],
            //        "date": 1589874294,
            //        "code": 0
            //    }
            //
            const date = this.safeInteger (response, 'date');
            const tickers = this.safeValue (response, 'ticker', []);
            const firstTicker = this.safeValue (tickers, 0, {});
            const result = this.extend ({ 'date': date }, firstTicker);
            return this.parseTicker (result, market);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker, fetchTickers
            //
            //     {
            //         "last":0.021957,
            //         "symbol": "btc_usdt",
            //         "base_vol":2249.3521732227,
            //         "change":-0.6,
            //         "vol":102443.5111,
            //         "sell":0.021978,
            //         "low":0.021791,
            //         "buy":0.021946,
            //         "high":0.022266,
            //         "date"1564518452, // injected from fetchTicker/fetchTickers
            //     }
            //
            const marketId = this.safeStringUpper (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '_');
            const timestamp = this.safeTimestamp (ticker, 'date');
            const last = this.safeNumber (ticker, 'last');
            const percentage = this.safeNumber (ticker, 'change');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': this.safeNumber (ticker, 'base_vol'),
                'info': ticker,
            };
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "date":1564520003,
            //         "id":1596149203,
            //         "amount":0.7073,
            //         "type":"buy",
            //         "price":0.02193,
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "symbol": "BTC_USDT",
            //         "order_id": "6707cbdcda0edfaa7f4ab509e4cbf966",
            //         "id": 28457,
            //         "price": 0.1,
            //         "amount": 0,
            //         "fee": 0.096,
            //         "fee_currency": "USDT",
            //         "timestamp": 1499865549,
            //         "side": "buy",
            //         "is_maker": true
            //     }
            //
            const id = this.safeString (trade, 'id');
            const orderId = this.safeString (trade, 'order_id');
            const timestamp = this.safeTimestamp2 (trade, 'date', 'timestamp');
            const side = this.safeString2 (trade, 'type', 'side');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const marketId = this.safeString (trade, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '_');
            const takerOrMaker = this.safeValue (trade, 'is_maker');
            const feeCost = this.safeNumber (trade, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'fee_currency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'order': orderId,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'takerOrMaker': takerOrMaker,
                'fee': fee,
            };
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     {
            //         "server_time": 1589873762,
            //         "code": 0
            //     }
            //
            return this.safeTimestamp (response, 'server_time');
        }
    
        async fetchStatus (params = {}) {
            await this.publicGetPing (params);
            //
            //     {
            //         "msg": "pong",
            //         "code": 0
            //     }
            //
            this.status = this.extend (this.status, {
                'status': 'ok',
                'updated': this.milliseconds (),
            });
            return this.status;
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 100, max 500
            }
            const response = await this.publicGetTrades (this.extend (request, params));
            //
            //     {
            //         "data":[
            //             {
            //                 "date":1564520003,
            //                 "id":1596149203,
            //                 "amount":0.7073,
            //                 "type":"buy",
            //                 "price":0.02193,
            //             },
            //             {
            //                 "date":1564520002,
            //                 "id":1596149165,
            //                 "amount":0.3232,
            //                 "type":"sell",
            //                 "price":0.021927,
            //             },
            //         ],
            //         "code": 0,
            //         "date": 1564520003,
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1556712900,
            //         2205.899,
            //         0.029967,
            //         0.02997,
            //         0.029871,
            //         0.029927
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 0),
                this.safeNumber (ohlcv, 5), // open
                this.safeNumber (ohlcv, 3), // high
                this.safeNumber (ohlcv, 4), // low
                this.safeNumber (ohlcv, 2), // close
                this.safeNumber (ohlcv, 1), // volume
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'period': this.timeframes[timeframe],
                // 'start_time': 1564520003, // starting timestamp, 200 candles before end_time by default
                // 'end_time': 1564520003, // ending timestamp, current timestamp by default
            };
            if (since !== undefined) {
                const startTime = parseInt (since / 1000);
                request['start_time'] = startTime;
                if (limit !== undefined) {
                    const duration = this.parseTimeframe (timeframe);
                    request['end_time'] = this.sum (startTime, limit * duration);
                }
            } else if (limit !== undefined) {
                const endTime = this.seconds ();
                const duration = this.parseTimeframe (timeframe);
                request['startTime'] = this.sum (endTime, -limit * duration);
            }
            const response = await this.publicGetKline (this.extend (request, params));
            //
            //     {
            //         "code":0,
            //         "data":[
            //             [1556712900,2205.899,0.029967,0.02997,0.029871,0.029927],
            //             [1556713800,1912.9174,0.029992,0.030014,0.029955,0.02996],
            //             [1556714700,1556.4795,0.029974,0.030019,0.029969,0.02999],
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            const request = {
                'market': orderType,
                'symbol': market['id'],
                'amount': this.amountToPrecision (symbol, amount),
                // 'post_only': 0, // 0 by default, if set to 1 the order will be canceled if it can be executed immediately, making sure there will be no market taking
            };
            let suffix = '';
            if (type === 'market') {
                suffix = '_market';
            } else {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            request['type'] = side + suffix;
            const response = await this.privatePostMarketOrderNew (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "order_id": "198361cecdc65f9c8c9bb2fa68faec40"
            //     }
            //
            const result = this.parseOrder (response, market);
            return this.extend (result, {
                'symbol': symbol,
                'side': side,
                'type': type,
                'amount': amount,
                'price': price,
            });
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            const request = {
                'market': orderType,
                'order_id': id,
            };
            const response = await this.privatePostMarketOrderCancel (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "success": [
            //             "198361cecdc65f9c8c9bb2fa68faec40",
            //             "3fb0d98e51c18954f10d439a9cf57de0"
            //         ],
            //         "error": [
            //             "78a7104e3c65cc0c5a212a53e76d0205"
            //         ]
            //     }
            //
            const canceledOrders = this.safeValue (response, 'success', []);
            const numCanceledOrders = canceledOrders.length;
            if (numCanceledOrders !== 1) {
                throw new OrderNotFound (this.id + ' cancelOrder ' + id + ' not found');
            }
            return response;
        }
    
        async cancelOrders (ids, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            const request = {
                'market': orderType,
                'order_id': ids.join (','),
            };
            const response = await this.privatePostCancelOrder (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "success": [
            //             "198361cecdc65f9c8c9bb2fa68faec40",
            //             "3fb0d98e51c18954f10d439a9cf57de0"
            //         ],
            //         "error": [
            //             "78a7104e3c65cc0c5a212a53e76d0205"
            //         ]
            //     }
            //
            const canceledOrders = this.safeValue (response, 'success', []);
            const numCanceledOrders = canceledOrders.length;
            if (numCanceledOrders < 1) {
                throw new OrderNotFound (this.id + ' cancelOrders error');
            }
            return response;
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '0': 'open',
                '1': 'open', // partially filled
                '2': 'closed',
                '3': 'canceled',
                '4': 'canceled', // partially filled and canceled
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "code": 0,
            //         "order_id": "198361cecdc65f9c8c9bb2fa68faec40"
            //     }
            //
            // fetchOrder, fetchOpenOrders, fetchOrders
            //
            //     {
            //         "symbol": "BTC_USDT",
            //         "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
            //         "created_date": 1562303547,
            //         "finished_date": 0,
            //         "price": 0.1,
            //         "amount": 1,
            //         "cash_amount": 1,
            //         "executed_amount": 0,
            //         "avg_price": 0,
            //         "status": 1,
            //         "type": "buy",
            //         "kind": "margin"
            //     }
            //
            const id = this.safeString (order, 'order_id');
            const timestamp = this.safeTimestamp (order, 'created_date');
            const lastTradeTimestamp = this.safeTimestamp (order, 'finished_date');
            let side = this.safeString (order, 'type');
            let type = undefined;
            if (side !== undefined) {
                const parts = side.split ('_');
                const numParts = parts.length;
                if (numParts > 1) {
                    side = parts[0];
                    type = parts[1];
                } else {
                    type = 'limit';
                }
            }
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '_');
            const amount = this.safeNumber (order, 'amount');
            const filled = this.safeNumber (order, 'executed_amount');
            const price = this.safeNumber (order, 'price');
            const average = this.safeNumber (order, 'avg_price');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'cost': undefined,
                'average': average,
                'status': status,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                'market': orderType,
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const response = await this.privateGetMarketOrderCurrent (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
            //                 "created_date": 1562303547,
            //                 "finished_date": 0,
            //                 "price": 0.1,
            //                 "amount": 1,
            //                 "cash_amount": 1,
            //                 "executed_amount": 0,
            //                 "avg_price": 0,
            //                 "status": 1,
            //                 "type": "buy",
            //                 "kind": "margin"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                'market': orderType,
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['start_time'] = parseInt (since / 1000); // default 3 days from now, max 30 days
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 10, max 100
            }
            const response = await this.privateGetMarketOrderHistory (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
            //                 "created_date": 1562303547,
            //                 "finished_date": 0,
            //                 "price": 0.1,
            //                 "amount": 1,
            //                 "cash_amount": 1,
            //                 "executed_amount": 0,
            //                 "avg_price": 0,
            //                 "status": 1,
            //                 "type": "buy",
            //                 "kind": "margin"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const request = {
                'market': orderType,
                'order_id': id,
            };
            const response = await this.privateGetMarketOrder (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": [
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "order_id": "dd3164b333a4afa9d5730bb87f6db8b3",
            //                 "created_date": 1562303547,
            //                 "finished_date": 0,
            //                 "price": 0.1,
            //                 "amount": 1,
            //                 "cash_amount": 1,
            //                 "executed_amount": 0,
            //                 "avg_price": 0,
            //                 "status": 1,
            //                 "type": "buy",
            //                 "kind": "margin"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const order = this.safeValue (data, 0);
            if (order === undefined) {
                throw new OrderNotFound (this.id + ' fetchOrder() order ' + id + ' not found');
            }
            return this.parseOrder (order, market);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                'market': orderType,
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['start_time'] = parseInt (since / 1000); // default 3 days from now, max 30 days
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 10, max 100
            }
            const response = await this.privateGetMarketMytrades (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "list": [
            //             {
            //                 "symbol": "BTC_USDT",
            //                 "order_id": "6707cbdcda0edfaa7f4ab509e4cbf966",
            //                 "id": 28457,
            //                 "price": 0.1,
            //                 "amount": 0,
            //                 "fee": 0.096,
            //                 "fee_currency": "USDT",
            //                 "timestamp": 1499865549,
            //                 "side": "buy",
            //                 "is_maker": true
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'list', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        parseLedgerEntryType (type) {
            const types = {};
            return this.safeString (types, type, type);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //     {
            //         "currency_mark": "BTC",
            //         "type": 100234,
            //         "num": 28457,
            //         "balance": 0.1,
            //         "time": 1546272000
            //     }
            //
            const id = this.safeString (item, 'num');
            const account = undefined;
            const type = this.parseLedgerEntryType (this.safeString (item, 'type'));
            const code = this.safeCurrencyCode (this.safeString (item, 'currency_mark'), currency);
            const timestamp = this.safeTimestamp (item, 'time');
            const before = undefined;
            const after = this.safeNumber (item, 'balance');
            const status = 'ok';
            return {
                'info': item,
                'id': id,
                'direction': undefined,
                'account': account,
                'referenceId': undefined,
                'referenceAccount': undefined,
                'type': type,
                'currency': code,
                'amount': undefined,
                'before': before,
                'after': after,
                'status': status,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': undefined,
            };
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            const defaultType = this.safeString (this.options, 'defaultType', 'spot');
            const orderType = this.safeString (params, 'type', defaultType);
            params = this.omit (params, 'type');
            await this.loadMarkets ();
            const request = {
                'market': orderType,
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency_mark'] = currency['id'];
            }
            if (since !== undefined) {
                request['start_time'] = parseInt (since / 1000);
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 100, max 1000
            }
            const response = await this.privateGetMarketFinancelog (this.extend (request, params));
            //
            //     {
            //         "code": 0,
            //         "data": {
            //             "total": 521,
            //             "finance": [
            //                 {
            //                     "currency_mark": "BTC",
            //                     "type": 100234,
            //                     "num": 28457,
            //                     "balance": 0.1,
            //                     "time": 1546272000
            //                 }
            //             ]
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const items = this.safeValue (data, 'finance', []);
            return this.parseLedger (items, currency, since, limit);
        }
    
        parseDepositAddress (depositAddress, currency = undefined) {
            //
            //     {
            //         "addressTag":"",
            //         "address":"0xf1104d9f8624f89775a3e9d480fc0e75a8ef4373",
            //         "currency":"USDT",
            //         "chain":"ERC20"
            //     }
            //
            const address = this.safeString (depositAddress, 'address');
            const tag = this.safeString (depositAddress, 'addressTag');
            const currencyId = this.safeStringUpper (depositAddress, 'currency');
            const code = this.safeCurrencyCode (currencyId);
            return {
                'info': depositAddress,
                'code': code,
                'address': address,
                'tag': tag,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetDepositAddress (this.extend (request, params));
            //
            //     {
            //         "data":[
            //             {
            //                 "addressTag":"",
            //                 "address":"0xf1104d9f8624f89775a3e9d480fc0e75a8ef4373",
            //                 "currency":"USDT",
            //                 "chain":"ERC20"
            //             }
            //         ],
            //         "code":200
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const addresses = this.parseDepositAddresses (data);
            const address = this.safeValue (addresses, code);
            if (address === undefined) {
                throw new InvalidAddress (this.id + ' fetchDepositAddress did not return an address for ' + code + ' - create the deposit address in the user settings on the exchange website first.');
            }
            return address;
        }
    
        async fetchTransactionsByType (type, code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {
                // 'currency': currency['id'],
                // 'from': 'fromId', // When direct is' prev ', from is 1, returning from old to new ascending, when direct is' next ', from is the ID of the most recent record, returned from the old descending order
                // 'size': 100, // default 100, max 500
                // 'direct': 'prev', // "prev" ascending, "next" descending
            };
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['size'] = Math.min (500, limit);
            }
            const method = (type === 'deposit') ? 'privateGetDepositHistory' : 'privateGetWithdrawHistory';
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "code": 200,
            //         "data": [
            //             {
            //                 "id": 1171,
            //                 "currency": "xrp",
            //                 "hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
            //                 "chain": "",
            //                 "amount": 7.457467,
            //                 "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
            //                 "memo": "100040",
            //                 "fee": 0,
            //                 "state": "safe",
            //                 "created_date": "2020-04-20 11:23:00",
            //                 "finished_date": "2020-04-20 13:23:00"
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTransactions (data, currency, since, limit, { 'type': type });
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsByType ('deposit', code, since, limit, params);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchTransactionsByType ('withdrawal', code, since, limit, params);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                '0': 'pending', // Email Sent
                '1': 'canceled', // Cancelled (different from 1 = ok in deposits)
                '2': 'pending', // Awaiting Approval
                '3': 'failed', // Rejected
                '4': 'pending', // Processing
                '5': 'failed', // Failure
                '6': 'ok', // Completed
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // withdraw
            //
            //     {
            //         "code": 200,
            //         "withdraw_id": 700
            //     }
            //
            // fetchDeposits, fetchWithdrawals
            //
            //     {
            //         "id": 1171,
            //         "currency": "xrp",
            //         "hash": "ed03094b84eafbe4bc16e7ef766ee959885ee5bcb265872baaa9c64e1cf86c2b",
            //         "chain": "",
            //         "amount": 7.457467,
            //         "address": "rae93V8d2mdoUQHwBDBdM4NHCMehRJAsbm",
            //         "memo": "100040",
            //         "fee": 0,
            //         "state": "safe",
            //         "created_date": "2020-04-20 11:23:00",
            //         "finished_date": "2020-04-20 13:23:00"
            //     }
            //
            const id = this.safeString2 (transaction, 'id', 'withdraw_id');
            const address = this.safeString (transaction, 'address');
            let tag = this.safeString (transaction, 'memo'); // set but unused
            if (tag !== undefined) {
                if (tag.length < 1) {
                    tag = undefined;
                }
            }
            const txid = this.safeString (transaction, 'hash');
            const currencyId = this.safeStringUpper (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const timestamp = this.parse8601 (this.safeString (transaction, 'created_date'));
            const updated = this.parse8601 (this.safeString (transaction, 'finished_date'));
            const status = this.parseTransactionStatus (this.safeString (transaction, 'state'));
            const amount = this.safeNumber (transaction, 'amount');
            const feeCost = this.safeNumber (transaction, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = { 'currency': code, 'cost': feeCost };
            }
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'addressTo': address,
                'addressFrom': undefined,
                'tag': tag,
                'tagTo': tag,
                'tagFrom': undefined,
                'type': undefined,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                // 'chain': 'ERC20', 'OMNI', 'TRC20', // required for USDT
                'address': address,
                'amount': parseFloat (amount),
                'currency': currency['id'],
            };
            if (tag !== undefined) {
                request['memo'] = tag;
            }
            const response = await this.privatePostWithdrawNew (this.extend (request, params));
            //
            //     {
            //         "code": 200,
            //         "withdraw_id": 700
            //     }
            //
            return this.parseTransaction (response, currency);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const version = this.version;
            let url = this.urls['api'] + '/' + version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            const urlencoded = this.urlencode (this.keysort (query));
            if (api === 'private') {
                const nonce = this.nonce ().toString ();
                const auth = urlencoded;
                // the signature is not time-limited :\
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                if (method === 'GET') {
                    if (urlencoded) {
                        url += '?' + urlencoded;
                    }
                } else if (method === 'POST') {
                    headers = {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    };
                    if (urlencoded) {
                        body = urlencoded;
                    }
                }
                headers = {
                    'ACCESS-KEY': this.apiKey,
                    'ACCESS-SIGN': signature,
                    'ACCESS-TIMESTAMP': nonce,
                };
            } else {
                if (urlencoded) {
                    url += '?' + urlencoded;
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (statusCode, statusText, url, method, responseHeaders, responseBody, response, requestHeaders, requestBody) {
            if (!response) {
                return; // fall back to default error handler
            }
            const code = this.safeString (response, 'code');
            if ((code === '0') || (code === '200')) {
                return; // no error
            }
            const feedback = this.id + ' ' + responseBody;
            if (code === undefined) {
                throw new BadResponse (feedback);
            }
            const unknownError = [ ExchangeError, feedback ];
            const [ ExceptionClass, message ] = this.safeValue (this.exceptions['exact'], code, unknownError);
            throw new ExceptionClass (message);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],76:[function(require,module,exports){
    'use strict';
    
    // ----------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, BadSymbol } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    // ----------------------------------------------------------------------------
    
    module.exports = class eqonex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'eqonex',
                'name': 'EQONEX',
                'countries': [ 'US', 'SG' ], // United States, Singapore
                'rateLimit': 10,
                'has': {
                    'CORS': false,
                    'cancelOrder': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchCanceledOrders': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': false,
                    'fetchTrades': true,
                    'fetchTradingFees': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': 1,
                    '5m': 2,
                    '15m': 3,
                    '1h': 4,
                    '6h': 5,
                    '1d': 6,
                    '7d': 7,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/122649755-1a076c80-d138-11eb-8f2e-9a9166a03d79.jpg',
                    'test': {
                        'public': 'https://testnet.eqonex.com/api',
                        'private': 'https://testnet.eqonex.com/api',
                    },
                    'api': {
                        'public': 'https://eqonex.com/api',
                        'private': 'https://eqonex.com/api',
                    },
                    'www': 'https://eqonex.com',
                    'doc': [
                        'https://developer.eqonex.com',
                    ],
                    'referral': 'https://eqonex.com?referredByCode=zpa8kij4ouvBFup3',
                },
                'api': {
                    'public': {
                        'get': [
                            'health',
                            'getInstruments',
                            'getInstrumentPairs',
                            'getOrderBook',
                            'getRisk',
                            'getTradeHistory',
                            'getFundingRateHistory',
                            'getChart',
                            'getExchangeInfo', // not documented
                        ],
                    },
                    'private': {
                        'post': [
                            'logon',
                            'order',
                            'cancelOrder',
                            'cancelReplaceOrder',
                            'getOrder',
                            'getOrders',
                            'getOrderStatus',
                            'getOrderHistory',
                            'userTrades',
                            'getPositions',
                            'cancelAll',
                            'getUserHistory',
                            'getRisk',
                            'getDepositAddresses',
                            'getDepositHistory', // not documented
                            'getWithdrawRequests',
                            'sendWithdrawRequest',
                            'getTransferHistory',
                        ],
                    },
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'uid': true,
                },
                'exceptions': {
                    'broad': {
                        'symbol not found': BadSymbol,
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const request = {
                'verbose': true,
            };
            const response = await this.publicGetGetInstrumentPairs (this.extend (request, params));
            //
            //     {
            //         "instrumentPairs":[
            //             {
            //                 "instrumentId":52,
            //                 "symbol":"BTC/USDC",
            //                 "quoteId":1,
            //                 "baseId":3,
            //                 "price_scale":2,
            //                 "quantity_scale":6,
            //                 "securityStatus":1,
            //                 "securityDesc":"BTC/USDC", // "BTC/USDC[F]"
            //                 "assetType":"PAIR", // "PERPETUAL_SWAP"
            //                 "currency":"BTC",
            //                 "contAmtCurr":"USDC",
            //                 "settlCurrency":"USDC",
            //                 "commCurrency":"USDC",
            //                 "cfiCode":"XXXXXX",
            //                 "securityExchange":"XXXX",
            //                 "instrumentPricePrecision":2,
            //                 "minPriceIncrement":1.0,
            //                 "minPriceIncrementAmount":1.0,
            //                 "roundLot":1,
            //                 "minTradeVol":0.001000,
            //                 "maxTradeVol":0.000000
            //                 // contracts onlye
            //                 "qtyType":0,
            //                 "contractMultiplier":1.0,
            //                 "issueDate":1598608087000
            //             },
            //         ]
            //     }
            //
            const instrumentPairs = this.safeValue (response, 'instrumentPairs', []);
            const markets = [];
            for (let i = 0; i < instrumentPairs.length; i++) {
                const market = this.parseMarket (instrumentPairs[i]);
                markets.push (market);
            }
            return markets;
        }
    
        parseMarket (market) {
            //
            //     {
            //         "instrumentId":52,
            //         "symbol":"BTC/USDC", // "BTC/USDC[F]"
            //         "quoteId":1,
            //         "baseId":3,
            //         "price_scale":2,
            //         "quantity_scale":6,
            //         "securityStatus":1,
            //         "securityDesc":"BTC/USDC", // "BTC/USDC[F]"
            //         "assetType":"PAIR", // "PERPETUAL_SWAP"
            //         "currency":"BTC",
            //         "contAmtCurr":"USDC",
            //         "settlCurrency":"USDC",
            //         "commCurrency":"USDC",
            //         "cfiCode":"XXXXXX",
            //         "securityExchange":"XXXX",
            //         "instrumentPricePrecision":2,
            //         "minPriceIncrement":1.0,
            //         "minPriceIncrementAmount":1.0,
            //         "roundLot":1,
            //         "minTradeVol":0.001000,
            //         "maxTradeVol":0.000000
            //         // contracts onlye
            //         "qtyType":0,
            //         "contractMultiplier":1.0,
            //         "issueDate":1598608087000
            //     }
            //
            const id = this.safeString (market, 'instrumentId');
            const uppercaseId = this.safeString (market, 'symbol');
            const assetType = this.safeString (market, 'assetType');
            const spot = (assetType === 'PAIR');
            const swap = (assetType === 'PERPETUAL_SWAP');
            const type = swap ? 'swap' : 'spot';
            const baseId = this.safeString (market, 'currency');
            const quoteId = this.safeString (market, 'contAmtCurr');
            const base = this.safeCurrencyCode (baseId);
            const quote = this.safeCurrencyCode (quoteId);
            const symbol = swap ? uppercaseId : (base + '/' + quote);
            const status = this.safeInteger (market, 'securityStatus');
            const active = (status === 1);
            const precision = {
                'amount': this.safeInteger (market, 'quantity_scale'),
                'price': this.safeInteger (market, 'price_scale'),
            };
            return {
                'id': id,
                'uppercaseId': uppercaseId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'type': type,
                'spot': spot,
                'swap': swap,
                'active': active,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': this.safeNumber (market, 'minTradeVol'),
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
                'info': market,
            };
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetGetInstruments (params);
            //
            //     {
            //         "instruments": [
            //             [
            //                 3,     // id
            //                 "BTC", // symbol
            //                 2,     // price_scale
            //                 6,     // amount_scale
            //                 1,     // status
            //                 0,     // withdraw_fee
            //                 "BTC", // name
            //                 true,  // withdrawal_pct
            //             ],
            //         ]
            //     }
            //
            const currencies = {};
            const instruments = this.safeValue (response, 'instruments', []);
            for (let i = 0; i < instruments.length; i++) {
                const currency = this.parseCurrency (instruments[i]);
                const code = currency['code'];
                currencies[code] = currency;
            }
            return currencies;
        }
    
        parseCurrency (currency) {
            //
            //     [
            //         3,     // 0 id
            //         "BTC", // 1 symbol
            //         2,     // 2 price_scale
            //         6,     // 3 amount_scale
            //         1,     // 4 status
            //         0,     // 5 withdraw_fee
            //         "BTC", // 6 name
            //         true,  // 7 withdrawal_pct
            //     ],
            //
            const id = this.safeString (currency, 0);
            const uppercaseId = this.safeString (currency, 1);
            const code = this.safeCurrencyCode (uppercaseId);
            const priceScale = this.safeInteger (currency, 2);
            const amountScale = this.safeInteger (currency, 3);
            const precision = Math.max (priceScale, amountScale);
            const name = this.safeString (currency, 6);
            const status = this.safeInteger (currency, 4);
            const active = (status === 1);
            const fee = this.safeNumber (currency, 5); // withdraw_fee
            return {
                'id': id,
                'info': currency,
                'uppercaseId': uppercaseId,
                'code': code,
                'name': name,
                'precision': precision,
                'fee': fee,
                'active': active,
                'limits': {
                    'amount': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            };
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pairId': parseInt (market['id']),
                'timespan': this.timeframes[timeframe],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetGetChart (this.extend (request, params));
            //
            //     {
            //         "pairId":57,
            //         "t":1,
            //         "s":"ETH/BTC",
            //         "lastPx":44099,
            //         "lastQty":100000,
            //         "o":0.043831000000000016,
            //         "h":0.04427100000000002,
            //         "l":0.032000000000000015,
            //         "c":0.04409900000000002,
            //         "v":0.21267333000000016,
            //         "q":4.850000000000001,
            //         "chart":[
            //             [1612519260000,44099,44099,44099,44099,0,441],
            //             [1612519200000,44099,44099,44099,44099,0,440],
            //             [1612519140000,44269,44271,44269,44271,0,439],
            //         ]
            //     }
            //
            const chart = this.safeValue (response, 'chart', []);
            return this.parseOHLCVs (chart, market, timeframe, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1612519260000, // timestamp
            //         44099,         // open
            //         44099,         // high
            //         44099,         // low
            //         44099,         // close
            //         0,             // base volume
            //         441,           // seqNumber
            //     ]
            //
            const timestamp = this.safeInteger (ohlcv, 0);
            const open = this.parseNumber (this.convertFromScale (this.safeString (ohlcv, 1), market['precision']['price']));
            const high = this.parseNumber (this.convertFromScale (this.safeString (ohlcv, 2), market['precision']['price']));
            const low = this.parseNumber (this.convertFromScale (this.safeString (ohlcv, 3), market['precision']['price']));
            const close = this.parseNumber (this.convertFromScale (this.safeString (ohlcv, 4), market['precision']['price']));
            const volume = this.parseNumber (this.convertFromScale (this.safeString (ohlcv, 5), market['precision']['amount']));
            return [timestamp, open, high, low, close, volume];
        }
    
        parseBidAsk (bidask, priceKey = 0, amountKey = 1, market = undefined) {
            if (market === undefined) {
                throw new ArgumentsRequired (this.id + ' parseBidAsk() requires a market argument');
            }
            const priceString = this.safeString (bidask, priceKey);
            const amountString = this.safeString (bidask, amountKey);
            return [
                this.parseNumber (this.convertFromScale (priceString, market['precision']['price'])),
                this.parseNumber (this.convertFromScale (amountString, market['precision']['amount'])),
            ];
        }
    
        parseOrderBook (orderbook, symbol, timestamp = undefined, bidsKey = 'bids', asksKey = 'asks', priceKey = 0, amountKey = 1, market = undefined) {
            const result = {
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'nonce': undefined,
            };
            const sides = [ bidsKey, asksKey ];
            for (let i = 0; i < sides.length; i++) {
                const side = sides[i];
                const orders = [];
                const bidasks = this.safeValue (orderbook, side);
                for (let k = 0; k < bidasks.length; k++) {
                    orders.push (this.parseBidAsk (bidasks[k], priceKey, amountKey, market));
                }
                result[side] = orders;
            }
            result[bidsKey] = this.sortBy (result[bidsKey], 0, true);
            result[asksKey] = this.sortBy (result[asksKey], 0);
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pairId': parseInt (market['id']),
            };
            const response = await this.publicGetGetOrderBook (this.extend (request, params));
            //
            //     {
            //         "bids":[
            //             [4000480,30000,1612644984667],
            //             [3999304,200000,1612644984667],
            //             [3998862,50000,1612644984667],
            //         ],
            //         "asks":[
            //             [4001962,1790000,1612644984667],
            //             [4002616,1000,1612644984667],
            //             [4003889,1000,1612644984667],
            //         ],
            //         "usdMark":40011.02,
            //         "marketStatus":0,
            //         "estFundingRate":0.0,
            //         "fundingRateTime":0,
            //         "auctionPrice":0.0,
            //         "auctionVolume":0.0
            //     }
            //
            return this.parseOrderBook (response, symbol, undefined, 'bids', 'asks', 0, 1, market);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pairId': parseInt (market['id']),
            };
            const response = await this.publicGetGetTradeHistory (this.extend (request, params));
            //
            //     {
            //         "trades":[
            //             [4022800,47000,"20210206-21:39:12.886",256323,1],
            //             [4023066,1000,"20210206-21:38:55.030",256322,1],
            //             [4022406,50000,"20210206-21:36:56.334",256321,1],
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'trades', []);
            return this.parseTrades (trades, market, since, limit, params);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     [
            //         4022800,                 // 0 price
            //         47000,                   // 1 quantity
            //         "20210206-21:39:12.886", // 2 timestamp
            //         256323,                  // 3 sequence number
            //         1                        // 4 taker side 1 = buy, 2 = sell
            //     ]
            //
            // private fetchMyTrades
            //
            //     {
            //         "account":3583,
            //         "commission":"-0.015805",
            //         "commCurrency":"USDC",
            //         "execId":265757,
            //         "ordType":"2",
            //         "ordStatus":"2",
            //         "execType":"F",
            //         "aggressorIndicator":true,
            //         "orderId":388953019,
            //         "price":"1842.04",
            //         "qty":"0.010000",
            //         "lastPx":"1756.22",
            //         "avgPx":"1756.22",
            //         "cumQty":"0.010000",
            //         "quoteQty":"0.010000",
            //         "side":"BUY",
            //         "symbol":"ETH/USDC",
            //         "clOrdId":"1613106766970339107",
            //         "submitterId":3583,
            //         "targetStrategy":"0",
            //         "time":1613106766971,
            //         "date":"20210212-05:12:46.971"
            //     }
            //
            let id = undefined;
            let timestamp = undefined;
            let orderId = undefined;
            let type = undefined;
            let side = undefined;
            let priceString = undefined;
            let amountString = undefined;
            let fee = undefined;
            let symbol = undefined;
            if (Array.isArray (trade)) {
                id = this.safeString (trade, 3);
                priceString = this.convertFromScale (this.safeString (trade, 0), market['precision']['price']);
                amountString = this.convertFromScale (this.safeString (trade, 1), market['precision']['amount']);
                timestamp = this.toMilliseconds (this.safeString (trade, 2));
                const takerSide = this.safeInteger (trade, 4);
                if (takerSide === 1) {
                    side = 'buy';
                } else if (takerSide === 2) {
                    side = 'sell';
                }
            } else {
                id = this.safeString (trade, 'execId');
                timestamp = this.safeInteger (trade, 'time');
                const marketId = this.safeString (trade, 'symbol');
                symbol = this.safeSymbol (marketId, market);
                orderId = this.safeString (trade, 'orderId');
                side = this.safeStringLower (trade, 'side');
                type = this.parseOrderType (this.safeString (trade, 'ordType'));
                priceString = this.safeString (trade, 'lastPx');
                amountString = this.safeString (trade, 'qty');
                let feeCost = this.safeNumber (trade, 'commission');
                if (feeCost !== undefined) {
                    feeCost = -feeCost;
                    const feeCurrencyId = this.safeString (trade, 'commCurrency');
                    const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                    fee = {
                        'cost': feeCost,
                        'currency': feeCurrencyCode,
                    };
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const cost = this.parseNumber (Precise.stringMul (amountString, priceString));
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            return {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostGetPositions (params);
            //     {
            //         "positions":[
            //             {
            //                 "instrumentId":1,
            //                 "userId":3583,
            //                 "quantity":0,
            //                 "availableQuantity":0,
            //                 "quantity_scale":6,
            //                 "symbol":"USDC",
            //                 "assetType":"ASSET",
            //                 "usdCostBasis":0.0,
            //                 "usdAvgCostBasis":0.0,
            //                 "usdValue":0.0,
            //                 "usdUnrealized":0.0,
            //                 "usdRealized":0.0,
            //                 "baseUsdMark":1.0,
            //                 "settleCoinUsdMark":0.0,
            //                 "settleCoinUnrealized":0.0,
            //                 "settleCoinRealized":0.0
            //             },
            //         ]
            //     }
            const positions = this.safeValue (response, 'positions', []);
            const result = {
                'info': response,
            };
            for (let i = 0; i < positions.length; i++) {
                const position = positions[i];
                const assetType = this.safeString (position, 'assetType');
                if (assetType === 'ASSET') {
                    const currencyId = this.safeString (position, 'symbol');
                    const code = this.safeCurrencyCode (currencyId);
                    const quantityString = this.safeString (position, 'quantity');
                    const availableQuantityString = this.safeString (position, 'availableQuantity');
                    const scale = this.safeInteger (position, 'quantity_scale');
                    const account = this.account ();
                    account['free'] = this.convertFromScale (availableQuantityString, scale);
                    account['total'] = this.convertFromScale (quantityString, scale);
                    result[code] = account;
                }
            }
            return this.parseBalance (result);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderSide = (side === 'buy') ? 1 : 2;
            const quantityScale = this.getScale (amount);
            const request = {
                // 'id': 0,
                // 'account': 0, // required for institutional users
                'instrumentId': parseInt (market['id']),
                'symbol': market['uppercaseId'],
                // 'clOrdId': '',
                'side': orderSide, // 1 = buy, 2 = sell
                // 'ordType': 1, // 1 = market, 2 = limit, 3 = stop market, 4 = stop limit
                // 'price': this.priceToPrecision (symbol, price), // required for limit and stop limit orders
                // 'price_scale': this.getScale (price),
                'quantity': this.convertToScale (this.numberToString (amount), quantityScale),
                'quantity_scale': quantityScale,
                // 'stopPx': this.priceToPrecision (symbol, stopPx),
                // 'stopPx_scale': this.getScale (stopPx),
                // 'targetStrategy': 0,
                // 'isHidden': false,
                // 'timeInForce': 1, // 1 = Good Till Cancel (GTC), 3 = Immediate or Cancel (IOC), 4 = Fill or Kill (FOK), 5 = Good Till Crossing (GTX), 6 = Good Till Date (GTD)
                // 'interval': 0,
                // 'intervalCount': 0,
                // 'intervalDelay': 0,
                // 'price2': 0,
                // 'price2_scale': this.getScale (price2),
                // 'blockWaitAck': 0, // 1 = wait for order acknowledgement, when set, response will include the matching engine "orderId" field
            };
            if (type === 'market') {
                request['ordType'] = 1;
            } else if (type === 'limit') {
                request['ordType'] = 2;
                const priceScale = this.getScale (price);
                request['price'] = this.convertToScale (this.numberToString (price), priceScale);
                request['priceScale'] = priceScale;
            } else {
                const stopPrice = this.safeNumber2 (params, 'stopPrice', 'stopPx');
                params = this.omit (params, [ 'stopPrice', 'stopPx' ]);
                if (stopPrice === undefined) {
                    if (type === 'stop') {
                        if (price === undefined) {
                            throw new ArgumentsRequired (this.id + ' createOrder() requires a price argument or a stopPrice parameter or a stopPx parameter for ' + type + ' orders');
                        }
                        request['ordType'] = 3;
                        request['stopPx'] = this.convertToScale (this.numberToString (price), this.getScale (price));
                    } else if (type === 'stop limit') {
                        throw new ArgumentsRequired (this.id + ' createOrder() requires a stopPrice parameter or a stopPx parameter for ' + type + ' orders');
                    }
                } else {
                    if (type === 'stop') {
                        request['ordType'] = 3;
                        request['stopPx'] = this.convertToScale (this.numberToString (stopPrice), this.getScale (stopPrice));
                    } else if (type === 'stop limit') {
                        request['ordType'] = 4;
                        const priceScale = this.getScale (price);
                        const stopPriceScale = this.getScale (stopPrice);
                        request['price_scale'] = priceScale;
                        request['stopPx_scale'] = stopPriceScale;
                        request['stopPx'] = this.convertToScale (this.numberToString (stopPrice), stopPriceScale);
                        request['price'] = this.convertToScale (this.numberToString (price), priceScale);
                    }
                }
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            //
            //     {
            //         "status":"sent",
            //         "id":385617863,
            //         "instrumentId":53,
            //         "clOrdId":"1613037510849637345",
            //         "userId":3583,
            //         "price":2000,
            //         "quantity":200,
            //         "ordType":2
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'origOrderId': parseInt (id),
                'instrumentId': parseInt (market['id']),
            };
            const response = await this.privatePostCancelOrder (this.extend (request, params));
            //
            //     {
            //         "status":"sent",
            //         "id":0,
            //         "origOrderId":385613629,
            //         "instrumentId":53,
            //         "userId":3583,
            //         "price":0,
            //         "quantity":0,
            //         "ordType":0
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async editOrder (id, symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderSide = (side === 'buy') ? 1 : 2;
            const quantityScale = this.getScale (amount);
            const request = {
                // 'id': 0,
                'origOrderId': id,
                // 'account': 0, // required for institutional users
                'instrumentId': parseInt (market['id']),
                'symbol': market['uppercaseId'],
                // 'clOrdId': '',
                'side': orderSide, // 1 = buy, 2 = sell
                // 'ordType': 1, // 1 = market, 2 = limit, 3 = stop market, 4 = stop limit
                // 'price': this.priceToPrecision (symbol, price), // required for limit and stop limit orders
                // 'price_scale': this.getScale (price),
                'quantity': this.convertToScale (this.numberToString (amount), quantityScale),
                'quantity_scale': quantityScale,
                // 'stopPx': this.priceToPrecision (symbol, stopPx),
                // 'stopPx_scale': this.getScale (stopPx),
                // 'timeInForce': 1, // 1 = Good Till Cancel (GTC), 3 = Immediate or Cancel (IOC), 4 = Fill or Kill (FOK), 5 = Good Till Crossing (GTX), 6 = Good Till Date (GTD)
            };
            if (type === 'market') {
                request['ordType'] = 1;
            } else if (type === 'limit') {
                request['ordType'] = 2;
                request['price'] = this.convertToScale (this.numberToString (price), this.getScale (price));
            } else {
                const stopPrice = this.safeNumber2 (params, 'stopPrice', 'stopPx');
                params = this.omit (params, [ 'stopPrice', 'stopPx' ]);
                if (stopPrice === undefined) {
                    if (type === 'stop') {
                        if (price === undefined) {
                            throw new ArgumentsRequired (this.id + ' editOrder() requires a price argument or a stopPrice parameter or a stopPx parameter for ' + type + ' orders');
                        }
                        request['ordType'] = 3;
                        request['stopPx'] = this.convertToScale (this.numberToString (price), this.getScale (price));
                    } else if (type === 'stop limit') {
                        throw new ArgumentsRequired (this.id + ' editOrder() requires a stopPrice parameter or a stopPx parameter for ' + type + ' orders');
                    }
                } else {
                    if (type === 'stop') {
                        request['ordType'] = 3;
                        request['stopPx'] = this.convertToScale (this.numberToString (stopPrice), this.getScale (stopPrice));
                    } else if (type === 'stop limit') {
                        request['ordType'] = 4;
                        const priceScale = this.getScale (price);
                        const stopPriceScale = this.getScale (stopPrice);
                        request['price_scale'] = priceScale;
                        request['stopPx_scale'] = stopPriceScale;
                        request['stopPx'] = this.convertToScale (this.numberToString (stopPrice), stopPriceScale);
                        request['price'] = this.convertToScale (this.numberToString (price), priceScale);
                    }
                }
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            //
            //     {
            //         "status":"sent",
            //         "id":385617863,
            //         "instrumentId":53,
            //         "clOrdId":"1613037510849637345",
            //         "userId":3583,
            //         "price":2000,
            //         "quantity":200,
            //         "ordType":2
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderId': parseInt (id),
            };
            const response = await this.privatePostGetOrderStatus (this.extend (request, params));
            //
            //     {
            //         "orderId":388953019,
            //         "clOrdId":"1613106766970339107",
            //         "symbol":"ETH/USDC",
            //         "instrumentId":53,
            //         "side":"1",
            //         "userId":3583,
            //         "account":3583,
            //         "execType":"F",
            //         "ordType":"2",
            //         "ordStatus":"2",
            //         "timeInForce":"3",
            //         "timeStamp":"20210212-05:12:46.971",
            //         "execId":265757,
            //         "targetStrategy":0,
            //         "isHidden":false,
            //         "isReduceOnly":false,
            //         "isLiquidation":false,
            //         "fee":0,
            //         "fee_scale":6,
            //         "feeInstrumentId":1,
            //         "price":184204,
            //         "price_scale":2,
            //         "quantity":10000,
            //         "quantity_scale":6,
            //         "leavesQty":0,
            //         "leavesQty_scale":6,
            //         "cumQty":10000,
            //         "cumQty_scale":6,
            //         "lastPx":175622,
            //         "lastPx_scale":2,
            //         "avgPx":175622,
            //         "avgPx_scale":2,
            //         "lastQty":10000,
            //         "lastQty_scale":6
            //     }
            //
            return this.parseOrder (response);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'ordStatus': '2', // '0' = New, '1' = Partially filled, '2' = Filled, '4' = Cancelled, '8' = Rejected, 'C' = Expired
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchCanceledOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'ordStatus': '4', // '0' = New, '1' = Partially filled, '2' = Filled, '4' = Cancelled, '8' = Rejected, 'C' = Expired
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                // 'account': id, // for institutional users
                // 'symbol': marketSymbol, // cannot be used with instrumentId
                // 'instrumentId': market['numericId'],
                // 'limit': limit,
                // 'execType': execType, // '0' = New, '4' = Canceled, '5' = Replace, '8' = Rejected, 'C' = Expired, 'F' = Fill Status, 'I' = Order Status
                // 'ordStatus': ordStatus, // '0' = New, '1' = Partially filled, '2' = Filled, '4' = Cancelled, '8' = Rejected, 'C' = Expired
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['instrumentId'] = parseInt (market['id']);
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privatePostGetOrders (this.extend (request, params));
            //
            //     {
            //         "isInitialSnap":false,
            //         "orders":[
            //             {
            //                 "orderId":385613629,
            //                 "orderUpdateSeq":1,
            //                 "clOrdId":"1613037448945798198",
            //                 "symbol":"ETH/USDC",
            //                 "instrumentId":53,
            //                 "side":"1",
            //                 "userId":3583,
            //                 "account":3583,
            //                 "execType":"4",
            //                 "ordType":"2",
            //                 "ordStatus":"C",
            //                 "timeInForce":"3",
            //                 "timeStamp":"20210211-09:57:28.944",
            //                 "execId":0,
            //                 "targetStrategy":0,
            //                 "isHidden":false,
            //                 "isReduceOnly":false,
            //                 "isLiquidation":false,
            //                 "fee":0,
            //                 "feeTotal":0,
            //                 "fee_scale":0,
            //                 "feeInstrumentId":0,
            //                 "price":999,
            //                 "price_scale":2,
            //                 "quantity":10000000,
            //                 "quantity_scale":6,
            //                 "leavesQty":10000000,
            //                 "leavesQty_scale":6,
            //                 "cumQty":0,
            //                 "cumQty_scale":0,
            //                 "lastPx":0,
            //                 "lastPx_scale":2,
            //                 "avgPx":0,
            //                 "avgPx_scale":0,
            //                 "lastQty":0,
            //                 "lastQty_scale":6
            //             }
            //         ]
            //     }
            //
            const orders = this.safeValue (response, 'orders', []);
            return this.parseOrders (orders, market, since, limit, params);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'account': 123, // for institutional users
                // 'instrumentId': market['id'],
                // 'startTime': since,
                // 'endTime': this.milliseconds (),
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['instrumentId'] = market['id'];
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            const response = await this.privatePostUserTrades (this.extend (request, params));
            //
            //     {
            //         "trades":[
            //             {
            //                 "account":3583,
            //                 "commission":"-0.015805",
            //                 "commCurrency":"USDC",
            //                 "execId":265757,
            //                 "ordType":"2",
            //                 "ordStatus":"2",
            //                 "execType":"F",
            //                 "aggressorIndicator":true,
            //                 "orderId":388953019,
            //                 "price":"1842.04",
            //                 "qty":"0.010000",
            //                 "lastPx":"1756.22",
            //                 "avgPx":"1756.22",
            //                 "cumQty":"0.010000",
            //                 "quoteQty":"0.010000",
            //                 "side":"BUY",
            //                 "symbol":"ETH/USDC",
            //                 "clOrdId":"1613106766970339107",
            //                 "submitterId":3583,
            //                 "targetStrategy":"0",
            //                 "time":1613106766971,
            //                 "date":"20210212-05:12:46.971"
            //             }
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'trades', []);
            return this.parseTrades (trades, market, since, limit, params);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'instrumentId': parseInt (currency['id']),
            };
            const response = await this.privatePostGetDepositAddresses (this.extend (request, params));
            //
            //     {
            //         "addresses":[
            //             {"instrumentId":1,"userId":3583,"symbol":"USDC","address":"0xdff47af071ea3c537e57278290516cda32a78b97","status":1}
            //         ]
            //     }
            //
            const addresses = this.safeValue (response, 'addresses', []);
            const address = this.safeValue (addresses, 0);
            return this.parseDepositAddress (address, currency);
        }
    
        parseDepositAddress (depositAddress, currency = undefined) {
            //
            //     {
            //         "instrumentId":1,
            //         "userId":3583,
            //         "symbol":"USDC",
            //         "address":"0xdff47af071ea3c537e57278290516cda32a78b97",
            //         "status":1
            //     }
            //
            const currencyId = this.safeString (depositAddress, 'symbol');
            const code = this.safeCurrencyCode (currencyId, currency);
            const address = this.safeString (depositAddress, 'address');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': depositAddress,
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['instrumentId'] = parseInt (currency['id']);
            }
            const response = await this.privatePostGetDepositHistory (this.extend (request, params));
            //
            //     {
            //         "deposits":[
            //             {
            //                 "id":4309,
            //                 "instrumentId":1,
            //                 "userId":3583,
            //                 "symbol":"USDC",
            //                 "address":"null",
            //                 "timestamp":"1613021112189",
            //                 "status":1,
            //                 "balance":0.0,
            //                 "balance_change":100.0,
            //                 "confirms":1,
            //                 "transactionId":"caba4500-489f-424e-abd7-b4dabc09a800"
            //             }
            //         ]
            //     }
            //
            const deposits = this.safeValue (response, 'deposits', []);
            return this.parseTransactions (deposits, currency, since, limit, { 'type': 'deposit' });
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['instrumentId'] = parseInt (currency['id']);
            }
            const response = await this.privatePostGetWithdrawRequests (this.extend (request, params));
            //
            //     {
            //         "addresses":[
            //             {
            //                 "id":3841,
            //                 "instrumentId":3,
            //                 "userId":4245,
            //                 "symbol":"BTC",
            //                 "address":"XXXXXYYYYYZZZZZ",
            //                 "timestamp":"20200806-11:04:35.053",
            //                 "status":0,
            //                 "balance":1,
            //                 "balance_scale":3,
            //                 "confirms":0,
            //                 "transactionId":"null"
            //             }
            //         ]
            //     }
            //
            const withdrawals = this.safeValue (response, 'addresses', []);
            return this.parseTransactions (withdrawals, currency, since, limit, { 'type': 'withdrawal' });
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits, fetchWithdrawals
            //
            //     {
            //         "id":4309,
            //         "instrumentId":1,
            //         "userId":3583,
            //         "symbol":"USDC",
            //         "address":"null",
            //         "timestamp":"1613021112189",
            //         "status":1,
            //         "balance":0.0,
            //         "balance_change":100.0,
            //         "confirms":1,
            //         "transactionId":"caba4500-489f-424e-abd7-b4dabc09a800"
            //     }
            //
            // withdraw
            //
            //     {
            //         "instrumentId": 1,
            //         "userId": 23750,
            //         "symbol": "USDC",
            //         "timestamp": "20200201-05:37:16.584",
            //         "status": 1,
            //         "userUuid": "b9e33713-c28f-468f-99bd-f6deab0dd854",
            //         "currencyCode": "USDC",
            //         "address": "2MvW97yT6E2Kq8bWc1aj1DqfbgMzjRNk2LE",
            //         "quantity": 20,
            //         "requestUuid": "56782b34-8a78-4f5f-b164-4b8f7d583b7f",
            //         "transactionUuid": "1004eb0f-41e1-41e9-9d48-8eefcc6c09f2",
            //         "transactionId": "WS23436",
            //         "destinationWalletAlias": "Test",
            //         "quantity_scale": 0
            //     }
            //
            const id = this.safeString (transaction, 'id', 'transactionId');
            const txid = this.safeString (transaction, 'transactionUuid');
            const timestamp = this.safeInteger (transaction, 'timestamp');
            let address = this.safeString (transaction, 'address');
            if (address === 'null') {
                address = undefined;
            }
            const type = this.safeString (transaction, 'type');
            let amount = this.safeNumber (transaction, 'balance_change');
            if (amount === undefined) {
                amount = this.safeString (transaction, 'quantity');
                const amountScale = this.safeInteger (transaction, 'quantity_scale');
                amount = this.parseNumber (this.convertFromScale (amount, amountScale));
            }
            const currencyId = this.safeString (transaction, 'symbol');
            const code = this.safeCurrencyCode (currencyId, currency);
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': undefined,
                'address': address,
                'addressTo': undefined,
                'tagFrom': undefined,
                'tag': undefined,
                'tagTo': undefined,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'comment': undefined,
                'fee': undefined,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                '0': 'pending',
                '1': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const scale = this.getScale (amount);
            const quantity = this.convertToScale (amount, scale);
            const request = {
                'instrumentId': parseInt (currency['id']),
                'symbol': currency['uppercaseId'],
                'quantity': quantity,
                'quantity_scale': scale,
                'address': address,
            };
            const response = await this.privatePostSendWithdrawRequest (this.extend (request, params));
            //
            //     {
            //         "instrumentId": 1,
            //         "userId": 23750,
            //         "symbol": "USDC",
            //         "timestamp": "20200201-05:37:16.584",
            //         "status": 1,
            //         "userUuid": "b9e33713-c28f-468f-99bd-f6deab0dd854",
            //         "currencyCode": "USDC",
            //         "address": "2MvW97yT6E2Kq8bWc1aj1DqfbgMzjRNk2LE",
            //         "quantity": 20,
            //         "requestUuid": "56782b34-8a78-4f5f-b164-4b8f7d583b7f",
            //         "transactionUuid": "1004eb0f-41e1-41e9-9d48-8eefcc6c09f2",
            //         "transactionId": "WS23436",
            //         "destinationWalletAlias": "Test",
            //         "quantity_scale": 0
            //     }
            //
            return this.parseTransaction (response, currency);
        }
    
        async fetchTradingFees (params = {}) {
            // getExchangeInfo
            const response = await this.publicGetGetExchangeInfo (params);
            const tradingFees = this.safeValue (response, 'spotFees', []);
            const taker = {};
            const maker = {};
            for (let i = 0; i < tradingFees.length; i++) {
                const tradingFee = tradingFees[i];
                if (this.safeString (tradingFee, 'tier') !== undefined) {
                    taker[tradingFee['tier']] = this.safeNumber (tradingFee, 'taker');
                    maker[tradingFee['tier']] = this.safeNumber (tradingFee, 'maker');
                }
            }
            return {
                'info': tradingFees,
                'tierBased': true,
                'maker': maker,
                'taker': taker,
            };
        }
    
        async fetchTradingLimits (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            // getExchangeInfo
            const response = await this.publicGetGetExchangeInfo (params);
            const tradingLimits = this.safeValue (response, 'tradingLimits', []);
            // To-do parsing response when available
            return {
                'info': tradingLimits,
                'limits': {
                    'amount': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'price': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                },
            };
        }
    
        async fetchFundingLimits (params = {}) {
            // getExchangeInfo
            const response = await this.publicGetGetExchangeInfo (params);
            const withdrawLimits = this.safeValue (response, 'withdrawLimits', []);
            // TO-DO parse response when available
            return {
                'info': withdrawLimits,
                'withdraw': undefined,
            };
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder, editOrder, cancelOrder
            //
            //     {
            //         "status":"sent",
            //         "id":385617863,
            //         "instrumentId":53,
            //         "clOrdId":"1613037510849637345",
            //         "userId":3583,
            //         "price":2000,
            //         "quantity":200,
            //         "ordType":2
            //     }
            //
            // fetchOrders, fetchOrder
            //
            //     {
            //         "orderId":385613629,
            //         "orderUpdateSeq":1,
            //         "clOrdId":"1613037448945798198",
            //         "symbol":"ETH/USDC",
            //         "instrumentId":53,
            //         "side":"1",
            //         "userId":3583,
            //         "account":3583,
            //         "execType":"4",
            //         "ordType":"2",
            //         "ordStatus":"C",
            //         "timeInForce":"3",
            //         "timeStamp":"20210211-09:57:28.944",
            //         "execId":0,
            //         "targetStrategy":0,
            //         "isHidden":false,
            //         "isReduceOnly":false,
            //         "isLiquidation":false,
            //         "fee":0,
            //         "feeTotal":0,
            //         "fee_scale":0,
            //         "feeInstrumentId":0,
            //         "price":999,
            //         "price_scale":2,
            //         "quantity":10000000,
            //         "quantity_scale":6,
            //         "leavesQty":10000000,
            //         "leavesQty_scale":6,
            //         "cumQty":0,
            //         "cumQty_scale":0,
            //         "lastPx":0,
            //         "lastPx_scale":2,
            //         "avgPx":0,
            //         "avgPx_scale":0,
            //         "lastQty":0,
            //         "lastQty_scale":6
            //     }
            //
            let id = this.safeString2 (order, 'orderId', 'id');
            id = this.safeString (order, 'origOrderId', id);
            const clientOrderId = this.safeString (order, 'clOrdId');
            const type = this.parseOrderType (this.safeString (order, 'ordType'));
            const side = this.parseOrderSide (this.safeString (order, 'side'));
            const status = this.parseOrderStatus (this.safeString (order, 'ordStatus'));
            const marketId = this.safeString (order, 'instrumentId');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.toMilliseconds (this.safeString (order, 'timeStamp'));
            const lastTradeTimestamp = undefined;
            const priceString = this.safeString (order, 'price');
            const priceScale = this.safeInteger (order, 'price_scale');
            const price = this.parseNumber (this.convertFromScale (priceString, priceScale));
            const amountString = this.safeString (order, 'quantity');
            const amountScale = this.safeInteger (order, 'quantity_scale');
            const amount = this.parseNumber (this.convertFromScale (amountString, amountScale));
            const filledString = this.safeString (order, 'cumQty');
            const filledScale = this.safeInteger (order, 'cumQty_scale');
            const filled = this.parseNumber (this.convertFromScale (filledString, filledScale));
            const remainingString = this.safeString (order, 'leavesQty');
            const remainingScale = this.safeInteger (order, 'leavesQty_scale');
            const remaining = this.parseNumber (this.convertFromScale (remainingString, remainingScale));
            let fee = undefined;
            const currencyId = this.safeInteger (order, 'feeInstrumentId');
            const feeCurrencyCode = this.safeCurrencyCode (currencyId);
            let feeCost = this.safeString (order, 'feeTotal');
            const feeScale = this.safeInteger (order, 'fee_scale');
            if (feeCost !== undefined) {
                feeCost = Precise.stringNeg (feeCost);
                feeCost = this.parseNumber (this.convertFromScale (feeCost, feeScale));
            }
            if (feeCost !== undefined) {
                fee = {
                    'currency': feeCurrencyCode,
                    'cost': feeCost,
                    'rate': undefined,
                };
            }
            let timeInForce = this.parseTimeInForce (this.safeString (order, 'timeInForce'));
            if (timeInForce === '0') {
                timeInForce = undefined;
            }
            const stopPriceScale = this.safeInteger (order, 'stopPx_scale', 0);
            const stopPrice = this.parseNumber (this.convertFromScale (this.safeString (order, 'stopPx'), stopPriceScale));
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': undefined,
                'average': undefined,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '0': 'open',
                '1': 'open', // 'partially filled',
                '2': 'closed', // 'filled',
                '3': 'open', // 'done for day',
                '4': 'canceled',
                '5': 'canceled', // 'replaced',
                '6': 'canceling', // 'pending cancel',
                '7': 'canceled', // 'stopped',
                '8': 'rejected', // 'rejected',
                '9': 'canceled', // 'suspended',
                'A': 'open', // 'pending new',
                'B': 'open', // 'calculated',
                'C': 'expired',
                'D': 'open', // 'accepted for bidding',
                'E': 'canceling', // 'pending replace',
                'F': 'open', // 'partial fill or fill',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrderSide (side) {
            const sides = {
                '1': 'buy',
                '2': 'sell',
            };
            return this.safeString (sides, side, side);
        }
    
        parseOrderType (type) {
            const types = {
                '1': 'market',
                '2': 'limit',
                '3': 'stop',
                '4': 'stop limit',
            };
            return this.safeString (types, type, type);
        }
    
        parseTimeInForce (timeInForce) {
            const timeInForces = {
                '1': 'GTC', // Good Till Canceled
                '3': 'IOC', // Immediate or Cancel
                '4': 'FOK', // Fill or Kill
                '5': 'GTX', // Good Till Crossing (GTX)
                '6': 'GTD', // Good Till Date
            };
            return this.safeString (timeInForces, timeInForce, timeInForce);
        }
    
        toMilliseconds (dateString) {
            if (dateString === undefined) {
                return dateString;
            }
            // '20200328-10:31:01.575' -> '2020-03-28 12:42:48.000'
            const splits = dateString.split ('-');
            const partOne = this.safeString (splits, 0);
            const partTwo = this.safeString (splits, 1);
            if (partOne === undefined || partTwo === undefined) {
                return undefined;
            }
            if (partOne.length !== 8) {
                return undefined;
            }
            const date = partOne.slice (0, 4) + '-' + partOne.slice (4, 6) + '-' + partOne.slice (6, 8);
            return this.parse8601 (date + ' ' + partTwo);
        }
    
        convertFromScale (number, scale) {
            if ((number === undefined) || (scale === undefined)) {
                return undefined;
            }
            const precise = new Precise (number);
            precise.decimals = precise.decimals + scale;
            precise.reduce ();
            return precise.toString ();
        }
    
        getScale (num) {
            const s = this.numberToString (num);
            return this.precisionFromString (s);
        }
    
        convertToScale (number, scale) {
            if ((number === undefined) || (scale === undefined)) {
                return undefined;
            }
            const precise = new Precise (number);
            precise.decimals = precise.decimals - scale;
            precise.reduce ();
            const preciseString = precise.toString ();
            return parseInt (preciseString);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            const error = this.safeString (response, 'error');
            if (error !== undefined) {
                const feedback = this.id + ' ' + body;
                this.throwExactlyMatchedException (this.exceptions, error, feedback);
                this.throwBroadlyMatchedException (this.exceptions, body, feedback);
                throw new ExchangeError (this.id + ' ' + body);
            }
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.implodeParams (path, params);
            let query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else if (api === 'private') {
                // special case for getUserHistory
                const format = this.safeValue (params, 'format');
                const type = this.safeValue (params, 'type');
                const extension = {};
                if (format !== undefined) {
                    extension['format'] = format;
                }
                if (type !== undefined) {
                    extension['type'] = type;
                }
                if (Object.keys (extension).length) {
                    url += '?' + this.urlencode (extension);
                }
                params = this.omit (params, [ 'format', 'type' ]);
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                query = this.extend (query, {
                    'userId': this.uid,
                    'nonce': nonce,
                });
                params['nonce'] = this.nonce ();
                body = this.json (query);
                const signature = this.hmac (this.encode (body), this.encode (this.secret), 'sha384');
                headers = {
                    'Content-Type': 'application/json',
                    'requestToken': this.apiKey,
                    'signature': signature,
                };
            }
            url = this.urls['api'][api] + '/' + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],77:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const eqonex = require ('./eqonex.js');
    
    // ----------------------------------------------------------------------------
    
    module.exports = class equos extends eqonex {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'equos',
                'name': 'EQUOS',
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/107758499-05edd180-6d38-11eb-9e09-0b69602a7a15.jpg',
                },
            });
        }
    };
    
    },{"./eqonex.js":76}],78:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ArgumentsRequired, ExchangeError, OrderNotFound, AuthenticationError, InsufficientFunds, InvalidOrder, InvalidNonce, NotSupported, OnMaintenance, RateLimitExceeded, BadRequest, PermissionDenied } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class exmo extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'exmo',
                'name': 'EXMO',
                'countries': [ 'ES', 'RU' ], // Spain, Russia
                'rateLimit': 350, // once every 350 ms ≈ 180 requests per minute ≈ 3 requests per second
                'version': 'v1.1',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchFundingFees': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': 'emulated',
                    'fetchOrderBook': true,
                    'fetchOrderBooks': true,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTradingFee': true,
                    'fetchTradingFees': true,
                    'fetchTransactions': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1',
                    '5m': '5',
                    '15m': '15',
                    '30m': '30',
                    '45m': '45',
                    '1h': '60',
                    '2h': '120',
                    '3h': '180',
                    '4h': '240',
                    '1d': 'D',
                    '1w': 'W',
                    '1M': 'M',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766491-1b0ea956-5eda-11e7-9225-40d67b481b8d.jpg',
                    'api': {
                        'public': 'https://api.exmo.com',
                        'private': 'https://api.exmo.com',
                        'web': 'https://exmo.me',
                    },
                    'www': 'https://exmo.me',
                    'referral': 'https://exmo.me/?ref=131685',
                    'doc': [
                        'https://exmo.me/en/api_doc?ref=131685',
                        'https://github.com/exmo-dev/exmo_api_lib/tree/master/nodejs',
                    ],
                    'fees': 'https://exmo.com/en/docs/fees',
                },
                'api': {
                    'web': {
                        'get': [
                            'ctrl/feesAndLimits',
                            'en/docs/fees',
                        ],
                    },
                    'public': {
                        'get': [
                            'currency',
                            'currency/list/extended',
                            'order_book',
                            'pair_settings',
                            'ticker',
                            'trades',
                            'candles_history',
                            'required_amount',
                            'payments/providers/crypto/list',
                        ],
                    },
                    'private': {
                        'post': [
                            'user_info',
                            'order_create',
                            'order_cancel',
                            'stop_market_order_create',
                            'stop_market_order_cancel',
                            'user_open_orders',
                            'user_trades',
                            'user_cancelled_orders',
                            'order_trades',
                            'deposit_address',
                            'withdraw_crypt',
                            'withdraw_get_txid',
                            'excode_create',
                            'excode_load',
                            'code_check',
                            'wallet_history',
                            'wallet_operations',
                            'margin/user/order/create',
                            'margin/user/order/update',
                            'margin/user/order/cancel',
                            'margin/user/position/close',
                            'margin/user/position/margin_add',
                            'margin/user/position/margin_remove',
                            'margin/currency/list',
                            'margin/pair/list',
                            'margin/settings',
                            'margin/funding/list',
                            'margin/user/info',
                            'margin/user/order/list',
                            'margin/user/order/history',
                            'margin/user/order/trades',
                            'margin/user/order/max_quantity',
                            'margin/user/position/list',
                            'margin/user/position/margin_remove_info',
                            'margin/user/position/margin_add_info',
                            'margin/user/wallet/list',
                            'margin/user/wallet/history',
                            'margin/user/trade/list',
                            'margin/trades',
                            'margin/liquidation/feed',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'tierBased': false,
                        'percentage': true,
                        'maker': this.parseNumber ('0.002'),
                        'taker': this.parseNumber ('0.002'),
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': false, // fixed funding fees for crypto, see fetchFundingFees below
                    },
                },
                'exceptions': {
                    'exact': {
                        '40005': AuthenticationError, // Authorization error, incorrect signature
                        '40009': InvalidNonce, //
                        '40015': ExchangeError, // API function do not exist
                        '40016': OnMaintenance, // {"result":false,"error":"Error 40016: Maintenance work in progress"}
                        '40017': AuthenticationError, // Wrong API Key
                        '40032': PermissionDenied, // {"result":false,"error":"Error 40032: Access is denied for this API key"}
                        '40033': PermissionDenied, // {"result":false,"error":"Error 40033: Access is denied, this resources are temporarily blocked to user"}
                        '40034': RateLimitExceeded, // {"result":false,"error":"Error 40034: Access is denied, rate limit is exceeded"}
                        '50052': InsufficientFunds,
                        '50054': InsufficientFunds,
                        '50304': OrderNotFound, // "Order was not found '123456789'" (fetching order trades for an order that does not have trades yet)
                        '50173': OrderNotFound, // "Order with id X was not found." (cancelling non-existent, closed and cancelled order)
                        '50277': InvalidOrder,
                        '50319': InvalidOrder, // Price by order is less than permissible minimum for this pair
                        '50321': InvalidOrder, // Price by order is more than permissible maximum for this pair
                        '50381': InvalidOrder, // {"result":false,"error":"Error 50381: More than 2 decimal places are not permitted for pair BTC_USD"}
                    },
                    'broad': {
                        'range period is too long': BadRequest,
                        'invalid syntax': BadRequest,
                        'API rate limit exceeded': RateLimitExceeded, // {"result":false,"error":"API rate limit exceeded for x.x.x.x. Retry after 60 sec.","history":[],"begin":1579392000,"end":1579478400}
                    },
                },
            });
        }
    
        async fetchTradingFees (params = {}) {
            if (this.options['useWebapiForFetchingFees']) {
                const response = await this.webGetEnDocsFees (params);
                let parts = response.split ('<td class="th_fees_2" colspan="2">');
                let numParts = parts.length;
                if (numParts !== 2) {
                    throw new NotSupported (this.id + ' fetchTradingFees format has changed');
                }
                const rest = parts[1];
                parts = rest.split ('</td>');
                numParts = parts.length;
                if (numParts < 2) {
                    throw new NotSupported (this.id + ' fetchTradingFees format has changed');
                }
                const fee = parseFloat (parts[0].replace ('%', '')) * 0.01;
                const taker = fee;
                const maker = fee;
                return {
                    // 'info': response,
                    'maker': maker,
                    'taker': taker,
                };
            } else {
                return {
                    'maker': this.fees['trading']['maker'],
                    'taker': this.fees['trading']['taker'],
                };
            }
        }
    
        parseFixedFloatValue (input) {
            if ((input === undefined) || (input === '-')) {
                return undefined;
            }
            if (input === '') {
                return 0;
            }
            const isPercentage = (input.indexOf ('%') >= 0);
            const parts = input.split (' ');
            const value = parts[0].replace ('%', '');
            const result = parseFloat (value);
            if ((result > 0) && isPercentage) {
                throw new ExchangeError (this.id + ' parseFixedFloatValue detected an unsupported non-zero percentage-based fee ' + input);
            }
            return result;
        }
    
        async fetchFundingFees (params = {}) {
            await this.loadMarkets ();
            const currencyList = await this.publicGetCurrencyListExtended (params);
            //
            //     [
            //         {"name":"VLX","description":"Velas"},
            //         {"name":"RUB","description":"Russian Ruble"},
            //         {"name":"BTC","description":"Bitcoin"},
            //         {"name":"USD","description":"US Dollar"}
            //     ]
            //
            const cryptoList = await this.publicGetPaymentsProvidersCryptoList (params);
            //
            //     {
            //         "BTC":[
            //             { "type":"deposit", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.001 BTC. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
            //             { "type":"withdraw", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"350", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.0005 BTC", "currency_confirmations":6 }
            //         ],
            //         "ETH":[
            //             { "type":"withdraw", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"500", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.004 ETH", "currency_confirmations":4 },
            //             { "type":"deposit", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.01 ETH. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 }
            //         ],
            //         "USDT":[
            //             { "type":"deposit", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":false,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
            //             { "type":"withdraw", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":false,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"5 USDT", "currency_confirmations":6 },
            //             { "type":"deposit", "name":"USDT (ERC20)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
            //             {
            //                 "type":"withdraw",
            //                 "name":"USDT (ERC20)",
            //                 "currency_name":"USDT",
            //                 "min":"55",
            //                 "max":"200000",
            //                 "enabled":true,
            //                 "comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Recommendation: Due to the high load of ERC20 network, using TRC20 address for withdrawal is recommended.",
            //                 "commission_desc":"10 USDT",
            //                 "currency_confirmations":6
            //             },
            //             { "type":"deposit", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":true,"comment":"Minimum deposit amount is 10 USDT. Only TRON main network supported", "commission_desc":"0%", "currency_confirmations":2 },
            //             { "type":"withdraw", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"150000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Only TRON main network supported.", "commission_desc":"1 USDT", "currency_confirmations":6 }
            //         ],
            //         "XLM":[
            //             { "type":"deposit", "name":"XLM", "currency_name":"XLM", "min":"1", "max":"1000000", "enabled":true,"comment":"Attention! A deposit without memo(invoice) will not be credited. Minimum deposit amount is 1 XLM. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
            //             { "type":"withdraw", "name":"XLM", "currency_name":"XLM", "min":"21", "max":"1000000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales.", "commission_desc":"0.01 XLM", "currency_confirmations":1 }
            //         ],
            //     }
            //
            const result = {
                'info': cryptoList,
                'withdraw': {},
                'deposit': {},
            };
            for (let i = 0; i < currencyList.length; i++) {
                const currency = currencyList[i];
                const currencyId = this.safeString (currency, 'name');
                const code = this.safeCurrencyCode (currencyId);
                const providers = this.safeValue (cryptoList, currencyId, []);
                for (let j = 0; j < providers.length; j++) {
                    const provider = providers[j];
                    const type = this.safeString (provider, 'type');
                    const commissionDesc = this.safeString (provider, 'commission_desc');
                    const newFee = this.parseFixedFloatValue (commissionDesc);
                    const previousFee = this.safeNumber (result[type], code);
                    if ((previousFee === undefined) || ((newFee !== undefined) && (newFee < previousFee))) {
                        result[type][code] = newFee;
                    }
                }
            }
            // cache them for later use
            this.options['fundingFees'] = result;
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            //
            const currencyList = await this.publicGetCurrencyListExtended (params);
            //
            //     [
            //         {"name":"VLX","description":"Velas"},
            //         {"name":"RUB","description":"Russian Ruble"},
            //         {"name":"BTC","description":"Bitcoin"},
            //         {"name":"USD","description":"US Dollar"}
            //     ]
            //
            const cryptoList = await this.publicGetPaymentsProvidersCryptoList (params);
            //
            //     {
            //         "BTC":[
            //             { "type":"deposit", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.001 BTC. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
            //             { "type":"withdraw", "name":"BTC", "currency_name":"BTC", "min":"0.001", "max":"350", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.0005 BTC", "currency_confirmations":6 }
            //         ],
            //         "ETH":[
            //             { "type":"withdraw", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"500", "enabled":true,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"0.004 ETH", "currency_confirmations":4 },
            //             { "type":"deposit", "name":"ETH", "currency_name":"ETH", "min":"0.01", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 0.01 ETH. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 }
            //         ],
            //         "USDT":[
            //             { "type":"deposit", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":false,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
            //             { "type":"withdraw", "name":"USDT (OMNI)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":false,"comment":"Do not withdraw directly to the Crowdfunding or ICO address as your account will not be credited with tokens from such sales.", "commission_desc":"5 USDT", "currency_confirmations":6 },
            //             { "type":"deposit", "name":"USDT (ERC20)", "currency_name":"USDT", "min":"10", "max":"0", "enabled":true,"comment":"Minimum deposit amount is 10 USDT", "commission_desc":"0%", "currency_confirmations":2 },
            //             {
            //                 "type":"withdraw",
            //                 "name":"USDT (ERC20)",
            //                 "currency_name":"USDT",
            //                 "min":"55",
            //                 "max":"200000",
            //                 "enabled":true,
            //                 "comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Recommendation: Due to the high load of ERC20 network, using TRC20 address for withdrawal is recommended.",
            //                 "commission_desc":"10 USDT",
            //                 "currency_confirmations":6
            //             },
            //             { "type":"deposit", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"100000", "enabled":true,"comment":"Minimum deposit amount is 10 USDT. Only TRON main network supported", "commission_desc":"0%", "currency_confirmations":2 },
            //             { "type":"withdraw", "name":"USDT (TRC20)", "currency_name":"USDT", "min":"10", "max":"150000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales. Only TRON main network supported.", "commission_desc":"1 USDT", "currency_confirmations":6 }
            //         ],
            //         "XLM":[
            //             { "type":"deposit", "name":"XLM", "currency_name":"XLM", "min":"1", "max":"1000000", "enabled":true,"comment":"Attention! A deposit without memo(invoice) will not be credited. Minimum deposit amount is 1 XLM. We do not support BSC and BEP20 network, please consider this when sending funds", "commission_desc":"0%", "currency_confirmations":1 },
            //             { "type":"withdraw", "name":"XLM", "currency_name":"XLM", "min":"21", "max":"1000000", "enabled":true,"comment":"Caution! Do not withdraw directly to a crowdfund or ICO address, as your account will not be credited with tokens from such sales.", "commission_desc":"0.01 XLM", "currency_confirmations":1 }
            //         ],
            //     }
            //
            const result = {};
            for (let i = 0; i < currencyList.length; i++) {
                const currency = currencyList[i];
                const currencyId = this.safeString (currency, 'name');
                const name = this.safeString (currency, 'description');
                const providers = this.safeValue (cryptoList, currencyId);
                let active = false;
                let type = 'crypto';
                const limits = {
                    'deposit': {
                        'min': undefined,
                        'max': undefined,
                    },
                    'withdraw': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                let fee = undefined;
                if (providers === undefined) {
                    active = true;
                    type = 'fiat';
                } else {
                    for (let j = 0; j < providers.length; j++) {
                        const provider = providers[j];
                        const type = this.safeString (provider, 'type');
                        const minValue = this.safeNumber (provider, 'min');
                        let maxValue = this.safeNumber (provider, 'max');
                        if (maxValue === 0.0) {
                            maxValue = undefined;
                        }
                        const activeProvider = this.safeValue (provider, 'enabled');
                        if (activeProvider) {
                            active = true;
                            if ((limits[type]['min'] === undefined) || (minValue < limits[type]['min'])) {
                                limits[type]['min'] = minValue;
                                limits[type]['max'] = maxValue;
                                if (type === 'withdraw') {
                                    const commissionDesc = this.safeString (provider, 'commission_desc');
                                    fee = this.parseFixedFloatValue (commissionDesc);
                                }
                            }
                        }
                    }
                }
                const code = this.safeCurrencyCode (currencyId);
                result[code] = {
                    'id': currencyId,
                    'code': code,
                    'name': name,
                    'type': type,
                    'active': active,
                    'fee': fee,
                    'precision': 8,
                    'limits': limits,
                    'info': providers,
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetPairSettings (params);
            //
            //     {
            //         "BTC_USD":{
            //             "min_quantity":"0.0001",
            //             "max_quantity":"1000",
            //             "min_price":"1",
            //             "max_price":"30000",
            //             "max_amount":"500000",
            //             "min_amount":"1",
            //             "price_precision":8,
            //             "commission_taker_percent":"0.4",
            //             "commission_maker_percent":"0.4"
            //         },
            //     }
            //
            const keys = Object.keys (response);
            const result = [];
            for (let i = 0; i < keys.length; i++) {
                const id = keys[i];
                const market = response[id];
                const symbol = id.replace ('_', '/');
                const [ baseId, quoteId ] = symbol.split ('/');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const takerString = this.safeString (market, 'commission_taker_percent');
                const makerString = this.safeString (market, 'commission_maker_percent');
                const taker = this.parseNumber (Precise.stringDiv (takerString, '100'));
                const maker = this.parseNumber (Precise.stringDiv (makerString, '100'));
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'taker': taker,
                    'maker': maker,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'min_quantity'),
                            'max': this.safeNumber (market, 'max_quantity'),
                        },
                        'price': {
                            'min': this.safeNumber (market, 'min_price'),
                            'max': this.safeNumber (market, 'max_price'),
                        },
                        'cost': {
                            'min': this.safeNumber (market, 'min_amount'),
                            'max': this.safeNumber (market, 'max_amount'),
                        },
                    },
                    'precision': {
                        'amount': 8,
                        'price': this.safeInteger (market, 'price_precision'),
                    },
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'resolution': this.timeframes[timeframe],
            };
            const options = this.safeValue (this.options, 'fetchOHLCV');
            const maxLimit = this.safeInteger (options, 'maxLimit', 3000);
            const duration = this.parseTimeframe (timeframe);
            const now = this.milliseconds ();
            if (since === undefined) {
                if (limit === undefined) {
                    throw new ArgumentsRequired (this.id + ' fetchOHLCV() requires a since argument or a limit argument');
                } else {
                    if (limit > maxLimit) {
                        throw new BadRequest (this.id + ' fetchOHLCV will serve ' + maxLimit.toString () + ' candles at most');
                    }
                    request['from'] = parseInt (now / 1000) - limit * duration - 1;
                    request['to'] = parseInt (now / 1000);
                }
            } else {
                request['from'] = parseInt (since / 1000) - 1;
                if (limit === undefined) {
                    request['to'] = parseInt (now / 1000);
                } else {
                    if (limit > maxLimit) {
                        throw new BadRequest (this.id + ' fetchOHLCV will serve ' + maxLimit.toString () + ' candles at most');
                    }
                    const to = this.sum (since, limit * duration * 1000);
                    request['to'] = parseInt (to / 1000);
                }
            }
            const response = await this.publicGetCandlesHistory (this.extend (request, params));
            //
            //     {
            //         "candles":[
            //             {"t":1584057600000,"o":0.02235144,"c":0.02400233,"h":0.025171,"l":0.02221,"v":5988.34031761},
            //             {"t":1584144000000,"o":0.0240373,"c":0.02367413,"h":0.024399,"l":0.0235,"v":2027.82522329},
            //             {"t":1584230400000,"o":0.02363458,"c":0.02319242,"h":0.0237948,"l":0.02223196,"v":1707.96944997},
            //         ]
            //     }
            //
            const candles = this.safeValue (response, 'candles', []);
            return this.parseOHLCVs (candles, market, timeframe, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "t":1584057600000,
            //         "o":0.02235144,
            //         "c":0.02400233,
            //         "h":0.025171,
            //         "l":0.02221,
            //         "v":5988.34031761
            //     }
            //
            return [
                this.safeInteger (ohlcv, 't'),
                this.safeNumber (ohlcv, 'o'),
                this.safeNumber (ohlcv, 'h'),
                this.safeNumber (ohlcv, 'l'),
                this.safeNumber (ohlcv, 'c'),
                this.safeNumber (ohlcv, 'v'),
            ];
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostUserInfo (params);
            //
            //     {
            //         "uid":131685,
            //         "server_date":1628999600,
            //         "balances":{
            //             "EXM":"0",
            //             "USD":"0",
            //             "EUR":"0",
            //             "GBP":"0",
            //         },
            //     }
            //
            const result = { 'info': response };
            const free = this.safeValue (response, 'balances', {});
            const used = this.safeValue (response, 'reserved', {});
            const currencyIds = Object.keys (free);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                if (currencyId in free) {
                    account['free'] = this.safeString (free, currencyId);
                }
                if (currencyId in used) {
                    account['used'] = this.safeString (used, currencyId);
                }
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetOrderBook (this.extend (request, params));
            const result = this.safeValue (response, market['id']);
            return this.parseOrderBook (result, symbol, undefined, 'bid', 'ask');
        }
    
        async fetchOrderBooks (symbols = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let ids = undefined;
            if (symbols === undefined) {
                ids = this.ids.join (',');
                // max URL length is 2083 symbols, including http schema, hostname, tld, etc...
                if (ids.length > 2048) {
                    const numIds = this.ids.length;
                    throw new ExchangeError (this.id + ' has ' + numIds.toString () + ' symbols exceeding max URL length, you are required to specify a list of symbols in the first argument to fetchOrderBooks');
                }
            } else {
                ids = this.marketIds (symbols);
                ids = ids.join (',');
            }
            const request = {
                'pair': ids,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetOrderBook (this.extend (request, params));
            const result = {};
            const marketIds = Object.keys (response);
            for (let i = 0; i < marketIds.length; i++) {
                const marketId = marketIds[i];
                let symbol = marketId;
                if (marketId in this.markets_by_id) {
                    const market = this.markets_by_id[marketId];
                    symbol = market['symbol'];
                }
                result[symbol] = this.parseOrderBook (response[marketId], symbol, undefined, 'bid', 'ask');
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.safeTimestamp (ticker, 'updated');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const last = this.safeNumber (ticker, 'last_trade');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy_price'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell_price'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': this.safeNumber (ticker, 'avg'),
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': this.safeNumber (ticker, 'vol_curr'),
                'info': ticker,
            };
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTicker (params);
            const result = {};
            const ids = Object.keys (response);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const market = this.markets_by_id[id];
                const symbol = market['symbol'];
                const ticker = response[id];
                result[symbol] = this.parseTicker (ticker, market);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTicker (params);
            const market = this.market (symbol);
            return this.parseTicker (response[market['id']], market);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "trade_id":165087520,
            //         "date":1587470005,
            //         "type":"buy",
            //         "quantity":"1.004",
            //         "price":"0.02491461",
            //         "amount":"0.02501426"
            //     },
            //
            // fetchMyTrades, fetchOrderTrades
            //
            //     {
            //         "trade_id": 3,
            //         "date": 1435488248,
            //         "type": "buy",
            //         "pair": "BTC_USD",
            //         "order_id": 12345,
            //         "quantity": 1,
            //         "price": 100,
            //         "amount": 100,
            //         "exec_type": "taker",
            //         "commission_amount": "0.02",
            //         "commission_currency": "BTC",
            //         "commission_percent": "0.2"
            //     }
            //
            const timestamp = this.safeTimestamp (trade, 'date');
            let symbol = undefined;
            const id = this.safeString (trade, 'trade_id');
            const orderId = this.safeString (trade, 'order_id');
            const price = this.safeNumber (trade, 'price');
            const amount = this.safeNumber (trade, 'quantity');
            const cost = this.safeNumber (trade, 'amount');
            const side = this.safeString (trade, 'type');
            const type = undefined;
            const marketId = this.safeString (trade, 'pair');
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const [ baseId, quoteId ] = marketId.split ('_');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const takerOrMaker = this.safeString (trade, 'exec_type');
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'commission_amount');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'commission_currency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                let feeRate = this.safeNumber (trade, 'commission_percent');
                if (feeRate !== undefined) {
                    feeRate /= 1000;
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                    'rate': feeRate,
                };
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': type,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetTrades (this.extend (request, params));
            //
            //     {
            //         "ETH_BTC":[
            //             {
            //                 "trade_id":165087520,
            //                 "date":1587470005,
            //                 "type":"buy",
            //                 "quantity":"1.004",
            //                 "price":"0.02491461",
            //                 "amount":"0.02501426"
            //             },
            //             {
            //                 "trade_id":165087369,
            //                 "date":1587469938,
            //                 "type":"buy",
            //                 "quantity":"0.94",
            //                 "price":"0.02492348",
            //                 "amount":"0.02342807"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, market['id'], []);
            return this.parseTrades (data, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // a symbol is required but it can be a single string, or a non-empty array
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument (a single symbol or an array)');
            }
            await this.loadMarkets ();
            let pair = undefined;
            let market = undefined;
            if (Array.isArray (symbol)) {
                const numSymbols = symbol.length;
                if (numSymbols < 1) {
                    throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a non-empty symbol array');
                }
                const marketIds = this.marketIds (symbol);
                pair = marketIds.join (',');
            } else {
                market = this.market (symbol);
                pair = market['id'];
            }
            const request = {
                'pair': pair,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privatePostUserTrades (this.extend (request, params));
            let result = [];
            const marketIds = Object.keys (response);
            for (let i = 0; i < marketIds.length; i++) {
                const marketId = marketIds[i];
                let symbol = undefined;
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                    symbol = market['symbol'];
                } else {
                    const [ baseId, quoteId ] = marketId.split ('_');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
                const items = response[marketId];
                const trades = this.parseTrades (items, market, since, limit, {
                    'symbol': symbol,
                });
                result = this.arrayConcat (result, trades);
            }
            return this.filterBySinceLimit (result, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const prefix = (type === 'market') ? (type + '_') : '';
            const orderType = prefix + side;
            let orderPrice = price;
            if ((type === 'market') && (price === undefined)) {
                orderPrice = 0;
            }
            const request = {
                'pair': market['id'],
                // 'leverage': 2,
                'quantity': this.amountToPrecision (symbol, amount),
                // spot - buy, sell, market_buy, market_sell, market_buy_total, market_sell_total
                // margin - limit_buy, limit_sell, market_buy, market_sell, stop_buy, stop_sell, stop_limit_buy, stop_limit_sell, trailing_stop_buy, trailing_stop_sell
                'type': orderType,
                'price': this.priceToPrecision (symbol, orderPrice),
                // 'stop_price': this.priceToPrecision (symbol, stopPrice),
                // 'distance': 0, // distance for trailing stop orders
                // 'expire': 0, // expiration timestamp in UTC timezone for the order, unless expire is 0
                // 'client_id': 123, // optional, must be a positive integer
                // 'comment': '', // up to 50 latin symbols, whitespaces, underscores
            };
            let method = 'privatePostOrderCreate';
            let clientOrderId = this.safeValue2 (params, 'client_id', 'clientOrderId');
            if (clientOrderId !== undefined) {
                clientOrderId = this.safeInteger2 (params, 'client_id', 'clientOrderId');
                if (clientOrderId === undefined) {
                    throw new BadRequest (this.id + ' createOrder client order id must be an integer / numeric literal');
                } else {
                    request['client_id'] = clientOrderId;
                }
                params = this.omit (params, [ 'client_id', 'clientOrderId' ]);
            }
            if ((type === 'stop') || (type === 'stop_limit') || (type === 'trailing_stop')) {
                const stopPrice = this.safeNumber2 (params, 'stop_price', 'stopPrice');
                if (stopPrice === undefined) {
                    throw new InvalidOrder (this.id + ' createOrder() requires a stopPrice extra param for a ' + type + ' order');
                } else {
                    params = this.omit (params, [ 'stopPrice', 'stop_price' ]);
                    request['stop_price'] = this.priceToPrecision (symbol, stopPrice);
                    method = 'privatePostMarginUserOrderCreate';
                }
            }
            const response = await this[method] (this.extend (request, params));
            const id = this.safeString (response, 'order_id');
            const timestamp = this.milliseconds ();
            const status = 'open';
            return {
                'id': id,
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'cost': undefined,
                'amount': amount,
                'remaining': amount,
                'filled': 0.0,
                'fee': undefined,
                'trades': undefined,
                'clientOrderId': clientOrderId,
                'average': undefined,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = { 'order_id': id };
            return await this.privatePostOrderCancel (this.extend (request, params));
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id.toString (),
            };
            const response = await this.privatePostOrderTrades (this.extend (request, params));
            //
            //     {
            //         "type": "buy",
            //         "in_currency": "BTC",
            //         "in_amount": "1",
            //         "out_currency": "USD",
            //         "out_amount": "100",
            //         "trades": [
            //             {
            //                 "trade_id": 3,
            //                 "date": 1435488248,
            //                 "type": "buy",
            //                 "pair": "BTC_USD",
            //                 "order_id": 12345,
            //                 "quantity": 1,
            //                 "price": 100,
            //                 "amount": 100
            //             }
            //         ]
            //     }
            //
            const order = this.parseOrder (response);
            return this.extend (order, {
                'id': id.toString (),
            });
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const request = {
                'order_id': id.toString (),
            };
            const response = await this.privatePostOrderTrades (this.extend (request, params));
            //
            //     {
            //         "type": "buy",
            //         "in_currency": "BTC",
            //         "in_amount": "1",
            //         "out_currency": "USD",
            //         "out_amount": "100",
            //         "trades": [
            //             {
            //                 "trade_id": 3,
            //                 "date": 1435488248,
            //                 "type": "buy",
            //                 "pair": "BTC_USD",
            //                 "order_id": 12345,
            //                 "quantity": 1,
            //                 "price": 100,
            //                 "amount": 100,
            //                 "exec_type": "taker",
            //                 "commission_amount": "0.02",
            //                 "commission_currency": "BTC",
            //                 "commission_percent": "0.2"
            //             }
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'trades');
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostUserOpenOrders (params);
            const marketIds = Object.keys (response);
            let orders = [];
            for (let i = 0; i < marketIds.length; i++) {
                const marketId = marketIds[i];
                let market = undefined;
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                }
                const parsedOrders = this.parseOrders (response[marketId], market);
                orders = this.arrayConcat (orders, parsedOrders);
            }
            return this.filterBySymbolSinceLimit (orders, symbol, since, limit);
        }
    
        parseOrder (order, market = undefined) {
            //
            // fetchOrders, fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "order_id": "14",
            //         "created": "1435517311",
            //         "type": "buy",
            //         "pair": "BTC_USD",
            //         "price": "100",
            //         "quantity": "1",
            //         "amount": "100"
            //     }
            //
            // fetchOrder
            //
            //     {
            //         "type": "buy",
            //         "in_currency": "BTC",
            //         "in_amount": "1",
            //         "out_currency": "USD",
            //         "out_amount": "100",
            //         "trades": [
            //             {
            //                 "trade_id": 3,
            //                 "date": 1435488248,
            //                 "type": "buy",
            //                 "pair": "BTC_USD",
            //                 "order_id": 12345,
            //                 "quantity": 1,
            //                 "price": 100,
            //                 "amount": 100
            //             }
            //         ]
            //     }
            //
            let id = this.safeString (order, 'order_id');
            let timestamp = this.safeTimestamp (order, 'created');
            let symbol = undefined;
            const side = this.safeString (order, 'type');
            if (market === undefined) {
                let marketId = undefined;
                if ('pair' in order) {
                    marketId = order['pair'];
                } else if (('in_currency' in order) && ('out_currency' in order)) {
                    if (side === 'buy') {
                        marketId = order['in_currency'] + '_' + order['out_currency'];
                    } else {
                        marketId = order['out_currency'] + '_' + order['in_currency'];
                    }
                }
                if ((marketId !== undefined) && (marketId in this.markets_by_id)) {
                    market = this.markets_by_id[marketId];
                }
            }
            let amount = this.safeNumber (order, 'quantity');
            if (amount === undefined) {
                const amountField = (side === 'buy') ? 'in_amount' : 'out_amount';
                amount = this.safeNumber (order, amountField);
            }
            let price = this.safeNumber (order, 'price');
            let cost = this.safeNumber (order, 'amount');
            let filled = 0.0;
            const trades = [];
            const transactions = this.safeValue (order, 'trades', []);
            let feeCost = undefined;
            let lastTradeTimestamp = undefined;
            let average = undefined;
            const numTransactions = transactions.length;
            if (numTransactions > 0) {
                feeCost = 0;
                for (let i = 0; i < numTransactions; i++) {
                    const trade = this.parseTrade (transactions[i], market);
                    if (id === undefined) {
                        id = trade['order'];
                    }
                    if (timestamp === undefined) {
                        timestamp = trade['timestamp'];
                    }
                    if (timestamp > trade['timestamp']) {
                        timestamp = trade['timestamp'];
                    }
                    filled = this.sum (filled, trade['amount']);
                    feeCost = this.sum (feeCost, trade['fee']['cost']);
                    trades.push (trade);
                }
                lastTradeTimestamp = trades[numTransactions - 1]['timestamp'];
            }
            let status = this.safeString (order, 'status'); // in case we need to redefine it for canceled orders
            let remaining = undefined;
            if (amount !== undefined) {
                remaining = amount - filled;
                if (filled >= amount) {
                    status = 'closed';
                } else {
                    status = 'open';
                }
            }
            if (market === undefined) {
                market = this.getMarketFromTrades (trades);
            }
            let feeCurrency = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
                feeCurrency = market['quote'];
            }
            if (cost === undefined) {
                if (price !== undefined) {
                    cost = price * filled;
                }
            } else {
                if (filled > 0) {
                    if (average === undefined) {
                        average = cost / filled;
                    }
                    if (price === undefined) {
                        price = cost / filled;
                    }
                }
            }
            const fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            };
            const clientOrderId = this.safeInteger (order, 'client_id');
            return {
                'id': id,
                'clientOrderId': clientOrderId,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': lastTradeTimestamp,
                'status': status,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'average': average,
                'trades': trades,
                'fee': fee,
                'info': order,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostDepositAddress (params);
            const depositAddress = this.safeString (response, code);
            let address = undefined;
            let tag = undefined;
            if (depositAddress) {
                const addressAndTag = depositAddress.split (',');
                address = addressAndTag[0];
                const numParts = addressAndTag.length;
                if (numParts > 1) {
                    tag = addressAndTag[1];
                }
            }
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        getMarketFromTrades (trades) {
            const tradesBySymbol = this.indexBy (trades, 'pair');
            const symbols = Object.keys (tradesBySymbol);
            const numSymbols = symbols.length;
            if (numSymbols === 1) {
                return this.markets[symbols[0]];
            }
            return undefined;
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'amount': amount,
                'currency': currency['id'],
                'address': address,
            };
            if (tag !== undefined) {
                request['invoice'] = tag;
            }
            const response = await this.privatePostWithdrawCrypt (this.extend (request, params));
            return {
                'info': response,
                'id': response['task_id'],
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'transferred': 'ok',
                'paid': 'ok',
                'pending': 'pending',
                'processing': 'pending',
                'verifying': 'pending',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchTransactions
            //
            //          {
            //            "dt": 1461841192,
            //            "type": "deposit",
            //            "curr": "RUB",
            //            "status": "processing",
            //            "provider": "Qiwi (LA) [12345]",
            //            "amount": "1",
            //            "account": "",
            //            "txid": "ec46f784ad976fd7f7539089d1a129fe46...",
            //          }
            //
            // fetchWithdrawals
            //
            //          {
            //             "operation_id": 47412538520634344,
            //             "created": 1573760013,
            //             "updated": 1573760013,
            //             "type": "withdraw",
            //             "currency": "DOGE",
            //             "status": "Paid",
            //             "amount": "300",
            //             "provider": "DOGE",
            //             "commission": "0",
            //             "account": "DOGE: DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
            //             "order_id": 69670170,
            //             "provider_type": "crypto",
            //             "crypto_address": "DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
            //             "card_number": "",
            //             "wallet_address": "",
            //             "email": "",
            //             "phone": "",
            //             "extra": {
            //                 "txid": "f2b66259ae1580f371d38dd27e31a23fff8c04122b65ee3ab5a3f612d579c792",
            //                 "confirmations": null,
            //                 "excode": "",
            //                 "invoice": ""
            //             },
            //             "error": ""
            //          },
            //
            const id = this.safeString (transaction, 'order_id');
            const timestamp = this.safeTimestamp2 (transaction, 'dt', 'created');
            const updated = this.safeTimestamp (transaction, 'updated');
            let amount = this.safeNumber (transaction, 'amount');
            if (amount !== undefined) {
                amount = Math.abs (amount);
            }
            const status = this.parseTransactionStatus (this.safeStringLower (transaction, 'status'));
            let txid = this.safeString (transaction, 'txid');
            if (txid === undefined) {
                const extra = this.safeValue (transaction, 'extra', {});
                const extraTxid = this.safeString (extra, 'txid');
                if (extraTxid !== '') {
                    txid = extraTxid;
                }
            }
            const type = this.safeString (transaction, 'type');
            const currencyId = this.safeString2 (transaction, 'curr', 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            let address = undefined;
            const tag = undefined;
            let comment = undefined;
            const account = this.safeString (transaction, 'account');
            if (type === 'deposit') {
                comment = account;
            } else if (type === 'withdrawal') {
                address = account;
                if (address !== undefined) {
                    const parts = address.split (':');
                    const numParts = parts.length;
                    if (numParts === 2) {
                        address = this.safeString (parts, 1);
                        address = address.replace (' ', '');
                    }
                }
            }
            let fee = undefined;
            // fixed funding fees only (for now)
            if (!this.fees['funding']['percentage']) {
                const key = (type === 'withdrawal') ? 'withdraw' : 'deposit';
                let feeCost = this.safeNumber (transaction, 'commission');
                if (feeCost === undefined) {
                    feeCost = this.safeNumber (this.options['fundingFees'][key], code);
                }
                // users don't pay for cashbacks, no fees for that
                const provider = this.safeString (transaction, 'provider');
                if (provider === 'cashback') {
                    feeCost = 0;
                }
                if (feeCost !== undefined) {
                    // withdrawal amount includes the fee
                    if (type === 'withdrawal') {
                        amount = amount - feeCost;
                    }
                    fee = {
                        'cost': feeCost,
                        'currency': code,
                        'rate': undefined,
                    };
                }
            }
            return {
                'info': transaction,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'currency': code,
                'amount': amount,
                'address': address,
                'addressTo': address,
                'addressFrom': undefined,
                'tag': tag,
                'tagTo': tag,
                'tagFrom': undefined,
                'status': status,
                'type': type,
                'updated': updated,
                'comment': comment,
                'txid': txid,
                'fee': fee,
            };
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (since !== undefined) {
                request['date'] = parseInt (since / 1000);
            }
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            const response = await this.privatePostWalletHistory (this.extend (request, params));
            //
            //     {
            //       "result": true,
            //       "error": "",
            //       "begin": "1493942400",
            //       "end": "1494028800",
            //       "history": [
            //          {
            //            "dt": 1461841192,
            //            "type": "deposit",
            //            "curr": "RUB",
            //            "status": "processing",
            //            "provider": "Qiwi (LA) [12345]",
            //            "amount": "1",
            //            "account": "",
            //            "txid": "ec46f784ad976fd7f7539089d1a129fe46...",
            //          },
            //          {
            //            "dt": 1463414785,
            //            "type": "withdrawal",
            //            "curr": "USD",
            //            "status": "paid",
            //            "provider": "EXCODE",
            //            "amount": "-1",
            //            "account": "EX-CODE_19371_USDda...",
            //            "txid": "",
            //          },
            //       ],
            //     }
            //
            return this.parseTransactions (response['history'], currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {
                'type': 'withdraw',
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default: 100, maximum: 100
            }
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            const response = await this.privatePostWalletOperations (this.extend (request, params));
            //
            //     {
            //         "items": [
            //         {
            //             "operation_id": 47412538520634344,
            //             "created": 1573760013,
            //             "updated": 1573760013,
            //             "type": "withdraw",
            //             "currency": "DOGE",
            //             "status": "Paid",
            //             "amount": "300",
            //             "provider": "DOGE",
            //             "commission": "0",
            //             "account": "DOGE: DBVy8pF1f8yxaCVEHqHeR7kkcHecLQ8nRS",
            //             "order_id": 69670170,
            //             "extra": {
            //                 "txid": "f2b66259ae1580f371d38dd27e31a23fff8c04122b65ee3ab5a3f612d579c792",
            //                 "excode": "",
            //                 "invoice": ""
            //             },
            //             "error": ""
            //         },
            //     ],
            //         "count": 23
            //     }
            //
            return this.parseTransactions (response['items'], currency, since, limit);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/';
            if (api !== 'web') {
                url += this.version + '/';
            }
            url += path;
            if ((api === 'public') || (api === 'web')) {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Key': this.apiKey,
                    'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if (('result' in response) || ('errmsg' in response)) {
                //
                //     {"result":false,"error":"Error 50052: Insufficient funds"}
                //     {"s":"error","errmsg":"strconv.ParseInt: parsing \"\": invalid syntax"}
                //
                let success = this.safeValue (response, 'result', false);
                if (typeof success === 'string') {
                    if ((success === 'true') || (success === '1')) {
                        success = true;
                    } else {
                        success = false;
                    }
                }
                if (!success) {
                    let code = undefined;
                    const message = this.safeString2 (response, 'error', 'errmsg');
                    const errorParts = message.split (':');
                    const numParts = errorParts.length;
                    if (numParts > 1) {
                        const errorSubParts = errorParts[0].split (' ');
                        const numSubParts = errorSubParts.length;
                        code = (numSubParts > 1) ? errorSubParts[1] : errorSubParts[0];
                    }
                    const feedback = this.id + ' ' + body;
                    this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);
                    this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],79:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AuthenticationError, ExchangeNotAvailable, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class exx extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'exx',
                'name': 'EXX',
                'countries': [ 'CN' ],
                'rateLimit': 1000 / 10,
                'userAgent': this.userAgents['chrome'],
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/37770292-fbf613d0-2de4-11e8-9f79-f2dc451b8ccb.jpg',
                    'api': {
                        'public': 'https://api.exx.com/data/v1',
                        'private': 'https://trade.exx.com/api',
                    },
                    'www': 'https://www.exx.com/',
                    'doc': 'https://www.exx.com/help/restApi',
                    'fees': 'https://www.exx.com/help/rate',
                    'referral': 'https://www.exx.com/r/fde4260159e53ab8a58cc9186d35501f?recommQd=1',
                },
                'api': {
                    'public': {
                        'get': [
                            'markets',
                            'tickers',
                            'ticker',
                            'depth',
                            'trades',
                        ],
                    },
                    'private': {
                        'get': [
                            'order',
                            'cancel',
                            'getOrder',
                            'getOpenOrders',
                            'getBalance',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.001'),
                        'taker': this.parseNumber ('0.001'),
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'commonCurrencies': {
                    'DOS': 'DEMOS',
                    'TV': 'TIV', // Ti-Value
                },
                'exceptions': {
                    '103': AuthenticationError,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarkets (params);
            const ids = Object.keys (response);
            const result = [];
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const market = response[id];
                const [ baseId, quoteId ] = id.split ('_');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const active = market['isOpen'] === true;
                const amountPrecisionString = this.safeString (market, 'amountScale');
                const pricePrecisionString = this.safeString (market, 'priceScale');
                const amountLimit = this.parsePrecision (amountPrecisionString);
                const priceLimit = this.parsePrecision (pricePrecisionString);
                const precision = {
                    'amount': parseInt (amountPrecisionString),
                    'price': parseInt (pricePrecisionString),
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.parseNumber (amountLimit),
                            'max': undefined,
                        },
                        'price': {
                            'min': this.parseNumber (priceLimit),
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.safeNumber (market, 'minAmount'),
                            'max': undefined,
                        },
                    },
                    'info': market,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            const symbol = market['symbol'];
            const timestamp = this.safeInteger (ticker, 'date');
            ticker = ticker['ticker'];
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': this.safeNumber (ticker, 'riseRate'),
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTickers (params);
            const result = {};
            const timestamp = this.milliseconds ();
            const ids = Object.keys (response);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                if (!(id in this.markets_by_id)) {
                    continue;
                }
                const market = this.markets_by_id[id];
                const symbol = market['symbol'];
                const ticker = {
                    'date': timestamp,
                    'ticker': response[id],
                };
                result[symbol] = this.parseTicker (ticker, market);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'currency': this.marketId (symbol),
            };
            const response = await this.publicGetDepth (this.extend (request, params));
            const timestamp = this.safeTimestamp (response, 'timestamp');
            return this.parseOrderBook (response, symbol, timestamp);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeTimestamp (trade, 'date');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const type = 'limit';
            const side = this.safeString (trade, 'type');
            const id = this.safeString (trade, 'tid');
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': undefined,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
            };
            const response = await this.publicGetTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetGetBalance (params);
            const result = { 'info': response };
            const balances = this.safeValue (response, 'funds');
            const currencies = Object.keys (balances);
            for (let i = 0; i < currencies.length; i++) {
                const currencyId = currencies[i];
                const balance = balances[currencyId];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'balance');
                account['used'] = this.safeString (balance, 'freeze');
                account['total'] = this.safeString (balance, 'total');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "fees": 0,
            //         "total_amount": 1,
            //         "trade_amount": 0,
            //         "price": 30,
            //         "currency": “eth_hsr",
            //         "id": "13878",
            //         "trade_money": 0,
            //         "type": "buy",
            //         "trade_date": 1509728897772,
            //         "status": 0
            //     }
            //
            const symbol = market['symbol'];
            const timestamp = parseInt (order['trade_date']);
            const price = this.safeNumber (order, 'price');
            const cost = this.safeNumber (order, 'trade_money');
            const amount = this.safeNumber (order, 'total_amount');
            const filled = this.safeNumber (order, 'trade_amount', 0.0);
            let status = this.safeInteger (order, 'status');
            if (status === 1) {
                status = 'canceled';
            } else if (status === 2) {
                status = 'closed';
            } else {
                status = 'open';
            }
            let fee = undefined;
            if ('fees' in order) {
                fee = {
                    'cost': this.safeNumber (order, 'fees'),
                    'currency': market['quote'],
                };
            }
            return this.safeOrder ({
                'id': this.safeString (order, 'id'),
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': order['type'],
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'trades': undefined,
                'fee': fee,
                'info': order,
                'average': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
                'type': side,
                'price': price,
                'amount': amount,
            };
            const response = await this.privateGetOrder (this.extend (request, params));
            const id = this.safeString (response, 'id');
            const order = this.parseOrder ({
                'id': id,
                'trade_date': this.milliseconds (),
                'total_amount': amount,
                'price': price,
                'type': side,
                'info': response,
            }, market);
            return order;
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': id,
                'currency': market['id'],
            };
            const response = await this.privateGetCancel (this.extend (request, params));
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': id,
                'currency': market['id'],
            };
            const response = await this.privateGetGetOrder (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            const market = this.market (symbol);
            const request = {
                'currency': market['id'],
            };
            const response = await this.privateGetGetOpenOrders (this.extend (request, params));
            if (!Array.isArray (response)) {
                return [];
            }
            return this.parseOrders (response, market, since, limit);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/' + path;
            if (api === 'public') {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                this.checkRequiredCredentials ();
                const query = this.urlencode (this.keysort (this.extend ({
                    'accesskey': this.apiKey,
                    'nonce': this.nonce (),
                }, params)));
                const signed = this.hmac (this.encode (query), this.encode (this.secret), 'sha512');
                url += '?' + query + '&signature=' + signed;
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            //
            //  {"result":false,"message":"服务端忙碌"}
            //  ... and other formats
            //
            const code = this.safeString (response, 'code');
            const message = this.safeString (response, 'message');
            const feedback = this.id + ' ' + body;
            if (code === '100') {
                return;
            }
            if (code !== undefined) {
                this.throwExactlyMatchedException (this.exceptions, code, feedback);
                if (code === '308') {
                    // this is returned by the exchange when there are no open orders
                    // {"code":308,"message":"Not Found Transaction Record"}
                    return;
                } else {
                    throw new ExchangeError (feedback);
                }
            }
            const result = this.safeValue (response, 'result');
            if (result !== undefined) {
                if (!result) {
                    if (message === '服务端忙碌') {
                        throw new ExchangeNotAvailable (feedback);
                    } else {
                        throw new ExchangeError (feedback);
                    }
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],80:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class flowbtc extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'flowbtc',
                'name': 'flowBTC',
                'countries': [ 'BR' ], // Brazil
                'version': 'v1',
                'rateLimit': 1000,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87443317-01c0d080-c5fe-11ea-95c2-9ebe1a8fafd9.jpg',
                    'api': 'https://publicapi.flowbtc.com.br',
                    'www': 'https://www.flowbtc.com.br',
                    'doc': 'https://www.flowbtc.com.br/api.html',
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'uid': true,
                },
                'api': {
                    'public': {
                        'post': [
                            'GetTicker',
                            'GetTrades',
                            'GetTradesByDate',
                            'GetOrderBook',
                            'GetProductPairs',
                            'GetProducts',
                        ],
                    },
                    'private': {
                        'post': [
                            'CreateAccount',
                            'GetUserInfo',
                            'SetUserInfo',
                            'GetAccountInfo',
                            'GetAccountTrades',
                            'GetDepositAddresses',
                            'Withdraw',
                            'CreateOrder',
                            'ModifyOrder',
                            'CancelOrder',
                            'CancelAllOrders',
                            'GetAccountOpenOrders',
                            'GetOrderFee',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': 0.0025,
                        'taker': 0.005,
                    },
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicPostGetProductPairs (params);
            const markets = this.safeValue (response, 'productPairs');
            const result = {};
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'name');
                const baseId = this.safeString (market, 'product1Label');
                const quoteId = this.safeString (market, 'product2Label');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const precision = {
                    'amount': this.safeInteger (market, 'product1DecimalPlaces'),
                    'price': this.safeInteger (market, 'product2DecimalPlaces'),
                };
                const symbol = base + '/' + quote;
                result[symbol] = {
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'info': market,
                    'active': undefined,
                };
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostGetAccountInfo (params);
            const balances = this.safeValue (response, 'currencies');
            const result = { 'info': response };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = balance['name'];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'balance');
                account['total'] = this.safeString (balance, 'hold');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'productPair': market['id'],
            };
            const response = await this.publicPostGetOrderBook (this.extend (request, params));
            return this.parseOrderBook (response, symbol, undefined, 'bids', 'asks', 'px', 'qty');
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'productPair': market['id'],
            };
            const ticker = await this.publicPostGetTicker (this.extend (request, params));
            const timestamp = this.milliseconds ();
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume24hr'),
                'quoteVolume': this.safeNumber (ticker, 'volume24hrProduct2'),
                'info': ticker,
            };
        }
    
        parseTrade (trade, market) {
            const timestamp = this.safeTimestamp (trade, 'unixtime');
            const side = (trade['incomingOrderSide'] === 0) ? 'buy' : 'sell';
            const id = this.safeString (trade, 'tid');
            const priceString = this.safeString (trade, 'px');
            const amountString = this.safeString (trade, 'qty');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': market['symbol'],
                'id': id,
                'order': undefined,
                'type': undefined,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'takerOrMaker': undefined,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'ins': market['id'],
                'startIndex': -1,
            };
            const response = await this.publicPostGetTrades (this.extend (request, params));
            return this.parseTrades (response['trades'], market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const orderType = (type === 'market') ? 1 : 0;
            const request = {
                'ins': this.marketId (symbol),
                'side': side,
                'orderType': orderType,
                'qty': amount,
                'px': this.priceToPrecision (symbol, price),
            };
            const response = await this.privatePostCreateOrder (this.extend (request, params));
            return {
                'info': response,
                'id': response['serverOrderId'],
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            if ('ins' in params) {
                const request = {
                    'serverOrderId': id,
                };
                return await this.privatePostCancelOrder (this.extend (request, params));
            }
            throw new ExchangeError (this.id + ' cancelOrder() requires an `ins` symbol parameter for cancelling an order');
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const url = this.urls['api'] + '/' + this.version + '/' + path;
            if (api === 'public') {
                if (Object.keys (params).length) {
                    body = this.json (params);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                const auth = nonce.toString () + this.uid + this.apiKey;
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                body = this.json (this.extend ({
                    'apiKey': this.apiKey,
                    'apiNonce': nonce,
                    'apiSig': signature.toUpperCase (),
                }, params));
                headers = {
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const isAccepted = this.safeValue (response, 'isAccepted', true);
            if (!isAccepted) {
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],81:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { TICK_SIZE } = require ('./base/functions/number');
    const { ExchangeError, InvalidOrder, BadRequest, InsufficientFunds, OrderNotFound, AuthenticationError, RateLimitExceeded, ExchangeNotAvailable, CancelPending, ArgumentsRequired, PermissionDenied, BadSymbol, DuplicateOrderId } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class ftx extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'ftx',
                'name': 'FTX',
                'countries': [ 'HK' ],
                'rateLimit': 50,
                'certified': true,
                'pro': true,
                'hostname': 'ftx.com', // or ftx.us
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/67149189-df896480-f2b0-11e9-8816-41593e17f9ec.jpg',
                    'www': 'https://ftx.com',
                    'api': {
                        'public': 'https://{hostname}',
                        'private': 'https://{hostname}',
                    },
                    'doc': 'https://github.com/ftexchange/ftx',
                    'fees': 'https://ftexchange.zendesk.com/hc/en-us/articles/360024479432-Fees',
                    'referral': {
                        'url': 'https://ftx.com/#a=ccxt',
                        'discount': 0.05,
                    },
                },
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': false,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchFundingFees': false,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchPositions': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTradingFees': true,
                    'fetchWithdrawals': true,
                    'setLeverage': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '15s': '15',
                    '1m': '60',
                    '5m': '300',
                    '15m': '900',
                    '1h': '3600',
                    '4h': '14400',
                    '1d': '86400',
                    '3d': '259200',
                    '1w': '604800',
                    '2w': '1209600',
                    '1M': '2592000',
                },
                'api': {
                    'public': {
                        'get': [
                            'coins',
                            // markets
                            'markets',
                            'markets/{market_name}',
                            'markets/{market_name}/orderbook', // ?depth={depth}
                            'markets/{market_name}/trades', // ?limit={limit}&start_time={start_time}&end_time={end_time}
                            'markets/{market_name}/candles', // ?resolution={resolution}&limit={limit}&start_time={start_time}&end_time={end_time}
                            // futures
                            'futures',
                            'futures/{future_name}',
                            'futures/{future_name}/stats',
                            'funding_rates',
                            'indexes/{index_name}/weights',
                            'expired_futures',
                            'indexes/{market_name}/candles', // ?resolution={resolution}&limit={limit}&start_time={start_time}&end_time={end_time}
                            // wallet
                            'wallet/coins',
                            // leverage tokens
                            'lt/tokens',
                            'lt/{token_name}',
                            // etfs
                            'etfs/rebalance_info',
                            // options
                            'options/requests',
                            'options/trades',
                            'options/historical_volumes/BTC',
                            'stats/24h_options_volume',
                            'options/open_interest/BTC',
                            'options/historical_open_interest/BTC',
                            // spot margin
                            'spot_margin/history',
                            'spot_margin/borrow_summary',
                            // nfts
                            'nft/nfts',
                            'nft/{nft_id}',
                            'nft/{nft_id}/trades',
                            'nft/all_trades',
                            'nft/{nft_id}/account_info',
                            'nft/collections',
                            // ftx pay
                            'ftxpay/apps/{user_specific_id}/details',
                        ],
                        'post': [
                            'ftxpay/apps/{user_specific_id}/orders',
                        ],
                    },
                    'private': {
                        'get': [
                            // subaccounts
                            'subaccounts',
                            'subaccounts/{nickname}/balances',
                            // account
                            'account',
                            'positions',
                            // wallet
                            'wallet/balances',
                            'wallet/all_balances',
                            'wallet/deposit_address/{coin}', // ?method={method}
                            'wallet/deposits',
                            'wallet/withdrawals',
                            'wallet/airdrops',
                            'wallet/withdrawal_fee',
                            'wallet/saved_addresses',
                            // orders
                            'orders', // ?market={market}
                            'orders/history', // ?market={market}
                            'orders/{order_id}',
                            'orders/by_client_id/{client_order_id}',
                            // conditional orders
                            'conditional_orders', // ?market={market}
                            'conditional_orders/{conditional_order_id}/triggers',
                            'conditional_orders/history', // ?market={market}
                            'fills', // ?market={market}
                            'funding_payments',
                            // leverage tokens
                            'lt/balances',
                            'lt/creations',
                            'lt/redemptions',
                            // options
                            'options/my_requests',
                            'options/requests/{request_id}/quotes',
                            'options/my_quotes',
                            'options/account_info',
                            'options/positions',
                            'options/fills',
                            // staking
                            'staking/stakes',
                            'staking/unstake_requests',
                            'staking/balances',
                            'staking/staking_rewards',
                            // otc
                            'otc/quotes/{quoteId}',
                            // spot margin
                            'spot_margin/borrow_rates',
                            'spot_margin/lending_rates',
                            'spot_margin/market_info', // ?market={market}
                            'spot_margin/borrow_history',
                            'spot_margin/lending_history',
                            'spot_margin/offers',
                            'spot_margin/lending_info',
                            // nfts
                            'nft/balances',
                            'nft/bids',
                            'nft/deposits',
                            'nft/withdrawals',
                            'nft/fills',
                            'nft/gallery/{gallery_id}',
                            'nft/gallery_settings',
                            // latency statistics
                            'stats/latency_stats',
                        ],
                        'post': [
                            // subaccounts
                            'subaccounts',
                            'subaccounts/update_name',
                            'subaccounts/transfer',
                            // account
                            'account/leverage',
                            // wallet
                            'wallet/withdrawals',
                            'wallet/saved_addresses',
                            // orders
                            'orders',
                            'conditional_orders',
                            'orders/{order_id}/modify',
                            'orders/by_client_id/{client_order_id}/modify',
                            'conditional_orders/{order_id}/modify',
                            // leverage tokens
                            'lt/{token_name}/create',
                            'lt/{token_name}/redeem',
                            // options
                            'options/requests',
                            'options/requests/{request_id}/quotes',
                            'options/quotes/{quote_id}/accept',
                            // staking
                            'staking/unstake_requests',
                            'srm_stakes/stakes',
                            // otc
                            'otc/quotes/{quote_id}/accept',
                            'otc/quotes',
                            // spot margin
                            'spot_margin/offers',
                            // nfts
                            'nft/offer',
                            'nft/buy',
                            'nft/auction',
                            'nft/edit_auction',
                            'nft/cancel_auction',
                            'nft/bids',
                            'nft/redeem',
                            'nft/gallery_settings',
                            // ftx pay
                            'ftxpay/apps/{user_specific_id}/orders',
                        ],
                        'delete': [
                            // subaccounts
                            'subaccounts',
                            // wallet
                            'wallet/saved_addresses/{saved_address_id}',
                            // orders
                            'orders/{order_id}',
                            'orders/by_client_id/{client_order_id}',
                            'orders',
                            'conditional_orders/{order_id}',
                            // options
                            'options/requests/{request_id}',
                            'options/quotes/{quote_id}',
                            // staking
                            'staking/unstake_requests/{request_id}',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'maker': this.parseNumber ('0.0002'),
                        'taker': this.parseNumber ('0.0007'),
                        'tiers': {
                            'taker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.0007') ],
                                [ this.parseNumber ('2000000'), this.parseNumber ('0.0006') ],
                                [ this.parseNumber ('5000000'), this.parseNumber ('0.00055') ],
                                [ this.parseNumber ('10000000'), this.parseNumber ('0.0005') ],
                                [ this.parseNumber ('25000000'), this.parseNumber ('0.045') ],
                                [ this.parseNumber ('50000000'), this.parseNumber ('0.0004') ],
                            ],
                            'maker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.0002') ],
                                [ this.parseNumber ('2000000'), this.parseNumber ('0.00015') ],
                                [ this.parseNumber ('5000000'), this.parseNumber ('0.0001') ],
                                [ this.parseNumber ('10000000'), this.parseNumber ('0.00005') ],
                                [ this.parseNumber ('25000000'), this.parseNumber ('0') ],
                                [ this.parseNumber ('50000000'), this.parseNumber ('0') ],
                            ],
                        },
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'exceptions': {
                    'exact': {
                        'Please slow down': RateLimitExceeded, // {"error":"Please slow down","success":false}
                        'Size too small for provide': InvalidOrder, // {"error":"Size too small for provide","success":false}
                        'Not logged in': AuthenticationError, // {"error":"Not logged in","success":false}
                        'Not enough balances': InsufficientFunds, // {"error":"Not enough balances","success":false}
                        'InvalidPrice': InvalidOrder, // {"error":"Invalid price","success":false}
                        'Size too small': InvalidOrder, // {"error":"Size too small","success":false}
                        'Size too large': InvalidOrder, // {"error":"Size too large","success":false}
                        'Missing parameter price': InvalidOrder, // {"error":"Missing parameter price","success":false}
                        'Order not found': OrderNotFound, // {"error":"Order not found","success":false}
                        'Order already closed': InvalidOrder, // {"error":"Order already closed","success":false}
                        'Trigger price too high': InvalidOrder, // {"error":"Trigger price too high","success":false}
                        'Trigger price too low': InvalidOrder, // {"error":"Trigger price too low","success":false}
                        'Order already queued for cancellation': CancelPending, // {"error":"Order already queued for cancellation","success":false}
                        'Duplicate client order ID': DuplicateOrderId, // {"error":"Duplicate client order ID","success":false}
                        'Spot orders cannot be reduce-only': InvalidOrder, // {"error":"Spot orders cannot be reduce-only","success":false}
                        'Invalid reduce-only order': InvalidOrder, // {"error":"Invalid reduce-only order","success":false}
                        'Account does not have enough balances': InsufficientFunds, // {"success":false,"error":"Account does not have enough balances"}
                        'Not authorized for subaccount-specific access': PermissionDenied, // {"success":false,"error":"Not authorized for subaccount-specific access"}
                    },
                    'broad': {
                        'Account does not have enough margin for order': InsufficientFunds,
                        'Invalid parameter': BadRequest, // {"error":"Invalid parameter start_time","success":false}
                        'The requested URL was not found on the server': BadRequest,
                        'No such coin': BadRequest,
                        'No such subaccount': BadRequest,
                        'No such future': BadSymbol,
                        'No such market': BadSymbol,
                        'Do not send more than': RateLimitExceeded,
                        'An unexpected error occurred': ExchangeNotAvailable, // {"error":"An unexpected error occurred, please try again later (58BC21C795).","success":false}
                        'Please retry request': ExchangeNotAvailable, // {"error":"Please retry request","success":false}
                        'Please try again': ExchangeNotAvailable, // {"error":"Please try again","success":false}
                        'Try again': ExchangeNotAvailable, // {"error":"Try again","success":false}
                        'Only have permissions for subaccount': PermissionDenied, // {"success":false,"error":"Only have permissions for subaccount *sub_name*"}
                    },
                },
                'precisionMode': TICK_SIZE,
                'options': {
                    // support for canceling conditional orders
                    // https://github.com/ccxt/ccxt/issues/6669
                    'cancelOrder': {
                        'method': 'privateDeleteOrdersOrderId', // privateDeleteConditionalOrdersOrderId
                    },
                    'fetchOpenOrders': {
                        'method': 'privateGetOrders', // privateGetConditionalOrders
                    },
                    'fetchOrders': {
                        'method': 'privateGetOrdersHistory', // privateGetConditionalOrdersHistory
                    },
                    'sign': {
                        'ftx.com': 'FTX',
                        'ftx.us': 'FTXUS',
                    },
                },
            });
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCoins (params);
            const currencies = this.safeValue (response, 'result', []);
            //
            //     {
            //         "success":true,
            //         "result": [
            //             {"id":"BTC","name":"Bitcoin"},
            //             {"id":"ETH","name":"Ethereum"},
            //             {"id":"ETHMOON","name":"10X Long Ethereum Token","underlying":"ETH"},
            //             {"id":"EOSBULL","name":"3X Long EOS Token","underlying":"EOS"},
            //         ],
            //     }
            //
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                const id = this.safeString (currency, 'id');
                const code = this.safeCurrencyCode (id);
                const name = this.safeString (currency, 'name');
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'type': undefined,
                    'name': name,
                    'active': undefined,
                    'fee': undefined,
                    'precision': undefined,
                    'limits': {
                        'withdraw': { 'min': undefined, 'max': undefined },
                        'amount': { 'min': undefined, 'max': undefined },
                    },
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarkets (params);
            //
            //     {
            //         'success': true,
            //         "result": [
            //             {
            //                 "ask":170.37,
            //                 "baseCurrency":null,
            //                 "bid":170.31,
            //                 "change1h":-0.019001554672655036,
            //                 "change24h":-0.024841165359738997,
            //                 "changeBod":-0.03816406029469881,
            //                 "enabled":true,
            //                 "last":170.37,
            //                 "name":"ETH-PERP",
            //                 "price":170.37,
            //                 "priceIncrement":0.01,
            //                 "quoteCurrency":null,
            //                 "quoteVolume24h":7742164.59889,
            //                 "sizeIncrement":0.001,
            //                 "type":"future",
            //                 "underlying":"ETH",
            //                 "volumeUsd24h":7742164.59889
            //             },
            //             {
            //                 "ask":170.44,
            //                 "baseCurrency":"ETH",
            //                 "bid":170.41,
            //                 "change1h":-0.018485459257126403,
            //                 "change24h":-0.023825887743413515,
            //                 "changeBod":-0.037605872388481086,
            //                 "enabled":true,
            //                 "last":172.72,
            //                 "name":"ETH/USD",
            //                 "price":170.44,
            //                 "priceIncrement":0.01,
            //                 "quoteCurrency":"USD",
            //                 "quoteVolume24h":382802.0252,
            //                 "sizeIncrement":0.001,
            //                 "type":"spot",
            //                 "underlying":null,
            //                 "volumeUsd24h":382802.0252
            //             },
            //         ],
            //     }
            //
            const result = [];
            const markets = this.safeValue (response, 'result', []);
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'name');
                const baseId = this.safeString2 (market, 'baseCurrency', 'underlying');
                const quoteId = this.safeString (market, 'quoteCurrency', 'USD');
                const type = this.safeString (market, 'type');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                // check if a market is a spot or future market
                const symbol = (type === 'future') ? this.safeString (market, 'name') : (base + '/' + quote);
                const active = this.safeValue (market, 'enabled');
                const sizeIncrement = this.safeNumber (market, 'sizeIncrement');
                const priceIncrement = this.safeNumber (market, 'priceIncrement');
                const precision = {
                    'amount': sizeIncrement,
                    'price': priceIncrement,
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'type': type,
                    'future': (type === 'future'),
                    'spot': (type === 'spot'),
                    'active': active,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': sizeIncrement,
                            'max': undefined,
                        },
                        'price': {
                            'min': priceIncrement,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'info': market,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         "ask":171.29,
            //         "baseCurrency":null, // base currency for spot markets
            //         "bid":171.24,
            //         "change1h":-0.0012244897959183673,
            //         "change24h":-0.031603346901854366,
            //         "changeBod":-0.03297013492914808,
            //         "enabled":true,
            //         "last":171.44,
            //         "name":"ETH-PERP",
            //         "price":171.29,
            //         "priceIncrement":0.01,
            //         "quoteCurrency":null, // quote currency for spot markets
            //         "quoteVolume24h":8570651.12113,
            //         "sizeIncrement":0.001,
            //         "type":"future",
            //         "underlying":"ETH", // null for spot markets
            //         "volumeUsd24h":8570651.12113,
            //     }
            //
            let symbol = undefined;
            const marketId = this.safeString (ticker, 'name');
            if (marketId in this.markets_by_id) {
                market = this.markets_by_id[marketId];
            } else {
                const type = this.safeString (ticker, 'type');
                if (type === 'future') {
                    symbol = marketId;
                } else {
                    const base = this.safeCurrencyCode (this.safeString (ticker, 'baseCurrency'));
                    const quote = this.safeCurrencyCode (this.safeString (ticker, 'quoteCurrency'));
                    if ((base !== undefined) && (quote !== undefined)) {
                        symbol = base + '/' + quote;
                    }
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const last = this.safeNumber (ticker, 'last');
            const timestamp = this.safeTimestamp (ticker, 'time', this.milliseconds ());
            let percentage = this.safeNumber (ticker, 'change24h');
            if (percentage !== undefined) {
                percentage *= 100;
            }
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': this.safeNumber (ticker, 'bidSize'),
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': this.safeNumber (ticker, 'askSize'),
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': this.safeNumber (ticker, 'quoteVolume24h'),
                'info': ticker,
            }, market);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market_name': market['id'],
            };
            const response = await this.publicGetMarketsMarketName (this.extend (request, params));
            //
            //     {
            //         "success":true,
            //         "result":{
            //             "ask":171.29,
            //             "baseCurrency":null, // base currency for spot markets
            //             "bid":171.24,
            //             "change1h":-0.0012244897959183673,
            //             "change24h":-0.031603346901854366,
            //             "changeBod":-0.03297013492914808,
            //             "enabled":true,
            //             "last":171.44,
            //             "name":"ETH-PERP",
            //             "price":171.29,
            //             "priceIncrement":0.01,
            //             "quoteCurrency":null, // quote currency for spot markets
            //             "quoteVolume24h":8570651.12113,
            //             "sizeIncrement":0.001,
            //             "type":"future",
            //             "underlying":"ETH", // null for spot markets
            //             "volumeUsd24h":8570651.12113,
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseTicker (result, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetMarkets (params);
            //
            //     {
            //         'success': true,
            //         "result": [
            //             {
            //                 "ask":170.44,
            //                 "baseCurrency":"ETH",
            //                 "bid":170.41,
            //                 "change1h":-0.018485459257126403,
            //                 "change24h":-0.023825887743413515,
            //                 "changeBod":-0.037605872388481086,
            //                 "enabled":true,
            //                 "last":172.72,
            //                 "name":"ETH/USD",
            //                 "price":170.44,
            //                 "priceIncrement":0.01,
            //                 "quoteCurrency":"USD",
            //                 "quoteVolume24h":382802.0252,
            //                 "sizeIncrement":0.001,
            //                 "type":"spot",
            //                 "underlying":null,
            //                 "volumeUsd24h":382802.0252
            //             },
            //         ],
            //     }
            //
            const tickers = this.safeValue (response, 'result', []);
            return this.parseTickers (tickers, symbols);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market_name': market['id'],
            };
            if (limit !== undefined) {
                request['depth'] = limit; // max 100, default 20
            }
            const response = await this.publicGetMarketsMarketNameOrderbook (this.extend (request, params));
            //
            //     {
            //         "success":true,
            //         "result":{
            //             "asks":[
            //                 [171.95,279.865],
            //                 [171.98,102.42],
            //                 [171.99,124.11],
            //             ],
            //             "bids":[
            //                 [171.93,69.749],
            //                 [171.9,288.325],
            //                 [171.88,87.47],
            //             ],
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseOrderBook (result, symbol);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "close":177.23,
            //         "high":177.45,
            //         "low":177.2,
            //         "open":177.43,
            //         "startTime":"2019-10-17T13:27:00+00:00",
            //         "time":1571318820000.0,
            //         "volume":0.0
            //     }
            //
            return [
                this.safeInteger (ohlcv, 'time'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        getMarketId (symbol, key, params = {}) {
            const parts = this.getMarketParams (symbol, key, params);
            return this.safeString (parts, 1, symbol);
        }
    
        getMarketParams (symbol, key, params = {}) {
            let market = undefined;
            let marketId = undefined;
            if (symbol in this.markets) {
                market = this.market (symbol);
                marketId = market['id'];
            } else {
                marketId = this.safeString (params, key, symbol);
            }
            return [ market, marketId ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const [ market, marketId ] = this.getMarketParams (symbol, 'market_name', params);
            const request = {
                'resolution': this.timeframes[timeframe],
                'market_name': marketId,
            };
            // max 1501 candles, including the current candle when since is not specified
            limit = (limit === undefined) ? 1501 : limit;
            if (since === undefined) {
                request['end_time'] = this.seconds ();
                request['limit'] = limit;
                request['start_time'] = request['end_time'] - limit * this.parseTimeframe (timeframe);
            } else {
                request['start_time'] = parseInt (since / 1000);
                request['limit'] = limit;
                request['end_time'] = this.sum (request['start_time'], limit * this.parseTimeframe (timeframe));
            }
            const response = await this.publicGetMarketsMarketNameCandles (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result":[
            //             {
            //                 "close":177.23,
            //                 "high":177.45,
            //                 "low":177.2,
            //                 "open":177.43,
            //                 "startTime":"2019-10-17T13:27:00+00:00",
            //                 "time":1571318820000.0,
            //                 "volume":0.0
            //             },
            //             {
            //                 "close":177.26,
            //                 "high":177.33,
            //                 "low":177.23,
            //                 "open":177.23,
            //                 "startTime":"2019-10-17T13:28:00+00:00",
            //                 "time":1571318880000.0,
            //                 "volume":0.0
            //             },
            //         ],
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOHLCVs (result, market, timeframe, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "id":1715826,
            //         "liquidation":false,
            //         "price":171.62,
            //         "side":"buy",
            //         "size":2.095,
            //         "time":"2019-10-18T12:59:54.288166+00:00"
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "fee": 20.1374935,
            //         "feeRate": 0.0005,
            //         "feeCurrency": "USD",
            //         "future": "EOS-0329",
            //         "id": 11215,
            //         "liquidity": "taker",
            //         "market": "EOS-0329",
            //         "baseCurrency": null,
            //         "quoteCurrency": null,
            //         "orderId": 8436981,
            //         "price": 4.201,
            //         "side": "buy",
            //         "size": 9587,
            //         "time": "2019-03-27T19:15:10.204619+00:00",
            //         "type": "order"
            //     }
            //
            //     {
            //         "baseCurrency": "BTC",
            //         "fee": 0,
            //         "feeCurrency": "USD",
            //         "feeRate": 0,
            //         "future": null,
            //         "id": 664079556,
            //         "liquidity": "taker",
            //         "market": null,
            //         "orderId": null,
            //         "price": 34830.61359,
            //         "quoteCurrency": "USD",
            //         "side": "sell",
            //         "size": 0.0005996,
            //         "time": "2021-01-15T16:05:29.246135+00:00",
            //         "tradeId": null,
            //         "type": "otc"
            //     }
            //
            //     with -ve fee
            //     {
            //         "id": 1171258927,
            //         "fee": -0.0000713875,
            //         "side": "sell",
            //         "size": 1,
            //         "time": "2021-03-11T13:34:35.523627+00:00",
            //         "type": "order",
            //         "price": 14.2775,
            //         "future": null,
            //         "market": "SOL/USD",
            //         "feeRate": -0.000005,
            //         "orderId": 33182929044,
            //         "tradeId": 582936801,
            //         "liquidity": "maker",
            //         "feeCurrency": "USD",
            //         "baseCurrency": "SOL",
            //         "quoteCurrency": "USD"
            //     }
            //
            //     // from OTC order
            //     {
            //         "id": 1172129651,
            //         "fee": 0,
            //         "side": "sell",
            //         "size": 1.47568846,
            //         "time": "2021-03-11T15:04:46.893383+00:00",
            //         "type": "otc",
            //         "price": 14.60932598,
            //         "future": null,
            //         "market": null,
            //         "feeRate": 0,
            //         "orderId": null,
            //         "tradeId": null,
            //         "liquidity": "taker",
            //         "feeCurrency": "USD",
            //         "baseCurrency": "BCHA",
            //         "quoteCurrency": "USD"
            //     }
            const id = this.safeString (trade, 'id');
            const takerOrMaker = this.safeString (trade, 'liquidity');
            const marketId = this.safeString (trade, 'market');
            let symbol = undefined;
            if (marketId in this.markets_by_id) {
                market = this.markets_by_id[marketId];
                symbol = market['symbol'];
            } else {
                const base = this.safeCurrencyCode (this.safeString (trade, 'baseCurrency'));
                const quote = this.safeCurrencyCode (this.safeString (trade, 'quoteCurrency'));
                if ((base !== undefined) && (quote !== undefined)) {
                    symbol = base + '/' + quote;
                } else {
                    symbol = marketId;
                }
            }
            const timestamp = this.parse8601 (this.safeString (trade, 'time'));
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'size');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const side = this.safeString (trade, 'side');
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'feeCurrency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                    'rate': this.safeNumber (trade, 'feeRate'),
                };
            }
            const orderId = this.safeString (trade, 'orderId');
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': undefined,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const [ market, marketId ] = this.getMarketParams (symbol, 'market_name', params);
            const request = {
                'market_name': marketId,
            };
            if (since !== undefined) {
                request['start_time'] = parseInt (since / 1000);
                // start_time doesn't work without end_time
                request['end_time'] = this.seconds ();
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetMarketsMarketNameTrades (this.extend (request, params));
            //
            //     {
            //         "success":true,
            //         "result":[
            //             {
            //                 "id":1715826,
            //                 "liquidation":false,
            //                 "price":171.62,
            //                 "side":"buy",
            //                 "size":2.095,
            //                 "time":"2019-10-18T12:59:54.288166+00:00"
            //             },
            //             {
            //                 "id":1715763,
            //                 "liquidation":false,
            //                 "price":171.89,
            //                 "side":"sell",
            //                 "size":1.477,
            //                 "time":"2019-10-18T12:58:38.443734+00:00"
            //             },
            //         ],
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseTrades (result, market, since, limit);
        }
    
        async fetchTradingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccount (params);
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "backstopProvider": true,
            //             "collateral": 3568181.02691129,
            //             "freeCollateral": 1786071.456884368,
            //             "initialMarginRequirement": 0.12222384240257728,
            //             "liquidating": false,
            //             "maintenanceMarginRequirement": 0.07177992558058484,
            //             "makerFee": 0.0002,
            //             "marginFraction": 0.5588433331419503,
            //             "openMarginFraction": 0.2447194090423075,
            //             "takerFee": 0.0005,
            //             "totalAccountValue": 3568180.98341129,
            //             "totalPositionSize": 6384939.6992,
            //             "username": "user@domain.com",
            //             "positions": [
            //                 {
            //                     "cost": -31.7906,
            //                     "entryPrice": 138.22,
            //                     "future": "ETH-PERP",
            //                     "initialMarginRequirement": 0.1,
            //                     "longOrderSize": 1744.55,
            //                     "maintenanceMarginRequirement": 0.04,
            //                     "netSize": -0.23,
            //                     "openSize": 1744.32,
            //                     "realizedPnl": 3.39441714,
            //                     "shortOrderSize": 1732.09,
            //                     "side": "sell",
            //                     "size": 0.23,
            //                     "unrealizedPnl": 0,
            //                 },
            //             ],
            //         },
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return {
                'info': response,
                'maker': this.safeNumber (result, 'makerFee'),
                'taker': this.safeNumber (result, 'takerFee'),
            };
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetWalletBalances (params);
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "coin": "USDTBEAR",
            //                 "free": 2320.2,
            //                 "total": 2340.2
            //             },
            //         ],
            //     }
            //
            const result = {
                'info': response,
            };
            const balances = this.safeValue (response, 'result', []);
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const code = this.safeCurrencyCode (this.safeString (balance, 'coin'));
                const account = this.account ();
                account['free'] = this.safeString2 (balance, 'availableWithoutBorrow', 'free');
                account['total'] = this.safeString (balance, 'total');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'new': 'open',
                'open': 'open',
                'closed': 'closed', // filled or canceled
                'triggered': 'closed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // limit orders - fetchOrder, fetchOrders, fetchOpenOrders, createOrder, editOrder
            //
            //     {
            //         "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //         "filledSize": 0,
            //         "future": "XRP-PERP",
            //         "id": 9596912,
            //         "market": "XRP-PERP",
            //         "price": 0.306525,
            //         "remainingSize": 31431,
            //         "side": "sell",
            //         "size": 31431,
            //         "status": "open",
            //         "type": "limit",
            //         "reduceOnly": false,
            //         "ioc": false,
            //         "postOnly": false,
            //         "clientId": null,
            //     }
            //
            // market orders - fetchOrder, fetchOrders, fetchOpenOrders, createOrder
            //
            //     {
            //         "avgFillPrice": 2666.0,
            //         "clientId": None,
            //         "createdAt": "2020-02-12T00: 53: 49.009726+00: 00",
            //         "filledSize": 0.0007,
            //         "future": None,
            //         "id": 3109208514,
            //         "ioc": True,
            //         "market": "BNBBULL/USD",
            //         "postOnly": False,
            //         "price": None,
            //         "reduceOnly": False,
            //         "remainingSize": 0.0,
            //         "side": "buy",
            //         "size": 0.0007,
            //         "status": "closed",
            //         "type": "market"
            //     }
            //
            // createOrder (conditional, "stop", "trailingStop", or "takeProfit")
            //
            //     {
            //         "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //         "future": "XRP-PERP",
            //         "id": 9596912,
            //         "market": "XRP-PERP",
            //         "triggerPrice": 0.306525,
            //         "orderId": null,
            //         "side": "sell",
            //         "size": 31431,
            //         "status": "open",
            //         "type": "stop",
            //         "orderPrice": null,
            //         "error": null,
            //         "triggeredAt": null,
            //         "reduceOnly": false
            //     }
            //
            // editOrder (conditional, stop, trailing stop, take profit)
            //
            //     {
            //         "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //         "future": "XRP-PERP",
            //         "id": 9596912,
            //         "market": "XRP-PERP",
            //         "triggerPrice": 0.306225,
            //         "orderId": null,
            //         "side": "sell",
            //         "size": 31431,
            //         "status": "open",
            //         "type": "stop",
            //         "orderPrice": null,
            //         "error": null,
            //         "triggeredAt": null,
            //         "reduceOnly": false,
            //         "orderType": "market",
            //         "filledSize": 0,
            //         "avgFillPrice": null,
            //         "retryUntilFilled": false
            //     }
            //
            // canceled order with a closed status
            //
            //     {
            //         "avgFillPrice":null,
            //         "clientId":null,
            //         "createdAt":"2020-09-01T13:45:57.119695+00:00",
            //         "filledSize":0.0,
            //         "future":null,
            //         "id":8553541288,
            //         "ioc":false,
            //         "liquidation":false,
            //         "market":"XRP/USDT",
            //         "postOnly":false,
            //         "price":0.5,
            //         "reduceOnly":false,
            //         "remainingSize":0.0,
            //         "side":"sell",
            //         "size":46.0,
            //         "status":"closed",
            //         "type":"limit"
            //     }
            //
            const id = this.safeString (order, 'id');
            const timestamp = this.parse8601 (this.safeString (order, 'createdAt'));
            let status = this.parseOrderStatus (this.safeString (order, 'status'));
            const amount = this.safeNumber (order, 'size');
            const filled = this.safeNumber (order, 'filledSize');
            let remaining = this.safeNumber (order, 'remainingSize');
            if ((remaining === 0.0) && (amount !== undefined) && (filled !== undefined)) {
                remaining = Math.max (amount - filled, 0);
                if (remaining > 0) {
                    status = 'canceled';
                }
            }
            let symbol = undefined;
            const marketId = this.safeString (order, 'market');
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                    symbol = market['symbol'];
                } else {
                    // support for delisted market ids
                    // https://github.com/ccxt/ccxt/issues/7113
                    symbol = marketId;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            const side = this.safeString (order, 'side');
            const type = this.safeString (order, 'type');
            const average = this.safeNumber (order, 'avgFillPrice');
            const price = this.safeNumber2 (order, 'price', 'triggerPrice', average);
            let cost = undefined;
            if (filled !== undefined && price !== undefined) {
                cost = filled * price;
            }
            const lastTradeTimestamp = this.parse8601 (this.safeString (order, 'triggeredAt'));
            const clientOrderId = this.safeString (order, 'clientId');
            const stopPrice = this.safeNumber (order, 'triggerPrice');
            const postOnly = this.safeValue (order, 'postOnly');
            return {
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'amount': amount,
                'cost': cost,
                'average': average,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': undefined,
                'trades': undefined,
            };
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                'side': side, // "buy" or "sell"
                // 'price': 0.306525, // send null for market orders
                'type': type, // "limit", "market", "stop", "trailingStop", or "takeProfit"
                'size': parseFloat (this.amountToPrecision (symbol, amount)),
                // 'reduceOnly': false, // optional, default is false
                // 'ioc': false, // optional, default is false, limit or market orders only
                // 'postOnly': false, // optional, default is false, limit or market orders only
                // 'clientId': 'abcdef0123456789', // string, optional, client order id, limit or market orders only
            };
            const clientOrderId = this.safeString2 (params, 'clientId', 'clientOrderId');
            if (clientOrderId !== undefined) {
                request['clientId'] = clientOrderId;
                params = this.omit (params, [ 'clientId', 'clientOrderId' ]);
            }
            let method = undefined;
            if (type === 'limit') {
                method = 'privatePostOrders';
                request['price'] = parseFloat (this.priceToPrecision (symbol, price));
            } else if (type === 'market') {
                method = 'privatePostOrders';
                request['price'] = null;
            } else if ((type === 'stop') || (type === 'takeProfit')) {
                method = 'privatePostConditionalOrders';
                const stopPrice = this.safeNumber2 (params, 'stopPrice', 'triggerPrice');
                if (stopPrice === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder () requires a stopPrice parameter or a triggerPrice parameter for ' + type + ' orders');
                } else {
                    params = this.omit (params, [ 'stopPrice', 'triggerPrice' ]);
                    request['triggerPrice'] = parseFloat (this.priceToPrecision (symbol, stopPrice));
                }
                if (price !== undefined) {
                    request['orderPrice'] = parseFloat (this.priceToPrecision (symbol, price)); // optional, order type is limit if this is specified, otherwise market
                }
            } else if (type === 'trailingStop') {
                method = 'privatePostConditionalOrders';
                request['trailValue'] = parseFloat (this.priceToPrecision (symbol, price)); // negative for "sell", positive for "buy"
            } else {
                throw new InvalidOrder (this.id + ' createOrder () does not support order type ' + type + ', only limit, market, stop, trailingStop, or takeProfit orders are supported');
            }
            const response = await this[method] (this.extend (request, params));
            //
            // orders
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //                 "filledSize": 0,
            //                 "future": "XRP-PERP",
            //                 "id": 9596912,
            //                 "market": "XRP-PERP",
            //                 "price": 0.306525,
            //                 "remainingSize": 31431,
            //                 "side": "sell",
            //                 "size": 31431,
            //                 "status": "open",
            //                 "type": "limit",
            //                 "reduceOnly": false,
            //                 "ioc": false,
            //                 "postOnly": false,
            //                 "clientId": null,
            //             }
            //         ]
            //     }
            //
            // conditional orders
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //                 "future": "XRP-PERP",
            //                 "id": 9596912,
            //                 "market": "XRP-PERP",
            //                 "triggerPrice": 0.306525,
            //                 "orderId": null,
            //                 "side": "sell",
            //                 "size": 31431,
            //                 "status": "open",
            //                 "type": "stop",
            //                 "orderPrice": null,
            //                 "error": null,
            //                 "triggeredAt": null,
            //                 "reduceOnly": false
            //             }
            //         ]
            //     }
            //
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOrder (result, market);
        }
    
        async editOrder (id, symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {};
            let method = undefined;
            const clientOrderId = this.safeString2 (params, 'client_order_id', 'clientOrderId');
            const triggerPrice = this.safeNumber (params, 'triggerPrice');
            const orderPrice = this.safeNumber (params, 'orderPrice');
            const trailValue = this.safeNumber (params, 'trailValue');
            params = this.omit (params, [ 'client_order_id', 'clientOrderId', 'triggerPrice', 'orderPrice', 'trailValue' ]);
            const triggerPriceIsDefined = (triggerPrice !== undefined);
            const orderPriceIsDefined = (orderPrice !== undefined);
            const trailValueIsDefined = (trailValue !== undefined);
            if (triggerPriceIsDefined || orderPriceIsDefined || trailValueIsDefined) {
                method = 'privatePostConditionalOrdersOrderIdModify';
                request['order_id'] = id;
                if (triggerPriceIsDefined) {
                    request['triggerPrice'] = parseFloat (this.priceToPrecision (symbol, triggerPrice));
                }
                if (orderPriceIsDefined) {
                    // only for stop limit or take profit limit orders
                    request['orderPrice'] = parseFloat (this.priceToPrecision (symbol, orderPrice));
                }
                if (trailValueIsDefined) {
                    // negative for sell orders, positive for buy orders
                    request['trailValue'] = parseFloat (this.priceToPrecision (symbol, trailValue));
                }
            } else {
                if (clientOrderId === undefined) {
                    method = 'privatePostOrdersOrderIdModify';
                    request['order_id'] = id;
                } else {
                    method = 'privatePostOrdersByClientIdClientOrderIdModify';
                    request['client_order_id'] = clientOrderId;
                    // request['clientId'] = clientOrderId;
                }
                if (price !== undefined) {
                    request['price'] = parseFloat (this.priceToPrecision (symbol, price));
                }
            }
            if (amount !== undefined) {
                request['size'] = parseFloat (this.amountToPrecision (symbol, amount));
            }
            const response = await this[method] (this.extend (request, params));
            //
            // regular order
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "createdAt": "2019-03-05T11:56:55.728933+00:00",
            //             "filledSize": 0,
            //             "future": "XRP-PERP",
            //             "id": 9596932,
            //             "market": "XRP-PERP",
            //             "price": 0.326525,
            //             "remainingSize": 31431,
            //             "side": "sell",
            //             "size": 31431,
            //             "status": "open",
            //             "type": "limit",
            //             "reduceOnly": false,
            //             "ioc": false,
            //             "postOnly": false,
            //             "clientId": null,
            //         }
            //     }
            //
            // conditional trigger order
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //             "future": "XRP-PERP",
            //             "id": 9596912,
            //             "market": "XRP-PERP",
            //             "triggerPrice": 0.306225,
            //             "orderId": null,
            //             "side": "sell",
            //             "size": 31431,
            //             "status": "open",
            //             "type": "stop",
            //             "orderPrice": null,
            //             "error": null,
            //             "triggeredAt": null,
            //             "reduceOnly": false,
            //             "orderType": "market",
            //             "filledSize": 0,
            //             "avgFillPrice": null,
            //             "retryUntilFilled": false
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseOrder (result, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            // support for canceling conditional orders
            // https://github.com/ccxt/ccxt/issues/6669
            const options = this.safeValue (this.options, 'cancelOrder', {});
            const defaultMethod = this.safeString (options, 'method', 'privateDeleteOrdersOrderId');
            let method = this.safeString (params, 'method', defaultMethod);
            const type = this.safeValue (params, 'type');
            const clientOrderId = this.safeValue2 (params, 'client_order_id', 'clientOrderId');
            if (clientOrderId === undefined) {
                request['order_id'] = parseInt (id);
                if ((type === 'stop') || (type === 'trailingStop') || (type === 'takeProfit')) {
                    method = 'privateDeleteConditionalOrdersOrderId';
                }
            } else {
                request['client_order_id'] = clientOrderId;
                method = 'privateDeleteOrdersByClientIdClientOrderId';
            }
            const query = this.omit (params, [ 'method', 'type', 'client_order_id', 'clientOrderId' ]);
            const response = await this[method] (this.extend (request, query));
            //
            //     {
            //         "success": true,
            //         "result": "Order queued for cancelation"
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return result;
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'market': market['id'], // optional
                // 'conditionalOrdersOnly': false, // cancel conditional orders only
                // 'limitOrdersOnly': false, // cancel existing limit orders (non-conditional orders) only
            };
            const marketId = this.getMarketId (symbol, 'market', params);
            if (marketId !== undefined) {
                request['market'] = marketId;
            }
            const response = await this.privateDeleteOrders (this.extend (request, params));
            const result = this.safeValue (response, 'result', {});
            //
            //     {
            //         "success": true,
            //         "result": "Orders queued for cancelation"
            //     }
            //
            return result;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const clientOrderId = this.safeValue2 (params, 'client_order_id', 'clientOrderId');
            let method = 'privateGetOrdersOrderId';
            if (clientOrderId === undefined) {
                request['order_id'] = id;
            } else {
                request['client_order_id'] = clientOrderId;
                params = this.omit (params, [ 'client_order_id', 'clientOrderId']);
                method = 'privateGetOrdersByClientIdClientOrderId';
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //             "filledSize": 10,
            //             "future": "XRP-PERP",
            //             "id": 9596912,
            //             "market": "XRP-PERP",
            //             "price": 0.306525,
            //             "avgFillPrice": 0.306526,
            //             "remainingSize": 31421,
            //             "side": "sell",
            //             "size": 31431,
            //             "status": "open",
            //             "type": "limit",
            //             "reduceOnly": false,
            //             "ioc": false,
            //             "postOnly": false,
            //             "clientId": null
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseOrder (result);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const [ market, marketId ] = this.getMarketParams (symbol, 'market', params);
            if (marketId !== undefined) {
                request['market'] = marketId;
            }
            // support for canceling conditional orders
            // https://github.com/ccxt/ccxt/issues/6669
            const options = this.safeValue (this.options, 'fetchOpenOrders', {});
            const defaultMethod = this.safeString (options, 'method', 'privateGetOrders');
            let method = this.safeString (params, 'method', defaultMethod);
            const type = this.safeValue (params, 'type');
            if ((type === 'stop') || (type === 'trailingStop') || (type === 'takeProfit')) {
                method = 'privateGetConditionalOrders';
            }
            const query = this.omit (params, [ 'method', 'type' ]);
            const response = await this[method] (this.extend (request, query));
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //                 "filledSize": 10,
            //                 "future": "XRP-PERP",
            //                 "id": 9596912,
            //                 "market": "XRP-PERP",
            //                 "price": 0.306525,
            //                 "avgFillPrice": 0.306526,
            //                 "remainingSize": 31421,
            //                 "side": "sell",
            //                 "size": 31431,
            //                 "status": "open",
            //                 "type": "limit",
            //                 "reduceOnly": false,
            //                 "ioc": false,
            //                 "postOnly": false,
            //                 "clientId": null
            //             }
            //         ]
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOrders (result, market, since, limit);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const [ market, marketId ] = this.getMarketParams (symbol, 'market', params);
            if (marketId !== undefined) {
                request['market'] = marketId;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 100, max 100
            }
            if (since !== undefined) {
                request['start_time'] = parseInt (since / 1000);
            }
            // support for canceling conditional orders
            // https://github.com/ccxt/ccxt/issues/6669
            const options = this.safeValue (this.options, 'fetchOrders', {});
            const defaultMethod = this.safeString (options, 'method', 'privateGetOrdersHistory');
            let method = this.safeString (params, 'method', defaultMethod);
            const type = this.safeValue (params, 'type');
            if ((type === 'stop') || (type === 'trailingStop') || (type === 'takeProfit')) {
                method = 'privateGetConditionalOrdersHistory';
            }
            const query = this.omit (params, [ 'method', 'type' ]);
            const response = await this[method] (this.extend (request, query));
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "createdAt": "2019-03-05T09:56:55.728933+00:00",
            //                 "filledSize": 10,
            //                 "future": "XRP-PERP",
            //                 "id": 9596912,
            //                 "market": "XRP-PERP",
            //                 "price": 0.306525,
            //                 "avgFillPrice": 0.306526,
            //                 "remainingSize": 31421,
            //                 "side": "sell",
            //                 "size": 31431,
            //                 "status": "open",
            //                 "type": "limit",
            //                 "reduceOnly": false,
            //                 "ioc": false,
            //                 "postOnly": false,
            //                 "clientId": null
            //             }
            //         ]
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            return this.parseOrders (result, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const [ market, marketId ] = this.getMarketParams (symbol, 'market', params);
            const request = {};
            if (marketId !== undefined) {
                request['market'] = marketId;
            }
            if (since !== undefined) {
                request['start_time'] = parseInt (since / 1000);
                request['end_time'] = this.seconds ();
            }
            const response = await this.privateGetFills (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "fee": 20.1374935,
            //                 "feeRate": 0.0005,
            //                 "future": "EOS-0329",
            //                 "id": 11215,
            //                 "liquidity": "taker",
            //                 "market": "EOS-0329",
            //                 "baseCurrency": null,
            //                 "quoteCurrency": null,
            //                 "orderId": 8436981,
            //                 "price": 4.201,
            //                 "side": "buy",
            //                 "size": 9587,
            //                 "time": "2019-03-27T19:15:10.204619+00:00",
            //                 "type": "order"
            //             }
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'result', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            await this.loadMarkets ();
            this.checkAddress (address);
            const currency = this.currency (code);
            const request = {
                'coin': currency['id'],
                'size': amount,
                'address': address,
                // 'password': 'string', // optional withdrawal password if it is required for your account
                // 'code': '192837', // optional 2fa code if it is required for your account
            };
            if (this.password !== undefined) {
                request['password'] = this.password;
            }
            if (tag !== undefined) {
                request['tag'] = tag;
            }
            const response = await this.privatePostWalletWithdrawals (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "coin": "USDTBEAR",
            //             "address": "0x83a127952d266A6eA306c40Ac62A4a70668FE3BE",
            //             "tag": "null",
            //             "fee": 0,
            //             "id": 1,
            //             "size": "20.2",
            //             "status": "requested",
            //             "time": "2019-03-05T09:56:55.728933+00:00",
            //             "txid": "null"
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            return this.parseTransaction (result, currency);
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'showAvgPrice': false,
            };
            const response = await this.privateGetPositions (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result": [
            //             {
            //                 "cost": -31.7906,
            //                 "entryPrice": 138.22,
            //                 "estimatedLiquidationPrice": 152.1,
            //                 "future": "ETH-PERP",
            //                 "initialMarginRequirement": 0.1,
            //                 "longOrderSize": 1744.55,
            //                 "maintenanceMarginRequirement": 0.04,
            //                 "netSize": -0.23,
            //                 "openSize": 1744.32,
            //                 "realizedPnl": 3.39441714,
            //                 "shortOrderSize": 1732.09,
            //                 "side": "sell",
            //                 "size": 0.23,
            //                 "unrealizedPnl": 0,
            //                 "collateralUsed": 3.17906
            //             }
            //         ]
            //     }
            //
            // todo unify parsePosition/parsePositions
            return this.safeValue (response, 'result', []);
        }
    
        async fetchAccountPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccount (params);
            //
            //     {
            //         "result":{
            //             "backstopProvider":false,
            //             "chargeInterestOnNegativeUsd":false,
            //             "collateral":2830.2567913677476,
            //             "freeCollateral":2829.670741867416,
            //             "initialMarginRequirement":0.05,
            //             "leverage":20.0,
            //             "liquidating":false,
            //             "maintenanceMarginRequirement":0.03,
            //             "makerFee":0.0,
            //             "marginFraction":null,
            //             "openMarginFraction":null,
            //             "positionLimit":null,
            //             "positionLimitUsed":null,
            //             "positions":[
            //                 {
            //                     "collateralUsed":0.0,
            //                     "cost":0.0,
            //                     "entryPrice":null,
            //                     "estimatedLiquidationPrice":null,
            //                     "future":"XRP-PERP",
            //                     "initialMarginRequirement":0.05,
            //                     "longOrderSize":0.0,
            //                     "maintenanceMarginRequirement":0.03,
            //                     "netSize":0.0,
            //                     "openSize":0.0,
            //                     "realizedPnl":0.016,
            //                     "shortOrderSize":0.0,
            //                     "side":"buy",
            //                     "size":0.0,
            //                     "unrealizedPnl":0.0,
            //                 }
            //             ],
            //             "spotLendingEnabled":false,
            //             "spotMarginEnabled":false,
            //             "takerFee":0.0007,
            //             "totalAccountValue":2830.2567913677476,
            //             "totalPositionSize":0.0,
            //             "useFttCollateral":true,
            //             "username":"igor.kroitor@gmail.com"
            //         },
            //         "success":true
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            // todo unify parsePosition/parsePositions
            return this.safeValue (result, 'positions', []);
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'coin': currency['id'],
            };
            const response = await this.privateGetWalletDepositAddressCoin (this.extend (request, params));
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "address": "0x83a127952d266A6eA306c40Ac62A4a70668FE3BE",
            //             "tag": "null"
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            const address = this.safeString (result, 'address');
            const tag = this.safeString (result, 'tag');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                // what are other statuses here?
                'confirmed': 'ok', // deposits
                'complete': 'ok', // withdrawals
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     airdrop
            //
            //     {
            //         "id": 9147072,
            //         "coin": "SRM_LOCKED",
            //         "size": 3.12,
            //         "time": "2021-04-27T23:59:03.565983+00:00",
            //         "notes": "SRM Airdrop for FTT holdings",
            //         "status": "complete"
            //     }
            //
            //     regular deposits
            //
            //     {
            //         "coin": "TUSD",
            //         "confirmations": 64,
            //         "confirmedTime": "2019-03-05T09:56:55.728933+00:00",
            //         "fee": 0,
            //         "id": 1,
            //         "sentTime": "2019-03-05T09:56:55.735929+00:00",
            //         "size": "99.0",
            //         "status": "confirmed",
            //         "time": "2019-03-05T09:56:55.728933+00:00",
            //         "txid": "0x8078356ae4b06a036d64747546c274af19581f1c78c510b60505798a7ffcaf1"
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         "coin": "TUSD",
            //         "address": "0x83a127952d266A6eA306c40Ac62A4a70668FE3BE",
            //         "tag": "null",
            //         "fee": 0,
            //         "id": 1,
            //         "size": "99.0",
            //         "status": "complete",
            //         "time": "2019-03-05T09:56:55.728933+00:00",
            //         "txid": "0x8078356ae4b06a036d64747546c274af19581f1c78c510b60505798a7ffcaf1"
            //     }
            //
            //     {
            //         "coin": 'BTC',
            //         "id": 1969806,
            //         "notes": 'Transfer to Dd6gi7m2Eg4zzBbPAxuwfEaHs6tYvyUX5hbPpsTcNPXo',
            //         "size": 0.003,
            //         "status": 'complete',
            //         "time": '2021-02-03T20:28:54.918146+00:00'
            //     }
            //
            const code = this.safeCurrencyCode (this.safeString (transaction, 'coin'));
            const id = this.safeString (transaction, 'id');
            const amount = this.safeNumber (transaction, 'size');
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const timestamp = this.parse8601 (this.safeString (transaction, 'time'));
            const txid = this.safeString (transaction, 'txid');
            let tag = undefined;
            let address = this.safeValue (transaction, 'address');
            if (typeof address !== 'string') {
                tag = this.safeString (address, 'tag');
                address = this.safeString (address, 'address');
            }
            if (address === undefined) {
                // parse address from internal transfer
                const notes = this.safeString (transaction, 'notes');
                if ((notes !== undefined) && (notes.indexOf ('Transfer to') >= 0)) {
                    address = notes.slice (12);
                }
            }
            const fee = this.safeNumber (transaction, 'fee');
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': undefined,
                'address': address,
                'addressTo': address,
                'tagFrom': undefined,
                'tag': tag,
                'tagTo': tag,
                'type': undefined,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': {
                    'currency': code,
                    'cost': fee,
                    'rate': undefined,
                },
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetWalletDeposits (params);
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "coin": "TUSD",
            //             "confirmations": 64,
            //             "confirmedTime": "2019-03-05T09:56:55.728933+00:00",
            //             "fee": 0,
            //             "id": 1,
            //             "sentTime": "2019-03-05T09:56:55.735929+00:00",
            //             "size": "99.0",
            //             "status": "confirmed",
            //             "time": "2019-03-05T09:56:55.728933+00:00",
            //             "txid": "0x8078356ae4b06a036d64747546c274af19581f1c78c510b60505798a7ffcaf1"
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            return this.parseTransactions (result, currency, since, limit, { 'type': 'deposit' });
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetWalletWithdrawals (params);
            //
            //     {
            //         "success": true,
            //         "result": {
            //             "coin": "TUSD",
            //             "address": "0x83a127952d266A6eA306c40Ac62A4a70668FE3BE",
            //             "tag": "null",
            //             "fee": 0,
            //             "id": 1,
            //             "size": "99.0",
            //             "status": "complete",
            //             "time": "2019-03-05T09:56:55.728933+00:00",
            //             "txid": "0x8078356ae4b06a036d64747546c274af19581f1c78c510b60505798a7ffcaf1"
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            return this.parseTransactions (result, currency, since, limit, { 'type': 'withdrawal' });
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/api/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            const baseUrl = this.implodeHostname (this.urls['api'][api]);
            let url = baseUrl + request;
            if (method !== 'POST') {
                if (Object.keys (query).length) {
                    const suffix = '?' + this.urlencode (query);
                    url += suffix;
                    request += suffix;
                }
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const timestamp = this.milliseconds ().toString ();
                let auth = timestamp + method + request;
                headers = {};
                if ((method === 'POST') || (method === 'DELETE')) {
                    body = this.json (query);
                    auth += body;
                    headers['Content-Type'] = 'application/json';
                }
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256');
                const options = this.safeValue (this.options, 'sign', {});
                const headerPrefix = this.safeString (options, this.hostname, 'FTX');
                const keyField = headerPrefix + '-KEY';
                const tsField = headerPrefix + '-TS';
                const signField = headerPrefix + '-SIGN';
                headers[keyField] = this.apiKey;
                headers[tsField] = timestamp;
                headers[signField] = signature;
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to the default error handler
            }
            //
            //     {"error":"Invalid parameter start_time","success":false}
            //     {"error":"Not enough balances","success":false}
            //
            const success = this.safeValue (response, 'success');
            if (!success) {
                const feedback = this.id + ' ' + body;
                const error = this.safeString (response, 'error');
                this.throwExactlyMatchedException (this.exceptions['exact'], error, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], error, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    
        async setLeverage (leverage, symbol = undefined, params = {}) {
            // WARNING: THIS WILL INCREASE LIQUIDATION PRICE FOR OPEN ISOLATED LONG POSITIONS
            // AND DECREASE LIQUIDATION PRICE FOR OPEN ISOLATED SHORT POSITIONS
            if ((leverage < 1) || (leverage > 20)) {
                throw new BadRequest (this.id + ' leverage should be between 1 and 20');
            }
            const request = {
                'leverage': leverage,
            };
            return await this.privatePostAccountLeverage (this.extend (request, params));
        }
    
        parseIncome (income, market = undefined) {
            //
            //   {
            //       "future": "ETH-PERP",
            //        "id": 33830,
            //        "payment": 0.0441342,
            //        "time": "2019-05-15T18:00:00+00:00",
            //        "rate": 0.0001
            //   }
            //
            const marketId = this.safeString (income, 'future');
            const symbol = this.safeSymbol (marketId, market);
            const amount = this.safeNumber (income, 'payment');
            const code = this.safeCurrencyCode ('USD');
            const id = this.safeString (income, 'id');
            const timestamp = this.safeInteger (income, 'time');
            const rate = this.safe_number (income, 'rate');
            return {
                'info': income,
                'symbol': symbol,
                'code': code,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'id': id,
                'amount': amount,
                'rate': rate,
            };
        }
    
        parseIncomes (incomes, market = undefined, since = undefined, limit = undefined) {
            const result = [];
            for (let i = 0; i < incomes.length; i++) {
                const entry = incomes[i];
                const parsed = this.parseIncome (entry, market);
                result.push (parsed);
            }
            return this.filterBySinceLimit (result, since, limit, 'timestamp');
        }
    
        async fetchFundingHistory (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const method = 'private_get_funding_payments';
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['future'] = market['id'];
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            const response = await this[method] (this.extend (request, params));
            return this.parseIncomes (response, market, since, limit);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],82:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const Precise = require ('./base/Precise');
    const { ExchangeError, BadRequest, ArgumentsRequired, AuthenticationError, PermissionDenied, AccountSuspended, InsufficientFunds, RateLimitExceeded, ExchangeNotAvailable, BadSymbol, InvalidOrder, OrderNotFound } = require ('./base/errors');
    
    module.exports = class gateio extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'gateio',
                'name': 'Gate.io',
                'countries': [ 'KR' ],
                'rateLimit': 1000,
                'version': '4',
                'certified': true,
                'pro': true,
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/31784029-0313c702-b509-11e7-9ccc-bc0da6a0e435.jpg',
                    'doc': 'https://www.gate.io/docs/apiv4/en/index.html',
                    'www': 'https://gate.io/',
                    'api': {
                        'public': 'https://api.gateio.ws/api/v4',
                        'private': 'https://api.gateio.ws/api/v4',
                    },
                    'referral': {
                        'url': 'https://www.gate.io/ref/2436035',
                        'discount': 0.2,
                    },
                },
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'transfer': true,
                    'withdraw': true,
                },
                'api': {
                    'public': {
                        'spot': {
                            'get': [
                                'currencies',
                                'currencies/{currency}',
                                'currency_pairs',
                                'currency_pairs/{currency_pair}',
                                'tickers',
                                'order_book',
                                'trades',
                                'candlesticks',
                            ],
                        },
                        'margin': {
                            'get': [
                                'currency_pairs',
                                'currency_pairs/{currency_pair}',
                                'cross/currencies',
                                'cross/currencies/{currency}',
                            ],
                        },
                        'futures': {
                            'get': [
                                '{settle}/contracts',
                                '{settle}/contracts/{contract}',
                                '{settle}/order_book',
                                '{settle}/trades',
                                '{settle}/candlesticks',
                                '{settle}/tickers',
                                '{settle}/funding_rate',
                                '{settle}/insurance',
                                '{settle}/contract_stats',
                                '{settle}/liq_orders',
                            ],
                        },
                        'delivery': {
                            'get': [
                                '{settle}/contracts',
                                '{settle}/contracts/{contract}',
                                '{settle}/order_book',
                                '{settle}/trades',
                                '{settle}/candlesticks',
                                '{settle}/tickers',
                                '{settle}/insurance',
                            ],
                        },
                    },
                    'private': {
                        'withdrawals': {
                            'post': [
                                '', // /withdrawals
                            ],
                            'delete': [
                                '{withdrawal_id}',
                            ],
                        },
                        'wallet': {
                            'get': [
                                'deposit_address',
                                'withdrawals',
                                'deposits',
                                'sub_account_transfers',
                                'withdraw_status',
                                'sub_account_balances',
                                'fee',
                            ],
                            'post': [
                                'transfers',
                                'sub_account_transfers',
                            ],
                        },
                        'spot': {
                            'get': [
                                'accounts',
                                'open_orders',
                                'orders',
                                'orders/{order_id}',
                                'my_trades',
                                'price_orders',
                                'price_orders/{order_id}',
                            ],
                            'post': [
                                'batch_orders',
                                'orders',
                                'cancel_batch_orders',
                                'price_orders',
                            ],
                            'delete': [
                                'orders',
                                'orders/{order_id}',
                                'price_orders',
                                'price_orders/{order_id}',
                            ],
                        },
                        'margin': {
                            'get': [
                                'account_book',
                                'funding_accounts',
                                'loans',
                                'loans/{loan_id}',
                                'loans/{loan_id}/repayment',
                                'loan_records',
                                'loan_records/{load_record_id}',
                                'auto_repay',
                                'transferable',
                                'cross/accounts',
                                'cross/account_book',
                                'cross/loans',
                                'cross/loans/{loan_id}',
                                'cross/loans/repayments',
                                'cross/transferable',
                            ],
                            'post': [
                                'loans',
                                'merged_loans',
                                'loans/{loan_id}/repayment',
                                'auto_repay',
                                'cross/loans',
                                'cross/loans/repayments',
                            ],
                            'patch': [
                                'loans/{loan_id}',
                                'loan_records/{loan_record_id}',
                            ],
                            'delete': [
                                'loans/{loan_id}',
                            ],
                        },
                        'futures': {
                            'get': [
                                '{settle}/accounts',
                                '{settle}/account_book',
                                '{settle}/positions',
                                '{settle}/positions/{contract}',
                                '{settle}/orders',
                                '{settle}/orders/{order_id}',
                                '{settle}/my_trades',
                                '{settle}/position_close',
                                '{settle}/liquidates',
                                '{settle}/price_orders',
                                '{settle}/price_orders/{order_id}',
                            ],
                            'post': [
                                '{settle}/positions/{contract}/margin',
                                '{settle}/positions/{contract}/leverage',
                                '{settle}/positions/{contract}/risk_limit',
                                '{settle}/dual_mode',
                                '{settle}/dual_comp/positions/{contract}',
                                '{settle}/dual_comp/positions/{contract}/margin',
                                '{settle}/dual_comp/positions/{contract}/leverage',
                                '{settle}/dual_comp/positions/{contract}/risk_limit',
                                '{settle}/orders',
                                '{settle}/price_orders',
                            ],
                            'delete': [
                                '{settle}/orders',
                                '{settle}/orders/{order_id}',
                                '{settle}/price_orders',
                                '{settle}/price_orders/{order_id}',
                            ],
                        },
                        'delivery': {
                            'get': [
                                '{settle}/accounts',
                                '{settle}/account_book',
                                '{settle}/positions',
                                '{settle}/positions/{contract}',
                                '{settle}/orders',
                                '{settle}/orders/{order_id}',
                                '{settle}/my_trades',
                                '{settle}/position_close',
                                '{settle}/liquidates',
                                '{settle}/price_orders',
                                '{settle}/price_orders/{order_id}',
                            ],
                            'post': [
                                '{settle}/positions/{contract}/margin',
                                '{settle}/positions/{contract}/leverage',
                                '{settle}/positions/{contract}/risk_limit',
                                '{settle}/orders',
                            ],
                            'delete': [
                                '{settle}/orders',
                                '{settle}/orders/{order_id}',
                                '{settle}/price_orders',
                                '{settle}/price_orders/{order_id}',
                            ],
                        },
                    },
                },
                'timeframes': {
                    '10s': '10s',
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '4h': '4h',
                    '8h': '8h',
                    '1d': '1d',
                    '7d': '7d',
                },
                // copied from gateiov2
                'commonCurrencies': {
                    '88MPH': 'MPH',
                    'BIFI': 'Bitcoin File',
                    'BOX': 'DefiBox',
                    'BTCBEAR': 'BEAR',
                    'BTCBULL': 'BULL',
                    'BYN': 'Beyond Finance',
                    'GTC': 'Game.com', // conflict with Gitcoin and Gastrocoin
                    'GTC_HT': 'Game.com HT',
                    'GTC_BSC': 'Game.com BSC',
                    'HIT': 'HitChain',
                    'MPH': 'Morpher', // conflict with 88MPH
                    'RAI': 'Rai Reflex Index', // conflict with RAI Finance
                    'SBTC': 'Super Bitcoin',
                    'TNC': 'Trinity Network Credit',
                    'VAI': 'VAIOT',
                },
                'options': {
                    'accountsByType': {
                        'spot': 'spot',
                        'margin': 'margin',
                        'futures': 'futures',
                        'delivery': 'delivery',
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'feeSide': 'get',
                        'percentage': true,
                        'maker': this.parseNumber ('0.002'),
                        'taker': this.parseNumber ('0.002'),
                        'tiers': {
                            // volume is in BTC
                            'maker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.002') ],
                                [ this.parseNumber ('1.5'), this.parseNumber ('0.00185') ],
                                [ this.parseNumber ('3'), this.parseNumber ('0.00175') ],
                                [ this.parseNumber ('6'), this.parseNumber ('0.00165') ],
                                [ this.parseNumber ('12.5'), this.parseNumber ('0.00155') ],
                                [ this.parseNumber ('25'), this.parseNumber ('0.00145') ],
                                [ this.parseNumber ('75'), this.parseNumber ('0.00135') ],
                                [ this.parseNumber ('200'), this.parseNumber ('0.00125') ],
                                [ this.parseNumber ('500'), this.parseNumber ('0.00115') ],
                                [ this.parseNumber ('1250'), this.parseNumber ('0.00105') ],
                                [ this.parseNumber ('2500'), this.parseNumber ('0.00095') ],
                                [ this.parseNumber ('3000'), this.parseNumber ('0.00085') ],
                                [ this.parseNumber ('6000'), this.parseNumber ('0.00075') ],
                                [ this.parseNumber ('11000'), this.parseNumber ('0.00065') ],
                                [ this.parseNumber ('20000'), this.parseNumber ('0.00055') ],
                                [ this.parseNumber ('40000'), this.parseNumber ('0.00055') ],
                                [ this.parseNumber ('75000'), this.parseNumber ('0.00055') ],
                            ],
                            'taker': [
                                [ this.parseNumber ('0'), this.parseNumber ('0.002') ],
                                [ this.parseNumber ('1.5'), this.parseNumber ('0.00195') ],
                                [ this.parseNumber ('3'), this.parseNumber ('0.00185') ],
                                [ this.parseNumber ('6'), this.parseNumber ('0.00175') ],
                                [ this.parseNumber ('12.5'), this.parseNumber ('0.00165') ],
                                [ this.parseNumber ('25'), this.parseNumber ('0.00155') ],
                                [ this.parseNumber ('75'), this.parseNumber ('0.00145') ],
                                [ this.parseNumber ('200'), this.parseNumber ('0.00135') ],
                                [ this.parseNumber ('500'), this.parseNumber ('0.00125') ],
                                [ this.parseNumber ('1250'), this.parseNumber ('0.00115') ],
                                [ this.parseNumber ('2500'), this.parseNumber ('0.00105') ],
                                [ this.parseNumber ('3000'), this.parseNumber ('0.00095') ],
                                [ this.parseNumber ('6000'), this.parseNumber ('0.00085') ],
                                [ this.parseNumber ('11000'), this.parseNumber ('0.00075') ],
                                [ this.parseNumber ('20000'), this.parseNumber ('0.00065') ],
                                [ this.parseNumber ('40000'), this.parseNumber ('0.00065') ],
                                [ this.parseNumber ('75000'), this.parseNumber ('0.00065') ],
                            ],
                        },
                    },
                },
                // https://www.gate.io/docs/apiv4/en/index.html#label-list
                'exceptions': {
                    'INVALID_PARAM_VALUE': BadRequest,
                    'INVALID_PROTOCOL': BadRequest,
                    'INVALID_ARGUMENT': BadRequest,
                    'INVALID_REQUEST_BODY': BadRequest,
                    'MISSING_REQUIRED_PARAM': ArgumentsRequired,
                    'BAD_REQUEST': BadRequest,
                    'INVALID_CONTENT_TYPE': BadRequest,
                    'NOT_ACCEPTABLE': BadRequest,
                    'METHOD_NOT_ALLOWED': BadRequest,
                    'NOT_FOUND': ExchangeError,
                    'INVALID_CREDENTIALS': AuthenticationError,
                    'INVALID_KEY': AuthenticationError,
                    'IP_FORBIDDEN': AuthenticationError,
                    'READ_ONLY': PermissionDenied,
                    'INVALID_SIGNATURE': AuthenticationError,
                    'MISSING_REQUIRED_HEADER': AuthenticationError,
                    'REQUEST_EXPIRED': AuthenticationError,
                    'ACCOUNT_LOCKED': AccountSuspended,
                    'FORBIDDEN': PermissionDenied,
                    'SUB_ACCOUNT_NOT_FOUND': ExchangeError,
                    'SUB_ACCOUNT_LOCKED': AccountSuspended,
                    'MARGIN_BALANCE_EXCEPTION': ExchangeError,
                    'MARGIN_TRANSFER_FAILED': ExchangeError,
                    'TOO_MUCH_FUTURES_AVAILABLE': ExchangeError,
                    'FUTURES_BALANCE_NOT_ENOUGH': InsufficientFunds,
                    'ACCOUNT_EXCEPTION': ExchangeError,
                    'SUB_ACCOUNT_TRANSFER_FAILED': ExchangeError,
                    'ADDRESS_NOT_USED': ExchangeError,
                    'TOO_FAST': RateLimitExceeded,
                    'WITHDRAWAL_OVER_LIMIT': ExchangeError,
                    'API_WITHDRAW_DISABLED': ExchangeNotAvailable,
                    'INVALID_WITHDRAW_ID': ExchangeError,
                    'INVALID_WITHDRAW_CANCEL_STATUS': ExchangeError,
                    'INVALID_PRECISION': InvalidOrder,
                    'INVALID_CURRENCY': BadSymbol,
                    'INVALID_CURRENCY_PAIR': BadSymbol,
                    'POC_FILL_IMMEDIATELY': ExchangeError,
                    'ORDER_NOT_FOUND': OrderNotFound,
                    'ORDER_CLOSED': InvalidOrder,
                    'ORDER_CANCELLED': InvalidOrder,
                    'QUANTITY_NOT_ENOUGH': InvalidOrder,
                    'BALANCE_NOT_ENOUGH': InsufficientFunds,
                    'MARGIN_NOT_SUPPORTED': InvalidOrder,
                    'MARGIN_BALANCE_NOT_ENOUGH': InsufficientFunds,
                    'AMOUNT_TOO_LITTLE': InvalidOrder,
                    'AMOUNT_TOO_MUCH': InvalidOrder,
                    'REPEATED_CREATION': InvalidOrder,
                    'LOAN_NOT_FOUND': OrderNotFound,
                    'LOAN_RECORD_NOT_FOUND': OrderNotFound,
                    'NO_MATCHED_LOAN': ExchangeError,
                    'NOT_MERGEABLE': ExchangeError,
                    'NO_CHANGE': ExchangeError,
                    'REPAY_TOO_MUCH': ExchangeError,
                    'TOO_MANY_CURRENCY_PAIRS': InvalidOrder,
                    'TOO_MANY_ORDERS': InvalidOrder,
                    'MIXED_ACCOUNT_TYPE': InvalidOrder,
                    'AUTO_BORROW_TOO_MUCH': ExchangeError,
                    'TRADE_RESTRICTED': InsufficientFunds,
                    'USER_NOT_FOUND': ExchangeError,
                    'CONTRACT_NO_COUNTER': ExchangeError,
                    'CONTRACT_NOT_FOUND': BadSymbol,
                    'RISK_LIMIT_EXCEEDED': ExchangeError,
                    'INSUFFICIENT_AVAILABLE': InsufficientFunds,
                    'LIQUIDATE_IMMEDIATELY': InvalidOrder,
                    'LEVERAGE_TOO_HIGH': InvalidOrder,
                    'LEVERAGE_TOO_LOW': InvalidOrder,
                    'ORDER_NOT_OWNED': ExchangeError,
                    'ORDER_FINISHED': ExchangeError,
                    'POSITION_CROSS_MARGIN': ExchangeError,
                    'POSITION_IN_LIQUIDATION': ExchangeError,
                    'POSITION_IN_CLOSE': ExchangeError,
                    'POSITION_EMPTY': InvalidOrder,
                    'REMOVE_TOO_MUCH': ExchangeError,
                    'RISK_LIMIT_NOT_MULTIPLE': ExchangeError,
                    'RISK_LIMIT_TOO_HIGH': ExchangeError,
                    'RISK_LIMIT_TOO_lOW': ExchangeError,
                    'PRICE_TOO_DEVIATED': InvalidOrder,
                    'SIZE_TOO_LARGE': InvalidOrder,
                    'SIZE_TOO_SMALL': InvalidOrder,
                    'PRICE_OVER_LIQUIDATION': InvalidOrder,
                    'PRICE_OVER_BANKRUPT': InvalidOrder,
                    'ORDER_POC_IMMEDIATE': InvalidOrder,
                    'INCREASE_POSITION': InvalidOrder,
                    'CONTRACT_IN_DELISTING': ExchangeError,
                    'INTERNAL': ExchangeError,
                    'SERVER_ERROR': ExchangeError,
                    'TOO_BUSY': ExchangeNotAvailable,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicSpotGetCurrencyPairs (params);
            //
            //     {
            //       "id": "DEGO_USDT",
            //       "base": "DEGO",
            //       "quote": "USDT",
            //       "fee": "0.2",
            //       "min_quote_amount": "1",
            //       "amount_precision": "4",
            //       "precision": "4",
            //       "trade_status": "tradable",
            //       "sell_start": "0",
            //       "buy_start": "0"
            //     }
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const id = this.safeString (entry, 'id');
                const baseId = this.safeString (entry, 'base');
                const quoteId = this.safeString (entry, 'quote');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                // Fee is in %, so divide by 100
                const taker = this.safeNumber (entry, 'fee') / 100;
                const maker = taker;
                const tradeStatus = this.safeString (entry, 'trade_status');
                const active = tradeStatus === 'tradable';
                const amountPrecision = this.safeString (entry, 'amount_precision');
                const pricePrecision = this.safeString (entry, 'precision');
                const amountLimit = this.parsePrecision (amountPrecision);
                const priceLimit = this.parsePrecision (pricePrecision);
                const limits = {
                    'amount': {
                        'min': this.parseNumber (amountLimit),
                        'max': undefined,
                    },
                    'price': {
                        'min': this.parseNumber (priceLimit),
                        'max': undefined,
                    },
                    'cost': {
                        'min': this.safeNumber (entry, 'min_quote_amount'),
                        'max': undefined,
                    },
                };
                const precision = {
                    'amount': parseInt (amountPrecision),
                    'price': parseInt (pricePrecision),
                };
                result.push ({
                    'info': entry,
                    'id': id,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'base': base,
                    'quote': quote,
                    'symbol': symbol,
                    'limits': limits,
                    'precision': precision,
                    'active': active,
                    'maker': maker,
                    'taker': taker,
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicSpotGetCurrencies (params);
            //
            //     {
            //       "currency": "BCN",
            //       "delisted": false,
            //       "withdraw_disabled": true,
            //       "withdraw_delayed": false,
            //       "deposit_disabled": true,
            //       "trade_disabled": false
            //     }
            //
            const result = {};
            // TODO: remove magic constants
            const amountPrecision = 6;
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const currencyId = this.safeString (entry, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const delisted = this.safeValue (entry, 'delisted');
                const withdraw_disabled = this.safeValue (entry, 'withdraw_disabled');
                const deposit_disabled = this.safeValue (entry, 'disabled_disabled');
                const trade_disabled = this.safeValue (entry, 'trade_disabled');
                const active = !(delisted && withdraw_disabled && deposit_disabled && trade_disabled);
                result[code] = {
                    'id': currencyId,
                    'name': undefined,
                    'code': code,
                    'precision': amountPrecision,
                    'info': entry,
                    'active': active,
                    'fee': undefined,
                    'fees': [],
                    'limits': this.limits,
                };
            }
            return result;
        }
    
        async fetchNetworkDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateWalletGetDepositAddress (this.extend (request, params));
            const addresses = this.safeValue (response, 'multichain_addresses');
            const currencyId = this.safeString (response, 'currency');
            code = this.safeCurrencyCode (currencyId);
            const result = {};
            for (let i = 0; i < addresses.length; i++) {
                const entry = addresses[i];
                //
                //     {
                //       "chain": "ETH",
                //       "address": "0x359a697945E79C7e17b634675BD73B33324E9408",
                //       "payment_id": "",
                //       "payment_name": "",
                //       "obtain_failed": "0"
                //     }
                //
                const obtainFailed = this.safeInteger (entry, 'obtain_failed');
                if (obtainFailed) {
                    continue;
                }
                const network = this.safeString (entry, 'chain');
                const address = this.safeString (entry, 'address');
                let tag = this.safeString (entry, 'payment_id');
                const tagLength = tag.length;
                tag = tagLength ? tag : undefined;
                result[network] = {
                    'info': entry,
                    'code': code,
                    'address': address,
                    'tag': tag,
                };
            }
            return result;
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateWalletGetDepositAddress (this.extend (request, params));
            //
            //     {
            //       "currency": "XRP",
            //       "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d 391331007",
            //       "multichain_addresses": [
            //         {
            //           "chain": "XRP",
            //           "address": "rHcFoo6a9qT5NHiVn1THQRhsEGcxtYCV4d",
            //           "payment_id": "391331007",
            //           "payment_name": "Tag",
            //           "obtain_failed": 0
            //         }
            //       ]
            //     }
            //
            const currencyId = this.safeString (response, 'currency');
            code = this.safeCurrencyCode (currencyId);
            const addressField = this.safeString (response, 'address');
            let tag = undefined;
            let address = undefined;
            if (addressField.indexOf (' ') > -1) {
                const splitted = addressField.split (' ');
                address = splitted[0];
                tag = splitted[1];
            } else {
                address = addressField;
            }
            return {
                'info': response,
                'code': code,
                'address': address,
                'tag': tag,
            };
        }
    
        async fetchTradingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateWalletGetFee (params);
            //
            //     {
            //       "user_id": 1486602,
            //       "taker_fee": "0.002",
            //       "maker_fee": "0.002",
            //       "gt_discount": true,
            //       "gt_taker_fee": "0.0015",
            //       "gt_maker_fee": "0.0015",
            //       "loan_fee": "0.18",
            //       "point_type": "0",
            //       "futures_taker_fee": "0.0005",
            //       "futures_maker_fee": "0"
            //     }
            //
            const result = {};
            const taker = this.safeNumber (response, 'taker_fee');
            const maker = this.safeNumber (response, 'maker_fee');
            for (let i = 0; i < this.symbols.length; i++) {
                const symbol = this.symbols[i];
                result[symbol] = {
                    'maker': maker,
                    'taker': taker,
                    'info': response,
                    'symbol': symbol,
                };
            }
            return result;
        }
    
        async fetchFundingFees (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateWalletGetWithdrawStatus (params);
            //
            //     {
            //       "currency": "MTN",
            //       "name": "Medicalchain",
            //       "name_cn": "Medicalchain",
            //       "deposit": "0",
            //       "withdraw_percent": "0%",
            //       "withdraw_fix": "900",
            //       "withdraw_day_limit": "500000",
            //       "withdraw_day_limit_remain": "500000",
            //       "withdraw_amount_mini": "900.1",
            //       "withdraw_eachtime_limit": "90000000000",
            //       "withdraw_fix_on_chains": {
            //         "ETH": "900"
            //       }
            //     }
            //
            const withdrawFees = {};
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const currencyId = this.safeString (entry, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                withdrawFees[code] = {};
                let withdrawFix = this.safeValue (entry, 'withdraw_fix_on_chains');
                if (withdrawFix === undefined) {
                    withdrawFix = {};
                    withdrawFix[code] = this.safeNumber (entry, 'withdraw_fix');
                }
                const keys = Object.keys (withdrawFix);
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    withdrawFees[code][key] = this.parseNumber (withdrawFix[key]);
                }
            }
            return {
                'info': response,
                'withdraw': withdrawFees,
                'deposit': {},
            };
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency_pair': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 10, max 100
            }
            const response = await this.publicSpotGetOrderBook (this.extend (request, params));
            const timestamp = this.safeInteger (response, 'current');
            return this.parseOrderBook (response, symbol, timestamp);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency_pair': market['id'],
            };
            const response = await this.publicSpotGetTickers (this.extend (request, params));
            const ticker = this.safeValue (response, 0);
            return this.parseTicker (ticker, market);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //       "currency_pair": "KFC_USDT",
            //       "last": "7.255",
            //       "lowest_ask": "7.298",
            //       "highest_bid": "7.218",
            //       "change_percentage": "-1.18",
            //       "base_volume": "1219.053687865",
            //       "quote_volume": "8807.40299875455",
            //       "high_24h": "7.262",
            //       "low_24h": "7.095"
            //     }
            //
            const marketId = this.safeString (ticker, 'currency_pair');
            const symbol = this.safeSymbol (marketId, market);
            const last = this.safeNumber (ticker, 'last');
            const ask = this.safeNumber (ticker, 'lowest_ask');
            const bid = this.safeNumber (ticker, 'highest_bid');
            const high = this.safeNumber (ticker, 'high_24h');
            const low = this.safeNumber (ticker, 'low_24h');
            const baseVolume = this.safeNumber (ticker, 'base_volume');
            const quoteVolume = this.safeNumber (ticker, 'quote_volume');
            const percentage = this.safeNumber (ticker, 'change_percentage');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': undefined,
                'datetime': undefined,
                'high': high,
                'low': low,
                'bid': bid,
                'bidVolume': undefined,
                'ask': ask,
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicSpotGetTickers (params);
            return this.parseTickers (response, symbols);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateSpotGetAccounts (params);
            //
            //     [
            //       {
            //         "currency": "DBC",
            //         "available": "0",
            //         "locked": "0"
            //       },
            //       ...
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const account = this.account ();
                const currencyId = this.safeString (entry, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                account['used'] = this.safeString (entry, 'locked');
                account['free'] = this.safeString (entry, 'available');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency_pair': market['id'],
                'interval': this.timeframes[timeframe],
            };
            if (since === undefined) {
                if (limit !== undefined) {
                    request['limit'] = limit;
                }
            } else {
                request['from'] = Math.floor (since / 1000);
                if (limit !== undefined) {
                    request['to'] = this.sum (request['from'], limit * this.parseTimeframe (timeframe) - 1);
                }
            }
            const response = await this.publicSpotGetCandlesticks (this.extend (request, params));
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //       "1626163200",           // Unix timestamp in seconds
            //       "346711.933138181617",  // Trading volume
            //       "33165.23",             // Close price
            //       "33260",                // Highest price
            //       "33117.6",              // Lowest price
            //       "33184.47"              // Open price
            //     ]
            //
            const timestamp = this.safeTimestamp (ohlcv, 0);
            const volume = this.safeNumber (ohlcv, 1);
            const close = this.safeNumber (ohlcv, 2);
            const high = this.safeNumber (ohlcv, 3);
            const low = this.safeNumber (ohlcv, 4);
            const open = this.safeNumber (ohlcv, 5);
            return [
                timestamp,
                open,
                high,
                low,
                close,
                volume,
            ];
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency_pair': market['id'],
            };
            const response = await this.publicSpotGetTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency_pair': market['id'],
                // 'limit': limit,
                // 'page': 0,
                // 'order_id': 'Order ID',
                // 'account': 'spot', // default to spot and margin account if not specified, set to cross_margin to operate against margin account
                // 'from': since, // default to 7 days before current time
                // 'to': this.milliseconds (), // default to current time
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 100, max 1000
            }
            if (since !== undefined) {
                request['from'] = Math.floor (since / 1000);
                // request['to'] = since + 7 * 24 * 60 * 60;
            }
            const response = await this.privateSpotGetMyTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public
            //     {
            //       "id": "1334253759",
            //       "create_time": "1626342738",
            //       "create_time_ms": "1626342738331.497000",
            //       "currency_pair": "BTC_USDT",
            //       "side": "sell",
            //       "amount": "0.0022",
            //       "price": "32452.16"
            //     }
            //
            // private
            //     {
            //       "id": "218087755",
            //       "create_time": "1578958740",
            //       "create_time_ms": "1578958740122.710000",
            //       "currency_pair": "BTC_USDT",
            //       "side": "sell",
            //       "role": "taker",
            //       "amount": "0.0004",
            //       "price": "8112.77",
            //       "order_id": "8445563839",
            //       "fee": "0.006490216",
            //       "fee_currency": "USDT",
            //       "point_fee": "0",
            //       "gt_fee": "0"
            //     }
            //
            const id = this.safeString (trade, 'id');
            const timestampString = this.safeString2 (trade, 'create_time_ms', 'time');
            let timestamp = undefined;
            if (timestampString.indexOf ('.') > 0) {
                const milliseconds = timestampString.split ('.');
                timestamp = parseInt (milliseconds[0]);
            }
            const marketId = this.safeString (trade, 'currency_pair');
            const symbol = this.safeSymbol (marketId, market);
            const amountString = this.safeString (trade, 'amount');
            const priceString = this.safeString (trade, 'price');
            const cost = this.parseNumber (Precise.stringMul (amountString, priceString));
            const amount = this.parseNumber (amountString);
            const price = this.parseNumber (priceString);
            const side = this.safeString (trade, 'side');
            const orderId = this.safeString (trade, 'order_id');
            const gtFee = this.safeString (trade, 'gt_fee');
            let feeCurrency = undefined;
            let feeCost = undefined;
            if (gtFee === '0') {
                feeCurrency = this.safeString (trade, 'fee_currency');
                feeCost = this.safeNumber (trade, 'fee');
            } else {
                feeCurrency = 'GT';
                feeCost = this.parseNumber (gtFee);
            }
            const fee = {
                'cost': feeCost,
                'currency': feeCurrency,
            };
            const takerOrMaker = this.safeString (trade, 'role');
            return {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['from'] = Math.floor (since / 1000);
                request['to'] = since + 30 * 24 * 60 * 60;
            }
            const response = await this.privateWalletGetDeposits (this.extend (request, params));
            return this.parseTransactions (response, currency);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['from'] = Math.floor (since / 1000);
                request['to'] = since + 30 * 24 * 60 * 60;
            }
            const response = await this.privateWalletGetWithdrawals (this.extend (request, params));
            return this.parseTransactions (response, currency);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'address': address,
                'amount': this.currencyToPrecision (code, amount),
            };
            if (tag !== undefined) {
                request['memo'] = tag;
            }
            const response = await this.privateWithdrawalsPost (this.extend (request, params));
            //
            //     {
            //       "id": "w13389675",
            //       "currency": "USDT",
            //       "amount": "50",
            //       "address": "TUu2rLFrmzUodiWfYki7QCNtv1akL682p1",
            //       "memo": null
            //     }
            //
            const currencyId = this.safeString (response, 'currency');
            const id = this.safeString (response, 'id');
            return {
                'info': response,
                'id': id,
                'code': this.safeCurrencyCode (currencyId),
                'amount': this.safeNumber (response, 'amount'),
                'address': this.safeString (response, 'address'),
                'tag': this.safeString (response, 'memo'),
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'PEND': 'pending',
                'REQUEST': 'pending',
                'DMOVE': 'pending',
                'CANCEL': 'failed',
                'DONE': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransactionType (type) {
            const types = {
                'd': 'deposit',
                'w': 'withdrawal',
            };
            return this.safeString (types, type, type);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // deposits
            //     {
            //       "id": "d33361395",
            //       "currency": "USDT_TRX",
            //       "address": "TErdnxenuLtXfnMafLbfappYdHtnXQ5U4z",
            //       "amount": "100",
            //       "txid": "ae9374de34e558562fe18cbb1bf9ab4d9eb8aa7669d65541c9fa2a532c1474a0",
            //       "timestamp": "1626345819",
            //       "status": "DONE",
            //       "memo": ""
            //     }
            //
            // withdrawals
            const id = this.safeString (transaction, 'id');
            let type = undefined;
            if (id !== undefined) {
                type = this.parseTransactionType (id[0]);
            }
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId);
            const amount = this.safeNumber (transaction, 'amount');
            const txid = this.safeString (transaction, 'txid');
            const rawStatus = this.safeString (transaction, 'status');
            const status = this.parseTransactionStatus (rawStatus);
            const address = this.safeString (transaction, 'address');
            const fee = this.safeNumber (transaction, 'fee');
            let tag = this.safeString (transaction, 'memo');
            if (tag === '') {
                tag = undefined;
            }
            const timestamp = this.safeTimestamp (transaction, 'timestamp');
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'currency': code,
                'amount': amount,
                'address': address,
                'tag': tag,
                'status': status,
                'type': type,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': fee,
            };
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'currency_pair': market['id'],
                'amount': this.amountToPrecision (symbol, amount),
                'price': this.priceToPrecision (symbol, price),
                'side': side,
            };
            const response = await this.privateSpotPostOrders (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //       "id": "62364648575",
            //       "text": "apiv4",
            //       "create_time": "1626354834",
            //       "update_time": "1626354834",
            //       "create_time_ms": "1626354833544",
            //       "update_time_ms": "1626354833544",
            //       "status": "open",
            //       "currency_pair": "BTC_USDT",
            //       "type": "limit",
            //       "account": "spot",
            //       "side": "buy",
            //       "amount": "0.0001",
            //       "price": "30000",
            //       "time_in_force": "gtc",
            //       "iceberg": "0",
            //       "left": "0.0001",
            //       "fill_price": "0",
            //       "filled_total": "0",
            //       "fee": "0",
            //       "fee_currency": "BTC",
            //       "point_fee": "0",
            //       "gt_fee": "0",
            //       "gt_discount": true,
            //       "rebated_fee": "0",
            //       "rebated_fee_currency": "USDT"
            //     }
            //
            //
            const id = this.safeString (order, 'id');
            const marketId = this.safeString (order, 'currency_pair');
            const symbol = this.safeSymbol (marketId, market);
            let timestamp = this.safeTimestamp (order, 'create_time');
            timestamp = this.safeInteger (order, 'create_time_ms', timestamp);
            let lastTradeTimestamp = this.safeTimestamp (order, 'update_time');
            lastTradeTimestamp = this.safeInteger (order, 'update_time_ms', lastTradeTimestamp);
            const amount = this.safeNumber (order, 'amount');
            const price = this.safeNumber (order, 'price');
            const remaining = this.safeNumber (order, 'left');
            const cost = this.safeNumber (order, 'filled_total'); // same as filled_price
            const side = this.safeString (order, 'side');
            const type = this.safeString (order, 'type');
            // open, closed, cancelled - almost already ccxt unified!
            let status = this.safeString (order, 'status');
            if (status === 'cancelled') {
                status = 'canceled';
            }
            const timeInForce = this.safeStringUpper (order, 'time_in_force');
            const fees = [];
            fees.push ({
                'currency': 'GT',
                'cost': this.safeNumber (order, 'gt_fee'),
            });
            fees.push ({
                'currency': this.safeCurrencyCode (this.safeString (order, 'fee_currency')),
                'cost': this.safeNumber (order, 'fee'),
            });
            const rebate = this.safeString (order, 'rebated_fee');
            fees.push ({
                'currency': this.safeCurrencyCode (this.safeString (order, 'rebated_fee_currency')),
                'cost': this.parseNumber (Precise.stringNeg (rebate)),
            });
            return this.safeOrder ({
                'id': id,
                'clientOrderId': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'average': undefined,
                'amount': amount,
                'cost': cost,
                'filled': undefined,
                'remaining': remaining,
                'fee': undefined,
                'fees': fees,
                'trades': undefined,
                'info': order,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'order_id': id,
                'currency_pair': market['id'],
            };
            const response = await this.privateSpotGetOrdersOrderId (this.extend (request, params));
            return this.parseOrder (response, market);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (symbol === undefined) {
                const request = {
                    // 'page': 1,
                    // 'limit': limit,
                    // 'account': '', // spot/margin (default), cross_margin
                };
                if (limit !== undefined) {
                    request['limit'] = limit;
                }
                const response = await this.privateSpotGetOpenOrders (this.extend (request, params));
                //
                //     [
                //         {
                //             "currency_pair": "ETH_BTC",
                //             "total": 1,
                //             "orders": [
                //                 {
                //                     "id": "12332324",
                //                     "text": "t-123456",
                //                     "create_time": "1548000000",
                //                     "update_time": "1548000100",
                //                     "currency_pair": "ETH_BTC",
                //                     "status": "open",
                //                     "type": "limit",
                //                     "account": "spot",
                //                     "side": "buy",
                //                     "amount": "1",
                //                     "price": "5.00032",
                //                     "time_in_force": "gtc",
                //                     "left": "0.5",
                //                     "filled_total": "2.50016",
                //                     "fee": "0.005",
                //                     "fee_currency": "ETH",
                //                     "point_fee": "0",
                //                     "gt_fee": "0",
                //                     "gt_discount": false,
                //                     "rebated_fee": "0",
                //                     "rebated_fee_currency": "BTC"
                //                 }
                //             ]
                //         },
                //         ...
                //     ]
                //
                let allOrders = [];
                for (let i = 0; i < response.length; i++) {
                    const entry = response[i];
                    const orders = this.safeValue (entry, 'orders', []);
                    const parsed = this.parseOrders (orders, undefined, since, limit);
                    allOrders = this.arrayConcat (allOrders, parsed);
                }
                return this.filterBySinceLimit (allOrders, since, limit);
            }
            return await this.fetchOrdersByStatus ('open', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStatus ('finished', symbol, since, limit, params);
        }
    
        async fetchOrdersByStatus (status, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrdersByStatus requires a symbol argument');
            }
            const market = this.market (symbol);
            const request = {
                'currency_pair': market['id'],
                'status': status,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['start'] = Math.floor (since / 1000);
            }
            const response = await this.privateSpotGetOrders (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrders requires a symbol parameter');
            }
            const market = this.market (symbol);
            const request = {
                'order_id': id,
                'currency_pair': market['id'],
            };
            const response = await this.privateSpotDeleteOrdersOrderId (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async transfer (code, amount, fromAccount, toAccount, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const accountsByType = this.safeValue (this.options, 'accountsByType', {});
            const fromId = this.safeString (accountsByType, fromAccount, fromAccount);
            const toId = this.safeString (accountsByType, toAccount, toAccount);
            if (fromId === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' fromAccount must be one of ' + keys.join (', '));
            }
            if (toId === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' toAccount must be one of ' + keys.join (', '));
            }
            const truncated = this.currencyToPrecision (code, amount);
            const request = {
                'currency': currency['id'],
                'from': fromId,
                'to': toId,
                'amount': truncated,
            };
            if ((toId === 'futures') || (toId === 'delivery')) {
                request['settle'] = currency['id'];
            }
            const response = await this.privateWalletPostTransfers (this.extend (request, params));
            //
            // according to the docs
            //     {
            //       "currency": "BTC",
            //       "from": "spot",
            //       "to": "margin",
            //       "amount": "1",
            //       "currency_pair": "BTC_USDT"
            //     }
            //
            // actual response
            //  POST https://api.gateio.ws/api/v4/wallet/transfers 204 No Content
            //
            return {
                'info': response,
                'from': fromId,
                'to': toId,
                'amount': truncated,
                'code': code,
            };
        }
    
        sign (path, api = [], method = 'GET', params = {}, headers = undefined, body = undefined) {
            const authentication = api[0]; // public, private
            const type = api[1]; // spot, margin, future, delivery
            const query = this.omit (params, this.extractParams (path));
            path = this.implodeParams (path, params);
            const endPart = (path === '' ? '' : '/' + path);
            const entirePath = '/' + type + endPart;
            let url = this.urls['api'][authentication] + entirePath;
            let queryString = '';
            if (authentication === 'public') {
                queryString = this.urlencode (query);
                if (Object.keys (query).length) {
                    url += '?' + queryString;
                }
            } else {
                if ((method === 'GET') || (method === 'DELETE')) {
                    queryString = this.urlencode (query);
                    if (Object.keys (query).length) {
                        url += '?' + queryString;
                    }
                } else {
                    body = this.json (query);
                }
                const bodyPayload = (body === undefined) ? '' : body;
                const bodySignature = this.hash (this.encode (bodyPayload), 'sha512');
                const timestamp = this.seconds ();
                const timestampString = timestamp.toString ();
                const signaturePath = '/api/v4' + entirePath;
                const payloadArray = [ method.toUpperCase (), signaturePath, queryString, bodySignature, timestampString ];
                // eslint-disable-next-line quotes
                const payload = payloadArray.join ("\n");
                const signature = this.hmac (this.encode (payload), this.encode (this.secret), 'sha512');
                headers = {
                    'KEY': this.apiKey,
                    'Timestamp': timestampString,
                    'SIGN': signature,
                    'Content-Type': 'application/json',
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            const label = this.safeString (response, 'label');
            if (label !== undefined) {
                const message = this.safeString (response, 'message');
                const Error = this.safeValue (this.exceptions, label, ExchangeError);
                throw new Error (this.id + ' ' + message);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],83:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, BadRequest, OrderNotFound, InvalidOrder, InvalidNonce, InsufficientFunds, AuthenticationError, PermissionDenied, NotSupported, OnMaintenance, RateLimitExceeded, ExchangeNotAvailable } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class gemini extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'gemini',
                'name': 'Gemini',
                'countries': [ 'US' ],
                'rateLimit': 1500, // 200 for private API
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createDepositAddress': true,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchBidsAsks': false,
                    'fetchClosedOrders': false,
                    'fetchDepositAddress': false,
                    'fetchDeposits': false,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': false,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTransactions': true,
                    'fetchWithdrawals': false,
                    'withdraw': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27816857-ce7be644-6096-11e7-82d6-3c257263229c.jpg',
                    'api': {
                        'public': 'https://api.gemini.com',
                        'private': 'https://api.gemini.com',
                        'web': 'https://docs.gemini.com',
                    },
                    'www': 'https://gemini.com/',
                    'doc': [
                        'https://docs.gemini.com/rest-api',
                        'https://docs.sandbox.gemini.com',
                    ],
                    'test': {
                        'public': 'https://api.sandbox.gemini.com',
                        'private': 'https://api.sandbox.gemini.com',
                        // use the true doc instead of the sandbox doc
                        // since they differ in parsing
                        // https://github.com/ccxt/ccxt/issues/7874
                        // https://github.com/ccxt/ccxt/issues/7894
                        'web': 'https://docs.gemini.com',
                    },
                    'fees': [
                        'https://gemini.com/api-fee-schedule',
                        'https://gemini.com/trading-fees',
                        'https://gemini.com/transfer-fees',
                    ],
                },
                'api': {
                    'web': {
                        'get': [
                            'rest-api',
                        ],
                    },
                    'public': {
                        'get': [
                            'v1/symbols',
                            'v1/pricefeed',
                            'v1/pubticker/{symbol}',
                            'v1/book/{symbol}',
                            'v1/trades/{symbol}',
                            'v1/auction/{symbol}',
                            'v1/auction/{symbol}/history',
                            'v2/candles/{symbol}/{timeframe}',
                            'v2/ticker/{symbol}',
                        ],
                    },
                    'private': {
                        'post': [
                            'v1/account/list',
                            'v1/order/new',
                            'v1/order/cancel',
                            'v1/order/cancel/session',
                            'v1/order/cancel/all',
                            'v1/order/status',
                            'v1/orders',
                            'v1/mytrades',
                            'v1/notionalvolume',
                            'v1/tradevolume',
                            'v1/transfers',
                            'v1/balances',
                            'v1/deposit/{currency}/newAddress',
                            'v1/withdraw/{currency}',
                            'v1/heartbeat',
                            'v1/transfers',
                        ],
                    },
                },
                'precisionMode': TICK_SIZE,
                'fees': {
                    'trading': {
                        'taker': 0.0035,
                        'maker': 0.001,
                    },
                },
                'httpExceptions': {
                    '400': BadRequest, // Auction not open or paused, ineligible timing, market not open, or the request was malformed, in the case of a private API request, missing or malformed Gemini private API authentication headers
                    '403': PermissionDenied, // The API key is missing the role necessary to access this private API endpoint
                    '404': OrderNotFound, // Unknown API entry point or Order not found
                    '406': InsufficientFunds, // Insufficient Funds
                    '429': RateLimitExceeded, // Rate Limiting was applied
                    '500': ExchangeError, // The server encountered an error
                    '502': ExchangeNotAvailable, // Technical issues are preventing the request from being satisfied
                    '503': OnMaintenance, // The exchange is down for maintenance
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1hr',
                    '6h': '6hr',
                    '1d': '1day',
                },
                'exceptions': {
                    'exact': {
                        'AuctionNotOpen': BadRequest, // Failed to place an auction-only order because there is no current auction open for this symbol
                        'ClientOrderIdTooLong': BadRequest, // The Client Order ID must be under 100 characters
                        'ClientOrderIdMustBeString': BadRequest, // The Client Order ID must be a string
                        'ConflictingOptions': BadRequest, // New orders using a combination of order execution options are not supported
                        'EndpointMismatch': BadRequest, // The request was submitted to an endpoint different than the one in the payload
                        'EndpointNotFound': BadRequest, // No endpoint was specified
                        'IneligibleTiming': BadRequest, // Failed to place an auction order for the current auction on this symbol because the timing is not eligible, new orders may only be placed before the auction begins.
                        'InsufficientFunds': InsufficientFunds, // The order was rejected because of insufficient funds
                        'InvalidJson': BadRequest, // The JSON provided is invalid
                        'InvalidNonce': InvalidNonce, // The nonce was not greater than the previously used nonce, or was not present
                        'InvalidOrderType': InvalidOrder, // An unknown order type was provided
                        'InvalidPrice': InvalidOrder, // For new orders, the price was invalid
                        'InvalidQuantity': InvalidOrder, // A negative or otherwise invalid quantity was specified
                        'InvalidSide': InvalidOrder, // For new orders, and invalid side was specified
                        'InvalidSignature': AuthenticationError, // The signature did not match the expected signature
                        'InvalidSymbol': BadRequest, // An invalid symbol was specified
                        'InvalidTimestampInPayload': BadRequest, // The JSON payload contained a timestamp parameter with an unsupported value.
                        'Maintenance': OnMaintenance, // The system is down for maintenance
                        'MarketNotOpen': InvalidOrder, // The order was rejected because the market is not accepting new orders
                        'MissingApikeyHeader': AuthenticationError, // The X-GEMINI-APIKEY header was missing
                        'MissingOrderField': InvalidOrder, // A required order_id field was not specified
                        'MissingRole': AuthenticationError, // The API key used to access this endpoint does not have the required role assigned to it
                        'MissingPayloadHeader': AuthenticationError, // The X-GEMINI-PAYLOAD header was missing
                        'MissingSignatureHeader': AuthenticationError, // The X-GEMINI-SIGNATURE header was missing
                        'NoSSL': AuthenticationError, // You must use HTTPS to access the API
                        'OptionsMustBeArray': BadRequest, // The options parameter must be an array.
                        'OrderNotFound': OrderNotFound, // The order specified was not found
                        'RateLimit': RateLimitExceeded, // Requests were made too frequently. See Rate Limits below.
                        'System': ExchangeError, // We are experiencing technical issues
                        'UnsupportedOption': BadRequest, // This order execution option is not supported.
                    },
                    'broad': {
                        'The Gemini Exchange is currently undergoing maintenance.': OnMaintenance, // The Gemini Exchange is currently undergoing maintenance. Please check https://status.gemini.com/ for more information.
                        'We are investigating technical issues with the Gemini Exchange.': ExchangeNotAvailable, // We are investigating technical issues with the Gemini Exchange. Please check https://status.gemini.com/ for more information.
                    },
                },
                'options': {
                    'fetchMarketsMethod': 'fetch_markets_from_web',
                    'fetchTickerMethod': 'fetchTickerV1', // fetchTickerV1, fetchTickerV2, fetchTickerV1AndV2
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const method = this.safeValue (this.options, 'fetchMarketsMethod', 'fetch_markets_from_api');
            return await this[method] (params);
        }
    
        async fetchMarketsFromWeb (params = {}) {
            const response = await this.webGetRestApi (params);
            const sections = response.split ('<h1 id="symbols-and-minimums">Symbols and minimums</h1>');
            const numSections = sections.length;
            const error = this.id + ' the ' + this.name + ' API doc HTML markup has changed, breaking the parser of order limits and precision info for ' + this.name + ' markets.';
            if (numSections !== 2) {
                throw new NotSupported (error);
            }
            const tables = sections[1].split ('tbody>');
            const numTables = tables.length;
            if (numTables < 2) {
                throw new NotSupported (error);
            }
            const rows = tables[1].split ("\n<tr>\n"); // eslint-disable-line quotes
            const numRows = rows.length;
            if (numRows < 2) {
                throw new NotSupported (error);
            }
            const result = [];
            // skip the first element (empty string)
            for (let i = 1; i < numRows; i++) {
                const row = rows[i];
                const cells = row.split ("</td>\n"); // eslint-disable-line quotes
                const numCells = cells.length;
                if (numCells < 5) {
                    throw new NotSupported (error);
                }
                //     [
                //         '<td>btcusd', // currency
                //         '<td>0.00001 BTC (1e-5)', // min order size
                //         '<td>0.00000001 BTC (1e-8)', // tick size
                //         '<td>0.01 USD', // quote currency price increment
                //         '</tr>'
                //     ]
                const marketId = cells[0].replace ('<td>', '');
                // const base = this.safeCurrencyCode (baseId);
                const minAmountString = cells[1].replace ('<td>', '');
                const minAmountParts = minAmountString.split (' ');
                const minAmount = this.safeNumber (minAmountParts, 0);
                const amountPrecisionString = cells[2].replace ('<td>', '');
                const amountPrecisionParts = amountPrecisionString.split (' ');
                const amountPrecision = this.safeNumber (amountPrecisionParts, 0);
                const idLength = marketId.length - 0;
                const quoteId = marketId.slice (idLength - 3, idLength);
                const quote = this.safeCurrencyCode (quoteId);
                const pricePrecisionString = cells[3].replace ('<td>', '');
                const pricePrecisionParts = pricePrecisionString.split (' ');
                const pricePrecision = this.safeNumber (pricePrecisionParts, 0);
                const baseId = marketId.replace (quoteId, '');
                const base = this.safeCurrencyCode (baseId);
                const symbol = base + '/' + quote;
                const active = undefined;
                result.push ({
                    'id': marketId,
                    'info': row,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'precision': {
                        'amount': amountPrecision,
                        'price': pricePrecision,
                    },
                    'limits': {
                        'amount': {
                            'min': minAmount,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchMarketsFromAPI (params = {}) {
            const response = await this.publicGetV1Symbols (params);
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const marketId = response[i];
                const market = marketId;
                const idLength = marketId.length - 0;
                const baseId = marketId.slice (0, idLength - 3);
                const quoteId = marketId.slice (idLength - 3, idLength);
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': undefined,
                    'price': undefined,
                };
                result.push ({
                    'id': marketId,
                    'info': market,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'price': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'active': undefined,
                });
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            if (limit !== undefined) {
                request['limit_bids'] = limit;
                request['limit_asks'] = limit;
            }
            const response = await this.publicGetV1BookSymbol (this.extend (request, params));
            return this.parseOrderBook (response, symbol, undefined, 'bids', 'asks', 'price', 'amount');
        }
    
        async fetchTickerV1 (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetV1PubtickerSymbol (this.extend (request, params));
            //
            //     {
            //         "bid":"9117.95",
            //         "ask":"9117.96",
            //         "volume":{
            //             "BTC":"1615.46861748",
            //             "USD":"14727307.57545006088",
            //             "timestamp":1594982700000
            //         },
            //         "last":"9115.23"
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchTickerV2 (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetV2TickerSymbol (this.extend (request, params));
            //
            //     {
            //         "symbol":"BTCUSD",
            //         "open":"9080.58",
            //         "high":"9184.53",
            //         "low":"9063.56",
            //         "close":"9116.08",
            //         // Hourly prices descending for past 24 hours
            //         "changes":["9117.33","9105.69","9106.23","9120.35","9098.57","9114.53","9113.55","9128.01","9113.63","9133.49","9133.49","9137.75","9126.73","9103.91","9119.33","9123.04","9124.44","9117.57","9114.22","9102.33","9076.67","9074.72","9074.97","9092.05"],
            //         "bid":"9115.86",
            //         "ask":"9115.87"
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchTickerV1AndV2 (symbol, params = {}) {
            const tickerA = await this.fetchTickerV1 (symbol, params);
            const tickerB = await this.fetchTickerV2 (symbol, params);
            return this.deepExtend (tickerA, {
                'open': tickerB['open'],
                'high': tickerB['high'],
                'low': tickerB['low'],
                'change': tickerB['change'],
                'percentage': tickerB['percentage'],
                'average': tickerB['average'],
                'info': tickerB['info'],
            });
        }
    
        async fetchTicker (symbol, params = {}) {
            const method = this.safeValue (this.options, 'fetchTickerMethod', 'fetchTickerV1');
            return await this[method] (symbol, params);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTickers
            //
            //     {
            //         "pair": "BATUSD",
            //         "price": "0.20687",
            //         "percentChange24h": "0.0146"
            //     }
            //
            // fetchTickerV1
            //
            //     {
            //         "bid":"9117.95",
            //         "ask":"9117.96",
            //         "volume":{
            //             "BTC":"1615.46861748",
            //             "USD":"14727307.57545006088",
            //             "timestamp":1594982700000
            //         },
            //         "last":"9115.23"
            //     }
            //
            // fetchTickerV2
            //
            //     {
            //         "symbol":"BTCUSD",
            //         "open":"9080.58",
            //         "high":"9184.53",
            //         "low":"9063.56",
            //         "close":"9116.08",
            //         // Hourly prices descending for past 24 hours
            //         "changes":["9117.33","9105.69","9106.23","9120.35","9098.57","9114.53","9113.55","9128.01","9113.63","9133.49","9133.49","9137.75","9126.73","9103.91","9119.33","9123.04","9124.44","9117.57","9114.22","9102.33","9076.67","9074.72","9074.97","9092.05"],
            //         "bid":"9115.86",
            //         "ask":"9115.87"
            //     }
            //
            const volume = this.safeValue (ticker, 'volume', {});
            const timestamp = this.safeInteger (volume, 'timestamp');
            let symbol = undefined;
            const marketId = this.safeString (ticker, 'pair');
            let baseId = undefined;
            let quoteId = undefined;
            let base = undefined;
            let quote = undefined;
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const idLength = marketId.length - 0;
                    if (idLength === 7) {
                        baseId = marketId.slice (0, 4);
                        quoteId = marketId.slice (4, 7);
                    } else {
                        baseId = marketId.slice (0, 3);
                        quoteId = marketId.slice (3, 6);
                    }
                    base = this.safeCurrencyCode (baseId);
                    quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
                baseId = market['baseId'].toUpperCase ();
                quoteId = market['quoteId'].toUpperCase ();
                base = market['base'];
                quote = market['quote'];
            }
            const price = this.safeNumber (ticker, 'price');
            const last = this.safeNumber2 (ticker, 'last', 'close', price);
            const percentage = this.safeNumber (ticker, 'percentChange24h');
            const open = this.safeNumber (ticker, 'open');
            const baseVolume = this.safeNumber (volume, baseId);
            const quoteVolume = this.safeNumber (volume, quoteId);
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined, // previous day close
                'change': undefined,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetV1Pricefeed (params);
            //
            //     [
            //         {
            //             "pair": "BATUSD",
            //             "price": "0.20687",
            //             "percentChange24h": "0.0146"
            //         },
            //         {
            //             "pair": "LINKETH",
            //             "price": "0.018",
            //             "percentChange24h": "0.0000"
            //         },
            //     ]
            //
            return this.parseTickers (response, symbols);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // public fetchTrades
            //
            //     {
            //         "timestamp":1601617445,
            //         "timestampms":1601617445144,
            //         "tid":14122489752,
            //         "price":"0.46476",
            //         "amount":"28.407209",
            //         "exchange":"gemini",
            //         "type":"buy"
            //     }
            //
            const timestamp = this.safeInteger (trade, 'timestampms');
            const id = this.safeString (trade, 'tid');
            const orderId = this.safeString (trade, 'order_id');
            const feeCurrencyId = this.safeString (trade, 'fee_currency');
            const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
            const fee = {
                'cost': this.safeNumber (trade, 'fee_amount'),
                'currency': feeCurrencyCode,
            };
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const type = undefined;
            const side = this.safeStringLower (trade, 'type');
            const symbol = this.safeSymbol (undefined, market);
            return {
                'id': id,
                'order': orderId,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'cost': cost,
                'amount': amount,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetV1TradesSymbol (this.extend (request, params));
            //
            //     [
            //         {
            //             "timestamp":1601617445,
            //             "timestampms":1601617445144,
            //             "tid":14122489752,
            //             "price":"0.46476",
            //             "amount":"28.407209",
            //             "exchange":"gemini",
            //             "type":"buy"
            //         },
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostV1Balances (params);
            const result = { 'info': response };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['total'] = this.safeString (balance, 'amount');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrder (order, market = undefined) {
            const timestamp = this.safeInteger (order, 'timestampms');
            const amount = this.safeNumber (order, 'original_amount');
            const remaining = this.safeNumber (order, 'remaining_amount');
            const filled = this.safeNumber (order, 'executed_amount');
            let status = 'closed';
            if (order['is_live']) {
                status = 'open';
            }
            if (order['is_cancelled']) {
                status = 'canceled';
            }
            const price = this.safeNumber (order, 'price');
            const average = this.safeNumber (order, 'avg_execution_price');
            let type = this.safeString (order, 'type');
            if (type === 'exchange limit') {
                type = 'limit';
            } else if (type === 'market buy' || type === 'market sell') {
                type = 'market';
            } else {
                type = order['type'];
            }
            const fee = undefined;
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const id = this.safeString (order, 'order_id');
            const side = this.safeStringLower (order, 'side');
            const clientOrderId = this.safeString (order, 'client_order_id');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'average': average,
                'cost': undefined,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privatePostV1OrderStatus (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostV1Orders (params);
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol); // throws on non-existent symbol
            }
            return this.parseOrders (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            if (type === 'market') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            const nonce = this.nonce ();
            const request = {
                'client_order_id': nonce.toString (),
                'symbol': this.marketId (symbol),
                'amount': amount.toString (),
                'price': price.toString (),
                'side': side,
                'type': 'exchange limit', // gemini allows limit orders only
            };
            const response = await this.privatePostV1OrderNew (this.extend (request, params));
            return {
                'info': response,
                'id': response['order_id'],
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            return await this.privatePostV1OrderCancel (this.extend (request, params));
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit_trades'] = limit;
            }
            if (since !== undefined) {
                request['timestamp'] = parseInt (since / 1000);
            }
            const response = await this.privatePostV1Mytrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'amount': amount,
                'address': address,
            };
            const response = await this.privatePostV1WithdrawCurrency (this.extend (request, params));
            return {
                'info': response,
                'id': this.safeString (response, 'txHash'),
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (limit !== undefined) {
                request['limit_transfers'] = limit;
            }
            if (since !== undefined) {
                request['timestamp'] = since;
            }
            const response = await this.privatePostV1Transfers (this.extend (request, params));
            return this.parseTransactions (response);
        }
    
        parseTransaction (transaction, currency = undefined) {
            const timestamp = this.safeInteger (transaction, 'timestampms');
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const address = this.safeString (transaction, 'destination');
            const type = this.safeStringLower (transaction, 'type');
            let status = 'pending';
            // When deposits show as Advanced or Complete they are available for trading.
            if (transaction['status']) {
                status = 'ok';
            }
            let fee = undefined;
            const feeAmount = this.safeNumber (transaction, 'feeAmount');
            if (feeAmount !== undefined) {
                fee = {
                    'cost': feeAmount,
                    'currency': code,
                };
            }
            return {
                'info': transaction,
                'id': this.safeString (transaction, 'eid'),
                'txid': this.safeString (transaction, 'txHash'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'tag': undefined, // or is it defined?
                'type': type, // direction of the transaction, ('deposit' | 'withdraw')
                'amount': this.safeNumber (transaction, 'amount'),
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': fee,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                const request = this.extend ({
                    'request': url,
                    'nonce': nonce,
                }, query);
                let payload = this.json (request);
                payload = this.stringToBase64 (payload);
                const signature = this.hmac (payload, this.encode (this.secret), 'sha384');
                headers = {
                    'Content-Type': 'text/plain',
                    'X-GEMINI-APIKEY': this.apiKey,
                    'X-GEMINI-PAYLOAD': this.decode (payload),
                    'X-GEMINI-SIGNATURE': signature,
                };
            } else {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            }
            url = this.urls['api'][api] + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                if (typeof body === 'string') {
                    const feedback = this.id + ' ' + body;
                    this.throwBroadlyMatchedException (this.exceptions['broad'], body, feedback);
                }
                return; // fallback to default error handler
            }
            //
            //     {
            //         "result": "error",
            //         "reason": "BadNonce",
            //         "message": "Out-of-sequence nonce <1234> precedes previously used nonce <2345>"
            //     }
            //
            const result = this.safeString (response, 'result');
            if (result === 'error') {
                const reason = this.safeString (response, 'reason');
                const message = this.safeString (response, 'message');
                const feedback = this.id + ' ' + message;
                this.throwExactlyMatchedException (this.exceptions['exact'], reason, feedback);
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privatePostV1DepositCurrencyNewAddress (this.extend (request, params));
            const address = this.safeString (response, 'address');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': undefined,
                'info': response,
            };
        }
    
        async fetchOHLCV (symbol, timeframe = '5m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'timeframe': this.timeframes[timeframe],
                'symbol': market['id'],
            };
            const response = await this.publicGetV2CandlesSymbolTimeframe (this.extend (request, params));
            //
            //     [
            //         [1591515000000,0.02509,0.02509,0.02509,0.02509,0],
            //         [1591514700000,0.02503,0.02509,0.02503,0.02509,44.6405],
            //         [1591514400000,0.02503,0.02503,0.02503,0.02503,0],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],84:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { AuthenticationError, ExchangeError, OrderNotFound, ArgumentsRequired, BadSymbol, BadRequest, NullResponse, InvalidOrder, BadResponse, NotSupported, ExchangeNotAvailable, RequestTimeout, RateLimitExceeded, PermissionDenied, InsufficientFunds, InvalidAddress } = require ('./base/errors');
    const { TICK_SIZE, TRUNCATE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class hbtc extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'hbtc',
                'name': 'HBTC',
                'countries': [ 'CN' ],
                'rateLimit': 2000,
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchAccounts': true,
                    'fetchBalance': true,
                    'fetchBidAsk': true,
                    'fetchBidsAsks': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': false,
                    'fetchDepositAddress': false,
                    'fetchDeposits': true,
                    'fetchLedger': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': false,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTradingLimits': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '3m': '3m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '2h': '2h',
                    '4h': '4h',
                    '6h': '6h',
                    '8h': '8h',
                    '12h': '12h',
                    '1d': '1d',
                    '3d': '3d',
                    '1w': '1w',
                    '1M': '1M',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/80134449-70663300-85a7-11ea-8942-e204cdeaab5d.jpg', // 交易所LOGO
                    'api': {
                        'quote': 'https://api.hbtc.com/openapi/quote', // 市场API数据端点
                        'contract': 'https://api.hbtc.com/openapi/contract', // 合约API数据端点
                        'option': 'https://api.hbtc.com/openapi/option', // 合约API数据端点
                        'public': 'https://api.hbtc.com/openapi', // 公共API数据端点
                        'private': 'https://api.hbtc.com/openapi', // 私有API数据端点
                        'zendesk': 'https://hbtc.zendesk.com/hc/en-us',
                    },
                    'www': 'https://www.hbtc.com', // 公司主页
                    'referral': 'https://www.hbtc.com/register/O2S8NS', // 邀请链接
                    'doc': 'https://github.com/bhexopen/BHEX-OpenApi/tree/master/doc', // openapi文档地址
                    'fees': 'https://hbtc.zendesk.com/hc/zh-cn/articles/360009274694', // 费率介绍
                },
                'api': {
                    'public': {
                        'get': [
                            'ping',
                            'time',
                            'brokerInfo', // 查询当前broker交易规则和symbol信息
                            'getOptions',
                        ],
                    },
                    'quote': {
                        'get': [
                            'depth', // 获取深度
                            'depth/merged',
                            'trades', // 获取当前最新成交
                            'klines', // 获取K线数据
                            'ticker/24hr', // 获取24小时价格变化数据
                            'ticker/price',
                            'ticker/bookTicker',
                            'contract/index', // 获取合约标的指数价格
                            'contract/depth', // 获取合约深度
                            'contract/depth/merged',
                            'contract/trades', // 获取合约最近成交,
                            'contract/klines', // 获取合约的K线数据
                            'contract/ticker/24hr',
                            'option/index',
                            'option/depth',
                            'option/depth/merged',
                            'option/trades',
                            'option/klines',
                            'option/ticker/24hr',
                        ],
                    },
                    'contract': {
                        'get': [
                            // public
                            'insurance',
                            'fundingRate', // 获取资金费率信息
                            // private
                            'openOrders', // 查询合约当前委托
                            'historyOrders', // 查询合约历史委托
                            'getOrder', // 查询合约订单详情
                            'myTrades', // 查询合约历史成交
                            'positions', // 查询合约当前持仓
                            'account', // 查询合约账户信息
                        ],
                        'post': [
                            'order', // 创建合约订单
                            'modifyMargin', // 修改保证金
                        ],
                        'delete': [
                            'order/cancel', // 取消合约订单
                            'order/batchCancel',
                        ],
                    },
                    'option': {
                        'get': [
                            'openOrders',
                            'positions',
                            'historyOrders',
                            // 'getOrder',
                            'myTrades',
                            'settlements',
                            'account',
                        ],
                        'post': [
                            'order',
                        ],
                        'delete': [
                            'order/cancel',
                        ],
                    },
                    'private': {
                        'get': [
                            'order', // 查询订单
                            'openOrders', // 查询当前委托
                            'historyOrders', // 查询历史委托
                            'account', // 获取当前账户信息
                            'myTrades', // 查询历史成交
                            'depositOrders',
                            'withdrawalOrders',
                            'withdraw/detail',
                            'balance_flow',
                        ],
                        'post': [
                            'order', // 创建新订单
                            'order/test',
                            'userDataStream',
                            'subAccount/query',
                            'transfer',
                            'user/transfer',
                            'withdraw',
                        ],
                        'put': [
                            'userDataStream',
                        ],
                        'delete': [
                            'order', // 取消订单
                            'userDataStream',
                        ],
                    },
                },
                'precisionMode': TICK_SIZE,
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': 0.001,
                        'taker': 0.001,
                    },
                },
                'exceptions': {
                    'exact': {
                        // general server or network errors
                        '-1000': ExchangeError, // An unknown error occured while processing the request
                        '-1001': ExchangeError, // Internal error, unable to process your request. Please try again
                        '-1002': AuthenticationError, // You are not authorized to execute this request. Request need API Key included in. We suggest that API Key be included in any request
                        '-1003': RateLimitExceeded, // Too many requests, please use the websocket for live updates
                        '-1004': BadRequest,
                        '-1005': PermissionDenied,
                        '-1006': BadResponse, // An unexpected response was received from the message bus. Execution status unknown. OPEN API server find some exception in execute request.Please report to Customer service
                        '-1007': RequestTimeout, // Timeout waiting for response from backend server. Send status unknown, execution status unknown
                        '-1014': InvalidOrder, // Unsupported order combination
                        '-1015': RateLimitExceeded, // Reach the rate limit.Please slow down your request speed
                        '-1016': ExchangeNotAvailable, // This service is no longer available
                        '-1020': NotSupported, // This operation is not supported
                        '-1021': BadRequest, // Timestamp for this request is outside of the recvWindow
                        '-1022': AuthenticationError, // Signature for this request is not valid
                        // request issues
                        '-1100': BadRequest, // Illegal characters found in a parameter
                        '-1101': BadRequest, // Too many parameters sent for this endpoint
                        '-1102': BadRequest, // A mandatory parameter was not sent, was empty/null, or malformed
                        '-1103': BadRequest, // An unknown parameter was sent
                        '-1104': BadRequest, // Not all sent parameters were read
                        '-1105': BadRequest, // A parameter was empty
                        '-1106': BadRequest, // A parameter was sent when not required
                        '-1111': BadRequest, // Precision is over the maximum defined for this asset
                        '-1112': NullResponse, // No orders on book for symbol
                        '-1114': InvalidOrder, // TimeInForce parameter sent when not required
                        '-1115': InvalidOrder, // Invalid timeInForce
                        '-1116': InvalidOrder, // Invalid orderType
                        '-1117': InvalidOrder, // Invalid side
                        '-1118': InvalidOrder, // New client order ID was empty
                        '-1119': InvalidOrder, // Original client order ID was empty
                        '-1120': BadRequest, // Invalid interval
                        '-1121': BadSymbol, // Invalid symbol
                        '-1125': AuthenticationError, // This listenKey does not exist
                        '-1127': BadRequest, // Lookup interval is too big
                        '-1128': BadRequest, // Combination of optional parameters invalid
                        '-1130': BadRequest, // Invalid data sent for a parameter
                        '-1131': InsufficientFunds,
                        '-1132': InvalidOrder, // Order price too high
                        '-1133': InvalidOrder, // Order price lower than the minimum,please check general broker info
                        '-1134': InvalidOrder, // Order price decimal too long,please check general broker info
                        '-1135': InvalidOrder, // Order quantity too large
                        '-1136': InvalidOrder, // Order quantity lower than the minimum
                        '-1137': InvalidOrder, // Order quantity decimal too long
                        '-1138': InvalidOrder, // Order price exceeds permissible range
                        '-1139': InvalidOrder, // Order has been filled
                        '-1140': InvalidOrder, // Transaction amount lower than the minimum
                        '-1141': InvalidOrder, // Duplicate clientOrderId
                        '-1142': InvalidOrder, // Order has been canceled
                        '-1143': OrderNotFound, // Cannot be found on order book
                        '-1144': InvalidOrder, // Order has been locked
                        '-1145': InvalidOrder, // This order type does not support cancellation
                        '-1146': RequestTimeout, // Order creation timeout
                        '-1147': RequestTimeout, // Order cancellation timeout
                        '-1149': InvalidOrder, // Create order failed
                        '-1187': InvalidAddress, // Withdrawal address not in whitelist
                        '-2010': InvalidOrder, // NEW_ORDER_REJECTED
                        '-2011': InvalidOrder, // CANCEL_REJECTED
                        '-2013': OrderNotFound, // Order does not exist
                        '-2014': AuthenticationError, // API-key format invalid
                        '-2015': AuthenticationError, // Invalid API-key, IP, or permissions for action
                        '-2016': ExchangeError, // No trading window could be found for the symbol. Try ticker/24hrs instead
                    },
                },
                // exchange-specific options
                'options': {
                    'fetchTickers': {
                        'method': 'quoteGetTicker24hr',
                    },
                    'accountsByType': {
                        'trade': 1,
                        'trading': 1,
                        'spot': 1,
                        'option': 2,
                        'options': 2,
                        'futures': 3,
                        'contract': 3,
                    },
                },
                'commonCurrencies': {
                    'MIS': 'Themis Protocol',
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTime (params);
            //
            //     {
            //         "serverTime": 1527777538000
            //     }
            //
            return this.safeInteger (response, 'serverTime');
        }
    
        parseMarket (market, type = 'spot') {
            const filters = this.safeValue (market, 'filters', []);
            const id = this.safeString (market, 'symbol');
            let baseId = this.safeString (market, 'baseAsset');
            const quoteId = this.safeString (market, 'quoteAsset');
            let base = this.safeCurrencyCode (baseId);
            const quote = this.safeCurrencyCode (quoteId);
            let symbol = base + '/' + quote;
            let spot = true;
            let future = false;
            let option = false;
            let inverse = false;
            if (type === 'future') {
                symbol = id;
                spot = false;
                future = true;
                inverse = this.safeValue (market, 'inverse', false);
                baseId = this.safeString (market, 'underlying');
                base = this.safeCurrencyCode (baseId);
            } else if (type === 'option') {
                symbol = id;
                spot = false;
                option = true;
            }
            const margin = this.safeValue (market, 'allowMargin', undefined);
            const isAggregate = this.safeValue (market, 'isAggregate', undefined);
            let active = true;
            if (isAggregate === true) {
                active = false;
            }
            let amountMin = undefined;
            let priceMin = undefined;
            let priceMax = undefined;
            let costMin = undefined;
            let pricePrecision = undefined;
            let amountPrecision = undefined;
            for (let j = 0; j < filters.length; j++) {
                const filter = filters[j];
                const filterType = this.safeString (filter, 'filterType');
                if (filterType === 'LOT_SIZE') {
                    amountMin = this.safeNumber (filter, 'minQty');
                    amountPrecision = this.safeNumber (filter, 'stepSize');
                }
                if (filterType === 'PRICE_FILTER') {
                    priceMin = this.safeNumber (filter, 'minPrice');
                    priceMax = this.safeNumber (filter, 'maxPrice');
                    pricePrecision = this.safeNumber (filter, 'tickSize');
                }
            }
            if ((amountMin !== undefined) && (priceMin !== undefined)) {
                costMin = amountMin * priceMin;
            }
            const precision = {
                'price': pricePrecision,
                'amount': amountPrecision,
                'base': this.safeNumber (market, 'baseAssetPrecision'),
                'quote': this.safeNumber2 (market, 'quotePrecision', 'quoteAssetPrecision'),
            };
            const limits = {
                'amount': {
                    'min': amountMin,
                    'max': undefined,
                },
                'price': {
                    'min': priceMin,
                    'max': priceMax,
                },
                'cost': {
                    'min': costMin,
                    'max': undefined,
                },
            };
            return {
                'id': id,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
                'active': active,
                'type': type,
                'spot': spot,
                'future': future,
                'option': option,
                'margin': margin,
                'inverse': inverse,
                'precision': precision,
                'limits': limits,
                'info': market,
            };
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetBrokerInfo (params);
            //
            //     {
            //         "timezone":"UTC",
            //         "serverTime":"1588015885118",
            //         "brokerFilters":[],
            //         "symbols":[
            //             {
            //                 "filters":[
            //                     {"minPrice":"0.01","maxPrice":"100000.00000000","tickSize":"0.01","filterType":"PRICE_FILTER"},
            //                     {"minQty":"0.0005","maxQty":"100000.00000000","stepSize":"0.000001","filterType":"LOT_SIZE"},
            //                     {"minNotional":"0.01","filterType":"MIN_NOTIONAL"}
            //                 ],
            //                 "exchangeId":"301",
            //                 "symbol":"BTCUSDT",
            //                 "symbolName":"BTCUSDT",
            //                 "status":"TRADING",
            //                 "baseAsset":"BTC",
            //                 "baseAssetName":"BTC",
            //                 "baseAssetPrecision":"0.000001",
            //                 "quoteAsset":"USDT",
            //                 "quoteAssetName":"USDT",
            //                 "quotePrecision":"0.01",
            //                 "icebergAllowed":false,
            //                 "isAggregate":false,
            //                 "allowMargin":true
            //            },
            //         ],
            //         "options":[
            //             {
            //                 "filters":[
            //                     {"minPrice":"0.01","maxPrice":"100000.00000000","tickSize":"0.01","filterType":"PRICE_FILTER"},
            //                     {"minQty":"0.01","maxQty":"100000.00000000","stepSize":"0.001","filterType":"LOT_SIZE"},
            //                     {"minNotional":"1","filterType":"MIN_NOTIONAL"}
            //                 ],
            //                 "exchangeId":"301",
            //                 "symbol":"BTC0501CS8500",
            //                 "symbolName":"BTC0501CS8500",
            //                 "status":"TRADING",
            //                 "baseAsset":"BTC0501CS8500",
            //                 "baseAssetName":"BTC0306CS3800",
            //                 "baseAssetPrecision":"0.001",
            //                 "quoteAsset":"BUSDT",
            //                 "quoteAssetName":"BUSDT",
            //                 "quotePrecision":"0.01",
            //                 "icebergAllowed":false
            //                 "isAggregate":false,
            //                 "allowMargin":false
            //             },
            //         ],
            //         "contracts":[
            //             {
            //                 "filters":[
            //                     {"minPrice":"0.1","maxPrice":"100000.00000000","tickSize":"0.1","filterType":"PRICE_FILTER"},
            //                     {"minQty":"1","maxQty":"100000.00000000","stepSize":"1","filterType":"LOT_SIZE"},
            //                     {"minNotional":"0.000001","filterType":"MIN_NOTIONAL"}
            //                 ],
            //                 "exchangeId":"301",
            //                 "symbol":"BTC-PERP-REV",
            //                 "symbolName":"BTC-PERP-REV",
            //                 "status":"TRADING",
            //                 "baseAsset":"BTC-PERP-REV",
            //                 "baseAssetPrecision":"1",
            //                 "quoteAsset":"USDT",
            //                 "quoteAssetPrecision":"0.1",
            //                 "icebergAllowed":false,
            //                 "inverse":true,
            //                 "index":"BTCUSDT",
            //                 "marginToken":"TBTC",
            //                 "marginPrecision":"0.00000001",
            //                 "contractMultiplier":"1.0",
            //                 "underlying":"TBTC",
            //                 "riskLimits":[
            //                     {"riskLimitId":"200000001","quantity":"1000000.0","initialMargin":"0.01","maintMargin":"0.005"},
            //                     {"riskLimitId":"200000002","quantity":"2000000.0","initialMargin":"0.02","maintMargin":"0.01"},
            //                     {"riskLimitId":"200000003","quantity":"3000000.0","initialMargin":"0.03","maintMargin":"0.015"},
            //                     {"riskLimitId":"200000004","quantity":"4000000.0","initialMargin":"0.04","maintMargin":"0.02"}
            //                 ]
            //             },
            //             {
            //                 "filters":[
            //                     {"minPrice":"0.1","maxPrice":"100000.00000000","tickSize":"0.1","filterType":"PRICE_FILTER"},
            //                     {"minQty":"1","maxQty":"100000.00000000","stepSize":"1","filterType":"LOT_SIZE"},
            //                     {"minNotional":"0.000001","filterType":"MIN_NOTIONAL"}
            //                 ],
            //                 "exchangeId":"301",
            //                 "symbol":"BTC-SWAP",
            //                 "symbolName":"BTC-SWAP",
            //                 "status":"TRADING",
            //                 "baseAsset":"BTC-SWAP",
            //                 "baseAssetPrecision":"1",
            //                 "quoteAsset":"USDT",
            //                 "quoteAssetPrecision":"0.1",
            //                 "icebergAllowed":false,
            //                 "inverse":true,
            //                 "index":"BTCUSDT",
            //                 "marginToken":"BTC",
            //                 "marginPrecision":"0.00000001",
            //                 "contractMultiplier":"1.0",
            //                 "underlying":"BTC",
            //                 "riskLimits":[
            //                     {"riskLimitId":"500000001","quantity":"1000000.0","initialMargin":"0.01","maintMargin":"0.005"},
            //                     {"riskLimitId":"500000002","quantity":"2000000.0","initialMargin":"0.02","maintMargin":"0.01"},
            //                     {"riskLimitId":"500000003","quantity":"3000000.0","initialMargin":"0.03","maintMargin":"0.015"},
            //                     {"riskLimitId":"500000004","quantity":"4000000.0","initialMargin":"0.04","maintMargin":"0.02"}
            //                 ]
            //             },
            //             {
            //                 "filters":[
            //                     {"minPrice":"0.1","maxPrice":"100000.00000000","tickSize":"0.1","filterType":"PRICE_FILTER"},
            //                     {"minQty":"1","maxQty":"100000.00000000","stepSize":"1","filterType":"LOT_SIZE"},
            //                     {"minNotional":"0.000000001","filterType":"MIN_NOTIONAL"}
            //                 ],
            //                 "exchangeId":"301",
            //                 "symbol":"BTC-PERP-BUSDT",
            //                 "symbolName":"BTC-PERP-BUSDT",
            //                 "status":"TRADING",
            //                 "baseAsset":"BTC-PERP-BUSDT",
            //                 "baseAssetPrecision":"1",
            //                 "quoteAsset":"BUSDT",
            //                 "quoteAssetPrecision":"0.1",
            //                 "icebergAllowed":false,
            //                 "inverse":false,
            //                 "index":"BTCUSDT",
            //                 "marginToken":"BUSDT",
            //                 "marginPrecision":"0.0001",
            //                 "contractMultiplier":"0.0001",
            //                 "underlying":"TBTC",
            //                 "riskLimits":[
            //                     {"riskLimitId":"600000132","quantity":"1000000.0","initialMargin":"0.01","maintMargin":"0.005"},
            //                     {"riskLimitId":"600000133","quantity":"2000000.0","initialMargin":"0.02","maintMargin":"0.01"},
            //                     {"riskLimitId":"600000134","quantity":"3000000.0","initialMargin":"0.03","maintMargin":"0.015"},
            //                     {"riskLimitId":"600000135","quantity":"4000000.0","initialMargin":"0.04","maintMargin":"0.02"}
            //                 ]
            //             },
            //         ]
            //     }
            //
            const result = [];
            const symbols = this.safeValue (response, 'symbols', []);
            for (let i = 0; i < symbols.length; i++) {
                const market = this.parseMarket (symbols[i], 'spot');
                result.push (market);
            }
            const options = this.safeValue (response, 'options', []);
            for (let i = 0; i < options.length; i++) {
                const market = this.parseMarket (options[i], 'option');
                result.push (market);
            }
            const contracts = this.safeValue (response, 'contracts', []);
            for (let i = 0; i < contracts.length; i++) {
                const market = this.parseMarket (contracts[i], 'future');
                result.push (market);
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 40, max 40
            }
            const response = await this.quoteGetDepth (this.extend (request, params));
            //
            //     {
            //         "time":1588068913453,
            //         "bids":[
            //             ["0.025278","0.0202"],
            //             ["0.025277","16.1132"],
            //             ["0.025276","7.9056"],
            //         ]
            //         "asks":[
            //             ["0.025302","5.9999"],
            //             ["0.025303","34.9151"],
            //             ["0.025304","92.391"],
            //         ]
            //     }
            //
            const timestamp = this.safeInteger (response, 'time');
            return this.parseOrderBook (response, symbol, timestamp);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.quoteGetTicker24hr (this.extend (request, params));
            //
            //     {
            //         "time":1588069860794,
            //         "symbol":"BNB0501PS16",
            //         "bestBidPrice":"0.2129",
            //         "bestAskPrice":"0.3163",
            //         "volume":"33547",
            //         "quoteVolume":"10801.987",
            //         "lastPrice":"0.2625",
            //         "highPrice":"0.3918",
            //         "lowPrice":"0.2625",
            //         "openPrice":"0.362",
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchBidAsk (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.quoteGetTickerBookTicker (this.extend (request, params));
            //
            //     {
            //         "symbol": "LTCBTC",
            //         "bidPrice": "4.00000000",
            //         "bidQty": "431.00000000",
            //         "askPrice": "4.00000200",
            //         "askQty": "9.00000000"
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchBidsAsks (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.quoteGetTickerBookTicker (params);
            //
            //     [
            //         {
            //             "symbol": "LTCBTC",
            //             "bidPrice": "4.00000000",
            //             "bidQty": "431.00000000",
            //             "askPrice": "4.00000200",
            //             "askQty": "9.00000000"
            //         },
            //         {
            //             "symbol": "ETHBTC",
            //             "bidPrice": "0.07946700",
            //             "bidQty": "9.00000000",
            //             "askPrice": "100000.00000000",
            //             "askQty": "1000.00000000"
            //         },
            //     ]
            //
            return this.parseTickers (response, symbols);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const options = this.safeValue (this.options, 'fetchTickers', {});
            const defaultMethod = this.safeString (options, 'method', 'quoteGetTicker24hr');
            const defaultType = this.safeString (options, 'type', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            let method = defaultMethod;
            if (type === 'future') {
                method = 'quoteGetContractTicker24hr';
            } else if (type === 'option') {
                method = 'quoteGetOptionTicker24hr';
            }
            const response = await this[method] (query);
            //
            //     [
            //         {
            //             "time": 1538725500422,
            //             "symbol": "ETHBTC",
            //             "lastPrice": "4.00000200",
            //             "openPrice": "99.00000000",
            //             "highPrice": "100.00000000",
            //             "lowPrice": "0.10000000",
            //             "volume": "8913.30000000"
            //         },
            //     ]
            //
            return this.parseTickers (response, symbols);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const options = this.safeValue (this.options, 'fetchBalance', {});
            const defaultType = this.safeString (options, 'type', 'spot');
            const type = this.safeString (params, 'type', defaultType);
            const query = this.omit (params, 'type');
            let method = 'privateGetAccount';
            if (type === 'future') {
                method = 'contractGetAccount';
            } else if (type === 'option') {
                method = 'optionGetAccount';
            }
            const response = await this[method] (query);
            //
            // spot
            //
            //     {
            //         'balances': [
            //             {
            //                 'asset': 'ALGO',
            //                 'free': '0',
            //                 'locked': '0'
            //             },
            //             {
            //                 'asset': 'BHT',
            //                 'free': '0',
            //                 'locked': '0'
            //             }
            //         ]
            //     }
            //
            // contract
            //
            //     {
            //         "BUSDT":{
            //             "total":"1000",
            //             "availableMargin":"1000",
            //             "positionMargin":"0",
            //             "orderMargin":"0",
            //             "tokenId":"BUSDT"
            //         },
            //         "TBTC":{
            //             "total":"0.5",
            //             "availableMargin":"0.5",
            //             "positionMargin":"0",
            //             "orderMargin":"0",
            //             "tokenId":"TBTC"
            //         }
            //     }
            //
            // option
            //
            //     {
            //         "optionAsset":"",
            //         "balances":[
            //             {
            //                 "tokenName":"USDT",
            //                 "free":"0.0",
            //                 "locked":"0.0",
            //                 "margin":"0.0"
            //             },
            //             {
            //                 "tokenName":"BUSDT",
            //                 "free":"0.0",
            //                 "locked":"0.0",
            //                 "margin":"0.0"
            //             }
            //         ]
            //     }
            //
            const balances = this.safeValue (response, 'balances');
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            if (balances !== undefined) {
                for (let i = 0; i < balances.length; i++) {
                    const balance = balances[i];
                    const currencyId = this.safeString2 (balance, 'asset', 'tokenName');
                    const code = this.safeCurrencyCode (currencyId);
                    const account = this.account ();
                    account['free'] = this.safeString (balance, 'free');
                    account['used'] = this.safeString (balance, 'locked');
                    result[code] = account;
                }
            } else {
                const currencyIds = Object.keys (response);
                for (let i = 0; i < currencyIds.length; i++) {
                    const currencyId = currencyIds[i];
                    const code = this.safeCurrencyCode (currencyId);
                    const balance = response[currencyId];
                    const account = this.account ();
                    account['free'] = this.safeString (balance, 'availableMargin');
                    account['total'] = this.safeString (balance, 'total');
                    result[code] = account;
                }
            }
            return this.parseBalance (result);
        }
    
        async fetchTrades (symbol, since = undefined, limit = 50, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.quoteGetTrades (this.extend (request, params));
            //
            //     [
            //         {"price":"0.025344","time":1588084082060,"qty":"1","isBuyerMaker":false},
            //         {"price":"0.02535","time":1588084086021,"qty":"0.553","isBuyerMaker":true},
            //         {"price":"0.025348","time":1588084097037,"qty":"1","isBuyerMaker":false},
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1587906000000, // open time
            //         "0.1761", // open
            //         "0.1761", // high
            //         "0.1761", // low
            //         "0.1761", // close
            //         "0", // base volume
            //         0, // close time
            //         "0", // quote volume
            //         0, // number of trades
            //         "0", // taker buy base asset volume
            //         "0" // taker buy quote asset volume
            //     ]
            //
            return [
                this.safeInteger (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'interval': this.timeframes[timeframe],
            };
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 500
            }
            const response = await this.quoteGetKlines (this.extend (request, params));
            //
            //     [
            //         [1587906000000,"0.1761","0.1761","0.1761","0.1761","0",0,"0",0,"0","0"],
            //         [1587906180000,"0.1761","0.1761","0.1761","0.1761","0",0,"0",0,"0","0"],
            //         [1587906360000,"0.1761","0.1848","0.1761","0.1848","53",0,"9.7944",1,"0","0"],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                // if only fromId is set，it will get orders < that fromId in descending order
                // if only toId is set, it will get orders > that toId in ascending order
                // if fromId is set and toId is set, it will get orders < that fromId and > that toId in descending order
                // if fromId is not set and toId it not set, most recent order are returned in descending order
                // 'fromId': '43287482374',
                // 'toId': '43287482374',
                // 'endTime': this.milliseconds (), // optional, spot only
            };
            const defaultType = this.safeString (this.options, 'type', 'spot');
            const options = this.safeValue (this.options, 'fetchMyTrades', {});
            const fetchMyTradesType = this.safeString (options, 'type', defaultType);
            let type = this.safeString (params, 'type', fetchMyTradesType);
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                type = market['type'];
            }
            const query = this.omit (params, 'type');
            if (limit !== undefined) {
                // spot default 500, max 1000
                // futures and options default 20, max 1000
                request['limit'] = limit;
            }
            let method = 'privateGetMyTrades';
            if (type === 'future') {
                method = 'contractGetMyTrades';
            } else {
                if (type === 'option') {
                    method = 'optionGetMyTrades';
                } else {
                    if (symbol === undefined) {
                        throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a `symbol` argument for ' + type + ' markets');
                    }
                    const market = this.market (symbol);
                    request['symbol'] = market['id'];
                    // spot only?
                    if (since !== undefined) {
                        request['startTime'] = since;
                    }
                }
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            const response = await this[method] (this.extend (request, query));
            //
            // spot
            //
            //     [
            //         {
            //             "id":"616384027512920576",
            //             "symbol":"TBTCBUSDT",
            //             "orderId":"616384027202542080",
            //             "matchOrderId":"605124954767266560",
            //             "price":"6826.06",
            //             "qty":"0.1",
            //             "commission":"0.682606",
            //             "commissionAsset":"BUSDT",
            //             "time":"1588214701982",
            //             "isBuyer":false,
            //             "isMaker":false,
            //             "fee":{
            //                 "feeTokenId":"BUSDT",
            //                 "feeTokenName":"BUSDT",
            //                 "fee":"0.682606"
            //             }
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const orderSide = side.toUpperCase ();
            const orderType = type.toUpperCase ();
            const request = {
                'symbol': market['id'],
                // BUY or SELL for spot and options
                'side': orderSide,
                // GTC, FOK, IOC for spot and options
                // GTC, FOK, IOC, LIMIT_MAKER for futures
                // 'timeInForce': 'GTC',
            };
            let query = params;
            let method = 'privatePostOrder';
            if (market['type'] === 'future') {
                if ((orderSide !== 'BUY_OPEN') && (orderSide !== 'SELL_OPEN') && (orderSide !== 'BUY_CLOSE') && (orderSide !== 'SELL_CLOSE')) {
                    throw new NotSupported (this.id + ' createOrder() does not support order side ' + side + ' for ' + market['type'] + ' markets, only BUY_OPEN, SELL_OPEN, BUY_CLOSE and SELL_CLOSE are supported');
                }
                if ((orderType !== 'LIMIT') && (orderType !== 'STOP')) {
                    throw new NotSupported (this.id + ' createOrder() does not support order type ' + type + ' for ' + market['type'] + ' markets, only LIMIT and STOP are supported');
                }
                const clientOrderId = this.safeValue (params, 'clientOrderId');
                if (clientOrderId === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a clientOrderId parameter for ' + market['type'] + ' markets, supply clientOrderId in the params argument');
                }
                const leverage = this.safeValue (params, 'leverage');
                if (leverage === undefined && (orderSide === 'BUY_OPEN' || orderSide === 'SELL_OPEN')) {
                    throw new NotSupported (this.id + ' createOrder() requires a leverage parameter for ' + market['type'] + ' markets if orderSide is BUY_OPEN or SELL_OPEN');
                }
                method = 'contractPostOrder';
                const priceType = this.safeString (params, 'priceType');
                if (priceType === undefined) {
                    request['price'] = this.priceToPrecision (symbol, price);
                } else {
                    request['priceType'] = priceType;
                    if (priceType === 'INPUT') {
                        request['price'] = this.priceToPrecision (symbol, price);
                    }
                }
                request['orderType'] = type.toUpperCase (); // LIMIT, STOP
                request['quantity'] = this.amountToPrecision (symbol, amount);
                // request['leverage'] = 1; // not required for closing orders
                request['leverage'] = leverage;
                request['clientOrderId'] = clientOrderId;
                // optional
                // request['priceType'] = 'INPUT', // INPUT, OPPONENT, QUEUE, OVER, MARKET
                // request['triggerPrice'] = 123.45;
            } else {
                if (market['type'] === 'option') {
                    method = 'optionPostOrder';
                }
                const newClientOrderId = this.safeValue2 (params, 'clientOrderId', 'newClientOrderId');
                if (newClientOrderId !== undefined) {
                    request['newClientOrderId'] = newClientOrderId;
                }
                request['type'] = orderType;
                if (type === 'limit') {
                    request['price'] = this.priceToPrecision (symbol, price);
                    request['quantity'] = this.amountToPrecision (symbol, amount);
                } else if (type === 'market') {
                    // for market buy it requires the amount of quote currency to spend
                    if (side === 'buy') {
                        const createMarketBuyOrderRequiresPrice = this.safeValue (this.options, 'createMarketBuyOrderRequiresPrice', true);
                        if (createMarketBuyOrderRequiresPrice) {
                            if (price !== undefined) {
                                amount = amount * price;
                            } else {
                                throw new InvalidOrder (this.id + " createOrder() requires the price argument with market buy orders to calculate total order cost (amount to spend), where cost = amount * price. Supply a price argument to createOrder() call if you want the cost to be calculated for you from price and amount, or, alternatively, add .options['createMarketBuyOrderRequiresPrice'] = false and supply the total cost value in the 'amount' argument (the exchange-specific behaviour)");
                            }
                        }
                        const precision = market['precision']['price'];
                        request['quantity'] = this.decimalToPrecision (amount, TRUNCATE, precision, this.precisionMode);
                    } else {
                        request['quantity'] = this.amountToPrecision (symbol, amount);
                    }
                }
            }
            query = this.omit (query, [ 'clientOrderId', 'newClientOrderId' ]);
            const response = await this[method] (this.extend (request, query));
            //
            // spot
            //
            //     {
            //         "symbol":"TBTCBUSDT",
            //         "orderId":"616376654496877056",
            //         "clientOrderId":"158821382304516955",
            //         "transactTime":"1588213823080",
            //         "price":"0",
            //         "origQty":"1000",
            //         "executedQty":"0",
            //         "status":"NEW",
            //         "timeInForce":"GTC",
            //         "type":"MARKET",
            //         "side":"BUY"
            //     }
            //
            // contract
            //
            //     {
            //         'time': '1570759718825',
            //         'updateTime': '0',
            //         'orderId': '469961015902208000',
            //         'clientOrderId': '6423344174',
            //         'symbol': 'BTC-PERP-REV',
            //         'price': '8200',
            //         'leverage': '12.08',
            //         'origQty': '5',
            //         'executedQty': '0',
            //         'avgPrice': '0',
            //         'marginLocked': '0.00005047',
            //         'orderType': 'LIMIT',
            //         'side': 'BUY_OPEN',
            //         'fees': [],
            //         'timeInForce': 'GTC',
            //         'status': 'NEW',
            //         'priceType': 'INPUT'
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const clientOrderId = this.safeValue2 (params, 'origClientOrderId', 'clientOrderId');
            const request = {};
            const defaultType = this.safeString (this.options, 'type', 'spot');
            const options = this.safeValue (this.options, 'cancelOrder', {});
            const cancelOrderType = this.safeString (options, 'type', defaultType);
            let type = this.safeString (params, 'type', cancelOrderType);
            let query = this.omit (params, 'type');
            if (clientOrderId !== undefined) {
                request['origClientOrderId'] = clientOrderId;
                query = this.omit (query, [ 'origClientOrderId', 'clientOrderId' ]);
            } else {
                request['orderId'] = id;
            }
            let method = 'privateDeleteOrder';
            const orderType = this.safeString (query, 'orderType');
            if (orderType !== undefined) {
                type = 'future';
            }
            if (type === 'future') {
                method = 'contractDeleteOrderCancel';
                if (orderType === undefined) {
                    throw new ArgumentsRequired (this.id + " cancelOrder() requires an orderType parameter, pass the { 'orderType': 'LIMIT' } or { 'orderType': 'STOP' } in params argument");
                }
                request['orderType'] = orderType;
            } else {
                if (type === 'option') {
                    method = 'optionDeleteOrderCancel';
                }
            }
            const response = await this[method] (this.extend (request, query));
            //
            // spot
            //
            //     {
            //         'exchangeId': '301',
            //         'symbol': 'BHTUSDT',
            //         'clientOrderId': '0',
            //         'orderId': '499890200602846976',
            //         'status': 'CANCELED'
            //     }
            //
            // futures
            //
            //     {
            //         "time":"1588353669383",
            //         "updateTime":"0",
            //         "orderId":"617549770304599296",
            //         "clientOrderId":"test-001",
            //         "symbol":"BTC-PERP-REV",
            //         "price":"10000",
            //         "leverage":"1",
            //         "origQty":"100",
            //         "executedQty":"0",
            //         "avgPrice":"0",
            //         "marginLocked":"0",
            //         "orderType":"LIMIT",
            //         "side":"SELL_OPEN",
            //         "fees":[],
            //         "timeInForce":"GTC",
            //         "status":"CANCELED",
            //         "priceType":"INPUT",
            //     }
            //
            return this.parseOrder (response);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                // if orderId is set, it will get orders < that orderId otherwise most recent orders are returned
                // 'orderId': '43287482374',
            };
            const defaultType = this.safeString (this.options, 'type', 'spot');
            const options = this.safeValue (this.options, 'fetchOpenOrders', {});
            const fetchOpenOrdersType = this.safeString (options, 'type', defaultType);
            let type = this.safeString (params, 'type', fetchOpenOrdersType);
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                type = market['type'];
            }
            const query = this.omit (params, 'type');
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            let method = 'privateGetOpenOrders';
            if (type === 'future') {
                method = 'contractGetOpenOrders';
            } else if (type === 'option') {
                method = 'optionGetOpenOrders';
            }
            const response = await this[method] (this.extend (request, query));
            //
            // spot
            //
            //     [
            //         {
            //             'orderId': '499902955766523648',
            //             'clientOrderId': '157432907618453',
            //             'exchangeId': '301',
            //             'symbol': 'BHTUSDT',
            //             'price': '0.01',
            //             'origQty': '50',
            //             'executedQty': '0',
            //             'cummulativeQuoteQty': '0',
            //             'avgPrice': '0',
            //             'status': 'NEW',
            //             'timeInForce': 'GTC',
            //             'type': 'LIMIT',
            //             'side': 'BUY',
            //             'stopPrice': '0.0',
            //             'icebergQty': '0.0',
            //             'time': '1574329076202',
            //             'updateTime': '0',
            //             'isWorking': true
            //         }
            //     ]
            //
            // futures
            //
            //     [
            //         {
            //             "time":"1588353669383",
            //             "updateTime":"0",
            //             "orderId":"617549770304599296",
            //             "clientOrderId":"test-001",
            //             "symbol":"BTC-PERP-REV",
            //             "price":"10000",
            //             "leverage":"1",
            //             "origQty":"100",
            //             "executedQty":"0",
            //             "avgPrice":"0",
            //             "marginLocked":"0.01",
            //             "orderType":"LIMIT",
            //             "side":"SELL_OPEN",
            //             "fees":[],
            //             "timeInForce":"GTC",
            //             "status":"NEW",
            //             "priceType":"INPUT"
            //         }
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                // if orderId is set, it will get orders < that orderId otherwise most recent orders are returned
                // 'orderId': '43287482374',
                // 'endTime': this.milliseconds (), // optional
            };
            const defaultType = this.safeString (this.options, 'type', 'spot');
            const options = this.safeValue (this.options, 'fetchClosedOrders', {});
            const fetchClosedOrdersType = this.safeString (options, 'type', defaultType);
            let type = this.safeString (params, 'type', fetchClosedOrdersType);
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
                type = market['type'];
            }
            const query = this.omit (params, 'type');
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            let method = 'privateGetHistoryOrders';
            if (type === 'future') {
                method = 'contractGetHistoryOrders';
            } else if (type === 'option') {
                method = 'optionGetHistoryOrders';
            }
            const response = await this[method] (this.extend (request, query));
            //
            // spot
            //
            //     [
            //         {
            //             "orderId":"616384027202542080",
            //             "clientOrderId":"158821470194414688",
            //             "exchangeId":"301",
            //             "symbol":"TBTCBUSDT",
            //             "price":"0",
            //             "origQty":"0.1",
            //             "executedQty":"0.1",
            //             "cummulativeQuoteQty":"682.606",
            //             "avgPrice":"6826.06",
            //             "status":"FILLED",
            //             "timeInForce":"GTC",
            //             "type":"MARKET",
            //             "side":"SELL",
            //             "stopPrice":"0.0",
            //             "icebergQty":"0.0",
            //             "time":"1588214701974",
            //             "updateTime":"0",
            //             "isWorking":true
            //         }
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const clientOrderId = this.safeValue2 (params, 'origClientOrderId', 'clientOrderId');
            const request = {};
            const defaultType = this.safeString (this.options, 'type', 'spot');
            const options = this.safeValue (this.options, 'fetchOrder', {});
            const fetchOrderType = this.safeString (options, 'type', defaultType);
            const type = this.safeString (params, 'type', fetchOrderType);
            let query = this.omit (params, 'type');
            if (clientOrderId !== undefined) {
                request['origClientOrderId'] = clientOrderId;
                query = this.omit (query, [ 'origClientOrderId', 'clientOrderId' ]);
            } else {
                request['orderId'] = id;
            }
            let method = 'privateGetOrder';
            if (type === 'future') {
                method = 'contractGetGetOrder';
            } else if (type === 'option') {
                method = 'optionGetGetOrder';
            }
            const response = await this[method] (this.extend (request, query));
            return this.parseOrder (response);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {
                // 'fromId': 'string', // if fromId is set, it will get deposits > that fromId, otherwise most recent deposits are returned
            };
            if (code !== undefined) {
                currency = this.currency (code);
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetDepositOrders (this.extend (request, params));
            //
            //     [
            //         {
            //             'time': '1565769575929',
            //             'orderId': '428100569859739648',
            //             'token': 'USDT',
            //             'address': '',
            //             'addressTag': '',
            //             'fromAddress': '',
            //             'fromAddressTag': '',
            //             'quantity': '1100',
            //         },
            //     ]
            //
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {
                // 'fromId': 'string', // if fromId is set, it will get deposits > that fromId, otherwise most recent deposits are returned
            };
            if (code !== undefined) {
                currency = this.currency (code);
                request['token'] = currency['id'];
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 1000
            }
            const response = await this.privateGetWithdrawalOrders (this.extend (request, params));
            //
            //     [
            //         {
            //             "time":"1536232111669",
            //             "orderId":"90161227158286336",
            //             "accountId":"517256161325920",
            //             "tokenId":"BHC",
            //             "tokenName":"BHC",
            //             "address":"0x815bF1c3cc0f49b8FC66B21A7e48fCb476051209",
            //             "addressExt":"address tag",
            //             "quantity":"14", // Withdrawal qty
            //             "arriveQuantity":"14", // Arrived qty
            //             "statusCode":"PROCESSING_STATUS",
            //             "status":3,
            //             "txid":"",
            //             "txidUrl":"",
            //             "walletHandleTime":"1536232111669",
            //             "feeTokenId":"BHC",
            //             "feeTokenName":"BHC",
            //             "fee":"0.1",
            //             "requiredConfirmNum":0, // Required confirmations
            //             "confirmNum":0, // Confirmations
            //             "kernelId":"", // BEAM and GRIN only
            //             "isInternalTransfer": false // True if this transfer is internal
            //         }
            //     ]
            //
            return this.parseTransactions (response, currency, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const clientOrderId = this.safeString (params, 'clientOrderId', this.uuid ());
            const request = {
                'clientOrderId': clientOrderId,
                'tokenId': currency['id'],
                'address': address, // the withdrawal address must be in current tag list in your PC/APP client
                'withdrawQuantity': amount,
                // 'chainType': 'OMNI', // OMNI, ERC20, TRC20
            };
            if (tag !== undefined) {
                request['addressExt'] = tag;
            }
            const response = await this.privatePostWithdraw (this.extend (request, params));
            //
            //     {
            //         "status": 0,
            //         "success": true,
            //         "needBrokerAudit": false, // Whether this request needs broker auit
            //         "orderId": "423885103582776064" // Id for successful withdrawal
            //     }
            //
            return {
                'info': response,
                'id': this.safeString (response, 'orderId'),
            };
        }
    
        async fetchAccounts (params = {}) {
            const response = await this.privatePostSubAccountQuery (params);
            //
            //     [
            //         {
            //             "accountId": "122216245228131",
            //             "accountName": "createSubAccountByCurl", // sub-account name
            //             "accountType": 1, // 1 token trading, 2 options, 3 futures
            //             "accountIndex": 1, // 0 main account, 1 sub-account
            //         },
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const account = response[i];
                const accountId = this.safeString (account, 'accountId');
                const accountType = this.safeString (account, 'accountType');
                let type = accountType;
                if (accountType === '1') {
                    type = 'spot';
                } else if (accountType === '2') {
                    type = 'option';
                } else if (accountType === '3') {
                    type = 'future';
                }
                result.push ({
                    'id': accountId,
                    'type': type,
                    'currency': undefined,
                    'info': account,
                });
            }
            return result;
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'accountType': 1, // spot 1, options 2, futures 3
                'accountIndex': 0, // main 0, sub-account 1
                'fromFlowId': '', // flowId to start from
                'endFlowId': '', // flowId to end with
                'endTime': 1588450533040,
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['tokenId'] = currency['id'];
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 500, max 500
            }
            const response = await this.privateGetBalanceFlow (this.extend (request, params));
            //
            //     [
            //         {
            //             "id": "539870570957903104",
            //             "accountId": "122216245228131",
            //             "tokenId": "BTC",
            //             "tokenName": "BTC",
            //             "flowTypeValue": 51,
            //             "flowType": "USER_ACCOUNT_TRANSFER",
            //             "flowName": "Transfer",
            //             "change": "-12.5",
            //             "total": "379.624059937852365", // after change
            //             "created": "1579093587214"
            //         },
            //         {
            //             "id": "536072393645448960",
            //             "accountId": "122216245228131",
            //             "tokenId": "USDT",
            //             "tokenName": "USDT",
            //             "flowTypeValue": 7,
            //             "flowType": "AIRDROP",
            //             "flowName": "Airdrop",
            //             "change": "-2000",
            //             "total": "918662.0917630848",
            //             "created": "1578640809195"
            //         }
            //     ]
            //
            return this.parseLedger (response, currency, since, limit);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //     {
            //         "id": "539870570957903104",
            //         "accountId": "122216245228131",
            //         "tokenId": "BTC",
            //         "tokenName": "BTC",
            //         "flowTypeValue": 51,
            //         "flowType": "USER_ACCOUNT_TRANSFER",
            //         "flowName": "Transfer",
            //         "change": "-12.5",
            //         "total": "379.624059937852365", // after change
            //         "created": "1579093587214"
            //     }
            //
            //     {
            //         "id": "536072393645448960",
            //         "accountId": "122216245228131",
            //         "tokenId": "USDT",
            //         "tokenName": "USDT",
            //         "flowTypeValue": 7,
            //         "flowType": "AIRDROP",
            //         "flowName": "Airdrop",
            //         "change": "-2000",
            //         "total": "918662.0917630848",
            //         "created": "1578640809195"
            //     }
            //
            const currencyId = this.safeString (item, 'tokenId');
            const code = this.safeCurrencyCode (currencyId, currency);
            const amount = this.safeNumber (item, 'change');
            const after = this.safeNumber (item, 'total');
            const direction = (amount < 0) ? 'out' : 'in';
            let before = undefined;
            if (after !== undefined && amount !== undefined) {
                const difference = (direction === 'out') ? amount : -amount;
                before = this.sum (after, difference);
            }
            const timestamp = this.safeInteger (item, 'created');
            const type = this.parseLedgerEntryType (this.safeString (item, 'flowType'));
            const id = this.safeString (item, 'id');
            const account = this.safeString (item, 'accountId');
            return {
                'id': id,
                'currency': code,
                'account': account,
                'referenceAccount': undefined,
                'referenceId': undefined,
                'status': undefined,
                'amount': amount,
                'before': before,
                'after': after,
                'fee': undefined,
                'direction': direction,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'type': type,
                'info': item,
            };
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'TRADE': 'trade',
                'FEE': 'fee',
                'TRANSFER': 'transfer',
                'DEPOSIT': 'transaction',
                'MAKER_REWARD': 'rebate',
                'PNL': 'pnl',
                'SETTLEMENT': 'settlement',
                'LIQUIDATION': 'liquidation',
                'FUNDING_SETTLEMENT': 'settlement',
                'USER_ACCOUNT_TRANSFER': 'transfer',
                'OTC_BUY_COIN': 'trade',
                'OTC_SELL_COIN': 'trade',
                'OTC_FEE': 'fee',
                'OTC_TRADE': 'trade',
                'ACTIVITY_AWARD': 'referral',
                'INVITATION_REFERRAL_BONUS': 'referral',
                'REGISTER_BONUS': 'referral',
                'AIRDROP': 'airdrop',
                'MINE_REWARD': 'reward',
            };
            return this.safeString (types, type, type);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'BROKER_AUDITING_STATUS': 'pending',
                'BROKER_REJECT_STATUS': 'failed',
                'AUDITING_STATUS': 'pending',
                'AUDIT_REJECT_STATUS': 'failed',
                'PROCESSING_STATUS': 'pending',
                'WITHDRAWAL_SUCCESS_STATUS': 'ok',
                'WITHDRAWAL_FAILURE_STATUS': 'failed',
                'BLOCK_MINING_STATUS': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         'time': '1565769575929',
            //         'orderId': '428100569859739648',
            //         'token': 'USDT',
            //         'address': '',
            //         'addressTag': '',
            //         'fromAddress': '',
            //         'fromAddressTag': '',
            //         'quantity': '1100',
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         "time":"1536232111669",
            //         "orderId":"90161227158286336",
            //         "accountId":"517256161325920",
            //         "tokenId":"BHC",
            //         "tokenName":"BHC",
            //         "address":"0x815bF1c3cc0f49b8FC66B21A7e48fCb476051209",
            //         "addressExt":"address tag",
            //         "quantity":"14", // Withdrawal qty
            //         "arriveQuantity":"14", // Arrived qty
            //         "statusCode":"PROCESSING_STATUS",
            //         "status":3,
            //         "txid":"",
            //         "txidUrl":"",
            //         "walletHandleTime":"1536232111669",
            //         "feeTokenId":"BHC",
            //         "feeTokenName":"BHC",
            //         "fee":"0.1",
            //         "requiredConfirmNum":0, // Required confirmations
            //         "confirmNum":0, // Confirmations
            //         "kernelId":"", // BEAM and GRIN only
            //         "isInternalTransfer": false // True if this transfer is internal
            //     }
            //
            const id = this.safeString (transaction, 'orderId');
            const address = this.safeString (transaction, 'address');
            let tag = this.safeString2 (transaction, 'addressExt', 'addressTag');
            if (tag !== undefined) {
                if (tag.length < 1) {
                    tag = undefined;
                }
            }
            const addressFrom = this.safeString (transaction, 'fromAddress');
            let tagFrom = this.safeString (transaction, 'fromAddressTag');
            if (tagFrom !== undefined) {
                if (tagFrom.length < 1) {
                    tagFrom = undefined;
                }
            }
            const currencyId = this.safeString (transaction, 'tokenId');
            const code = this.safeCurrencyCode (currencyId, currency);
            const timestamp = this.safeInteger (transaction, 'time');
            let txid = this.safeString (transaction, 'txid');
            if (txid === '') {
                txid = undefined;
            }
            let type = undefined;
            let status = this.parseTransactionStatus (this.safeString (transaction, 'statusCode'));
            if (status === undefined) {
                type = 'deposit';
                status = 'ok';
            } else {
                type = 'withdrawal';
            }
            const amount = this.safeNumber (transaction, 'quantity');
            const feeCost = this.safeNumber (transaction, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (transaction, 'feeTokenId');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'currency': feeCurrencyCode,
                    'cost': feeCost,
                };
            }
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': addressFrom,
                'address': address,
                'addressTo': address,
                'tagFrom': tagFrom,
                'tag': tag,
                'tagTo': tag,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': undefined,
                'fee': fee,
            };
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker, fetchTickers
            //
            //     {
            //         "time":1588069860794,
            //         "symbol":"BNB0501PS16",
            //         "bestBidPrice":"0.2129",
            //         "bestAskPrice":"0.3163",
            //         "volume":"33547",
            //         "quoteVolume":"10801.987",
            //         "lastPrice":"0.2625",
            //         "highPrice":"0.3918",
            //         "lowPrice":"0.2625",
            //         "openPrice":"0.362",
            //     }
            //
            // fetchBidAsk, fetchBidAsks
            //
            //     {
            //         "symbol": "LTCBTC",
            //         "bidPrice": "4.00000000",
            //         "bidQty": "431.00000000",
            //         "askPrice": "4.00000200",
            //         "askQty": "9.00000000"
            //     }
            //
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.safeInteger (ticker, 'time');
            const open = this.safeNumber (ticker, 'openPrice');
            const close = this.safeNumber (ticker, 'lastPrice');
            const quoteVolume = this.safeNumber (ticker, 'quoteVolume');
            const baseVolume = this.safeNumber (ticker, 'volume');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'highPrice'),
                'low': this.safeNumber (ticker, 'lowPrice'),
                'bid': this.safeNumber2 (ticker, 'bestBidPrice', 'bidPrice'),
                'bidVolume': this.safeNumber (ticker, 'bidQty'),
                'ask': this.safeNumber2 (ticker, 'bestAskPrice', 'askPrice'),
                'askVolume': this.safeNumber (ticker, 'askQty'),
                'vwap': vwap,
                'open': open,
                'close': close,
                'last': close,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        parseTrade (trade, market) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "price":"0.025344",
            //         "time":1588084082060,
            //         "qty":"1",
            //         "isBuyerMaker":false
            //     }
            //
            // fetchMyTrades (private)
            //
            // spot
            //
            //     {
            //         "id":"616384027512920576",
            //         "symbol":"TBTCBUSDT",
            //         "orderId":"616384027202542080",
            //         "matchOrderId":"605124954767266560",
            //         "price":"6826.06",
            //         "qty":"0.1",
            //         "commission":"0.682606",
            //         "commissionAsset":"BUSDT",
            //         "time":"1588214701982",
            //         "isBuyer":false,
            //         "isMaker":false,
            //         "fee":{
            //             "feeTokenId":"BUSDT",
            //             "feeTokenName":"BUSDT",
            //             "fee":"0.682606"
            //         }
            //     }
            //
            const id = this.safeString (trade, 'id');
            const timestamp = this.safeNumber (trade, 'time');
            const type = undefined;
            const orderId = this.safeString (trade, 'orderId');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'qty');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let side = undefined;
            let takerOrMaker = undefined;
            if ('isBuyerMaker' in trade) {
                side = trade['isBuyerMaker'] ? 'sell' : 'buy';
            } else {
                const isMaker = this.safeValue (trade, 'isMaker');
                if (isMaker !== undefined) {
                    takerOrMaker = isMaker ? 'maker' : 'taker';
                }
                const isBuyer = this.safeValue (trade, 'isBuyer');
                side = isBuyer ? 'buy' : 'sell';
            }
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'commission');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'commissionAsset');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            let symbol = undefined;
            if ((symbol === undefined) && (market !== undefined)) {
                symbol = market['symbol'];
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'order': orderId,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "symbol":"TBTCBUSDT",
            //         "orderId":"616376654496877056",
            //         "clientOrderId":"158821382304516955",
            //         "transactTime":"1588213823080",
            //         "price":"0",
            //         "origQty":"1000",
            //         "executedQty":"0",
            //         "status":"NEW",
            //         "timeInForce":"GTC",
            //         "type":"MARKET",
            //         "side":"BUY"
            //     }
            //
            // fetchOrder, fetchOpenOrders, fetchClosedOrders
            //
            // spot
            //
            //     {
            //         "orderId":"616384027202542080",
            //         "clientOrderId":"158821470194414688",
            //         "exchangeId":"301",
            //         "symbol":"TBTCBUSDT",
            //         "price":"0",
            //         "origQty":"0.1",
            //         "executedQty":"0.1",
            //         "cummulativeQuoteQty":"682.606",
            //         "avgPrice":"6826.06",
            //         "status":"FILLED",
            //         "timeInForce":"GTC",
            //         "type":"MARKET",
            //         "side":"SELL",
            //         "stopPrice":"0.0",
            //         "icebergQty":"0.0",
            //         "time":"1588214701974",
            //         "updateTime":"0",
            //         "isWorking":true
            //     }
            //
            // future
            //
            //     {
            //         time: "1588353669383",
            //         updateTime: "0",
            //         orderId: "617549770304599296",
            //         clientOrderId: "test-001",
            //         symbol: "BTC-PERP-REV",
            //         price: "10000",
            //         leverage: "1",
            //         origQty: "100",
            //         executedQty: "0",
            //         avgPrice: "0",
            //         marginLocked: "0",
            //         orderType: "LIMIT",
            //         side: "SELL_OPEN",
            //         fees: [],
            //         timeInForce: "GTC",
            //         status: "CANCELED",
            //         priceType: "INPUT"
            //     }
            //
            //
            const id = this.safeString (order, 'orderId');
            const clientOrderId = this.safeString (order, 'clientOrderId');
            let timestamp = this.safeInteger (order, 'time');
            if (timestamp === undefined) {
                timestamp = this.safeInteger (order, 'transactTime');
            }
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            let type = this.safeStringLower (order, 'type');
            const side = this.safeStringLower (order, 'side');
            let price = this.safeNumber (order, 'price');
            let average = this.safeNumber (order, 'avgPrice');
            let amount = undefined;
            let cost = this.safeNumber (order, 'cummulativeQuoteQty');
            let filled = undefined;
            let remaining = undefined;
            if (type === undefined) {
                type = this.safeStringLower (order, 'orderType');
                if ((market !== undefined) && market['inverse']) {
                    cost = this.safeNumber (order, 'executedQty');
                    amount = undefined;
                }
                if (cost === 0.0) {
                    filled = 0;
                }
            } else {
                amount = this.safeNumber (order, 'origQty');
                if (type === 'market') {
                    price = undefined;
                    if (side === 'buy') {
                        amount = undefined;
                    }
                }
                filled = this.safeNumber (order, 'executedQty');
                if (filled !== undefined) {
                    if (amount !== undefined) {
                        remaining = amount - filled;
                    }
                }
            }
            if (average === 0.0) {
                average = undefined;
            }
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const timeInForce = this.safeString (order, 'timeInForce');
            const stopPrice = this.safeNumber (order, 'stopPrice');
            const result = {
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'average': average,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'trades': undefined,
                'fee': undefined,
                'fees': undefined,
            };
            const fees = this.safeValue (order, 'fees', []);
            const numFees = fees.length;
            if (numFees > 0) {
                result['fees'] = [];
                for (let i = 0; i < fees.length; i++) {
                    const feeCost = this.safeNumber (fees[i], 'fee');
                    if (feeCost !== undefined) {
                        const feeCurrencyId = this.safeString (fees[i], 'feeToken');
                        const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                        result['fees'].push ({
                            'cost': feeCost,
                            'currency': feeCurrencyCode,
                        });
                    }
                }
            }
            return result;
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'NEW': 'open',
                'CANCELED': 'canceled',
                'FILLED': 'closed',
                'PARTIALLY_FILLED': 'open',
                'PENDING_CANCEL': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            const isPublicContract = (api === 'contract') && ((path === 'insurance') || (path === 'fundingRate'));
            if ((api === 'public') || (api === 'quote') || isPublicContract) {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                const timestamp = this.milliseconds ();
                this.checkRequiredCredentials ();
                const request = this.extend ({
                    'timestamp': timestamp,
                }, query);
                // 准备待签名数据
                const auth = this.urlencode (request);
                const signature = this.hmac (this.encode (auth), this.encode (this.secret), 'sha256');
                request['signature'] = signature;
                headers = {
                    'X-BH-APIKEY': this.apiKey,
                };
                if (method === 'POST') {
                    body = this.urlencode (request);
                    headers = this.extend ({
                        'Content-Type': 'application/x-www-form-urlencoded',
                    }, headers);
                } else {
                    url += '?' + this.urlencode (request);
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if ('code' in response) {
                const code = this.safeString (response, 'code');
                if (code !== '0') {
                    const feedback = this.id + ' ' + body;
                    this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],85:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { BadSymbol, PermissionDenied, ExchangeError, ExchangeNotAvailable, OrderNotFound, InsufficientFunds, InvalidOrder, RequestTimeout, AuthenticationError } = require ('./base/errors');
    const { TRUNCATE, DECIMAL_PLACES, TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class hitbtc extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'hitbtc',
                'name': 'HitBTC',
                'countries': [ 'HK' ],
                'rateLimit': 1500,
                'version': '2',
                'pro': true,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': false,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrder': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': false,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTradingFee': true,
                    'fetchTransactions': true,
                    'fetchWithdrawals': false,
                    'withdraw': true,
                    'transfer': true,
                },
                'timeframes': {
                    '1m': 'M1',
                    '3m': 'M3',
                    '5m': 'M5',
                    '15m': 'M15',
                    '30m': 'M30', // default
                    '1h': 'H1',
                    '4h': 'H4',
                    '1d': 'D1',
                    '1w': 'D7',
                    '1M': '1M',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27766555-8eaec20e-5edc-11e7-9c5b-6dc69fc42f5e.jpg',
                    'test': {
                        'public': 'https://api.demo.hitbtc.com',
                        'private': 'https://api.demo.hitbtc.com',
                    },
                    'api': {
                        'public': 'https://api.hitbtc.com',
                        'private': 'https://api.hitbtc.com',
                    },
                    'www': 'https://hitbtc.com',
                    'referral': 'https://hitbtc.com/?ref_id=5a5d39a65d466',
                    'doc': [
                        'https://api.hitbtc.com',
                        'https://github.com/hitbtc-com/hitbtc-api/blob/master/APIv2.md',
                    ],
                    'fees': [
                        'https://hitbtc.com/fees-and-limits',
                        'https://support.hitbtc.com/hc/en-us/articles/115005148605-Fees-and-limits',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            'currency', // Available Currencies
                            'currency/{currency}', // Get currency info
                            'symbol', // Available Currency Symbols
                            'symbol/{symbol}', // Get symbol info
                            'ticker', // Ticker list for all symbols
                            'ticker/{symbol}', // Ticker for symbol
                            'trades',
                            'trades/{symbol}', // Trades
                            'orderbook',
                            'orderbook/{symbol}', // Orderbook
                            'candles',
                            'candles/{symbol}', // Candles
                        ],
                    },
                    'private': {
                        'get': [
                            'trading/balance', // Get trading balance
                            'order', // List your current open orders
                            'order/{clientOrderId}', // Get a single order by clientOrderId
                            'trading/fee/all', // Get trading fee rate
                            'trading/fee/{symbol}', // Get trading fee rate
                            'margin/account',
                            'margin/account/{symbol}',
                            'margin/position',
                            'margin/position/{symbol}',
                            'margin/order',
                            'margin/order/{clientOrderId}',
                            'history/order', // Get historical orders
                            'history/trades', // Get historical trades
                            'history/order/{orderId}/trades', // Get historical trades by specified order
                            'account/balance', // Get main acccount balance
                            'account/crypto/address/{currency}', // Get current address
                            'account/crypto/addresses/{currency}', // Get last 10 deposit addresses for currency
                            'account/crypto/used-addresses/{currency}', // Get last 10 unique addresses used for withdraw by currency
                            'account/crypto/estimate-withdraw',
                            'account/crypto/is-mine/{address}',
                            'account/transactions', // Get account transactions
                            'account/transactions/{id}', // Get account transaction by id
                            'sub-acc',
                            'sub-acc/acl',
                            'sub-acc/balance/{subAccountUserID}',
                            'sub-acc/deposit-address/{subAccountUserId}/{currency}',
                        ],
                        'post': [
                            'order', // Create new order
                            'margin/order',
                            'account/crypto/address/{currency}', // Create new crypto deposit address
                            'account/crypto/withdraw', // Withdraw crypto
                            'account/crypto/transfer-convert',
                            'account/transfer', // Transfer amount to trading account or to main account
                            'account/transfer/internal',
                            'sub-acc/freeze',
                            'sub-acc/activate',
                            'sub-acc/transfer',
                        ],
                        'put': [
                            'order/{clientOrderId}', // Create new order
                            'margin/account/{symbol}',
                            'margin/order/{clientOrderId}',
                            'account/crypto/withdraw/{id}', // Commit crypto withdrawal
                            'sub-acc/acl/{subAccountUserId}',
                        ],
                        'delete': [
                            'order', // Cancel all open orders
                            'order/{clientOrderId}', // Cancel order
                            'margin/account',
                            'margin/account/{symbol}',
                            'margin/position',
                            'margin/position/{symbol}',
                            'margin/order',
                            'margin/order/{clientOrderId}',
                            'account/crypto/withdraw/{id}', // Rollback crypto withdrawal
                        ],
                        // outdated?
                        'patch': [
                            'order/{clientOrderId}', // Cancel Replace order
                        ],
                    },
                },
                'precisionMode': TICK_SIZE,
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': 0.1 / 100,
                        'taker': 0.2 / 100,
                    },
                },
                'options': {
                    'defaultTimeInForce': 'FOK',
                    'accountsByType': {
                        'bank': 'bank',
                        'exchange': 'exchange',
                        'main': 'bank',  // alias of the above
                        'funding': 'bank',
                        'spot': 'exchange',
                        'trade': 'exchange',
                        'trading': 'exchange',
                    },
                    'fetchBalanceMethod': {
                        'account': 'account',
                        'bank': 'account',
                        'main': 'account',
                        'funding': 'account',
                        'exchange': 'trading',
                        'spot': 'trading',
                        'trade': 'trading',
                        'trading': 'trading',
                    },
                },
                'commonCurrencies': {
                    'AUTO': 'Cube',
                    'BCC': 'BCC', // initial symbol for Bitcoin Cash, now inactive
                    'BDP': 'BidiPass',
                    'BET': 'DAO.Casino',
                    'BIT': 'BitRewards',
                    'BOX': 'BOX Token',
                    'CPT': 'Cryptaur', // conflict with CPT = Contents Protocol https://github.com/ccxt/ccxt/issues/4920 and https://github.com/ccxt/ccxt/issues/6081
                    'GET': 'Themis',
                    'HSR': 'HC',
                    'IQ': 'IQ.Cash',
                    'LNC': 'LinkerCoin',
                    'PLA': 'PlayChip',
                    'PNT': 'Penta',
                    'SBTC': 'Super Bitcoin',
                    'STX': 'Stox',
                    'TV': 'Tokenville',
                    'USD': 'USDT',
                    'XPNT': 'PNT',
                },
                'exceptions': {
                    '504': RequestTimeout, // {"error":{"code":504,"message":"Gateway Timeout"}}
                    '1002': AuthenticationError, // {"error":{"code":1002,"message":"Authorization failed","description":""}}
                    '1003': PermissionDenied, // "Action is forbidden for this API key"
                    '2010': InvalidOrder, // "Quantity not a valid number"
                    '2001': BadSymbol, // "Symbol not found"
                    '2011': InvalidOrder, // "Quantity too low"
                    '2020': InvalidOrder, // "Price not a valid number"
                    '20002': OrderNotFound, // canceling non-existent order
                    '20001': InsufficientFunds, // {"error":{"code":20001,"message":"Insufficient funds","description":"Check that the funds are sufficient, given commissions"}}
                },
            });
        }
    
        feeToPrecision (symbol, fee) {
            return this.decimalToPrecision (fee, TRUNCATE, 8, DECIMAL_PLACES);
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetSymbol (params);
            //
            //     [
            //         {
            //             "id":"BCNBTC",
            //             "baseCurrency":"BCN",
            //             "quoteCurrency":"BTC",
            //             "quantityIncrement":"100",
            //             "tickSize":"0.00000000001",
            //             "takeLiquidityRate":"0.002",
            //             "provideLiquidityRate":"0.001",
            //             "feeCurrency":"BTC"
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'id');
                const baseId = this.safeString (market, 'baseCurrency');
                const quoteId = this.safeString (market, 'quoteCurrency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                let symbol = base + '/' + quote;
                // bequant fix
                if (id.indexOf ('_') >= 0) {
                    symbol = id;
                }
                const lotString = this.safeString (market, 'quantityIncrement');
                const stepString = this.safeString (market, 'tickSize');
                const lot = this.parseNumber (lotString);
                const step = this.parseNumber (stepString);
                const precision = {
                    'price': step,
                    'amount': lot,
                };
                const taker = this.safeNumber (market, 'takeLiquidityRate');
                const maker = this.safeNumber (market, 'provideLiquidityRate');
                const feeCurrencyId = this.safeString (market, 'feeCurrency');
                const feeCurrencyCode = this.safeCurrencyCode (feeCurrencyId);
                result.push (this.extend (this.fees['trading'], {
                    'info': market,
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'taker': taker,
                    'maker': maker,
                    'precision': precision,
                    'feeCurrency': feeCurrencyCode,
                    'limits': {
                        'amount': {
                            'min': lot,
                            'max': undefined,
                        },
                        'price': {
                            'min': step,
                            'max': undefined,
                        },
                        'cost': {
                            'min': this.parseNumber (Precise.stringMul (lotString, stepString)),
                            'max': undefined,
                        },
                    },
                }));
            }
            return result;
        }
    
        async transfer (code, amount, fromAccount, toAccount, params = {}) {
            // account can be "exchange" or "bank", with aliases "main" or "trading" respectively
            await this.loadMarkets ();
            const currency = this.currency (code);
            const requestAmount = this.currencyToPrecision (code, amount);
            const request = {
                'currency': currency['id'],
                'amount': requestAmount,
            };
            let type = this.safeString (params, 'type');
            if (type === undefined) {
                const accountsByType = this.safeValue (this.options, 'accountsByType', {});
                const fromId = this.safeString (accountsByType, fromAccount);
                const toId = this.safeString (accountsByType, toAccount);
                const keys = Object.keys (accountsByType);
                if (fromId === undefined) {
                    throw new ExchangeError (this.id + ' fromAccount must be one of ' + keys.join (', ') + ' instead of ' + fromId);
                }
                if (toId === undefined) {
                    throw new ExchangeError (this.id + ' toAccount must be one of ' + keys.join (', ') + ' instead of ' + toId);
                }
                if (fromId === toId) {
                    throw new ExchangeError (this.id + ' from and to cannot be the same account');
                }
                type = fromId + 'To' + this.capitalize (toId);
            }
            request['type'] = type;
            const response = await this.privatePostAccountTransfer (this.extend (request, params));
            // { id: '2db6ebab-fb26-4537-9ef8-1a689472d236' }
            const id = this.safeString (response, 'id');
            return {
                'info': response,
                'id': id,
                'timestamp': undefined,
                'datetime': undefined,
                'amount': requestAmount,
                'currency': code,
                'fromAccount': fromAccount,
                'toAccount': toAccount,
                'status': undefined,
            };
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrency (params);
            //
            //     [
            //         {
            //             "id":"XPNT",
            //             "fullName":"pToken",
            //             "crypto":true,
            //             "payinEnabled":true,
            //             "payinPaymentId":false,
            //             "payinConfirmations":9,
            //             "payoutEnabled":true,
            //             "payoutIsPaymentId":false,
            //             "transferEnabled":true,
            //             "delisted":false,
            //             "payoutFee":"26.510000000000",
            //             "precisionPayout":18,
            //             "precisionTransfer":8
            //         }
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'id');
                // todo: will need to rethink the fees
                // to add support for multiple withdrawal/deposit methods and
                // differentiated fees for each particular method
                const decimals = this.safeInteger (currency, 'precisionTransfer', 8);
                const precision = 1 / Math.pow (10, decimals);
                const code = this.safeCurrencyCode (id);
                const payin = this.safeValue (currency, 'payinEnabled');
                const payout = this.safeValue (currency, 'payoutEnabled');
                const transfer = this.safeValue (currency, 'transferEnabled');
                let active = payin && payout && transfer;
                if ('disabled' in currency) {
                    if (currency['disabled']) {
                        active = false;
                    }
                }
                let type = 'fiat';
                if (('crypto' in currency) && currency['crypto']) {
                    type = 'crypto';
                }
                const name = this.safeString (currency, 'fullName');
                result[code] = {
                    'id': id,
                    'code': code,
                    'type': type,
                    'payin': payin,
                    'payout': payout,
                    'transfer': transfer,
                    'info': currency,
                    'name': name,
                    'active': active,
                    'fee': this.safeNumber (currency, 'payoutFee'), // todo: redesign
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': 1 / Math.pow (10, decimals),
                            'max': Math.pow (10, decimals),
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': Math.pow (10, precision),
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchTradingFee (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = this.extend ({
                'symbol': market['id'],
            }, this.omit (params, 'symbol'));
            const response = await this.privateGetTradingFeeSymbol (request);
            //
            //     {
            //         takeLiquidityRate: '0.001',
            //         provideLiquidityRate: '-0.0001'
            //     }
            //
            return {
                'info': response,
                'maker': this.safeNumber (response, 'provideLiquidityRate'),
                'taker': this.safeNumber (response, 'takeLiquidityRate'),
            };
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const type = this.safeString (params, 'type', 'trading');
            const fetchBalanceAccounts = this.safeValue (this.options, 'fetchBalanceMethod', {});
            const typeId = this.safeString (fetchBalanceAccounts, type);
            if (typeId === undefined) {
                throw new ExchangeError (this.id + ' fetchBalance account type must be either main or trading');
            }
            const method = 'privateGet' + this.capitalize (typeId) + 'Balance';
            const query = this.omit (params, 'type');
            const response = await this[method] (query);
            //
            //     [
            //         {"currency":"SPI","available":"0","reserved":"0"},
            //         {"currency":"GRPH","available":"0","reserved":"0"},
            //         {"currency":"DGTX","available":"0","reserved":"0"},
            //     ]
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'available');
                account['used'] = this.safeString (balance, 'reserved');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "timestamp":"2015-08-20T19:01:00.000Z",
            //         "open":"0.006",
            //         "close":"0.006",
            //         "min":"0.006",
            //         "max":"0.006",
            //         "volume":"0.003",
            //         "volumeQuote":"0.000018"
            //     }
            //
            return [
                this.parse8601 (this.safeString (ohlcv, 'timestamp')),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'max'),
                this.safeNumber (ohlcv, 'min'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'volume'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'period': this.timeframes[timeframe],
            };
            if (since !== undefined) {
                request['from'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetCandlesSymbol (this.extend (request, params));
            //
            //     [
            //         {"timestamp":"2015-08-20T19:01:00.000Z","open":"0.006","close":"0.006","min":"0.006","max":"0.006","volume":"0.003","volumeQuote":"0.000018"},
            //         {"timestamp":"2015-08-20T19:03:00.000Z","open":"0.006","close":"0.006","min":"0.006","max":"0.006","volume":"0.013","volumeQuote":"0.000078"},
            //         {"timestamp":"2015-08-20T19:06:00.000Z","open":"0.0055","close":"0.005","min":"0.005","max":"0.0055","volume":"0.003","volumeQuote":"0.0000155"},
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default = 100, 0 = unlimited
            }
            const response = await this.publicGetOrderbookSymbol (this.extend (request, params));
            return this.parseOrderBook (response, symbol, undefined, 'bid', 'ask', 'price', 'size');
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.parse8601 (ticker['timestamp']);
            const symbol = this.safeSymbol (undefined, market);
            const baseVolume = this.safeNumber (ticker, 'volume');
            const quoteVolume = this.safeNumber (ticker, 'volumeQuote');
            const open = this.safeNumber (ticker, 'open');
            const last = this.safeNumber (ticker, 'last');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTicker (params);
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const ticker = response[i];
                const marketId = this.safeString (ticker, 'symbol');
                const market = this.safeMarket (marketId);
                const symbol = market['symbol'];
                result[symbol] = this.parseTicker (ticker, market);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTickerSymbol (this.extend (request, params));
            if ('message' in response) {
                throw new ExchangeError (this.id + ' ' + response['message']);
            }
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            // createMarketOrder
            //
            //  {       fee: "0.0004644",
            //           id:  386394956,
            //        price: "0.4644",
            //     quantity: "1",
            //    timestamp: "2018-10-25T16:41:44.780Z" }
            //
            // fetchTrades
            //
            // { id: 974786185,
            //   price: '0.032462',
            //   quantity: '0.3673',
            //   side: 'buy',
            //   timestamp: '2020-10-16T12:57:39.846Z' }
            //
            // fetchMyTrades
            //
            // { id: 277210397,
            //   clientOrderId: '6e102f3e7f3f4e04aeeb1cdc95592f1a',
            //   orderId: 28102855393,
            //   symbol: 'ETHBTC',
            //   side: 'sell',
            //   quantity: '0.002',
            //   price: '0.073365',
            //   fee: '0.000000147',
            //   timestamp: '2018-04-28T18:39:55.345Z' }
            const timestamp = this.parse8601 (trade['timestamp']);
            const marketId = this.safeString (trade, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = market['symbol'];
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyCode = market ? market['feeCurrency'] : undefined;
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            // we use clientOrderId as the order id with this exchange intentionally
            // because most of their endpoints will require clientOrderId
            // explained here: https://github.com/ccxt/ccxt/issues/5674
            const orderId = this.safeString (trade, 'clientOrderId');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'quantity');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const side = this.safeString (trade, 'side');
            const id = this.safeString (trade, 'id');
            return {
                'info': trade,
                'id': id,
                'order': orderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let currency = undefined;
            const request = {};
            if (code !== undefined) {
                currency = this.currency (code);
                request['asset'] = currency['id'];
            }
            if (since !== undefined) {
                request['startTime'] = since;
            }
            const response = await this.privateGetAccountTransactions (this.extend (request, params));
            return this.parseTransactions (response, currency, since, limit);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            //     {
            //         id: 'd53ee9df-89bf-4d09-886e-849f8be64647',
            //         index: 1044718371,
            //         type: 'payout',
            //         status: 'success',
            //         currency: 'ETH',
            //         amount: '4.522683200000000000000000',
            //         createdAt: '2018-06-07T00:43:32.426Z',
            //         updatedAt: '2018-06-07T00:45:36.447Z',
            //         hash: '0x973e5683dfdf80a1fb1e0b96e19085b6489221d2ddf864daa46903c5ec283a0f',
            //         address: '0xC5a59b21948C1d230c8C54f05590000Eb3e1252c',
            //         fee: '0.00958',
            //     },
            //     {
            //         id: 'e6c63331-467e-4922-9edc-019e75d20ba3',
            //         index: 1044714672,
            //         type: 'exchangeToBank',
            //         status: 'success',
            //         currency: 'ETH',
            //         amount: '4.532263200000000000',
            //         createdAt: '2018-06-07T00:42:39.543Z',
            //         updatedAt: '2018-06-07T00:42:39.683Z',
            //     },
            //     {
            //         id: '3b052faa-bf97-4636-a95c-3b5260015a10',
            //         index: 1009280164,
            //         type: 'bankToExchange',
            //         status: 'success',
            //         currency: 'CAS',
            //         amount: '104797.875800000000000000',
            //         createdAt: '2018-05-19T02:34:36.750Z',
            //         updatedAt: '2018-05-19T02:34:36.857Z',
            //     },
            //     {
            //         id: 'd525249f-7498-4c81-ba7b-b6ae2037dc08',
            //         index: 1009279948,
            //         type: 'payin',
            //         status: 'success',
            //         currency: 'CAS',
            //         amount: '104797.875800000000000000',
            //         createdAt: '2018-05-19T02:30:16.698Z',
            //         updatedAt: '2018-05-19T02:34:28.159Z',
            //         hash: '0xa6530e1231de409cf1f282196ed66533b103eac1df2aa4a7739d56b02c5f0388',
            //         address: '0xd53ed559a6d963af7cb3f3fcd0e7ca499054db8b',
            //     }
            //
            //     {
            //         "id": "4f351f4f-a8ee-4984-a468-189ed590ddbd",
            //         "index": 3112719565,
            //         "type": "withdraw",
            //         "status": "success",
            //         "currency": "BCHOLD",
            //         "amount": "0.02423133",
            //         "createdAt": "2019-07-16T16:52:04.494Z",
            //         "updatedAt": "2019-07-16T16:54:07.753Z"
            //     }
            const id = this.safeString (transaction, 'id');
            const timestamp = this.parse8601 (this.safeString (transaction, 'createdAt'));
            const updated = this.parse8601 (this.safeString (transaction, 'updatedAt'));
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const amount = this.safeNumber (transaction, 'amount');
            const address = this.safeString (transaction, 'address');
            const txid = this.safeString (transaction, 'hash');
            let fee = undefined;
            const feeCost = this.safeNumber (transaction, 'fee');
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': code,
                };
            }
            const type = this.parseTransactionType (this.safeString (transaction, 'type'));
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'tag': undefined,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'pending': 'pending',
                'failed': 'failed',
                'success': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransactionType (type) {
            const types = {
                'payin': 'deposit',
                'payout': 'withdrawal',
                'withdraw': 'withdrawal',
            };
            return this.safeString (types, type, type);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['sort'] = 'ASC';
                request['from'] = this.iso8601 (since);
            }
            const response = await this.publicGetTradesSymbol (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            // we use clientOrderId as the order id with this exchange intentionally
            // because most of their endpoints will require clientOrderId
            // explained here: https://github.com/ccxt/ccxt/issues/5674
            // their max accepted length is 32 characters
            const uuid = this.uuid ();
            const parts = uuid.split ('-');
            let clientOrderId = parts.join ('');
            clientOrderId = clientOrderId.slice (0, 32);
            amount = parseFloat (amount);
            const request = {
                'clientOrderId': clientOrderId,
                'symbol': market['id'],
                'side': side,
                'quantity': this.amountToPrecision (symbol, amount),
                'type': type,
            };
            if (type === 'limit') {
                request['price'] = this.priceToPrecision (symbol, price);
            } else {
                request['timeInForce'] = this.options['defaultTimeInForce'];
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            const order = this.parseOrder (response);
            if (order['status'] === 'rejected') {
                throw new InvalidOrder (this.id + ' order was rejected by the exchange ' + this.json (order));
            }
            return order;
        }
    
        async editOrder (id, symbol, type, side, amount = undefined, price = undefined, params = {}) {
            await this.loadMarkets ();
            // we use clientOrderId as the order id with this exchange intentionally
            // because most of their endpoints will require clientOrderId
            // explained here: https://github.com/ccxt/ccxt/issues/5674
            // their max accepted length is 32 characters
            const uuid = this.uuid ();
            const parts = uuid.split ('-');
            let requestClientId = parts.join ('');
            requestClientId = requestClientId.slice (0, 32);
            const request = {
                'clientOrderId': id,
                'requestClientId': requestClientId,
            };
            if (amount !== undefined) {
                request['quantity'] = this.amountToPrecision (symbol, amount);
            }
            if (price !== undefined) {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePatchOrderClientOrderId (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            // we use clientOrderId as the order id with this exchange intentionally
            // because most of their endpoints will require clientOrderId
            // explained here: https://github.com/ccxt/ccxt/issues/5674
            const request = {
                'clientOrderId': id,
            };
            const response = await this.privateDeleteOrderClientOrderId (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'new': 'open',
                'suspended': 'open',
                'partiallyFilled': 'open',
                'filled': 'closed',
                'canceled': 'canceled',
                'expired': 'failed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createMarketOrder
            //
            //     {
            //         clientOrderId: "fe36aa5e190149bf9985fb673bbb2ea0",
            //         createdAt: "2018-10-25T16:41:44.780Z",
            //         cumQuantity: "1",
            //         id: "66799540063",
            //         quantity: "1",
            //         side: "sell",
            //         status: "filled",
            //         symbol: "XRPUSDT",
            //         timeInForce: "FOK",
            //         tradesReport: [
            //             {
            //                 fee: "0.0004644",
            //                 id:  386394956,
            //                 price: "0.4644",
            //                 quantity: "1",
            //                 timestamp: "2018-10-25T16:41:44.780Z"
            //             }
            //         ],
            //         type: "market",
            //         updatedAt: "2018-10-25T16:41:44.780Z"
            //     }
            //
            //     {
            //         "id": 119499457455,
            //         "clientOrderId": "87baab109d58401b9202fa0749cb8288",
            //         "symbol": "ETHUSD",
            //         "side": "buy",
            //         "status": "filled",
            //         "type": "market",
            //         "timeInForce": "FOK",
            //         "quantity": "0.0007",
            //         "price": "181.487",
            //         "avgPrice": "164.989",
            //         "cumQuantity": "0.0007",
            //         "createdAt": "2019-04-17T13:27:38.062Z",
            //         "updatedAt": "2019-04-17T13:27:38.062Z"
            //     }
            //
            const created = this.parse8601 (this.safeString (order, 'createdAt'));
            const updated = this.parse8601 (this.safeString (order, 'updatedAt'));
            const marketId = this.safeString (order, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = market['symbol'];
            const amount = this.safeNumber (order, 'quantity');
            const filled = this.safeNumber (order, 'cumQuantity');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            // we use clientOrderId as the order id with this exchange intentionally
            // because most of their endpoints will require clientOrderId
            // explained here: https://github.com/ccxt/ccxt/issues/5674
            const id = this.safeString (order, 'clientOrderId');
            const clientOrderId = id;
            const price = this.safeNumber (order, 'price');
            const type = this.safeString (order, 'type');
            const side = this.safeString (order, 'side');
            let trades = this.safeValue (order, 'tradesReport');
            const fee = undefined;
            const average = this.safeNumber (order, 'avgPrice');
            if (trades !== undefined) {
                trades = this.parseTrades (trades, market);
            }
            const timeInForce = this.safeString (order, 'timeInForce');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId, // https://github.com/ccxt/ccxt/issues/5674
                'timestamp': created,
                'datetime': this.iso8601 (created),
                'lastTradeTimestamp': updated,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'average': average,
                'amount': amount,
                'cost': undefined,
                'filled': filled,
                'remaining': undefined,
                'fee': fee,
                'trades': trades,
                'info': order,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            // we use clientOrderId as the order id with this exchange intentionally
            // because most of their endpoints will require clientOrderId
            // explained here: https://github.com/ccxt/ccxt/issues/5674
            const request = {
                'clientOrderId': id,
            };
            const response = await this.privateGetHistoryOrder (this.extend (request, params));
            const numOrders = response.length;
            if (numOrders > 0) {
                return this.parseOrder (response[0]);
            }
            throw new OrderNotFound (this.id + ' order ' + id + ' not found');
        }
    
        async fetchOpenOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            // we use clientOrderId as the order id with this exchange intentionally
            // because most of their endpoints will require clientOrderId
            // explained here: https://github.com/ccxt/ccxt/issues/5674
            const request = {
                'clientOrderId': id,
            };
            const response = await this.privateGetOrderClientOrderId (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const response = await this.privateGetOrder (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                request['from'] = this.iso8601 (since);
            }
            const response = await this.privateGetHistoryOrder (this.extend (request, params));
            const parsedOrders = this.parseOrders (response, market);
            const orders = [];
            for (let i = 0; i < parsedOrders.length; i++) {
                const order = parsedOrders[i];
                const status = order['status'];
                if ((status === 'closed') || (status === 'canceled')) {
                    orders.push (order);
                }
            }
            return this.filterBySinceLimit (orders, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'symbol': 'BTC/USD', // optional
                // 'sort':   'DESC', // or 'ASC'
                // 'by':     'timestamp', // or 'id' String timestamp by default, or id
                // 'from':   'Datetime or Number', // ISO 8601
                // 'till':   'Datetime or Number',
                // 'limit':  100,
                // 'offset': 0,
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['from'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetHistoryTrades (this.extend (request, params));
            //
            //     [
            //         {
            //         "id": 9535486,
            //         "clientOrderId": "f8dbaab336d44d5ba3ff578098a68454",
            //         "orderId": 816088377,
            //         "symbol": "ETHBTC",
            //         "side": "sell",
            //         "quantity": "0.061",
            //         "price": "0.045487",
            //         "fee": "0.000002775",
            //         "timestamp": "2017-05-17T12:32:57.848Z"
            //         },
            //         {
            //         "id": 9535437,
            //         "clientOrderId": "27b9bfc068b44194b1f453c7af511ed6",
            //         "orderId": 816088021,
            //         "symbol": "ETHBTC",
            //         "side": "buy",
            //         "quantity": "0.038",
            //         "price": "0.046000",
            //         "fee": "-0.000000174",
            //         "timestamp": "2017-05-17T12:30:57.848Z"
            //         }
            //     ]
            //
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            // The id needed here is the exchange's id, and not the clientOrderID,
            // which is the id that is stored in the unified order id
            // To get the exchange's id you need to grab it from order['info']['id']
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const request = {
                'orderId': id,
            };
            const response = await this.privateGetHistoryOrderOrderIdTrades (this.extend (request, params));
            const numOrders = response.length;
            if (numOrders > 0) {
                return this.parseTrades (response, market, since, limit);
            }
            throw new OrderNotFound (this.id + ' order ' + id + ' not found, ' + this.id + '.fetchOrderTrades() requires an exchange-specific order id, you need to grab it from order["info"]["id"]');
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privatePostAccountCryptoAddressCurrency (this.extend (request, params));
            const address = this.safeString (response, 'address');
            this.checkAddress (address);
            const tag = this.safeString (response, 'paymentId');
            return {
                'currency': currency,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetAccountCryptoAddressCurrency (this.extend (request, params));
            const address = this.safeString (response, 'address');
            this.checkAddress (address);
            const tag = this.safeString (response, 'paymentId');
            return {
                'currency': currency['code'],
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            await this.loadMarkets ();
            this.checkAddress (address);
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'amount': parseFloat (amount),
                'address': address,
            };
            if (tag) {
                request['paymentId'] = tag;
            }
            const response = await this.privatePostAccountCryptoWithdraw (this.extend (request, params));
            return {
                'info': response,
                'id': response['id'],
            };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = '/api/' + this.version + '/';
            const query = this.omit (params, this.extractParams (path));
            if (api === 'public') {
                url += api + '/' + this.implodeParams (path, params);
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                url += this.implodeParams (path, params);
                if (method === 'GET') {
                    if (Object.keys (query).length) {
                        url += '?' + this.urlencode (query);
                    }
                } else if (Object.keys (query).length) {
                    body = this.json (query);
                }
                const payload = this.encode (this.apiKey + ':' + this.secret);
                const auth = this.stringToBase64 (payload);
                headers = {
                    'Authorization': 'Basic ' + this.decode (auth),
                    'Content-Type': 'application/json',
                };
            }
            url = this.urls['api'][api] + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            if (code >= 400) {
                const feedback = this.id + ' ' + body;
                // {"code":504,"message":"Gateway Timeout","description":""}
                if ((code === 503) || (code === 504)) {
                    throw new ExchangeNotAvailable (feedback);
                }
                // fallback to default error handler on rate limit errors
                // {"code":429,"message":"Too many requests","description":"Too many requests"}
                if (code === 429) {
                    return;
                }
                // {"error":{"code":20002,"message":"Order not found","description":""}}
                if (body[0] === '{') {
                    if ('error' in response) {
                        const errorCode = this.safeString (response['error'], 'code');
                        this.throwExactlyMatchedException (this.exceptions, errorCode, feedback);
                        const message = this.safeString (response['error'], 'message');
                        if (message === 'Duplicate clientOrderId') {
                            throw new InvalidOrder (feedback);
                        }
                    }
                }
                throw new ExchangeError (feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],86:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { BadRequest, AuthenticationError, NetworkError, ArgumentsRequired, OrderNotFound, InsufficientFunds } = require ('./base/errors');
    const { TICK_SIZE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class hollaex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'hollaex',
                'name': 'HollaEx',
                'countries': [ 'KR' ],
                'rateLimit': 333,
                'version': 'v2',
                'has': {
                    'CORS': false,
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createLimitBuyOrder': true,
                    'createLimitSellOrder': true,
                    'createMarketBuyOrder': true,
                    'createMarketSellOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': 'emulated',
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrder': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrderBooks': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTransactions': false,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                    'fetchDepositAddresses': true,
                },
                'timeframes': {
                    '1h': '1h',
                    '1d': '1d',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/75841031-ca375180-5ddd-11ea-8417-b975674c23cb.jpg',
                    'api': 'https://api.hollaex.com',
                    'www': 'https://hollaex.com',
                    'doc': 'https://apidocs.hollaex.com',
                    'referral': 'https://pro.hollaex.com/signup?affiliation_code=QSWA6G',
                },
                'precisionMode': TICK_SIZE,
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'health',
                            'constants',
                            'kit',
                            'tiers',
                            'ticker',
                            'tickers',
                            'orderbook',
                            'orderbooks',
                            'trades',
                            'chart',
                            'charts',
                            // TradingView
                            'udf/config',
                            'udf/history',
                            'udf/symbols',
                        ],
                    },
                    'private': {
                        'get': [
                            'user',
                            'user/balance',
                            'user/deposits',
                            'user/withdrawals',
                            'user/withdrawal/fee',
                            'user/trades',
                            'orders',
                            'orders/{order_id}',
                        ],
                        'post': [
                            'user/request-withdrawal',
                            'order',
                        ],
                        'delete': [
                            'order/all',
                            'order',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': 0.001,
                        'maker': 0.001,
                    },
                },
                'exceptions': {
                    'broad': {
                        'Invalid token': AuthenticationError,
                        'Order not found': OrderNotFound,
                        'Insufficient balance': InsufficientFunds,
                    },
                    'exact': {
                        '400': BadRequest,
                        '403': AuthenticationError,
                        '404': BadRequest,
                        '405': BadRequest,
                        '410': BadRequest,
                        '429': BadRequest,
                        '500': NetworkError,
                        '503': NetworkError,
                    },
                },
                'options': {
                    // how many seconds before the authenticated request expires
                    'api-expires': parseInt (this.timeout / 1000),
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetConstants (params);
            //
            //     {
            //         coins: {
            //             xmr: {
            //                 id: 7,
            //                 fullname: "Monero",
            //                 symbol: "xmr",
            //                 active: true,
            //                 allow_deposit: true,
            //                 allow_withdrawal: true,
            //                 withdrawal_fee: 0.02,
            //                 min: 0.001,
            //                 max: 100000,
            //                 increment_unit: 0.001,
            //                 deposit_limits: { '1': 0, '2': 0, '3': 0, '4': 0, '5': 0, '6': 0 },
            //                 withdrawal_limits: { '1': 10, '2': 15, '3': 100, '4': 100, '5': 200, '6': 300, '7': 350, '8': 400, '9': 500, '10': -1 },
            //                 created_at: "2019-12-09T07:14:02.720Z",
            //                 updated_at: "2020-01-16T12:12:53.162Z"
            //             },
            //             // ...
            //         },
            //         pairs: {
            //             'btc-usdt': {
            //                 id: 2,
            //                 name: "btc-usdt",
            //                 pair_base: "btc",
            //                 pair_2: "usdt",
            //                 taker_fees: { '1': 0.3, '2': 0.25, '3': 0.2, '4': 0.18, '5': 0.1, '6': 0.09, '7': 0.08, '8': 0.06, '9': 0.04, '10': 0 },
            //                 maker_fees: { '1': 0.1, '2': 0.08, '3': 0.05, '4': 0.03, '5': 0, '6': 0, '7': 0, '8': 0, '9': 0, '10': 0 },
            //                 min_size: 0.0001,
            //                 max_size: 1000,
            //                 min_price: 100,
            //                 max_price: 100000,
            //                 increment_size: 0.0001,
            //                 increment_price: 0.05,
            //                 active: true,
            //                 created_at: "2019-12-09T07:15:54.537Z",
            //                 updated_at: "2019-12-09T07:15:54.537Z"
            //             },
            //         },
            //         config: { tiers: 10 },
            //         status: true
            //     }
            //
            const pairs = this.safeValue (response, 'pairs', {});
            const keys = Object.keys (pairs);
            const result = [];
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const market = pairs[key];
                const id = this.safeString (market, 'name');
                const baseId = this.safeString (market, 'pair_base');
                const quoteId = this.safeString (market, 'pair_2');
                const base = this.commonCurrencyCode (baseId.toUpperCase ());
                const quote = this.commonCurrencyCode (quoteId.toUpperCase ());
                const symbol = base + '/' + quote;
                const active = this.safeValue (market, 'active');
                const maker = this.fees['trading']['maker'];
                const taker = this.fees['trading']['taker'];
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'precision': {
                        'price': this.safeNumber (market, 'increment_price'),
                        'amount': this.safeNumber (market, 'increment_size'),
                    },
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (market, 'min_size'),
                            'max': this.safeNumber (market, 'max_size'),
                        },
                        'price': {
                            'min': this.safeNumber (market, 'min_price'),
                            'max': this.safeNumber (market, 'max_price'),
                        },
                        'cost': { 'min': undefined, 'max': undefined },
                    },
                    'taker': taker,
                    'maker': maker,
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetConstants (params);
            const coins = this.safeValue (response, 'coins', {});
            const keys = Object.keys (coins);
            const result = {};
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const currency = coins[key];
                const id = this.safeString (currency, 'symbol');
                const numericId = this.safeInteger (currency, 'id');
                const code = this.safeCurrencyCode (id);
                const name = this.safeString (currency, 'fullname');
                const active = this.safeValue (currency, 'active');
                const fee = this.safeNumber (currency, 'withdrawal_fee');
                const precision = this.safeNumber (currency, 'increment_unit');
                const withdrawalLimits = this.safeValue (currency, 'withdrawal_limits', []);
                result[code] = {
                    'id': id,
                    'numericId': numericId,
                    'code': code,
                    'info': currency,
                    'name': name,
                    'active': active,
                    'fee': fee,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': this.safeNumber (currency, 'min'),
                            'max': this.safeNumber (currency, 'max'),
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': this.safeValue (withdrawalLimits, 0),
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchOrderBooks (symbols = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetOrderbooks (params);
            const result = {};
            const marketIds = Object.keys (response);
            for (let i = 0; i < marketIds.length; i++) {
                const marketId = marketIds[i];
                const orderbook = response[marketId];
                const symbol = this.safeSymbol (marketId, undefined, '-');
                const timestamp = this.parse8601 (this.safeString (orderbook, 'timestamp'));
                result[symbol] = this.parseOrderBook (response[marketId], timestamp);
            }
            return result;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const marketId = this.marketId (symbol);
            const request = {
                'symbol': marketId,
            };
            const response = await this.publicGetOrderbooks (this.extend (request, params));
            //
            //     {
            //         "btc-usdt": {
            //             "bids": [
            //                 [ 8836.4, 1.022 ],
            //                 [ 8800, 0.0668 ],
            //                 [ 8797.75, 0.2398 ],
            //             ],
            //             "asks": [
            //                 [ 8839.35, 1.5334 ],
            //                 [ 8852.6, 0.0579 ],
            //                 [ 8860.45, 0.1815 ],
            //             ],
            //             "timestamp": "2020-03-03T02:27:25.147Z"
            //         },
            //         "eth-usdt": {},
            //         // ...
            //     }
            //
            const orderbook = this.safeValue (response, marketId);
            const timestamp = this.parse8601 (this.safeString (orderbook, 'timestamp'));
            return this.parseOrderBook (orderbook, symbol, timestamp);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            //
            //     {
            //         open: 8615.55,
            //         close: 8841.05,
            //         high: 8921.1,
            //         low: 8607,
            //         last: 8841.05,
            //         volume: 20.2802,
            //         timestamp: '2020-03-03T03:11:18.964Z'
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTickers (this.extend (params));
            //
            //     {
            //         "bch-usdt": {
            //             "time": "2020-03-02T04:29:45.011Z",
            //             "open": 341.65,
            //             "close":337.9,
            //             "high":341.65,
            //             "low":337.3,
            //             "last":337.9,
            //             "volume":0.054,
            //             "symbol":"bch-usdt"
            //         },
            //         // ...
            //     }
            //
            return this.parseTickers (response, symbols);
        }
    
        parseTickers (response, symbols = undefined, params = {}) {
            const result = {};
            const keys = Object.keys (response);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const ticker = response[key];
                const marketId = this.safeString (ticker, 'symbol', key);
                const market = this.safeMarket (marketId, undefined, '-');
                const symbol = market['symbol'];
                result[symbol] = this.extend (this.parseTicker (ticker, market), params);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker
            //
            //     {
            //         open: 8615.55,
            //         close: 8841.05,
            //         high: 8921.1,
            //         low: 8607,
            //         last: 8841.05,
            //         volume: 20.2802,
            //         timestamp: '2020-03-03T03:11:18.964Z',
            //     }
            //
            // fetchTickers
            //
            //     {
            //         "time": "2020-03-02T04:29:45.011Z",
            //         "open": 341.65,
            //         "close": 337.9,
            //         "high": 341.65,
            //         "low": 337.3,
            //         "last": 337.9,
            //         "volume": 0.054,
            //         "symbol": "bch-usdt"
            //     }
            //
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '-');
            const timestamp = this.parse8601 (this.safeString2 (ticker, 'time', 'timestamp'));
            const close = this.safeNumber (ticker, 'close');
            const result = {
                'symbol': symbol,
                'info': ticker,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': this.safeNumber (ticker, 'open'),
                'close': close,
                'last': this.safeNumber (ticker, 'last', close),
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume'),
                'quoteVolume': undefined,
            };
            return result;
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTrades (this.extend (request, params));
            //
            //     {
            //         "btc-usdt": [
            //             {
            //                 "size": 0.5,
            //                 "price": 8830,
            //                 "side": "buy",
            //                 "timestamp": "2020-03-03T04:44:33.034Z"
            //             },
            //             // ...
            //         ]
            //     }
            //
            const trades = this.safeValue (response, market['id'], []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "size": 0.5,
            //         "price": 8830,
            //         "side": "buy",
            //         "timestamp": "2020-03-03T04:44:33.034Z"
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "side": "buy",
            //         "symbol": "eth-usdt",
            //         "size": 0.086,
            //         "price": 226.19,
            //         "timestamp": "2020-03-03T08:03:55.459Z",
            //         "fee": 0.1
            //     }
            //
            const marketId = this.safeString (trade, 'symbol');
            market = this.safeMarket (marketId, market, '-');
            const symbol = market['symbol'];
            const datetime = this.safeString (trade, 'timestamp');
            const timestamp = this.parse8601 (datetime);
            const side = this.safeString (trade, 'side');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'size');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const feeCost = this.safeNumber (trade, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const quote = market['quote'];
                const feeCurrencyCode = (market !== undefined) ? market['quote'] : quote;
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrencyCode,
                };
            }
            return {
                'info': trade,
                'id': undefined,
                'timestamp': timestamp,
                'datetime': datetime,
                'symbol': symbol,
                'order': undefined,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchOHLCV (symbol, timeframe = '1h', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'resolution': this.timeframes[timeframe],
            };
            const duration = this.parseTimeframe (timeframe);
            if (since === undefined) {
                if (limit === undefined) {
                    throw new ArgumentsRequired (this.id + " fetchOHLCV() requires a 'since' or a 'limit' argument");
                } else {
                    const end = this.seconds ();
                    const start = end - duration * limit;
                    request['to'] = end;
                    request['from'] = start;
                }
            } else {
                if (limit === undefined) {
                    request['from'] = parseInt (since / 1000);
                    request['to'] = this.seconds ();
                } else {
                    const start = parseInt (since / 1000);
                    request['from'] = start;
                    request['to'] = this.sum (start, duration * limit);
                }
            }
            const response = await this.publicGetChart (this.extend (request, params));
            //
            //     [
            //         {
            //             "time":"2020-03-02T20:00:00.000Z",
            //             "close":8872.1,
            //             "high":8872.1,
            //             "low":8858.6,
            //             "open":8858.6,
            //             "symbol":"btc-usdt",
            //             "volume":1.2922
            //         },
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        parseOHLCV (response, market = undefined, timeframe = '1h', since = undefined, limit = undefined) {
            //
            //     {
            //         "time":"2020-03-02T20:00:00.000Z",
            //         "close":8872.1,
            //         "high":8872.1,
            //         "low":8858.6,
            //         "open":8858.6,
            //         "symbol":"btc-usdt",
            //         "volume":1.2922
            //     }
            //
            return [
                this.parse8601 (this.safeString (response, 'time')),
                this.safeNumber (response, 'open'),
                this.safeNumber (response, 'high'),
                this.safeNumber (response, 'low'),
                this.safeNumber (response, 'close'),
                this.safeNumber (response, 'volume'),
            ];
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetUserBalance (params);
            //
            //     {
            //         "updated_at": "2020-03-02T22:27:38.428Z",
            //         "btc_balance": 0,
            //         "btc_pending": 0,
            //         "btc_available": 0,
            //         "eth_balance": 0,
            //         "eth_pending": 0,
            //         "eth_available": 0,
            //         // ...
            //     }
            //
            const timestamp = this.parse8601 (this.safeString (response, 'updated_at'));
            const result = {
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
            };
            const currencyIds = Object.keys (this.currencies_by_id);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (response, currencyId + '_available');
                account['total'] = this.safeString (response, currencyId + '_balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOpenOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privateGetOrdersOrderId (this.extend (request, params));
            //
            //     {
            //         "id": "string",
            //         "side": "sell",
            //         "symbol": "xht-usdt",
            //         "size": 0.1,
            //         "filled": 0,
            //         "stop": null,
            //         "fee": 0,
            //         "fee_coin": "usdt",
            //         "type": "limit",
            //         "price": 1.09,
            //         "status": "new",
            //         "created_by": 116,
            //         "created_at": "2021-02-17T02:32:38.910Z",
            //         "updated_at": "2021-02-17T02:32:38.910Z",
            //         "User": {
            //             "id": 116,
            //             "email": "fight@club.com",
            //             "username": "narrator",
            //             "exchange_id": 176
            //         }
            //     }
            //
            return this.parseOrder (response);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'open': true,
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': 'filled',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privateGetOrders (this.extend (request, params));
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": "string",
            //                 "side": "sell",
            //                 "symbol": "xht-usdt",
            //                 "size": 0.1,
            //                 "filled": 0,
            //                 "stop": null,
            //                 "fee": 0,
            //                 "fee_coin": "usdt",
            //                 "type": "limit",
            //                 "price": 1.09,
            //                 "status": "new",
            //                 "created_by": 116,
            //                 "created_at": "2021-02-17T02:32:38.910Z",
            //                 "updated_at": "2021-02-17T02:32:38.910Z",
            //                 "User": {
            //                     "id": 116,
            //                     "email": "fight@club.com",
            //                     "username": "narrator",
            //                     "exchange_id": 176
            //                 }
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const order = this.safeValue (data, 0);
            if (order === undefined) {
                throw new OrderNotFound (this.id + ' fetchOrder() could not find order id ' + id);
            }
            return this.parseOrder (order);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                // 'symbol': market['id'],
                // 'side': 'buy', // 'sell'
                // 'status': 'new', // 'filled', 'pfilled', 'canceled'
                // 'open': true,
                // 'limit': limit, // default 50, max 100
                // 'page': 1,
                // 'order_by': 'created_at', // id, ...
                // 'order': 'asc', // 'desc'
                // 'start_date': this.iso8601 (since),
                // 'end_date': this.iso8601 (this.milliseconds ()),
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['start_date'] = this.iso8601 (since);
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 50, max 100
            }
            const response = await this.privateGetOrders (this.extend (request, params));
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": "string",
            //                 "side": "sell",
            //                 "symbol": "xht-usdt",
            //                 "size": 0.1,
            //                 "filled": 0,
            //                 "stop": null,
            //                 "fee": 0,
            //                 "fee_coin": "usdt",
            //                 "type": "limit",
            //                 "price": 1.09,
            //                 "status": "new",
            //                 "created_by": 116,
            //                 "created_at": "2021-02-17T02:32:38.910Z",
            //                 "updated_at": "2021-02-17T02:32:38.910Z",
            //                 "User": {
            //                     "id": 116,
            //                     "email": "fight@club.com",
            //                     "username": "narrator",
            //                     "exchange_id": 176
            //                 }
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'new': 'open',
                'pfilled': 'open',
                'filled': 'closed',
                'canceled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder, fetchOpenOrder, fetchOpenOrders
            //
            //     {
            //         "id": "string",
            //         "side": "sell",
            //         "symbol": "xht-usdt",
            //         "size": 0.1,
            //         "filled": 0,
            //         "stop": null,
            //         "fee": 0,
            //         "fee_coin": "usdt",
            //         "type": "limit",
            //         "price": 1.09,
            //         "status": "new",
            //         "created_by": 116,
            //         "created_at": "2021-02-17T02:32:38.910Z",
            //         "updated_at": "2021-02-17T02:32:38.910Z",
            //         "User": {
            //             "id": 116,
            //             "email": "fight@club.com",
            //             "username": "narrator",
            //             "exchange_id": 176
            //         },
            //         "fee_structure": {
            //             "maker": 0.2,
            //             "taker": 0.2
            //         },
            //     }
            //
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '-');
            const id = this.safeString (order, 'id');
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const type = this.safeString (order, 'type');
            const side = this.safeString (order, 'side');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'size');
            const filled = this.safeNumber (order, 'filled');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'cost': undefined,
                'trades': undefined,
                'fee': undefined,
                'info': order,
                'average': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'side': side,
                'size': amount,
                'type': type,
                // 'stop': parseFloat (this.priceToPrecision (symbol, stopPrice)),
                // 'meta': {}, // other options such as post_only
            };
            if (type !== 'market') {
                request['price'] = price;
            }
            const stopPrice = this.safeFloat2 (params, 'stopPrice', 'stop');
            if (stopPrice !== undefined) {
                request['stop'] = parseFloat (this.priceToPrecision (symbol, stopPrice));
                params = this.omit (params, [ 'stopPrice', 'stop' ]);
            }
            const response = await this.privatePostOrder (this.extend (request, params));
            //
            //     {
            //         "fee": 0,
            //         "meta": {},
            //         "symbol": "xht-usdt",
            //         "side": "sell",
            //         "size": 0.1,
            //         "type": "limit",
            //         "price": 1,
            //         "fee_structure": {
            //             "maker": 0.2,
            //             "taker": 0.2
            //         },
            //         "fee_coin": "usdt",
            //         "id": "string",
            //         "created_by": 116,
            //         "filled": 0,
            //         "status": "new",
            //         "updated_at": "2021-02-17T03:03:19.231Z",
            //         "created_at": "2021-02-17T03:03:19.231Z",
            //         "stop": null
            //     }
            //
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'order_id': id,
            };
            const response = await this.privateDeleteOrder (this.extend (request, params));
            //
            //     {
            //         "title": "string",
            //         "symbol": "xht-usdt",
            //         "side": "sell",
            //         "size": 1,
            //         "type": "limit",
            //         "price": 0.1,
            //         "id": "string",
            //         "created_by": 34,
            //         "filled": 0
            //     }
            //
            return this.parseOrder (response);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const response = await this.privateDeleteOrderAll (this.extend (request, params));
            //
            //     [
            //         {
            //             "title": "string",
            //             "symbol": "xht-usdt",
            //             "side": "sell",
            //             "size": 1,
            //             "type": "limit",
            //             "price": 0.1,
            //             "id": "string",
            //             "created_by": 34,
            //             "filled": 0
            //         }
            //     ]
            //
            return this.parseOrders (response, market);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'symbol': market['id'],
                // 'limit': 50, // default 50, max 100
                // 'page': 1, // page of data to retrieve
                // 'order_by': 'timestamp', // field to order data
                // 'order': 'asc', // asc or desc
                // 'start_date': 123, // starting date of queried data
                // 'end_date': 321, // ending date of queried data
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 50, max 100
            }
            if (since !== undefined) {
                request['start_date'] = this.iso8601 (since);
            }
            const response = await this.privateGetUserTrades (this.extend (request, params));
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "side": "buy",
            //                 "symbol": "eth-usdt",
            //                 "size": 0.086,
            //                 "price": 226.19,
            //                 "timestamp": "2020-03-03T08:03:55.459Z",
            //                 "fee": 0.1
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTrades (data, market, since, limit);
        }
    
        parseDepositAddress (depositAddress, currency = undefined) {
            //
            //     {
            //         "currency":"usdt",
            //         "address":"TECLD9XBH31XpyykdHU3uEAeUK7E6Lrmik",
            //         "network":"trx",
            //         "standard":null,
            //         "is_valid":true,
            //         "created_at":"2021-05-12T02:43:05.446Z"
            //     }
            //
            let address = this.safeString (depositAddress, 'address');
            let tag = undefined;
            if (address !== undefined) {
                const parts = address.split (':');
                address = this.safeString (parts, 0);
                tag = this.safeString (parts, 1);
            }
            this.checkAddress (address);
            const currencyId = this.safeString (depositAddress, 'currency');
            currency = this.safeCurrency (currencyId, currency);
            const network = this.safeString (depositAddress, 'network');
            return {
                'currency': currency['code'],
                'address': address,
                'tag': tag,
                'network': network,
                'info': depositAddress,
            };
        }
    
        async fetchDepositAddresses (codes = undefined, params = {}) {
            await this.loadMarkets ();
            const network = this.safeString (params, 'network');
            params = this.omit (params, 'network');
            const response = await this.privateGetUser (params);
            //
            //     {
            //         "id":620,
            //         "email":"igor.kroitor@gmail.com",
            //         "full_name":"",
            //         "gender":false,
            //         "nationality":"",
            //         "dob":null,
            //         "phone_number":"",
            //         "address":{"city":"","address":"","country":"","postal_code":""},
            //         "id_data":{"note":"","type":"","number":"","status":0,"issued_date":"","expiration_date":""},
            //         "bank_account":[],
            //         "crypto_wallet":{},
            //         "verification_level":1,
            //         "email_verified":true,
            //         "otp_enabled":true,
            //         "activated":true,
            //         "username":"igor.kroitor",
            //         "affiliation_code":"QSWA6G",
            //         "settings":{
            //             "chat":{"set_username":false},
            //             "risk":{"popup_warning":false,"order_portfolio_percentage":20},
            //             "audio":{"public_trade":false,"order_completed":true,"order_partially_completed":true},
            //             "language":"en",
            //             "interface":{"theme":"white","order_book_levels":10},
            //             "notification":{"popup_order_completed":true,"popup_order_confirmation":true,"popup_order_partially_filled":true}
            //         },
            //         "affiliation_rate":0,
            //         "network_id":10620,
            //         "discount":0,
            //         "created_at":"2021-03-24T02:37:57.379Z",
            //         "updated_at":"2021-03-24T02:37:57.379Z",
            //         "balance":{
            //             "btc_balance":0,
            //             "btc_available":0,
            //             "eth_balance":0.000914,
            //             "eth_available":0.000914,
            //             "updated_at":"2020-03-04T04:03:27.174Z
            //         "},
            //         "wallet":[
            //             {"currency":"usdt","address":"TECLD9XBH31XpyykdHU3uEAeUK7E6Lrmik","network":"trx","standard":null,"is_valid":true,"created_at":"2021-05-12T02:43:05.446Z"},
            //             {"currency":"xrp","address":"rGcSzmuRx8qngPRnrvpCKkP9V4njeCPGCv:286741597","network":"xrp","standard":null,"is_valid":true,"created_at":"2021-05-12T02:49:01.273Z"}
            //         ]
            //     }
            //
            const wallet = this.safeValue (response, 'wallet', []);
            const addresses = (network === undefined) ? wallet : this.filterBy (wallet, 'network', network);
            return this.parseDepositAddresses (addresses, codes);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'currency': currency['id'],
                // 'limit': 50, // default 50, max 100
                // 'page': 1, // page of data to retrieve
                // 'order_by': 'timestamp', // field to order data
                // 'order': 'asc', // asc or desc
                // 'start_date': 123, // starting date of queried data
                // 'end_date': 321, // ending date of queried data
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 50, max 100
            }
            if (since !== undefined) {
                request['start_date'] = this.iso8601 (since);
            }
            const response = await this.privateGetUserDeposits (this.extend (request, params));
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": 539,
            //                 "amount": 20,
            //                 "fee": 0,
            //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
            //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
            //                 "status": true,
            //                 "dismissed": false,
            //                 "rejected": false,
            //                 "description": "",
            //                 "type": "deposit",
            //                 "currency": "usdt",
            //                 "created_at": "2020-03-03T07:56:36.198Z",
            //                 "updated_at": "2020-03-03T08:00:05.674Z",
            //                 "user_id": 620
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTransactions (data, currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'currency': currency['id'],
                // 'limit': 50, // default 50, max 100
                // 'page': 1, // page of data to retrieve
                // 'order_by': 'timestamp', // field to order data
                // 'order': 'asc', // asc or desc
                // 'start_date': 123, // starting date of queried data
                // 'end_date': 321, // ending date of queried data
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['limit'] = limit; // default 50, max 100
            }
            if (since !== undefined) {
                request['start_date'] = this.iso8601 (since);
            }
            const response = await this.privateGetUserWithdrawals (this.extend (request, params));
            //
            //     {
            //         "count": 1,
            //         "data": [
            //             {
            //                 "id": 539,
            //                 "amount": 20,
            //                 "fee": 0,
            //                 "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
            //                 "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
            //                 "status": true,
            //                 "dismissed": false,
            //                 "rejected": false,
            //                 "description": "",
            //                 "type": "withdrawal",
            //                 "currency": "usdt",
            //                 "created_at": "2020-03-03T07:56:36.198Z",
            //                 "updated_at": "2020-03-03T08:00:05.674Z",
            //                 "user_id": 620
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseTransactions (data, currency, since, limit);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            //     {
            //         "id": 539,
            //         "amount": 20,
            //         "fee": 0,
            //         "address": "0x5c0cc98270d7089408fcbcc8e2131287f5be2306",
            //         "transaction_id": "0xd4006327a5ec2c41adbdcf566eaaba6597c3d45906abe78ea1a4a022647c2e28",
            //         "status": true,
            //         "dismissed": false,
            //         "rejected": false,
            //         "description": "",
            //         "type": "withdrawal",
            //         "currency": "usdt",
            //         "created_at": "2020-03-03T07:56:36.198Z",
            //         "updated_at": "2020-03-03T08:00:05.674Z",
            //         "user_id": 620
            //     }
            //
            const id = this.safeString (transaction, 'id');
            const txid = this.safeString (transaction, 'transaction_id');
            const timestamp = this.parse8601 (this.safeString (transaction, 'created_at'));
            const updated = this.parse8601 (this.safeString (transaction, 'updated_at'));
            const type = this.safeString (transaction, 'type');
            const amount = this.safeNumber (transaction, 'amount');
            let address = this.safeString (transaction, 'address');
            let addressTo = undefined;
            const addressFrom = undefined;
            let tag = undefined;
            let tagTo = undefined;
            const tagFrom = undefined;
            if (address !== undefined) {
                const parts = address.split (':');
                address = this.safeString (parts, 0);
                tag = this.safeString (parts, 1);
                addressTo = address;
                tagTo = tag;
            }
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId);
            let status = this.safeValue (transaction, 'status');
            const dismissed = this.safeValue (transaction, 'dismissed');
            const rejected = this.safeValue (transaction, 'rejected');
            if (status) {
                status = 'ok';
            } else if (dismissed) {
                status = 'canceled';
            } else if (rejected) {
                status = 'failed';
            } else {
                status = 'pending';
            }
            const fee = {
                'currency': code,
                'cost': this.safeNumber (transaction, 'fee'),
            };
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'addressFrom': addressFrom,
                'address': address,
                'addressTo': addressTo,
                'tagFrom': tagFrom,
                'tag': tag,
                'tagTo': tagTo,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            if (tag !== undefined) {
                address += ':' + tag;
            }
            const request = {
                'currency': currency['id'],
                'amount': amount,
                'address': address,
            };
            // one time password
            let otp = this.safeString (params, 'otp_code');
            if ((otp !== undefined) || (this.twofa !== undefined)) {
                if (otp === undefined) {
                    otp = this.oath ();
                }
                request['otp_code'] = otp;
            }
            const response = await this.privatePostUserRequestWithdrawal (this.extend (request, params));
            return {
                'info': response,
                'id': undefined,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const query = this.omit (params, this.extractParams (path));
            path = '/' + this.version + '/' + this.implodeParams (path, params);
            if ((method === 'GET') || (method === 'DELETE')) {
                if (Object.keys (query).length) {
                    path += '?' + this.urlencode (query);
                }
            }
            const url = this.urls['api'] + path;
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const defaultExpires = this.safeInteger2 (this.options, 'api-expires', 'expires', parseInt (this.timeout / 1000));
                const expires = this.sum (this.seconds (), defaultExpires);
                const expiresString = expires.toString ();
                let auth = method + path + expiresString;
                headers = {
                    'api-key': this.encode (this.apiKey),
                    'api-expires': expiresString,
                };
                if (method === 'POST') {
                    headers['Content-type'] = 'application/json';
                    if (Object.keys (query).length) {
                        body = this.json (query);
                        auth += body;
                    }
                }
                const signature = this.hmac (this.encode (auth), this.encode (this.secret));
                headers['api-signature'] = signature;
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            if ((code >= 400) && (code <= 503)) {
                //
                //  { "message": "Invalid token" }
                //
                const feedback = this.id + ' ' + body;
                const message = this.safeString (response, 'message');
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
                const status = code.toString ();
                this.throwExactlyMatchedException (this.exceptions['exact'], status, feedback);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],87:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { AuthenticationError, ExchangeError, PermissionDenied, ExchangeNotAvailable, OnMaintenance, InvalidOrder, OrderNotFound, InsufficientFunds, ArgumentsRequired, BadSymbol, BadRequest, RequestTimeout, NetworkError } = require ('./base/errors');
    const { TRUNCATE } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class huobi extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'huobi',
                'name': 'Huobi',
                'countries': [ 'CN' ],
                'rateLimit': 100,
                'userAgent': this.userAgents['chrome39'],
                'certified': true,
                'version': 'v1',
                'accounts': undefined,
                'accountsById': undefined,
                'hostname': 'api.huobi.pro', // api.testnet.huobi.pro
                'pro': true,
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'cancelOrders': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchOrderTrades': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTradingLimits': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '60min',
                    '4h': '4hour',
                    '1d': '1day',
                    '1w': '1week',
                    '1M': '1mon',
                    '1y': '1year',
                },
                'urls': {
                    'test': {
                        'market': 'https://api.testnet.huobi.pro',
                        'public': 'https://api.testnet.huobi.pro',
                        'private': 'https://api.testnet.huobi.pro',
                    },
                    'logo': 'https://user-images.githubusercontent.com/1294454/76137448-22748a80-604e-11ea-8069-6e389271911d.jpg',
                    'api': {
                        'market': 'https://{hostname}',
                        'public': 'https://{hostname}',
                        'private': 'https://{hostname}',
                        'v2Public': 'https://{hostname}',
                        'v2Private': 'https://{hostname}',
                    },
                    'www': 'https://www.huobi.com',
                    'referral': {
                        'url': 'https://www.huobi.com/en-us/topic/double-reward/?invite_code=6rmm2223',
                        'discount': 0.15,
                    },
                    'doc': [
                        'https://huobiapi.github.io/docs/spot/v1/cn/',
                        'https://huobiapi.github.io/docs/dm/v1/cn/',
                        'https://huobiapi.github.io/docs/coin_margined_swap/v1/cn/',
                        'https://huobiapi.github.io/docs/usdt_swap/v1/cn/',
                        'https://huobiapi.github.io/docs/option/v1/cn/',
                    ],
                    'fees': 'https://www.huobi.com/about/fee/',
                },
                'api': {
                    'v2Public': {
                        'get': {
                            'reference/currencies': 1, // 币链参考信息
                            'market-status': 1, // 获取当前市场状态
                        },
                    },
                    'v2Private': {
                        'get': {
                            'account/ledger': 1,
                            'account/withdraw/quota': 1,
                            'account/withdraw/address': 1, // 提币地址查询(限母用户可用)
                            'account/deposit/address': 1,
                            'account/repayment': 5, // 还币交易记录查询
                            'reference/transact-fee-rate': 1,
                            'account/asset-valuation': 0.2, // 获取账户资产估值
                            'point/account': 5, // 点卡余额查询
                            'sub-user/user-list': 1, // 获取子用户列表
                            'sub-user/user-state': 1, // 获取特定子用户的用户状态
                            'sub-user/account-list': 1, // 获取特定子用户的账户列表
                            'sub-user/deposit-address': 1, // 子用户充币地址查询
                            'sub-user/query-deposit': 1, // 子用户充币记录查询
                            'user/api-key': 1, // 母子用户API key信息查询
                            'user/uid': 1, // 母子用户获取用户UID
                            'algo-orders/opening': 1, // 查询未触发OPEN策略委托
                            'algo-orders/history': 1, // 查询策略委托历史
                            'algo-orders/specific': 1, // 查询特定策略委托
                            'c2c/offers': 1, // 查询借入借出订单
                            'c2c/offer': 1, // 查询特定借入借出订单及其交易记录
                            'c2c/transactions': 1, // 查询借入借出交易记录
                            'c2c/repayment': 1, // 查询还币交易记录
                            'c2c/account': 1, // 查询账户余额
                            'etp/reference': 1, // 基础参考信息
                            'etp/transactions': 5, // 获取杠杆ETP申赎记录
                            'etp/transaction': 5, // 获取特定杠杆ETP申赎记录
                            'etp/rebalance': 1, // 获取杠杆ETP调仓记录
                            'etp/limit': 1, // 获取ETP持仓限额
                        },
                        'post': {
                            // 'account/transfer',
                            'account/repayment': 5, // 归还借币（全仓逐仓通用）
                            'point/transfer': 5, // 点卡划转
                            'sub-user/management': 1, // 冻结/解冻子用户
                            'sub-user/creation': 1, // 子用户创建
                            'sub-user/tradable-market': 1, // 设置子用户交易权限
                            'sub-user/transferability': 1, // 设置子用户资产转出权限
                            'sub-user/api-key-generation': 1, // 子用户API key创建
                            'sub-user/api-key-modification': 1, // 修改子用户API key
                            'sub-user/api-key-deletion': 1, // 删除子用户API key
                            'sub-user/deduct-mode': 1, // 设置子用户手续费抵扣模式
                            'algo-orders': 1, // 策略委托下单
                            'algo-orders/cancel-all-after': 1, // 自动撤销订单
                            'algo-orders/cancellation': 1, // 策略委托（触发前）撤单
                            'c2c/offer': 1, // 借入借出下单
                            'c2c/cancellation': 1, // 借入借出撤单
                            'c2c/cancel-all': 1, // 撤销所有借入借出订单
                            'c2c/repayment': 1, // 还币
                            'c2c/transfer': 1, // 资产划转
                            'etp/creation': 5, // 杠杆ETP换入
                            'etp/redemption': 5, // 杠杆ETP换出
                            'etp/{transactId}/cancel': 10, // 杠杆ETP单个撤单
                            'etp/batch-cancel': 50, // 杠杆ETP批量撤单
                        },
                    },
                    'market': {
                        'get': {
                            'history/kline': 1, // 获取K线数据
                            'detail/merged': 1, // 获取聚合行情(Ticker)
                            'depth': 1, // 获取 Market Depth 数据
                            'trade': 1, // 获取 Trade Detail 数据
                            'history/trade': 1, // 批量获取最近的交易记录
                            'detail': 1, // 获取 Market Detail 24小时成交量数据
                            'tickers': 1,
                            'etp': 1, // 获取杠杆ETP实时净值
                        },
                    },
                    'public': {
                        'get': {
                            'common/symbols': 1, // 查询系统支持的所有交易对
                            'common/currencys': 1, // 查询系统支持的所有币种
                            'common/timestamp': 1, // 查询系统当前时间
                            'common/exchange': 1, // order limits
                            'settings/currencys': 1, // ?language=en-US
                        },
                    },
                    'private': {
                        'get': {
                            'account/accounts': 0.2, // 查询当前用户的所有账户(即account-id)
                            'account/accounts/{id}/balance': 0.2, // 查询指定账户的余额
                            'account/accounts/{sub-uid}': 1,
                            'account/history': 4,
                            'cross-margin/loan-info': 1,
                            'margin/loan-info': 1, // 查询借币币息率及额度
                            'fee/fee-rate/get': 1,
                            'order/openOrders': 0.4,
                            'order/orders': 0.4,
                            'order/orders/{id}': 0.4, // 查询某个订单详情
                            'order/orders/{id}/matchresults': 0.4, // 查询某个订单的成交明细
                            'order/orders/getClientOrder': 0.4,
                            'order/history': 1, // 查询当前委托、历史委托
                            'order/matchresults': 1, // 查询当前成交、历史成交
                            // 'dw/withdraw-virtual/addresses', // 查询虚拟币提现地址（Deprecated）
                            'query/deposit-withdraw': 1,
                            // 'margin/loan-info', // duplicate
                            'margin/loan-orders': 0.2, // 借贷订单
                            'margin/accounts/balance': 0.2, // 借贷账户详情
                            'cross-margin/loan-orders': 1, // 查询借币订单
                            'cross-margin/accounts/balance': 1, // 借币账户详情
                            'points/actions': 1,
                            'points/orders': 1,
                            'subuser/aggregate-balance': 10,
                            'stable-coin/exchange_rate': 1,
                            'stable-coin/quote': 1,
                        },
                        'post': {
                            'account/transfer': 1, // 资产划转(该节点为母用户和子用户进行资产划转的通用接口。)
                            'futures/transfer': 1,
                            'order/batch-orders': 0.4,
                            'order/orders/place': 0.2, // 创建并执行一个新订单 (一步下单， 推荐使用)
                            'order/orders/submitCancelClientOrder': 0.2,
                            'order/orders/batchCancelOpenOrders': 0.4,
                            // 'order/orders', // 创建一个新的订单请求 （仅创建订单，不执行下单）
                            // 'order/orders/{id}/place', // 执行一个订单 （仅执行已创建的订单）
                            'order/orders/{id}/submitcancel': 0.2, // 申请撤销一个订单请求
                            'order/orders/batchcancel': 0.4, // 批量撤销订单
                            // 'dw/balance/transfer', // 资产划转
                            'dw/withdraw/api/create': 1, // 申请提现虚拟币
                            // 'dw/withdraw-virtual/create', // 申请提现虚拟币
                            // 'dw/withdraw-virtual/{id}/place', // 确认申请虚拟币提现（Deprecated）
                            'dw/withdraw-virtual/{id}/cancel': 1, // 申请取消提现虚拟币
                            'dw/transfer-in/margin': 10, // 现货账户划入至借贷账户
                            'dw/transfer-out/margin': 10, // 借贷账户划出至现货账户
                            'margin/orders': 10, // 申请借贷
                            'margin/orders/{id}/repay': 10, // 归还借贷
                            'cross-margin/transfer-in': 1, // 资产划转
                            'cross-margin/transfer-out': 1, // 资产划转
                            'cross-margin/orders': 1, // 申请借币
                            'cross-margin/orders/{id}/repay': 1, // 归还借币
                            'stable-coin/exchange': 1,
                            'subuser/transfer': 10,
                        },
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'tierBased': false,
                        'percentage': true,
                        'maker': this.parseNumber ('0.002'),
                        'taker': this.parseNumber ('0.002'),
                    },
                },
                'exceptions': {
                    'broad': {
                        'contract is restricted of closing positions on API.  Please contact customer service': OnMaintenance,
                        'maintain': OnMaintenance,
                    },
                    'exact': {
                        // err-code
                        'bad-request': BadRequest,
                        'base-date-limit-error': BadRequest, // {"status":"error","err-code":"base-date-limit-error","err-msg":"date less than system limit","data":null}
                        'api-not-support-temp-addr': PermissionDenied, // {"status":"error","err-code":"api-not-support-temp-addr","err-msg":"API withdrawal does not support temporary addresses","data":null}
                        'timeout': RequestTimeout, // {"ts":1571653730865,"status":"error","err-code":"timeout","err-msg":"Request Timeout"}
                        'gateway-internal-error': ExchangeNotAvailable, // {"status":"error","err-code":"gateway-internal-error","err-msg":"Failed to load data. Try again later.","data":null}
                        'account-frozen-balance-insufficient-error': InsufficientFunds, // {"status":"error","err-code":"account-frozen-balance-insufficient-error","err-msg":"trade account balance is not enough, left: `0.0027`","data":null}
                        'invalid-amount': InvalidOrder, // eg "Paramemter `amount` is invalid."
                        'order-limitorder-amount-min-error': InvalidOrder, // limit order amount error, min: `0.001`
                        'order-limitorder-amount-max-error': InvalidOrder, // market order amount error, max: `1000000`
                        'order-marketorder-amount-min-error': InvalidOrder, // market order amount error, min: `0.01`
                        'order-limitorder-price-min-error': InvalidOrder, // limit order price error
                        'order-limitorder-price-max-error': InvalidOrder, // limit order price error
                        'order-holding-limit-failed': InvalidOrder, // {"status":"error","err-code":"order-holding-limit-failed","err-msg":"Order failed, exceeded the holding limit of this currency","data":null}
                        'order-orderprice-precision-error': InvalidOrder, // {"status":"error","err-code":"order-orderprice-precision-error","err-msg":"order price precision error, scale: `4`","data":null}
                        'order-etp-nav-price-max-error': InvalidOrder, // {"status":"error","err-code":"order-etp-nav-price-max-error","err-msg":"Order price cannot be higher than 5% of NAV","data":null}
                        'order-orderstate-error': OrderNotFound, // canceling an already canceled order
                        'order-queryorder-invalid': OrderNotFound, // querying a non-existent order
                        'order-update-error': ExchangeNotAvailable, // undocumented error
                        'api-signature-check-failed': AuthenticationError,
                        'api-signature-not-valid': AuthenticationError, // {"status":"error","err-code":"api-signature-not-valid","err-msg":"Signature not valid: Incorrect Access key [Access key错误]","data":null}
                        'base-record-invalid': OrderNotFound, // https://github.com/ccxt/ccxt/issues/5750
                        'base-symbol-trade-disabled': BadSymbol, // {"status":"error","err-code":"base-symbol-trade-disabled","err-msg":"Trading is disabled for this symbol","data":null}
                        'base-symbol-error': BadSymbol, // {"status":"error","err-code":"base-symbol-error","err-msg":"The symbol is invalid","data":null}
                        'system-maintenance': OnMaintenance, // {"status": "error", "err-code": "system-maintenance", "err-msg": "System is in maintenance!", "data": null}
                        // err-msg
                        'invalid symbol': BadSymbol, // {"ts":1568813334794,"status":"error","err-code":"invalid-parameter","err-msg":"invalid symbol"}
                        'symbol trade not open now': BadSymbol, // {"ts":1576210479343,"status":"error","err-code":"invalid-parameter","err-msg":"symbol trade not open now"}
                    },
                },
                'options': {
                    // https://github.com/ccxt/ccxt/issues/5376
                    'fetchOrdersByStatesMethod': 'private_get_order_orders', // 'private_get_order_history' // https://github.com/ccxt/ccxt/pull/5392
                    'fetchOpenOrdersMethod': 'fetch_open_orders_v1', // 'fetch_open_orders_v2' // https://github.com/ccxt/ccxt/issues/5388
                    'createMarketBuyOrderRequiresPrice': true,
                    'fetchMarketsMethod': 'publicGetCommonSymbols',
                    'fetchBalanceMethod': 'privateGetAccountAccountsIdBalance',
                    'createOrderMethod': 'privatePostOrderOrdersPlace',
                    'language': 'en-US',
                    'broker': {
                        'id': 'AA03022abc',
                    },
                },
                'commonCurrencies': {
                    // https://github.com/ccxt/ccxt/issues/6081
                    // https://github.com/ccxt/ccxt/issues/3365
                    // https://github.com/ccxt/ccxt/issues/2873
                    'GET': 'Themis', // conflict with GET (Guaranteed Entrance Token, GET Protocol)
                    'GTC': 'Game.com', // conflict with Gitcoin and Gastrocoin
                    'HIT': 'HitChain',
                    'HOT': 'Hydro Protocol', // conflict with HOT (Holo) https://github.com/ccxt/ccxt/issues/4929
                    // https://github.com/ccxt/ccxt/issues/7399
                    // https://coinmarketcap.com/currencies/pnetwork/
                    // https://coinmarketcap.com/currencies/penta/markets/
                    // https://en.cryptonomist.ch/blog/eidoo/the-edo-to-pnt-upgrade-what-you-need-to-know-updated/
                    'PNT': 'Penta',
                    'SBTC': 'Super Bitcoin',
                    'BIFI': 'Bitcoin File', // conflict with Beefy.Finance https://github.com/ccxt/ccxt/issues/8706
                },
            });
        }
    
        async fetchTradingLimits (symbols = undefined, params = {}) {
            // this method should not be called directly, use loadTradingLimits () instead
            //  by default it will try load withdrawal fees of all currencies (with separate requests)
            //  however if you define symbols = [ 'ETH/BTC', 'LTC/BTC' ] in args it will only load those
            await this.loadMarkets ();
            if (symbols === undefined) {
                symbols = this.symbols;
            }
            const result = {};
            for (let i = 0; i < symbols.length; i++) {
                const symbol = symbols[i];
                result[symbol] = await this.fetchTradingLimitsById (this.marketId (symbol), params);
            }
            return result;
        }
    
        async fetchTradingLimitsById (id, params = {}) {
            const request = {
                'symbol': id,
            };
            const response = await this.publicGetCommonExchange (this.extend (request, params));
            //
            //     { status:   "ok",
            //         data: {                                  symbol: "aidocbtc",
            //                              'buy-limit-must-less-than':  1.1,
            //                          'sell-limit-must-greater-than':  0.9,
            //                         'limit-order-must-greater-than':  1,
            //                            'limit-order-must-less-than':  5000000,
            //                    'market-buy-order-must-greater-than':  0.0001,
            //                       'market-buy-order-must-less-than':  100,
            //                   'market-sell-order-must-greater-than':  1,
            //                      'market-sell-order-must-less-than':  500000,
            //                       'circuit-break-when-greater-than':  10000,
            //                          'circuit-break-when-less-than':  10,
            //                 'market-sell-order-rate-must-less-than':  0.1,
            //                  'market-buy-order-rate-must-less-than':  0.1        } }
            //
            return this.parseTradingLimits (this.safeValue (response, 'data', {}));
        }
    
        parseTradingLimits (limits, symbol = undefined, params = {}) {
            //
            //   {                                  symbol: "aidocbtc",
            //                  'buy-limit-must-less-than':  1.1,
            //              'sell-limit-must-greater-than':  0.9,
            //             'limit-order-must-greater-than':  1,
            //                'limit-order-must-less-than':  5000000,
            //        'market-buy-order-must-greater-than':  0.0001,
            //           'market-buy-order-must-less-than':  100,
            //       'market-sell-order-must-greater-than':  1,
            //          'market-sell-order-must-less-than':  500000,
            //           'circuit-break-when-greater-than':  10000,
            //              'circuit-break-when-less-than':  10,
            //     'market-sell-order-rate-must-less-than':  0.1,
            //      'market-buy-order-rate-must-less-than':  0.1        }
            //
            return {
                'info': limits,
                'limits': {
                    'amount': {
                        'min': this.safeNumber (limits, 'limit-order-must-greater-than'),
                        'max': this.safeNumber (limits, 'limit-order-must-less-than'),
                    },
                },
            };
        }
    
        costToPrecision (symbol, cost) {
            return this.decimalToPrecision (cost, TRUNCATE, this.markets[symbol]['precision']['cost'], this.precisionMode);
        }
    
        async fetchMarkets (params = {}) {
            const method = this.options['fetchMarketsMethod'];
            const response = await this[method] (params);
            const markets = this.safeValue (response, 'data');
            const numMarkets = markets.length;
            if (numMarkets < 1) {
                throw new NetworkError (this.id + ' publicGetCommonSymbols returned empty response: ' + this.json (markets));
            }
            const result = [];
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const baseId = this.safeString (market, 'base-currency');
                const quoteId = this.safeString (market, 'quote-currency');
                const id = baseId + quoteId;
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeInteger (market, 'amount-precision'),
                    'price': this.safeInteger (market, 'price-precision'),
                    'cost': this.safeInteger (market, 'value-precision'),
                };
                const maker = (base === 'OMG') ? 0 : 0.2 / 100;
                const taker = (base === 'OMG') ? 0 : 0.2 / 100;
                const minAmount = this.safeNumber (market, 'min-order-amt', Math.pow (10, -precision['amount']));
                const maxAmount = this.safeNumber (market, 'max-order-amt');
                const minCost = this.safeNumber (market, 'min-order-value', 0);
                const state = this.safeString (market, 'state');
                const active = (state === 'online');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'precision': precision,
                    'taker': taker,
                    'maker': maker,
                    'limits': {
                        'amount': {
                            'min': minAmount,
                            'max': maxAmount,
                        },
                        'price': {
                            'min': Math.pow (10, -precision['price']),
                            'max': undefined,
                        },
                        'cost': {
                            'min': minCost,
                            'max': undefined,
                        },
                    },
                    'info': market,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            //
            // fetchTicker
            //
            //     {
            //         "amount": 26228.672978342216,
            //         "open": 9078.95,
            //         "close": 9146.86,
            //         "high": 9155.41,
            //         "id": 209988544334,
            //         "count": 265846,
            //         "low": 8988.0,
            //         "version": 209988544334,
            //         "ask": [ 9146.87, 0.156134 ],
            //         "vol": 2.3822168242201668E8,
            //         "bid": [ 9146.86, 0.080758 ],
            //     }
            //
            // fetchTickers
            //     {
            //         symbol: "bhdht",
            //         open:  2.3938,
            //         high:  2.4151,
            //         low:  2.3323,
            //         close:  2.3909,
            //         amount:  628.992,
            //         vol:  1493.71841095,
            //         count:  2088,
            //         bid:  2.3643,
            //         bidSize:  0.7136,
            //         ask:  2.4061,
            //         askSize:  0.4156
            //     }
            //
            const symbol = this.safeSymbol (undefined, market);
            const timestamp = this.safeInteger (ticker, 'ts');
            let bid = undefined;
            let bidVolume = undefined;
            let ask = undefined;
            let askVolume = undefined;
            if ('bid' in ticker) {
                if (Array.isArray (ticker['bid'])) {
                    bid = this.safeNumber (ticker['bid'], 0);
                    bidVolume = this.safeNumber (ticker['bid'], 1);
                } else {
                    bid = this.safeNumber (ticker, 'bid');
                    bidVolume = this.safeValue (ticker, 'bidSize');
                }
            }
            if ('ask' in ticker) {
                if (Array.isArray (ticker['ask'])) {
                    ask = this.safeNumber (ticker['ask'], 0);
                    askVolume = this.safeNumber (ticker['ask'], 1);
                } else {
                    ask = this.safeNumber (ticker, 'ask');
                    askVolume = this.safeValue (ticker, 'askSize');
                }
            }
            const open = this.safeNumber (ticker, 'open');
            const close = this.safeNumber (ticker, 'close');
            const baseVolume = this.safeNumber (ticker, 'amount');
            const quoteVolume = this.safeNumber (ticker, 'vol');
            const vwap = this.vwap (baseVolume, quoteVolume);
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': bid,
                'bidVolume': bidVolume,
                'ask': ask,
                'askVolume': askVolume,
                'vwap': vwap,
                'open': open,
                'close': close,
                'last': close,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            }, market);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'type': 'step0',
            };
            const response = await this.marketGetDepth (this.extend (request, params));
            //
            //     {
            //         "status": "ok",
            //         "ch": "market.btcusdt.depth.step0",
            //         "ts": 1583474832790,
            //         "tick": {
            //             "bids": [
            //                 [ 9100.290000000000000000, 0.200000000000000000 ],
            //                 [ 9099.820000000000000000, 0.200000000000000000 ],
            //                 [ 9099.610000000000000000, 0.205000000000000000 ],
            //             ],
            //             "asks": [
            //                 [ 9100.640000000000000000, 0.005904000000000000 ],
            //                 [ 9101.010000000000000000, 0.287311000000000000 ],
            //                 [ 9101.030000000000000000, 0.012121000000000000 ],
            //             ],
            //             "ts":1583474832008,
            //             "version":104999698780
            //         }
            //     }
            //
            if ('tick' in response) {
                if (!response['tick']) {
                    throw new BadSymbol (this.id + ' fetchOrderBook() returned empty response: ' + this.json (response));
                }
                const tick = this.safeValue (response, 'tick');
                const timestamp = this.safeInteger (tick, 'ts', this.safeInteger (response, 'ts'));
                const result = this.parseOrderBook (tick, symbol, timestamp);
                result['nonce'] = this.safeInteger (tick, 'version');
                return result;
            }
            throw new ExchangeError (this.id + ' fetchOrderBook() returned unrecognized response: ' + this.json (response));
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.marketGetDetailMerged (this.extend (request, params));
            //
            //     {
            //         "status": "ok",
            //         "ch": "market.btcusdt.detail.merged",
            //         "ts": 1583494336669,
            //         "tick": {
            //             "amount": 26228.672978342216,
            //             "open": 9078.95,
            //             "close": 9146.86,
            //             "high": 9155.41,
            //             "id": 209988544334,
            //             "count": 265846,
            //             "low": 8988.0,
            //             "version": 209988544334,
            //             "ask": [ 9146.87, 0.156134 ],
            //             "vol": 2.3822168242201668E8,
            //             "bid": [ 9146.86, 0.080758 ],
            //         }
            //     }
            //
            const ticker = this.parseTicker (response['tick'], market);
            const timestamp = this.safeInteger (response, 'ts');
            ticker['timestamp'] = timestamp;
            ticker['datetime'] = this.iso8601 (timestamp);
            return ticker;
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.marketGetTickers (params);
            const tickers = this.safeValue (response, 'data');
            const timestamp = this.safeInteger (response, 'ts');
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const marketId = this.safeString (tickers[i], 'symbol');
                const market = this.safeMarket (marketId);
                const symbol = market['symbol'];
                const ticker = this.parseTicker (tickers[i], market);
                ticker['timestamp'] = timestamp;
                ticker['datetime'] = this.iso8601 (timestamp);
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "amount": 0.010411000000000000,
            //         "trade-id": 102090736910,
            //         "ts": 1583497692182,
            //         "id": 10500517034273194594947,
            //         "price": 9096.050000000000000000,
            //         "direction": "sell"
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //          'symbol': 'swftcbtc',
            //          'fee-currency': 'swftc',
            //          'filled-fees': '0',
            //          'source': 'spot-api',
            //          'id': 83789509854000,
            //          'type': 'buy-limit',
            //          'order-id': 83711103204909,
            //          'filled-points': '0.005826843283532154',
            //          'fee-deduct-currency': 'ht',
            //          'filled-amount': '45941.53',
            //          'price': '0.0000001401',
            //          'created-at': 1597933260729,
            //          'match-id': 100087455560,
            //          'role': 'maker',
            //          'trade-id': 100050305348
            //     },
            //
            const marketId = this.safeString (trade, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.safeInteger2 (trade, 'ts', 'created-at');
            const order = this.safeString (trade, 'order-id');
            let side = this.safeString (trade, 'direction');
            let type = this.safeString (trade, 'type');
            if (type !== undefined) {
                const typeParts = type.split ('-');
                side = typeParts[0];
                type = typeParts[1];
            }
            const takerOrMaker = this.safeString (trade, 'role');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString2 (trade, 'filled-amount', 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let fee = undefined;
            let feeCost = this.safeNumber (trade, 'filled-fees');
            let feeCurrency = this.safeCurrencyCode (this.safeString (trade, 'fee-currency'));
            const filledPoints = this.safeNumber (trade, 'filled-points');
            if (filledPoints !== undefined) {
                if ((feeCost === undefined) || (feeCost === 0.0)) {
                    feeCost = filledPoints;
                    feeCurrency = this.safeCurrencyCode (this.safeString (trade, 'fee-deduct-currency'));
                }
            }
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
            }
            const tradeId = this.safeString2 (trade, 'trade-id', 'tradeId');
            const id = this.safeString (trade, 'id', tradeId);
            return {
                'id': id,
                'info': trade,
                'order': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privateGetOrderOrdersIdMatchresults (this.extend (request, params));
            return this.parseTrades (response['data'], undefined, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (limit !== undefined) {
                request['size'] = limit; // 1-100 orders, default is 100
            }
            if (since !== undefined) {
                request['start-date'] = this.ymd (since); // a date within 61 days from today
                request['end-date'] = this.ymd (this.sum (since, 86400000));
            }
            const response = await this.privateGetOrderMatchresults (this.extend (request, params));
            return this.parseTrades (response['data'], market, since, limit);
        }
    
        async fetchTrades (symbol, since = undefined, limit = 1000, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['size'] = limit;
            }
            const response = await this.marketGetHistoryTrade (this.extend (request, params));
            //
            //     {
            //         "status": "ok",
            //         "ch": "market.btcusdt.trade.detail",
            //         "ts": 1583497692365,
            //         "data": [
            //             {
            //                 "id": 105005170342,
            //                 "ts": 1583497692182,
            //                 "data": [
            //                     {
            //                         "amount": 0.010411000000000000,
            //                         "trade-id": 102090736910,
            //                         "ts": 1583497692182,
            //                         "id": 10500517034273194594947,
            //                         "price": 9096.050000000000000000,
            //                         "direction": "sell"
            //                     }
            //                 ]
            //             },
            //             // ...
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data');
            let result = [];
            for (let i = 0; i < data.length; i++) {
                const trades = this.safeValue (data[i], 'data', []);
                for (let j = 0; j < trades.length; j++) {
                    const trade = this.parseTrade (trades[j], market);
                    result.push (trade);
                }
            }
            result = this.sortBy (result, 'timestamp');
            return this.filterBySymbolSinceLimit (result, symbol, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     {
            //         "amount":1.2082,
            //         "open":0.025096,
            //         "close":0.025095,
            //         "high":0.025096,
            //         "id":1591515300,
            //         "count":6,
            //         "low":0.025095,
            //         "vol":0.0303205097
            //     }
            //
            return [
                this.safeTimestamp (ohlcv, 'id'),
                this.safeNumber (ohlcv, 'open'),
                this.safeNumber (ohlcv, 'high'),
                this.safeNumber (ohlcv, 'low'),
                this.safeNumber (ohlcv, 'close'),
                this.safeNumber (ohlcv, 'amount'),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = 1000, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'period': this.timeframes[timeframe],
            };
            if (limit !== undefined) {
                request['size'] = limit;
            }
            const response = await this.marketGetHistoryKline (this.extend (request, params));
            //
            //     {
            //         "status":"ok",
            //         "ch":"market.ethbtc.kline.1min",
            //         "ts":1591515374371,
            //         "data":[
            //             {"amount":0.0,"open":0.025095,"close":0.025095,"high":0.025095,"id":1591515360,"count":0,"low":0.025095,"vol":0.0},
            //             {"amount":1.2082,"open":0.025096,"close":0.025095,"high":0.025096,"id":1591515300,"count":6,"low":0.025095,"vol":0.0303205097},
            //             {"amount":0.0648,"open":0.025096,"close":0.025096,"high":0.025096,"id":1591515240,"count":2,"low":0.025096,"vol":0.0016262208},
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async fetchAccounts (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccountAccounts (params);
            return response['data'];
        }
    
        async fetchCurrencies (params = {}) {
            const request = {
                'language': this.options['language'],
            };
            const response = await this.publicGetSettingsCurrencys (this.extend (request, params));
            const currencies = this.safeValue (response, 'data');
            const result = {};
            for (let i = 0; i < currencies.length; i++) {
                const currency = currencies[i];
                //
                //  {                     name: "ctxc",
                //              'display-name': "CTXC",
                //        'withdraw-precision':  8,
                //             'currency-type': "eth",
                //        'currency-partition': "pro",
                //             'support-sites':  null,
                //                'otc-enable':  0,
                //        'deposit-min-amount': "2",
                //       'withdraw-min-amount': "4",
                //            'show-precision': "8",
                //                      weight: "2988",
                //                     visible:  true,
                //              'deposit-desc': "Please don’t deposit any other digital assets except CTXC t…",
                //             'withdraw-desc': "Minimum withdrawal amount: 4 CTXC. !>_<!For security reason…",
                //           'deposit-enabled':  true,
                //          'withdraw-enabled':  true,
                //    'currency-addr-with-tag':  false,
                //             'fast-confirms':  15,
                //             'safe-confirms':  30                                                             }
                //
                const id = this.safeValue (currency, 'name');
                const precision = this.safeInteger (currency, 'withdraw-precision');
                const code = this.safeCurrencyCode (id);
                const active = currency['visible'] && currency['deposit-enabled'] && currency['withdraw-enabled'];
                const name = this.safeString (currency, 'display-name');
                result[code] = {
                    'id': id,
                    'code': code,
                    'type': 'crypto',
                    // 'payin': currency['deposit-enabled'],
                    // 'payout': currency['withdraw-enabled'],
                    // 'transfer': undefined,
                    'name': name,
                    'active': active,
                    'fee': undefined, // todo need to fetch from fee endpoint
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision),
                            'max': Math.pow (10, precision),
                        },
                        'deposit': {
                            'min': this.safeNumber (currency, 'deposit-min-amount'),
                            'max': Math.pow (10, precision),
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'withdraw-min-amount'),
                            'max': Math.pow (10, precision),
                        },
                    },
                    'info': currency,
                };
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const method = this.options['fetchBalanceMethod'];
            const request = {
                'id': this.accounts[0]['id'],
            };
            const response = await this[method] (this.extend (request, params));
            const balances = this.safeValue (response['data'], 'list', []);
            const result = { 'info': response };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                let account = undefined;
                if (code in result) {
                    account = result[code];
                } else {
                    account = this.account ();
                }
                if (balance['type'] === 'trade') {
                    account['free'] = this.safeString (balance, 'balance');
                }
                if (balance['type'] === 'frozen') {
                    account['used'] = this.safeString (balance, 'balance');
                }
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrdersByStates (states, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'states': states,
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const method = this.safeString (this.options, 'fetchOrdersByStatesMethod', 'private_get_order_orders');
            const response = await this[method] (this.extend (request, params));
            //
            //     { status:   "ok",
            //         data: [ {                  id:  13997833014,
            //                                symbol: "ethbtc",
            //                          'account-id':  3398321,
            //                                amount: "0.045000000000000000",
            //                                 price: "0.034014000000000000",
            //                          'created-at':  1545836976871,
            //                                  type: "sell-limit",
            //                        'field-amount': "0.045000000000000000",
            //                   'field-cash-amount': "0.001530630000000000",
            //                          'field-fees': "0.000003061260000000",
            //                         'finished-at':  1545837948214,
            //                                source: "spot-api",
            //                                 state: "filled",
            //                         'canceled-at':  0                      }  ] }
            //
            return this.parseOrders (response['data'], market, since, limit);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privateGetOrderOrdersId (this.extend (request, params));
            const order = this.safeValue (response, 'data');
            return this.parseOrder (order);
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStates ('pre-submitted,submitted,partial-filled,filled,partial-canceled,canceled', symbol, since, limit, params);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const method = this.safeString (this.options, 'fetchOpenOrdersMethod', 'fetch_open_orders_v1');
            return await this[method] (symbol, since, limit, params);
        }
    
        async fetchOpenOrdersV1 (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrdersV1() requires a symbol argument');
            }
            return await this.fetchOrdersByStates ('pre-submitted,submitted,partial-filled', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStates ('filled,partial-canceled,canceled', symbol, since, limit, params);
        }
    
        async fetchOpenOrdersV2 (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            let accountId = this.safeString (params, 'account-id');
            if (accountId === undefined) {
                // pick the first account
                await this.loadAccounts ();
                for (let i = 0; i < this.accounts.length; i++) {
                    const account = this.accounts[i];
                    if (account['type'] === 'spot') {
                        accountId = this.safeString (account, 'id');
                        if (accountId !== undefined) {
                            break;
                        }
                    }
                }
            }
            request['account-id'] = accountId;
            if (limit !== undefined) {
                request['size'] = limit;
            }
            const omitted = this.omit (params, 'account-id');
            const response = await this.privateGetOrderOpenOrders (this.extend (request, omitted));
            //
            //     {
            //         "status":"ok",
            //         "data":[
            //             {
            //                 "symbol":"ethusdt",
            //                 "source":"api",
            //                 "amount":"0.010000000000000000",
            //                 "account-id":1528640,
            //                 "created-at":1561597491963,
            //                 "price":"400.000000000000000000",
            //                 "filled-amount":"0.0",
            //                 "filled-cash-amount":"0.0",
            //                 "filled-fees":"0.0",
            //                 "id":38477101630,
            //                 "state":"submitted",
            //                 "type":"sell-limit"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'partial-filled': 'open',
                'partial-canceled': 'canceled',
                'filled': 'closed',
                'canceled': 'canceled',
                'submitted': 'open',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {                  id:  13997833014,
            //                    symbol: "ethbtc",
            //              'account-id':  3398321,
            //                    amount: "0.045000000000000000",
            //                     price: "0.034014000000000000",
            //              'created-at':  1545836976871,
            //                      type: "sell-limit",
            //            'field-amount': "0.045000000000000000", // they have fixed it for filled-amount
            //       'field-cash-amount': "0.001530630000000000", // they have fixed it for filled-cash-amount
            //              'field-fees': "0.000003061260000000", // they have fixed it for filled-fees
            //             'finished-at':  1545837948214,
            //                    source: "spot-api",
            //                     state: "filled",
            //             'canceled-at':  0                      }
            //
            //     {                  id:  20395337822,
            //                    symbol: "ethbtc",
            //              'account-id':  5685075,
            //                    amount: "0.001000000000000000",
            //                     price: "0.0",
            //              'created-at':  1545831584023,
            //                      type: "buy-market",
            //            'field-amount': "0.029100000000000000", // they have fixed it for filled-amount
            //       'field-cash-amount': "0.000999788700000000", // they have fixed it for filled-cash-amount
            //              'field-fees': "0.000058200000000000", // they have fixed it for filled-fees
            //             'finished-at':  1545831584181,
            //                    source: "spot-api",
            //                     state: "filled",
            //             'canceled-at':  0                      }
            //
            const id = this.safeString (order, 'id');
            let side = undefined;
            let type = undefined;
            let status = undefined;
            if ('type' in order) {
                const orderType = order['type'].split ('-');
                side = orderType[0];
                type = orderType[1];
                status = this.parseOrderStatus (this.safeString (order, 'state'));
            }
            const marketId = this.safeString (order, 'symbol');
            market = this.safeMarket (marketId, market);
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.safeInteger (order, 'created-at');
            const clientOrderId = this.safeString (order, 'client-order-id');
            const amount = this.safeNumber (order, 'amount');
            const filled = this.safeNumber2 (order, 'filled-amount', 'field-amount'); // typo in their API, filled amount
            let price = this.safeNumber (order, 'price');
            if (price === 0.0) {
                price = undefined;
            }
            const cost = this.safeNumber2 (order, 'filled-cash-amount', 'field-cash-amount'); // same typo
            const feeCost = this.safeNumber2 (order, 'filled-fees', 'field-fees'); // typo in their API, filled fees
            let fee = undefined;
            if (feeCost !== undefined) {
                let feeCurrency = undefined;
                if (market !== undefined) {
                    feeCurrency = (side === 'sell') ? market['quote'] : market['base'];
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                };
            }
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'average': undefined,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            await this.loadAccounts ();
            const market = this.market (symbol);
            const request = {
                'account-id': this.accounts[0]['id'],
                'symbol': market['id'],
                'type': side + '-' + type,
            };
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client-order-id'); // must be 64 chars max and unique within 24 hours
            if (clientOrderId === undefined) {
                const broker = this.safeValue (this.options, 'broker', {});
                const brokerId = this.safeString (broker, 'id');
                request['client-order-id'] = brokerId + this.uuid ();
            } else {
                request['client-order-id'] = clientOrderId;
            }
            params = this.omit (params, [ 'clientOrderId', 'client-order-id' ]);
            if ((type === 'market') && (side === 'buy')) {
                if (this.options['createMarketBuyOrderRequiresPrice']) {
                    if (price === undefined) {
                        throw new InvalidOrder (this.id + " market buy order requires price argument to calculate cost (total amount of quote currency to spend for buying, amount * price). To switch off this warning exception and specify cost in the amount argument, set .options['createMarketBuyOrderRequiresPrice'] = false. Make sure you know what you're doing.");
                    } else {
                        // despite that cost = amount * price is in quote currency and should have quote precision
                        // the exchange API requires the cost supplied in 'amount' to be of base precision
                        // more about it here:
                        // https://github.com/ccxt/ccxt/pull/4395
                        // https://github.com/ccxt/ccxt/issues/7611
                        // we use amountToPrecision here because the exchange requires cost in base precision
                        request['amount'] = this.costToPrecision (symbol, parseFloat (amount) * parseFloat (price));
                    }
                } else {
                    request['amount'] = this.costToPrecision (symbol, amount);
                }
            } else {
                request['amount'] = this.amountToPrecision (symbol, amount);
            }
            if (type === 'limit' || type === 'ioc' || type === 'limit-maker') {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const method = this.options['createOrderMethod'];
            const response = await this[method] (this.extend (request, params));
            const timestamp = this.milliseconds ();
            const id = this.safeString (response, 'data');
            return {
                'info': response,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': undefined,
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': amount,
                'filled': undefined,
                'remaining': undefined,
                'cost': undefined,
                'trades': undefined,
                'fee': undefined,
                'clientOrderId': undefined,
                'average': undefined,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const response = await this.privatePostOrderOrdersIdSubmitcancel ({ 'id': id });
            //
            //     let response = {
            //         'status': 'ok',
            //         'data': '10138899000',
            //     };
            //
            return this.extend (this.parseOrder (response), {
                'id': id,
                'status': 'canceled',
            });
        }
    
        async cancelOrders (ids, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const clientOrderIds = this.safeValue2 (params, 'clientOrderIds', 'client-order-ids');
            params = this.omit (params, [ 'clientOrderIds', 'client-order-ids' ]);
            const request = {};
            if (clientOrderIds === undefined) {
                request['order-ids'] = ids;
            } else {
                request['client-order-ids'] = clientOrderIds;
            }
            const response = await this.privatePostOrderOrdersBatchcancel (this.extend (request, params));
            //
            //     {
            //         "status": "ok",
            //         "data": {
            //             "success": [
            //                 "5983466"
            //             ],
            //             "failed": [
            //                 {
            //                     "err-msg": "Incorrect order state",
            //                     "order-state": 7,
            //                     "order-id": "",
            //                     "err-code": "order-orderstate-error",
            //                     "client-order-id": "first"
            //                 },
            //                 {
            //                     "err-msg": "Incorrect order state",
            //                     "order-state": 7,
            //                     "order-id": "",
            //                     "err-code": "order-orderstate-error",
            //                     "client-order-id": "second"
            //                 },
            //                 {
            //                     "err-msg": "The record is not found.",
            //                     "order-id": "",
            //                     "err-code": "base-not-found",
            //                     "client-order-id": "third"
            //                 }
            //             ]
            //         }
            //     }
            //
            return response;
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'account-id' string false NA The account id used for this cancel Refer to GET /v1/account/accounts
                // 'symbol': market['id'], // a list of comma-separated symbols, all symbols by default
                // 'types' 'string', buy-market, sell-market, buy-limit, sell-limit, buy-ioc, sell-ioc, buy-stop-limit, sell-stop-limit, buy-limit-fok, sell-limit-fok, buy-stop-limit-fok, sell-stop-limit-fok
                // 'side': 'buy', // or 'sell'
                // 'size': 100, // the number of orders to cancel 1-100
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            const response = await this.privatePostOrderOrdersBatchCancelOpenOrders (this.extend (request, params));
            //
            //     {
            //         code: 200,
            //         data: {
            //             "success-count": 2,
            //             "failed-count": 0,
            //             "next-id": 5454600
            //         }
            //     }
            //
            return response;
        }
    
        currencyToPrecision (currency, fee) {
            return this.decimalToPrecision (fee, 0, this.currencies[currency]['precision']);
        }
    
        parseDepositAddress (depositAddress, currency = undefined) {
            //
            //     {
            //         currency: "eth",
            //         address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
            //         addressTag: "",
            //         chain: "eth"
            //     }
            //
            const address = this.safeString (depositAddress, 'address');
            const tag = this.safeString (depositAddress, 'addressTag');
            const currencyId = this.safeString (depositAddress, 'currency');
            const code = this.safeCurrencyCode (currencyId);
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': depositAddress,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.v2PrivateGetAccountDepositAddress (this.extend (request, params));
            //
            //     {
            //         code: 200,
            //         data: [
            //             {
            //                 currency: "eth",
            //                 address: "0xf7292eb9ba7bc50358e27f0e025a4d225a64127b",
            //                 addressTag: "",
            //                 chain: "eth"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseDepositAddress (this.safeValue (data, 0, {}), currency);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (limit === undefined || limit > 100) {
                limit = 100;
            }
            await this.loadMarkets ();
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            const request = {
                'type': 'deposit',
                'from': 0, // From 'id' ... if you want to get results after a particular transaction id, pass the id in params.from
            };
            if (currency !== undefined) {
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['size'] = limit; // max 100
            }
            const response = await this.privateGetQueryDepositWithdraw (this.extend (request, params));
            // return response
            return this.parseTransactions (response['data'], currency, since, limit);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (limit === undefined || limit > 100) {
                limit = 100;
            }
            await this.loadMarkets ();
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
            }
            const request = {
                'type': 'withdraw',
                'from': 0, // From 'id' ... if you want to get results after a particular transaction id, pass the id in params.from
            };
            if (currency !== undefined) {
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['size'] = limit; // max 100
            }
            const response = await this.privateGetQueryDepositWithdraw (this.extend (request, params));
            // return response
            return this.parseTransactions (response['data'], currency, since, limit);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         'id': 8211029,
            //         'type': 'deposit',
            //         'currency': 'eth',
            //         'chain': 'eth',
            //         'tx-hash': 'bd315....',
            //         'amount': 0.81162421,
            //         'address': '4b8b....',
            //         'address-tag': '',
            //         'fee': 0,
            //         'state': 'safe',
            //         'created-at': 1542180380965,
            //         'updated-at': 1542180788077
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         'id': 6908275,
            //         'type': 'withdraw',
            //         'currency': 'btc',
            //         'chain': 'btc',
            //         'tx-hash': 'c1a1a....',
            //         'amount': 0.80257005,
            //         'address': '1QR....',
            //         'address-tag': '',
            //         'fee': 0.0005,
            //         'state': 'confirmed',
            //         'created-at': 1552107295685,
            //         'updated-at': 1552108032859
            //     }
            //
            const timestamp = this.safeInteger (transaction, 'created-at');
            const updated = this.safeInteger (transaction, 'updated-at');
            const code = this.safeCurrencyCode (this.safeString (transaction, 'currency'));
            let type = this.safeString (transaction, 'type');
            if (type === 'withdraw') {
                type = 'withdrawal';
            }
            const status = this.parseTransactionStatus (this.safeString (transaction, 'state'));
            const tag = this.safeString (transaction, 'address-tag');
            let feeCost = this.safeNumber (transaction, 'fee');
            if (feeCost !== undefined) {
                feeCost = Math.abs (feeCost);
            }
            return {
                'info': transaction,
                'id': this.safeString (transaction, 'id'),
                'txid': this.safeString (transaction, 'tx-hash'),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': this.safeString (transaction, 'address'),
                'tag': tag,
                'type': type,
                'amount': this.safeNumber (transaction, 'amount'),
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': {
                    'currency': code,
                    'cost': feeCost,
                    'rate': undefined,
                },
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                // deposit statuses
                'unknown': 'failed',
                'confirming': 'pending',
                'confirmed': 'ok',
                'safe': 'ok',
                'orphan': 'failed',
                // withdrawal statuses
                'submitted': 'pending',
                'canceled': 'canceled',
                'reexamine': 'pending',
                'reject': 'failed',
                'pass': 'pending',
                'wallet-reject': 'failed',
                // 'confirmed': 'ok', // present in deposit statuses
                'confirm-error': 'failed',
                'repealed': 'failed',
                'wallet-transfer': 'pending',
                'pre-transfer': 'pending',
            };
            return this.safeString (statuses, status, status);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            await this.loadMarkets ();
            this.checkAddress (address);
            const currency = this.currency (code);
            const request = {
                'address': address, // only supports existing addresses in your withdraw address list
                'amount': amount,
                'currency': currency['id'].toLowerCase (),
            };
            if (tag !== undefined) {
                request['addr-tag'] = tag; // only for XRP?
            }
            const response = await this.privatePostDwWithdrawApiCreate (this.extend (request, params));
            const id = this.safeString (response, 'data');
            return {
                'info': response,
                'id': id,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = '/';
            if (api === 'market') {
                url += api;
            } else if ((api === 'public') || (api === 'private')) {
                url += this.version;
            } else if ((api === 'v2Public') || (api === 'v2Private')) {
                url += 'v2';
            }
            url += '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (api === 'private' || api === 'v2Private') {
                this.checkRequiredCredentials ();
                const timestamp = this.ymdhms (this.milliseconds (), 'T');
                let request = {
                    'SignatureMethod': 'HmacSHA256',
                    'SignatureVersion': '2',
                    'AccessKeyId': this.apiKey,
                    'Timestamp': timestamp,
                };
                if (method !== 'POST') {
                    request = this.extend (request, query);
                }
                request = this.keysort (request);
                let auth = this.urlencode (request);
                // unfortunately, PHP demands double quotes for the escaped newline symbol
                // eslint-disable-next-line quotes
                const payload = [ method, this.hostname, url, auth ].join ("\n");
                const signature = this.hmac (this.encode (payload), this.encode (this.secret), 'sha256', 'base64');
                auth += '&' + this.urlencode ({ 'Signature': signature });
                url += '?' + auth;
                if (method === 'POST') {
                    body = this.json (query);
                    headers = {
                        'Content-Type': 'application/json',
                    };
                } else {
                    headers = {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    };
                }
            } else {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            }
            url = this.implodeParams (this.urls['api'][api], {
                'hostname': this.hostname,
            }) + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        calculateRateLimiterCost (api, method, path, params, config = {}, context = {}) {
            return this.safeInteger (config, 'cost', 1);
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return; // fallback to default error handler
            }
            if ('status' in response) {
                //
                //     {"status":"error","err-code":"order-limitorder-amount-min-error","err-msg":"limit order amount error, min: `0.001`","data":null}
                //
                const status = this.safeString (response, 'status');
                if (status === 'error') {
                    const code = this.safeString (response, 'err-code');
                    const feedback = this.id + ' ' + body;
                    this.throwBroadlyMatchedException (this.exceptions['broad'], body, feedback);
                    this.throwExactlyMatchedException (this.exceptions['exact'], code, feedback);
                    const message = this.safeString (response, 'err-msg');
                    this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                    throw new ExchangeError (feedback);
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],88:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const huobipro = require ('./huobipro.js');
    const { NotSupported } = require ('./base/errors');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class huobijp extends huobipro {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'huobijp',
                'name': 'Huobi Japan',
                'countries': [ 'JP' ],
                'hostname': 'api-cloud.huobi.co.jp',
                'pro': true,
                'certified': false,
                'has': {
                    'fetchDepositAddress': false,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/85734211-85755480-b705-11ea-8b35-0b7f1db33a2f.jpg',
                    'api': {
                        'market': 'https://{hostname}',
                        'public': 'https://{hostname}',
                        'private': 'https://{hostname}',
                    },
                    'www': 'https://www.huobi.co.jp',
                    'referral': 'https://www.huobi.co.jp/register/?invite_code=znnq3',
                    'doc': 'https://api-doc.huobi.co.jp',
                    'fees': 'https://www.huobi.co.jp/support/fee',
                },
            });
        }
    
        async fetchDepositAddress (code, params = {}) {
            throw new NotSupported (this.id + ' fetchDepositAddress not supported yet');
        }
    };
    
    },{"./base/errors":9,"./huobipro.js":89}],89:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const huobi = require ('./huobi.js');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class huobipro extends huobi {
        describe () {
            // this is an alias for backward-compatibility
            // to be removed soon
            return this.deepExtend (super.describe (), {
                'id': 'huobipro',
            });
        }
    };
    
    },{"./huobi.js":87}],90:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { PAD_WITH_ZERO } = require ('./base/functions/number');
    const { InvalidOrder, InsufficientFunds, ExchangeError, ExchangeNotAvailable, DDoSProtection, BadRequest, NotSupported, InvalidAddress, AuthenticationError } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class idex extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'idex',
                'name': 'IDEX',
                'countries': [ 'US' ],
                'rateLimit': 1500,
                'version': 'v2',
                'pro': true,
                'certified': true,
                'requiresWeb3': true,
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchCurrencies': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchClosedOrders': true,
                    'fetchOrders': false,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchTransactions': false,
                    'fetchDeposits': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': '1m',
                    '5m': '5m',
                    '15m': '15m',
                    '30m': '30m',
                    '1h': '1h',
                    '6h': '6h',
                    '1d': '1d',
                },
                'urls': {
                    'test': {
                        'public': 'https://api-sandbox.idex.io',
                        'private': 'https://api-sandbox.idex.io',
                    },
                    'logo': 'https://user-images.githubusercontent.com/51840849/94481303-2f222100-01e0-11eb-97dd-bc14c5943a86.jpg',
                    'api': {
                        'ETH': 'https://api-eth.idex.io',
                        'BSC': 'https://api-bsc.idex.io',
                    },
                    'www': 'https://idex.io',
                    'doc': [
                        'https://docs.idex.io/',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            'ping',
                            'time',
                            'exchange',
                            'assets',
                            'markets',
                            'tickers',
                            'candles',
                            'trades',
                            'orderbook',
                            'wsToken',
                        ],
                    },
                    'private': {
                        'get': [
                            'user',
                            'wallets',
                            'balances',
                            'orders',
                            'fills',
                            'deposits',
                            'withdrawals',
                        ],
                        'post': [
                            'wallets',
                            'orders',
                            'orders/test',
                            'withdrawals',
                        ],
                        'delete': [
                            'orders',
                        ],
                    },
                },
                'options': {
                    'defaultTimeInForce': 'gtc',
                    'defaultSelfTradePrevention': 'cn',
                    'network': 'ETH', // also supports BSC
                },
                'exceptions': {
                    'INVALID_ORDER_QUANTITY': InvalidOrder,
                    'INSUFFICIENT_FUNDS': InsufficientFunds,
                    'SERVICE_UNAVAILABLE': ExchangeNotAvailable,
                    'EXCEEDED_RATE_LIMIT': DDoSProtection,
                    'INVALID_PARAMETER': BadRequest,
                    'WALLET_NOT_ASSOCIATED': InvalidAddress,
                    'INVALID_WALLET_SIGNATURE': AuthenticationError,
                },
                'requiredCredentials': {
                    'walletAddress': true,
                    'privateKey': true,
                    'apiKey': true,
                    'secret': true,
                },
                'paddingMode': PAD_WITH_ZERO,
                'commonCurrencies': {},
                'requireCredentials': {
                    'privateKey': true,
                    'apiKey': true,
                    'secret': true,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetMarkets (params);
            //
            // [
            //   {
            //     market: 'DIL-ETH',
            //     status: 'active',
            //     baseAsset: 'DIL',
            //     baseAssetPrecision: 8,
            //     quoteAsset: 'ETH',
            //     quoteAssetPrecision: 8
            //   }, ...
            // ]
            //
            const response2 = await this.publicGetExchange ();
            //
            // {
            //     "timeZone": "UTC",
            //     "serverTime": 1590408000000,
            //     "ethereumDepositContractAddress": "0x...",
            //     "ethUsdPrice": "206.46",
            //     "gasPrice": 7,
            //     "volume24hUsd": "10416227.98",
            //     "makerFeeRate": "0.001",
            //     "takerFeeRate": "0.002",
            //     "makerTradeMinimum": "0.15000000",
            //     "takerTradeMinimum": "0.05000000",
            //     "withdrawalMinimum": "0.04000000"
            // }
            //
            const maker = this.safeNumber (response2, 'makerFeeRate');
            const taker = this.safeNumber (response2, 'takerFeeRate');
            const makerMin = this.safeNumber (response2, 'makerTradeMinimum');
            const takerMin = this.safeNumber (response2, 'takerTradeMinimum');
            const minCostETH = Math.min (makerMin, takerMin);
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const marketId = this.safeString (entry, 'market');
                const baseId = this.safeString (entry, 'baseAsset');
                const quoteId = this.safeString (entry, 'quoteAsset');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const basePrecisionString = this.safeString (entry, 'baseAssetPrecision');
                const quotePrecisionString = this.safeString (entry, 'quoteAssetPrecision');
                const basePrecision = this.parsePrecision (basePrecisionString);
                const quotePrecision = this.parsePrecision (quotePrecisionString);
                const status = this.safeString (entry, 'status');
                const active = status === 'active';
                let minCost = undefined;
                if (quote === 'ETH') {
                    minCost = minCostETH;
                }
                const precision = {
                    'amount': parseInt (basePrecisionString),
                    'price': parseInt (quotePrecisionString),
                };
                result.push ({
                    'symbol': symbol,
                    'id': marketId,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': active,
                    'info': entry,
                    'precision': precision,
                    'taker': taker,
                    'maker': maker,
                    'limits': {
                        'amount': {
                            'min': this.parseNumber (basePrecision),
                            'max': undefined,
                        },
                        'price': {
                            'min': this.parseNumber (quotePrecision),
                            'max': undefined,
                        },
                        'cost': {
                            'min': minCost,
                            'max': undefined,
                        },
                    },
                });
            }
            return result;
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            // [
            //   {
            //     market: 'DIL-ETH',
            //     time: 1598367493008,
            //     open: '0.09695361',
            //     high: '0.10245881',
            //     low: '0.09572507',
            //     close: '0.09917079',
            //     closeQuantity: '0.71320950',
            //     baseVolume: '309.17380612',
            //     quoteVolume: '30.57633981',
            //     percentChange: '2.28',
            //     numTrades: 205,
            //     ask: '0.09910476',
            //     bid: '0.09688340',
            //     sequence: 3902
            //   }
            // ]
            const response = await this.publicGetTickers (this.extend (request, params));
            const ticker = this.safeValue (response, 0);
            return this.parseTicker (ticker, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            // [
            //   {
            //     market: 'DIL-ETH',
            //     time: 1598367493008,
            //     open: '0.09695361',
            //     high: '0.10245881',
            //     low: '0.09572507',
            //     close: '0.09917079',
            //     closeQuantity: '0.71320950',
            //     baseVolume: '309.17380612',
            //     quoteVolume: '30.57633981',
            //     percentChange: '2.28',
            //     numTrades: 205,
            //     ask: '0.09910476',
            //     bid: '0.09688340',
            //     sequence: 3902
            //   }, ...
            // ]
            const response = await this.publicGetTickers (params);
            return this.parseTickers (response, symbols);
        }
    
        parseTicker (ticker, market = undefined) {
            // {
            //   market: 'DIL-ETH',
            //   time: 1598367493008,
            //   open: '0.09695361',
            //   high: '0.10245881',
            //   low: '0.09572507',
            //   close: '0.09917079',
            //   closeQuantity: '0.71320950',
            //   baseVolume: '309.17380612',
            //   quoteVolume: '30.57633981',
            //   percentChange: '2.28',
            //   numTrades: 205,
            //   ask: '0.09910476',
            //   bid: '0.09688340',
            //   sequence: 3902
            // }
            const marketId = this.safeString (ticker, 'market');
            const symbol = this.safeSymbol (marketId, market, '-');
            const baseVolume = this.safeNumber (ticker, 'baseVolume');
            const quoteVolume = this.safeNumber (ticker, 'quoteVolume');
            const timestamp = this.safeInteger (ticker, 'time');
            const open = this.safeNumber (ticker, 'open');
            const high = this.safeNumber (ticker, 'high');
            const low = this.safeNumber (ticker, 'low');
            const close = this.safeNumber (ticker, 'close');
            const ask = this.safeNumber (ticker, 'ask');
            const bid = this.safeNumber (ticker, 'bid');
            let percentage = this.safeNumber (ticker, 'percentChange');
            if (percentage !== undefined) {
                percentage = 1 + percentage / 100;
            }
            let change = undefined;
            if ((close !== undefined) && (open !== undefined)) {
                change = close - open;
            }
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': high,
                'low': low,
                'bid': bid,
                'bidVolume': undefined,
                'ask': ask,
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': close,
                'last': close,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                'interval': timeframe,
            };
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.publicGetCandles (this.extend (request, params));
            if (Array.isArray (response)) {
                // [
                //   {
                //     start: 1598345580000,
                //     open: '0.09771286',
                //     high: '0.09771286',
                //     low: '0.09771286',
                //     close: '0.09771286',
                //     volume: '1.45340410',
                //     sequence: 3853
                //   }, ...
                // ]
                return this.parseOHLCVs (response, market, timeframe, since, limit);
            } else {
                //  {"nextTime":1595536440000}
                return [];
            }
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            // {
            //   start: 1598345580000,
            //   open: '0.09771286',
            //   high: '0.09771286',
            //   low: '0.09771286',
            //   close: '0.09771286',
            //   volume: '1.45340410',
            //   sequence: 3853
            // }
            const timestamp = this.safeInteger (ohlcv, 'start');
            const open = this.safeNumber (ohlcv, 'open');
            const high = this.safeNumber (ohlcv, 'high');
            const low = this.safeNumber (ohlcv, 'low');
            const close = this.safeNumber (ohlcv, 'close');
            const volume = this.safeNumber (ohlcv, 'volume');
            return [ timestamp, open, high, low, close, volume ];
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            // [
            //   {
            //     fillId: 'b5467d00-b13e-3fa9-8216-dd66735550fc',
            //     price: '0.09771286',
            //     quantity: '1.45340410',
            //     quoteQuantity: '0.14201627',
            //     time: 1598345638994,
            //     makerSide: 'buy',
            //     sequence: 3853
            //   }, ...
            // ]
            const response = await this.publicGetTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            // public trades
            // {
            //   fillId: 'b5467d00-b13e-3fa9-8216-dd66735550fc',
            //   price: '0.09771286',
            //   quantity: '1.45340410',
            //   quoteQuantity: '0.14201627',
            //   time: 1598345638994,
            //   makerSide: 'buy',
            //   sequence: 3853
            // }
            // private trades
            // {
            //   fillId: '48582d10-b9bb-3c4b-94d3-e67537cf2472',
            //   price: '0.09905990',
            //   quantity: '0.40000000',
            //   quoteQuantity: '0.03962396',
            //   time: 1598873478762,
            //   makerSide: 'sell',
            //   sequence: 5053,
            //   market: 'DIL-ETH',
            //   orderId: '7cdc8e90-eb7d-11ea-9e60-4118569f6e63',
            //   side: 'buy',
            //   fee: '0.00080000',
            //   feeAsset: 'DIL',
            //   gas: '0.00857497',
            //   liquidity: 'taker',
            //   txId: '0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65',
            //   txStatus: 'mined'
            // }
            const id = this.safeString (trade, 'fillId');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'quantity');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            let cost = this.safeNumber (trade, 'quoteQuantity');
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            const timestamp = this.safeInteger (trade, 'time');
            const marketId = this.safeString (trade, 'market');
            const symbol = this.safeSymbol (marketId, market, '-');
            // this code handles the duality of public vs private trades
            const makerSide = this.safeString (trade, 'makerSide');
            const oppositeSide = (makerSide === 'buy') ? 'sell' : 'buy';
            const side = this.safeString (trade, 'side', oppositeSide);
            const takerOrMaker = this.safeString (trade, 'liquidity', 'taker');
            const feeCost = this.safeNumber (trade, 'fee');
            let fee = undefined;
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'feeAsset');
                fee = {
                    'cost': feeCost,
                    'currency': this.safeCurrencyCode (feeCurrencyId),
                };
            }
            const orderId = this.safeString (trade, 'orderId');
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': 'limit',
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
                'level': 2,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            // {
            //   sequence: 36416753,
            //   bids: [
            //     [ '0.09672815', '8.22284267', 1 ],
            //     [ '0.09672814', '1.83685554', 1 ],
            //     [ '0.09672143', '4.10962617', 1 ],
            //     [ '0.09658884', '4.03863759', 1 ],
            //     [ '0.09653781', '3.35730684', 1 ],
            //     [ '0.09624660', '2.54163586', 1 ],
            //     [ '0.09617490', '1.93065030', 1 ]
            //   ],
            //   asks: [
            //     [ '0.09910476', '3.22840154', 1 ],
            //     [ '0.09940587', '3.39796593', 1 ],
            //     [ '0.09948189', '4.25088898', 1 ],
            //     [ '0.09958362', '2.42195784', 1 ],
            //     [ '0.09974393', '4.25234367', 1 ],
            //     [ '0.09995250', '3.40192141', 1 ]
            //   ]
            // }
            const response = await this.publicGetOrderbook (this.extend (request, params));
            const nonce = this.safeInteger (response, 'sequence');
            return {
                'symbol': symbol,
                'timestamp': undefined,
                'datetime': undefined,
                'nonce': nonce,
                'bids': this.parseSide (response, 'bids'),
                'asks': this.parseSide (response, 'asks'),
            };
        }
    
        parseSide (book, side) {
            const bookSide = this.safeValue (book, side, []);
            const result = [];
            for (let i = 0; i < bookSide.length; i++) {
                const order = bookSide[i];
                const price = this.safeNumber (order, 0);
                const amount = this.safeNumber (order, 1);
                const orderCount = this.safeInteger (order, 2);
                result.push ([ price, amount, orderCount ]);
            }
            const descending = side === 'bids';
            return this.sortBy (result, 0, descending);
        }
    
        async fetchCurrencies (params = {}) {
            // [
            //   {
            //     name: 'Ether',
            //     symbol: 'ETH',
            //     contractAddress: '0x0000000000000000000000000000000000000000',
            //     assetDecimals: 18,
            //     exchangeDecimals: 8
            //   }, ..
            // ]
            const response = await this.publicGetAssets (params);
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const name = this.safeString (entry, 'name');
                const currencyId = this.safeString (entry, 'symbol');
                const precisionString = this.safeString (entry, 'exchangeDecimals');
                const code = this.safeCurrencyCode (currencyId);
                const precision = this.parsePrecision (precisionString);
                const lot = this.parseNumber (precision);
                result[code] = {
                    'id': currencyId,
                    'code': code,
                    'info': entry,
                    'type': undefined,
                    'name': name,
                    'active': undefined,
                    'fee': undefined,
                    'precision': parseInt (precisionString),
                    'limits': {
                        'amount': { 'min': lot, 'max': undefined },
                        'withdraw': { 'min': lot, 'max': undefined },
                    },
                };
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            this.checkRequiredCredentials ();
            await this.loadMarkets ();
            const nonce1 = this.uuidv1 ();
            const request = {
                'nonce': nonce1,
                'wallet': this.walletAddress,
            };
            // [
            //   {
            //     asset: 'DIL',
            //     quantity: '0.00000000',
            //     availableForTrade: '0.00000000',
            //     locked: '0.00000000',
            //     usdValue: null
            //   }, ...
            // ]
            const extendedRequest = this.extend (request, params);
            if (extendedRequest['wallet'] === undefined) {
                throw new BadRequest (this.id + ' wallet is undefined, set this.walletAddress or "address" in params');
            }
            let response = undefined;
            try {
                response = await this.privateGetBalances (extendedRequest);
            } catch (e) {
                if (e instanceof InvalidAddress) {
                    const walletAddress = extendedRequest['wallet'];
                    await this.associateWallet (walletAddress);
                    response = await this.privateGetBalances (extendedRequest);
                } else {
                    throw e;
                }
            }
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            for (let i = 0; i < response.length; i++) {
                const entry = response[i];
                const currencyId = this.safeString (entry, 'asset');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['total'] = this.safeString (entry, 'quantity');
                account['free'] = this.safeString (entry, 'availableForTrade');
                account['used'] = this.safeString (entry, 'locked');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            this.checkRequiredCredentials ();
            await this.loadMarkets ();
            let market = undefined;
            const request = {
                'nonce': this.uuidv1 (),
                'wallet': this.walletAddress,
            };
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['market'] = market['id'];
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            // [
            //   {
            //     fillId: '48582d10-b9bb-3c4b-94d3-e67537cf2472',
            //     price: '0.09905990',
            //     quantity: '0.40000000',
            //     quoteQuantity: '0.03962396',
            //     time: 1598873478762,
            //     makerSide: 'sell',
            //     sequence: 5053,
            //     market: 'DIL-ETH',
            //     orderId: '7cdc8e90-eb7d-11ea-9e60-4118569f6e63',
            //     side: 'buy',
            //     fee: '0.00080000',
            //     feeAsset: 'DIL',
            //     gas: '0.00857497',
            //     liquidity: 'taker',
            //     txId: '0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65',
            //     txStatus: 'mined'
            //   }
            // ]
            const extendedRequest = this.extend (request, params);
            if (extendedRequest['wallet'] === undefined) {
                throw new BadRequest (this.id + ' walletAddress is undefined, set this.walletAddress or "address" in params');
            }
            let response = undefined;
            try {
                response = await this.privateGetFills (extendedRequest);
            } catch (e) {
                if (e instanceof InvalidAddress) {
                    const walletAddress = extendedRequest['wallet'];
                    await this.associateWallet (walletAddress);
                    response = await this.privateGetFills (extendedRequest);
                } else {
                    throw e;
                }
            }
            return this.parseTrades (response, market, since, limit);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            const request = {
                'orderId': id,
            };
            return await this.fetchOrdersHelper (symbol, undefined, undefined, this.extend (request, params));
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'closed': false,
            };
            return await this.fetchOrdersHelper (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'closed': true,
            };
            return await this.fetchOrdersHelper (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrdersHelper (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'nonce': this.uuidv1 (),
                'wallet': this.walletAddress,
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['market'] = market['id'];
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetOrders (this.extend (request, params));
            // fetchClosedOrders / fetchOpenOrders
            // [
            //   {
            //     "market": "DIL-ETH",
            //     "orderId": "7cdc8e90-eb7d-11ea-9e60-4118569f6e63",
            //     "wallet": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
            //     "time": 1598873478650,
            //     "status": "filled",
            //     "type": "limit",
            //     "side": "buy",
            //     "originalQuantity": "0.40000000",
            //     "executedQuantity": "0.40000000",
            //     "cumulativeQuoteQuantity": "0.03962396",
            //     "avgExecutionPrice": "0.09905990",
            //     "price": "1.00000000",
            //     "fills": [
            //       {
            //         "fillId": "48582d10-b9bb-3c4b-94d3-e67537cf2472",
            //         "price": "0.09905990",
            //         "quantity": "0.40000000",
            //         "quoteQuantity": "0.03962396",
            //         "time": 1598873478650,
            //         "makerSide": "sell",
            //         "sequence": 5053,
            //         "fee": "0.00080000",
            //         "feeAsset": "DIL",
            //         "gas": "0.00857497",
            //         "liquidity": "taker",
            //         "txId": "0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65",
            //         "txStatus": "mined"
            //       }
            //     ]
            //   }
            // ]
            // fetchOrder
            // { market: 'DIL-ETH',
            //   orderId: '7cdc8e90-eb7d-11ea-9e60-4118569f6e63',
            //   wallet: '0x0AB991497116f7F5532a4c2f4f7B1784488628e1',
            //   time: 1598873478650,
            //   status: 'filled',
            //   type: 'limit',
            //   side: 'buy',
            //   originalQuantity: '0.40000000',
            //   executedQuantity: '0.40000000',
            //   cumulativeQuoteQuantity: '0.03962396',
            //   avgExecutionPrice: '0.09905990',
            //   price: '1.00000000',
            //   fills:
            //    [ { fillId: '48582d10-b9bb-3c4b-94d3-e67537cf2472',
            //        price: '0.09905990',
            //        quantity: '0.40000000',
            //        quoteQuantity: '0.03962396',
            //        time: 1598873478650,
            //        makerSide: 'sell',
            //        sequence: 5053,
            //        fee: '0.00080000',
            //        feeAsset: 'DIL',
            //        gas: '0.00857497',
            //        liquidity: 'taker',
            //        txId: '0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65',
            //        txStatus: 'mined' } ] }
            if (Array.isArray (response)) {
                return this.parseOrders (response, market, since, limit);
            } else {
                return this.parseOrder (response, market);
            }
        }
    
        parseOrderStatus (status) {
            // https://docs.idex.io/#order-states-amp-lifecycle
            const statuses = {
                'active': 'open',
                'partiallyFilled': 'open',
                'rejected': 'canceled',
                'filled': 'closed',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "market": "DIL-ETH",
            //         "orderId": "7cdc8e90-eb7d-11ea-9e60-4118569f6e63",
            //         "wallet": "0x0AB991497116f7F5532a4c2f4f7B1784488628e1",
            //         "time": 1598873478650,
            //         "status": "filled",
            //         "type": "limit",
            //         "side": "buy",
            //         "originalQuantity": "0.40000000",
            //         "executedQuantity": "0.40000000",
            //         "cumulativeQuoteQuantity": "0.03962396",
            //         "avgExecutionPrice": "0.09905990",
            //         "price": "1.00000000",
            //         "fills": [
            //             {
            //             "fillId": "48582d10-b9bb-3c4b-94d3-e67537cf2472",
            //             "price": "0.09905990",
            //             "quantity": "0.40000000",
            //             "quoteQuantity": "0.03962396",
            //             "time": 1598873478650,
            //             "makerSide": "sell",
            //             "sequence": 5053,
            //             "fee": "0.00080000",
            //             "feeAsset": "DIL",
            //             "gas": "0.00857497",
            //             "liquidity": "taker",
            //             "txId": "0xeaa02b112c0b8b61bc02fa1776a2b39d6c614e287c1af90df0a2e591da573e65",
            //             "txStatus": "mined"
            //             }
            //         ]
            //     }
            //
            const timestamp = this.safeInteger (order, 'time');
            const fills = this.safeValue (order, 'fills', []);
            const id = this.safeString (order, 'orderId');
            const clientOrderId = this.safeString (order, 'clientOrderId');
            const marketId = this.safeString (order, 'market');
            const side = this.safeString (order, 'side');
            const symbol = this.safeSymbol (marketId, market, '-');
            const trades = this.parseTrades (fills, market);
            const type = this.safeString (order, 'type');
            const amount = this.safeNumber (order, 'originalQuantity');
            const filled = this.safeNumber (order, 'executedQuantity');
            const average = this.safeNumber (order, 'avgExecutionPrice');
            const price = this.safeNumber (order, 'price');
            const rawStatus = this.safeString (order, 'status');
            const status = this.parseOrderStatus (rawStatus);
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': clientOrderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'amount': amount,
                'cost': undefined,
                'average': average,
                'filled': filled,
                'remaining': undefined,
                'status': status,
                'fee': undefined,
                'trades': trades,
            });
        }
    
        async associateWallet (walletAddress, params = {}) {
            const nonce = this.uuidv1 ();
            const noPrefix = this.remove0xPrefix (walletAddress);
            const byteArray = [
                this.base16ToBinary (nonce),
                this.base16ToBinary (noPrefix),
            ];
            const binary = this.binaryConcatArray (byteArray);
            const hash = this.hash (binary, 'keccak', 'hex');
            const signature = this.signMessageString (hash, this.privateKey);
            // {
            //   address: '0x0AB991497116f7F5532a4c2f4f7B1784488628e1',
            //   totalPortfolioValueUsd: '0.00',
            //   time: 1598468353626
            // }
            const request = {
                'parameters': {
                    'nonce': nonce,
                    'wallet': walletAddress,
                },
                'signature': signature,
            };
            const result = await this.privatePostWallets (request);
            return result;
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            // https://docs.idex.io/#create-order
            this.checkRequiredCredentials ();
            await this.loadMarkets ();
            const market = this.market (symbol);
            const nonce = this.uuidv1 ();
            let typeEnum = undefined;
            const stopLossTypeEnums = {
                'stopLoss': 3,
                'stopLossLimit': 4,
                'takeProfit': 5,
                'takeProfitLimit': 6,
            };
            let stopPriceString = undefined;
            if ((type === 'stopLossLimit') || (type === 'takeProfitLimit') || ('stopPrice' in params)) {
                if (!('stopPrice' in params)) {
                    throw new BadRequest (this.id + ' stopPrice is a required parameter for ' + type + 'orders');
                }
                stopPriceString = this.priceToPrecision (symbol, params['stopPrice']);
            }
            const limitTypeEnums = {
                'limit': 1,
                'limitMaker': 2,
            };
            let priceString = undefined;
            const typeLower = type.toLowerCase ();
            const limitOrder = typeLower.indexOf ('limit') > -1;
            if (type in limitTypeEnums) {
                typeEnum = limitTypeEnums[type];
                priceString = this.priceToPrecision (symbol, price);
            } else if (type in stopLossTypeEnums) {
                typeEnum = stopLossTypeEnums[type];
                priceString = this.priceToPrecision (symbol, price);
            } else if (type === 'market') {
                typeEnum = 0;
            } else {
                throw new BadRequest (this.id + ' ' + type + ' is not a valid order type');
            }
            let amountEnum = 0; // base quantity
            if ('quoteOrderQuantity' in params) {
                if (type !== 'market') {
                    throw new NotSupported (this.id + ' quoteOrderQuantity is not supported for ' + type + ' orders, only supported for market orders');
                }
                amountEnum = 1;
                amount = this.safeNumber (params, 'quoteOrderQuantity');
            }
            const sideEnum = (side === 'buy') ? 0 : 1;
            const walletBytes = this.remove0xPrefix (this.walletAddress);
            const network = this.safeString (this.options, 'network', 'ETH');
            const orderVersion = (network === 'ETH') ? 1 : 2;
            const amountString = this.amountToPrecision (symbol, amount);
            // https://docs.idex.io/#time-in-force
            const timeInForceEnums = {
                'gtc': 0,
                'ioc': 2,
                'fok': 3,
            };
            const defaultTimeInForce = this.safeString (this.options, 'defaultTimeInForce', 'gtc');
            const timeInForce = this.safeString (params, 'timeInForce', defaultTimeInForce);
            let timeInForceEnum = undefined;
            if (timeInForce in timeInForceEnums) {
                timeInForceEnum = timeInForceEnums[timeInForce];
            } else {
                const allOptions = Object.keys (timeInForceEnums);
                const asString = allOptions.join (', ');
                throw new BadRequest (this.id + ' ' + timeInForce + ' is not a valid timeInForce, please choose one of ' + asString);
            }
            // https://docs.idex.io/#self-trade-prevention
            const selfTradePreventionEnums = {
                'dc': 0,
                'co': 1,
                'cn': 2,
                'cb': 3,
            };
            const defaultSelfTradePrevention = this.safeString (this.options, 'defaultSelfTradePrevention', 'cn');
            const selfTradePrevention = this.safeString (params, 'selfTradePrevention', defaultSelfTradePrevention);
            let selfTradePreventionEnum = undefined;
            if (selfTradePrevention in selfTradePreventionEnums) {
                selfTradePreventionEnum = selfTradePreventionEnums[selfTradePrevention];
            } else {
                const allOptions = Object.keys (selfTradePreventionEnums);
                const asString = allOptions.join (', ');
                throw new BadRequest (this.id + ' ' + selfTradePrevention + ' is not a valid selfTradePrevention, please choose one of ' + asString);
            }
            const byteArray = [
                this.numberToBE (orderVersion, 1),
                this.base16ToBinary (nonce),
                this.base16ToBinary (walletBytes),
                this.stringToBinary (this.encode (market['id'])),  // TODO: refactor to remove either encode or stringToBinary
                this.numberToBE (typeEnum, 1),
                this.numberToBE (sideEnum, 1),
                this.stringToBinary (this.encode (amountString)),
                this.numberToBE (amountEnum, 1),
            ];
            if (limitOrder) {
                const encodedPrice = this.stringToBinary (this.encode (priceString));
                byteArray.push (encodedPrice);
            }
            if (type in stopLossTypeEnums) {
                const encodedPrice = this.stringToBinary (this.encode (stopPriceString || priceString));
                byteArray.push (encodedPrice);
            }
            const clientOrderId = this.safeString (params, 'clientOrderId');
            if (clientOrderId !== undefined) {
                byteArray.push (this.stringToBinary (this.encode (clientOrderId)));
            }
            const after = [
                this.numberToBE (timeInForceEnum, 1),
                this.numberToBE (selfTradePreventionEnum, 1),
                this.numberToBE (0, 8), // unused
            ];
            const allBytes = this.arrayConcat (byteArray, after);
            const binary = this.binaryConcatArray (allBytes);
            const hash = this.hash (binary, 'keccak', 'hex');
            const signature = this.signMessageString (hash, this.privateKey);
            const request = {
                'parameters': {
                    'nonce': nonce,
                    'market': market['id'],
                    'side': side,
                    'type': type,
                    'wallet': this.walletAddress,
                    'timeInForce': timeInForce,
                    'selfTradePrevention': selfTradePrevention,
                },
                'signature': signature,
            };
            if (limitOrder) {
                request['parameters']['price'] = priceString;
            }
            if (type in stopLossTypeEnums) {
                request['parameters']['stopPrice'] = stopPriceString || priceString;
            }
            if (amountEnum === 0) {
                request['parameters']['quantity'] = amountString;
            } else {
                request['parameters']['quoteOrderQuantity'] = amountString;
            }
            if (clientOrderId !== undefined) {
                request['parameters']['clientOrderId'] = clientOrderId;
            }
            // {
            //   market: 'DIL-ETH',
            //   orderId: '7cdc8e90-eb7d-11ea-9e60-4118569f6e63',
            //   wallet: '0x0AB991497116f7F5532a4c2f4f7B1784488628e1',
            //   time: 1598873478650,
            //   status: 'filled',
            //   type: 'limit',
            //   side: 'buy',
            //   originalQuantity: '0.40000000',
            //   executedQuantity: '0.40000000',
            //   cumulativeQuoteQuantity: '0.03962396',
            //   price: '1.00000000',
            //   fills: [
            //     {
            //       fillId: '48582d10-b9bb-3c4b-94d3-e67537cf2472',
            //       price: '0.09905990',
            //       quantity: '0.40000000',
            //       quoteQuantity: '0.03962396',
            //       time: 1598873478650,
            //       makerSide: 'sell',
            //       sequence: 5053,
            //       fee: '0.00080000',
            //       feeAsset: 'DIL',
            //       gas: '0.00857497',
            //       liquidity: 'taker',
            //       txStatus: 'pending'
            //     }
            //   ],
            //   avgExecutionPrice: '0.09905990'
            // }
            // we don't use extend here because it is a signed endpoint
            const response = await this.privatePostOrders (request);
            return this.parseOrder (response, market);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkRequiredCredentials ();
            await this.loadMarkets ();
            const nonce = this.uuidv1 ();
            const amountString = this.currencyToPrecision (code, amount);
            const currency = this.currency (code);
            const walletBytes = this.remove0xPrefix (this.walletAddress);
            const byteArray = [
                this.base16ToBinary (nonce),
                this.base16ToBinary (walletBytes),
                this.stringToBinary (this.encode (currency['id'])),
                this.stringToBinary (this.encode (amountString)),
                this.numberToBE (1, 1), // bool set to true
            ];
            const binary = this.binaryConcatArray (byteArray);
            const hash = this.hash (binary, 'keccak', 'hex');
            const signature = this.signMessageString (hash, this.privateKey);
            const request = {
                'parameters': {
                    'nonce': nonce,
                    'wallet': address,
                    'asset': currency['id'],
                    'quantity': amountString,
                },
                'signature': signature,
            };
            // {
            //   withdrawalId: 'a61dcff0-ec4d-11ea-8b83-c78a6ecb3180',
            //   asset: 'ETH',
            //   assetContractAddress: '0x0000000000000000000000000000000000000000',
            //   quantity: '0.20000000',
            //   time: 1598962883190,
            //   fee: '0.00024000',
            //   txStatus: 'pending',
            //   txId: null
            // }
            const response = await this.privatePostWithdrawals (request);
            const id = this.safeString (response, 'withdrawalId');
            return {
                'info': response,
                'id': id,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            this.checkRequiredCredentials ();
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const nonce = this.uuidv1 ();
            const walletBytes = this.remove0xPrefix (this.walletAddress);
            const byteArray = [
                this.base16ToBinary (nonce),
                this.base16ToBinary (walletBytes),
                this.stringToBinary (this.encode (id)),
            ];
            const binary = this.binaryConcatArray (byteArray);
            const hash = this.hash (binary, 'keccak', 'hex');
            const signature = this.signMessageString (hash, this.privateKey);
            const request = {
                'parameters': {
                    'nonce': nonce,
                    'wallet': this.walletAddress,
                    'orderId': id,
                },
                'signature': signature,
            };
            // [ { orderId: '688336f0-ec50-11ea-9842-b332f8a34d0e' } ]
            const response = await this.privateDeleteOrders (this.extend (request, params));
            const canceledOrder = this.safeValue (response, 0);
            return this.parseOrder (canceledOrder, market);
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            const errorCode = this.safeString (response, 'code');
            const message = this.safeString (response, 'message');
            if (errorCode in this.exceptions) {
                const Exception = this.exceptions[errorCode];
                throw new Exception (this.id + ' ' + message);
            }
            if (errorCode !== undefined) {
                throw new ExchangeError (this.id + ' ' + message);
            }
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            params = this.extend ({
                'method': 'privateGetDeposits',
            }, params);
            return this.fetchTransactionsHelper (code, since, limit, params);
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            params = this.extend ({
                'method': 'privateGetWithdrawals',
            }, params);
            return this.fetchTransactionsHelper (code, since, limit, params);
        }
    
        async fetchTransactionsHelper (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const nonce = this.uuidv1 ();
            const request = {
                'nonce': nonce,
                'wallet': this.walletAddress,
            };
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['asset'] = currency['id'];
            }
            if (since !== undefined) {
                request['start'] = since;
            }
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            // [
            //   {
            //     depositId: 'e9970cc0-eb6b-11ea-9e89-09a5ebc1f98e',
            //     asset: 'ETH',
            //     quantity: '1.00000000',
            //     txId: '0xcd4aac3171d7131cc9e795568c67938675185ac17641553ef54c8a7c294c8142',
            //     txTime: 1598865853000,
            //     confirmationTime: 1598865930231
            //   }
            // ]
            const method = params['method'];
            params = this.omit (params, 'method');
            const response = await this[method] (this.extend (request, params));
            return this.parseTransactions (response, currency, since, limit);
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'mined': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            // fetchDeposits
            // {
            //   depositId: 'e9970cc0-eb6b-11ea-9e89-09a5ebc1f98f',
            //   asset: 'ETH',
            //   quantity: '1.00000000',
            //   txId: '0xcd4aac3171d7131cc9e795568c67938675185ac17641553ef54c8a7c294c8142',
            //   txTime: 1598865853000,
            //   confirmationTime: 1598865930231
            // }
            // fetchWithdrwalas
            // {
            //   withdrawalId: 'a62d8760-ec4d-11ea-9fa6-47904c19499b',
            //   asset: 'ETH',
            //   assetContractAddress: '0x0000000000000000000000000000000000000000',
            //   quantity: '0.20000000',
            //   time: 1598962883288,
            //   fee: '0.00024000',
            //   txId: '0x305e9cdbaa85ad029f50578d13d31d777c085de573ed5334d95c19116d8c03ce',
            //   txStatus: 'mined'
            //  }
            let type = undefined;
            if ('depositId' in transaction) {
                type = 'deposit';
            } else if ('withdrawalId' in transaction) {
                type = 'withdrawal';
            }
            const id = this.safeString2 (transaction, 'depositId', 'withdrawId');
            const code = this.safeCurrencyCode (this.safeString (transaction, 'asset'), currency);
            const amount = this.safeNumber (transaction, 'quantity');
            const txid = this.safeString (transaction, 'txId');
            const timestamp = this.safeInteger (transaction, 'txTime');
            let fee = undefined;
            if ('fee' in transaction) {
                fee = {
                    'cost': this.safeNumber (transaction, 'fee'),
                    'currency': 'ETH',
                };
            }
            const rawStatus = this.safeString (transaction, 'txStatus');
            const status = this.parseTransactionStatus (rawStatus);
            const updated = this.safeInteger (transaction, 'confirmationTime');
            return {
                'info': transaction,
                'id': id,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': undefined,
                'tag': undefined,
                'type': type,
                'amount': amount,
                'currency': code,
                'status': status,
                'updated': updated,
                'fee': fee,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const network = this.safeString (this.options, 'network', 'ETH');
            const version = this.safeString (this.options, 'version', 'v1');
            let url = this.urls['api'][network] + '/' + version + '/' + path;
            const keys = Object.keys (params);
            const length = keys.length;
            let query = undefined;
            if (length > 0) {
                if (method === 'GET') {
                    query = this.urlencode (params);
                    url = url + '?' + query;
                } else {
                    body = this.json (params);
                }
            }
            headers = {
                'Content-Type': 'application/json',
            };
            if (this.apiKey !== undefined) {
                headers['IDEX-API-Key'] = this.apiKey;
            }
            if (api === 'private') {
                let payload = undefined;
                if (method === 'GET') {
                    payload = query;
                } else {
                    payload = body;
                }
                headers['IDEX-HMAC-Signature'] = this.hmac (this.encode (payload), this.encode (this.secret), 'sha256', 'hex');
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],91:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class independentreserve extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'independentreserve',
                'name': 'Independent Reserve',
                'countries': [ 'AU', 'NZ' ], // Australia, New Zealand
                'rateLimit': 1000,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87182090-1e9e9080-c2ec-11ea-8e49-563db9a38f37.jpg',
                    'api': {
                        'public': 'https://api.independentreserve.com/Public',
                        'private': 'https://api.independentreserve.com/Private',
                    },
                    'www': 'https://www.independentreserve.com',
                    'doc': 'https://www.independentreserve.com/API',
                },
                'api': {
                    'public': {
                        'get': [
                            'GetValidPrimaryCurrencyCodes',
                            'GetValidSecondaryCurrencyCodes',
                            'GetValidLimitOrderTypes',
                            'GetValidMarketOrderTypes',
                            'GetValidOrderTypes',
                            'GetValidTransactionTypes',
                            'GetMarketSummary',
                            'GetOrderBook',
                            'GetAllOrders',
                            'GetTradeHistorySummary',
                            'GetRecentTrades',
                            'GetFxRates',
                            'GetOrderMinimumVolumes',
                            'GetCryptoWithdrawalFees',
                        ],
                    },
                    'private': {
                        'post': [
                            'GetOpenOrders',
                            'GetClosedOrders',
                            'GetClosedFilledOrders',
                            'GetOrderDetails',
                            'GetAccounts',
                            'GetTransactions',
                            'GetFiatBankAccounts',
                            'GetDigitalCurrencyDepositAddress',
                            'GetDigitalCurrencyDepositAddresses',
                            'GetTrades',
                            'GetBrokerageFees',
                            'GetDigitalCurrencyWithdrawal',
                            'PlaceLimitOrder',
                            'PlaceMarketOrder',
                            'CancelOrder',
                            'SynchDigitalCurrencyDepositAddressWithBlockchain',
                            'RequestFiatWithdrawal',
                            'WithdrawFiatCurrency',
                            'WithdrawDigitalCurrency',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'taker': 0.5 / 100,
                        'maker': 0.5 / 100,
                        'percentage': true,
                        'tierBased': false,
                    },
                },
                'commonCurrencies': {
                    'PLA': 'PlayChip',
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const baseCurrencies = await this.publicGetGetValidPrimaryCurrencyCodes (params);
            const quoteCurrencies = await this.publicGetGetValidSecondaryCurrencyCodes (params);
            const limits = await this.publicGetGetOrderMinimumVolumes (params);
            //
            //     {
            //         "Xbt": 0.0001,
            //         "Bch": 0.001,
            //         "Bsv": 0.001,
            //         "Eth": 0.001,
            //         "Ltc": 0.01,
            //         "Xrp": 1,
            //     }
            //
            const result = [];
            for (let i = 0; i < baseCurrencies.length; i++) {
                const baseId = baseCurrencies[i];
                const base = this.safeCurrencyCode (baseId);
                const minAmount = this.safeNumber (limits, baseId);
                for (let j = 0; j < quoteCurrencies.length; j++) {
                    const quoteId = quoteCurrencies[j];
                    const quote = this.safeCurrencyCode (quoteId);
                    const id = baseId + '/' + quoteId;
                    const symbol = base + '/' + quote;
                    result.push ({
                        'id': id,
                        'symbol': symbol,
                        'base': base,
                        'quote': quote,
                        'baseId': baseId,
                        'quoteId': quoteId,
                        'info': id,
                        'active': undefined,
                        'precision': this.precision,
                        'limits': {
                            'amount': { 'min': minAmount, 'max': undefined },
                        },
                    });
                }
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const balances = await this.privatePostGetAccounts (params);
            const result = { 'info': balances };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'CurrencyCode');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'AvailableBalance');
                account['total'] = this.safeString (balance, 'TotalBalance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'primaryCurrencyCode': market['baseId'],
                'secondaryCurrencyCode': market['quoteId'],
            };
            const response = await this.publicGetGetOrderBook (this.extend (request, params));
            const timestamp = this.parse8601 (this.safeString (response, 'CreatedTimestampUtc'));
            return this.parseOrderBook (response, symbol, timestamp, 'BuyOrders', 'SellOrders', 'Price', 'Volume');
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.parse8601 (this.safeString (ticker, 'CreatedTimestampUtc'));
            let symbol = undefined;
            if (market) {
                symbol = market['symbol'];
            }
            const last = this.safeNumber (ticker, 'LastPrice');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'DayHighestPrice'),
                'low': this.safeNumber (ticker, 'DayLowestPrice'),
                'bid': this.safeNumber (ticker, 'CurrentHighestBidPrice'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'CurrentLowestOfferPrice'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': this.safeNumber (ticker, 'DayAvgPrice'),
                'baseVolume': this.safeNumber (ticker, 'DayVolumeXbtInSecondaryCurrrency'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'primaryCurrencyCode': market['baseId'],
                'secondaryCurrencyCode': market['quoteId'],
            };
            const response = await this.publicGetGetMarketSummary (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        parseOrder (order, market = undefined) {
            //
            // fetchOrder
            //
            //     {
            //         "OrderGuid": "c7347e4c-b865-4c94-8f74-d934d4b0b177",
            //         "CreatedTimestampUtc": "2014-09-23T12:39:34.3817763Z",
            //         "Type": "MarketBid",
            //         "VolumeOrdered": 5.0,
            //         "VolumeFilled": 5.0,
            //         "Price": null,
            //         "AvgPrice": 100.0,
            //         "ReservedAmount": 0.0,
            //         "Status": "Filled",
            //         "PrimaryCurrencyCode": "Xbt",
            //         "SecondaryCurrencyCode": "Usd"
            //     }
            //
            // fetchOpenOrders & fetchClosedOrders
            //
            //     {
            //         "OrderGuid": "b8f7ad89-e4e4-4dfe-9ea3-514d38b5edb3",
            //         "CreatedTimestampUtc": "2020-09-08T03:04:18.616367Z",
            //         "OrderType": "LimitOffer",
            //         "Volume": 0.0005,
            //         "Outstanding": 0.0005,
            //         "Price": 113885.83,
            //         "AvgPrice": 113885.83,
            //         "Value": 56.94,
            //         "Status": "Open",
            //         "PrimaryCurrencyCode": "Xbt",
            //         "SecondaryCurrencyCode": "Usd",
            //         "FeePercent": 0.005,
            //     }
            //
            let symbol = undefined;
            const baseId = this.safeString (order, 'PrimaryCurrencyCode');
            const quoteId = this.safeString (order, 'SecondaryCurrencyCode');
            let base = undefined;
            let quote = undefined;
            if ((baseId !== undefined) && (quoteId !== undefined)) {
                base = this.safeCurrencyCode (baseId);
                quote = this.safeCurrencyCode (quoteId);
                symbol = base + '/' + quote;
            } else if (market !== undefined) {
                symbol = market['symbol'];
                base = market['base'];
                quote = market['quote'];
            }
            let orderType = this.safeString2 (order, 'Type', 'OrderType');
            let side = undefined;
            if (orderType.indexOf ('Bid') >= 0) {
                side = 'buy';
            } else if (orderType.indexOf ('Offer') >= 0) {
                side = 'sell';
            }
            if (orderType.indexOf ('Market') >= 0) {
                orderType = 'market';
            } else if (orderType.indexOf ('Limit') >= 0) {
                orderType = 'limit';
            }
            const timestamp = this.parse8601 (this.safeString (order, 'CreatedTimestampUtc'));
            const amount = this.safeNumber2 (order, 'VolumeOrdered', 'Volume');
            const filled = this.safeNumber (order, 'VolumeFilled');
            const remaining = this.safeNumber (order, 'Outstanding');
            const feeRate = this.safeNumber (order, 'FeePercent');
            let feeCost = undefined;
            if (feeRate !== undefined) {
                feeCost = feeRate * filled;
            }
            const fee = {
                'rate': feeRate,
                'cost': feeCost,
                'currency': base,
            };
            const id = this.safeString (order, 'OrderGuid');
            const status = this.parseOrderStatus (this.safeString (order, 'Status'));
            const cost = this.safeNumber (order, 'Value');
            const average = this.safeNumber (order, 'AvgPrice');
            const price = this.safeNumber (order, 'Price');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': orderType,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'average': average,
                'amount': amount,
                'filled': filled,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'Open': 'open',
                'PartiallyFilled': 'open',
                'Filled': 'closed',
                'PartiallyFilledAndCancelled': 'canceled',
                'Cancelled': 'canceled',
                'PartiallyFilledAndExpired': 'canceled',
                'Expired': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostGetOrderDetails (this.extend ({
                'orderGuid': id,
            }, params));
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            return this.parseOrder (response, market);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = this.ordered ({});
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['primaryCurrencyCode'] = market['baseId'];
                request['secondaryCurrencyCode'] = market['quoteId'];
            }
            if (limit === undefined) {
                limit = 50;
            }
            request['pageIndex'] = 1;
            request['pageSize'] = limit;
            const response = await this.privatePostGetOpenOrders (this.extend (request, params));
            const data = this.safeValue (response, 'Data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = this.ordered ({});
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['primaryCurrencyCode'] = market['baseId'];
                request['secondaryCurrencyCode'] = market['quoteId'];
            }
            if (limit === undefined) {
                limit = 50;
            }
            request['pageIndex'] = 1;
            request['pageSize'] = limit;
            const response = await this.privatePostGetClosedOrders (this.extend (request, params));
            const data = this.safeValue (response, 'Data', []);
            return this.parseOrders (data, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = 50, params = {}) {
            await this.loadMarkets ();
            const pageIndex = this.safeInteger (params, 'pageIndex', 1);
            if (limit === undefined) {
                limit = 50;
            }
            const request = this.ordered ({
                'pageIndex': pageIndex,
                'pageSize': limit,
            });
            const response = await this.privatePostGetTrades (this.extend (request, params));
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            return this.parseTrades (response['Data'], market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.parse8601 (trade['TradeTimestampUtc']);
            const id = this.safeString (trade, 'TradeGuid');
            const orderId = this.safeString (trade, 'OrderGuid');
            const priceString = this.safeString2 (trade, 'Price', 'SecondaryCurrencyTradePrice');
            const amountString = this.safeString2 (trade, 'VolumeTraded', 'PrimaryCurrencyAmount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const baseId = this.safeString (trade, 'PrimaryCurrencyCode');
            const quoteId = this.safeString (trade, 'SecondaryCurrencyCode');
            let marketId = undefined;
            if ((baseId !== undefined) && (quoteId !== undefined)) {
                marketId = baseId + '/' + quoteId;
            }
            const symbol = this.safeSymbol (marketId, market, '/');
            let side = this.safeString (trade, 'OrderType');
            if (side !== undefined) {
                if (side.indexOf ('Bid') >= 0) {
                    side = 'buy';
                } else if (side.indexOf ('Offer') >= 0) {
                    side = 'sell';
                }
            }
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'primaryCurrencyCode': market['baseId'],
                'secondaryCurrencyCode': market['quoteId'],
                'numberOfRecentTradesToRetrieve': 50, // max = 50
            };
            const response = await this.publicGetGetRecentTrades (this.extend (request, params));
            return this.parseTrades (response['Trades'], market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const capitalizedOrderType = this.capitalize (type);
            const method = 'privatePostPlace' + capitalizedOrderType + 'Order';
            let orderType = capitalizedOrderType;
            orderType += (side === 'sell') ? 'Offer' : 'Bid';
            const request = this.ordered ({
                'primaryCurrencyCode': market['baseId'],
                'secondaryCurrencyCode': market['quoteId'],
                'orderType': orderType,
            });
            if (type === 'limit') {
                request['price'] = price;
            }
            request['volume'] = amount;
            const response = await this[method] (this.extend (request, params));
            return {
                'info': response,
                'id': response['OrderGuid'],
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderGuid': id,
            };
            return await this.privatePostCancelOrder (this.extend (request, params));
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api] + '/' + path;
            if (api === 'public') {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ();
                const auth = [
                    url,
                    'apiKey=' + this.apiKey,
                    'nonce=' + nonce.toString (),
                ];
                const keys = Object.keys (params);
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    const value = params[key].toString ();
                    auth.push (key + '=' + value);
                }
                const message = auth.join (',');
                const signature = this.hmac (this.encode (message), this.encode (this.secret));
                const query = this.ordered ({});
                query['apiKey'] = this.apiKey;
                query['nonce'] = nonce;
                query['signature'] = signature.toUpperCase ();
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    query[key] = params[key];
                }
                body = this.json (query);
                headers = { 'Content-Type': 'application/json' };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7}],92:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, InsufficientFunds, InvalidOrder, OrderNotFound, AuthenticationError, BadSymbol } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class indodax extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'indodax',
                'name': 'INDODAX',
                'countries': [ 'ID' ], // Indonesia
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': false,
                    'fetchMarkets': true,
                    'fetchMyTrades': false,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': false,
                    'fetchTicker': true,
                    'fetchTickers': false,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'withdraw': true,
                },
                'version': '2.0', // as of 9 April 2018
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87070508-9358c880-c221-11ea-8dc5-5391afbbb422.jpg',
                    'api': {
                        'public': 'https://indodax.com/api',
                        'private': 'https://indodax.com/tapi',
                    },
                    'www': 'https://www.indodax.com',
                    'doc': 'https://github.com/btcid/indodax-official-api-docs',
                    'referral': 'https://indodax.com/ref/testbitcoincoid/1',
                },
                'api': {
                    'public': {
                        'get': [
                            'server_time',
                            'pairs',
                            '{pair}/ticker',
                            '{pair}/trades',
                            '{pair}/depth',
                        ],
                    },
                    'private': {
                        'post': [
                            'getInfo',
                            'transHistory',
                            'trade',
                            'tradeHistory',
                            'getOrder',
                            'openOrders',
                            'cancelOrder',
                            'orderHistory',
                            'withdrawCoin',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'maker': 0,
                        'taker': 0.003,
                    },
                },
                'exceptions': {
                    'exact': {
                        'invalid_pair': BadSymbol, // {"error":"invalid_pair","error_description":"Invalid Pair"}
                        'Insufficient balance.': InsufficientFunds,
                        'invalid order.': OrderNotFound,
                        'Invalid credentials. API not found or session has expired.': AuthenticationError,
                        'Invalid credentials. Bad sign.': AuthenticationError,
                    },
                    'broad': {
                        'Minimum price': InvalidOrder,
                        'Minimum order': InvalidOrder,
                    },
                },
                // exchange-specific options
                'options': {
                    'recvWindow': 5 * 1000, // default 5 sec
                    'timeDifference': 0, // the difference between system clock and exchange clock
                    'adjustForTimeDifference': false, // controls the adjustment logic upon instantiation
                },
                'commonCurrencies': {
                    'STR': 'XLM',
                    'BCHABC': 'BCH',
                    'BCHSV': 'BSV',
                    'DRK': 'DASH',
                    'NEM': 'XEM',
                },
            });
        }
    
        nonce () {
            return this.milliseconds () - this.options['timeDifference'];
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetServerTime (params);
            //
            //     {
            //         "timezone": "UTC",
            //         "server_time": 1571205969552
            //     }
            //
            return this.safeInteger (response, 'server_time');
        }
    
        async loadTimeDifference (params = {}) {
            const serverTime = await this.fetchTime (params);
            const after = this.milliseconds ();
            this.options['timeDifference'] = after - serverTime;
            return this.options['timeDifference'];
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetPairs (params);
            //
            //     [
            //         {
            //             "id": "btcidr",
            //             "symbol": "BTCIDR",
            //             "base_currency": "idr",
            //             "traded_currency": "btc",
            //             "traded_currency_unit": "BTC",
            //             "description": "BTC/IDR",
            //             "ticker_id": "btc_idr",
            //             "volume_precision": 0,
            //             "price_precision": 1000,
            //             "price_round": 8,
            //             "pricescale": 1000,
            //             "trade_min_base_currency": 10000,
            //             "trade_min_traded_currency": 0.00007457,
            //             "has_memo": false,
            //             "memo_name": false,
            //             "has_payment_id": false,
            //             "trade_fee_percent": 0.3,
            //             "url_logo": "https://indodax.com/v2/logo/svg/color/btc.svg",
            //             "url_logo_png": "https://indodax.com/v2/logo/png/color/btc.png",
            //             "is_maintenance": 0
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'ticker_id');
                const baseId = this.safeString (market, 'traded_currency');
                const quoteId = this.safeString (market, 'base_currency');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const taker = this.safeNumber (market, 'trade_fee_percent');
                const isMaintenance = this.safeInteger (market, 'is_maintenance');
                const active = (isMaintenance) ? false : true;
                const pricePrecision = this.safeInteger (market, 'price_round');
                const precision = {
                    'amount': 8,
                    'price': pricePrecision,
                };
                const limits = {
                    'amount': {
                        'min': this.safeNumber (market, 'trade_min_traded_currency'),
                        'max': undefined,
                    },
                    'price': {
                        'min': this.safeNumber (market, 'trade_min_base_currency'),
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'taker': taker,
                    'percentage': true,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                    'active': active,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostGetInfo (params);
            //
            //     {
            //         "success":1,
            //         "return":{
            //             "server_time":1619562628,
            //             "balance":{
            //                 "idr":167,
            //                 "btc":"0.00000000",
            //                 "1inch":"0.00000000",
            //             },
            //             "balance_hold":{
            //                 "idr":0,
            //                 "btc":"0.00000000",
            //                 "1inch":"0.00000000",
            //             },
            //             "address":{
            //                 "btc":"1KMntgzvU7iTSgMBWc11nVuJjAyfW3qJyk",
            //                 "1inch":"0x1106c8bb3172625e1f411c221be49161dac19355",
            //                 "xrp":"rwWr7KUZ3ZFwzgaDGjKBysADByzxvohQ3C",
            //                 "zrx":"0x1106c8bb3172625e1f411c221be49161dac19355"
            //             },
            //             "user_id":"276011",
            //             "name":"",
            //             "email":"testbitcoincoid@mailforspam.com",
            //             "profile_picture":null,
            //             "verification_status":"unverified",
            //             "gauth_enable":true
            //         }
            //     }
            //
            const balances = this.safeValue (response, 'return', {});
            const free = this.safeValue (balances, 'balance', {});
            const used = this.safeValue (balances, 'balance_hold', {});
            const timestamp = this.safeTimestamp (balances, 'server_time');
            const result = {
                'info': response,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
            };
            const currencyIds = Object.keys (free);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (free, currencyId);
                account['used'] = this.safeString (used, currencyId);
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'pair': this.marketId (symbol),
            };
            const orderbook = await this.publicGetPairDepth (this.extend (request, params));
            return this.parseOrderBook (orderbook, symbol, undefined, 'buy', 'sell');
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetPairTicker (this.extend (request, params));
            //
            //     {
            //         "ticker": {
            //             "high":"0.01951",
            //             "low":"0.01877",
            //             "vol_eth":"39.38839319",
            //             "vol_btc":"0.75320886",
            //             "last":"0.01896",
            //             "buy":"0.01896",
            //             "sell":"0.019",
            //             "server_time":1565248908
            //         }
            //     }
            //
            const ticker = response['ticker'];
            const timestamp = this.safeTimestamp (ticker, 'server_time');
            const baseVolume = 'vol_' + market['baseId'].toLowerCase ();
            const quoteVolume = 'vol_' + market['quoteId'].toLowerCase ();
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, baseVolume),
                'quoteVolume': this.safeNumber (ticker, quoteVolume),
                'info': ticker,
            };
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.safeTimestamp (trade, 'date');
            const id = this.safeString (trade, 'tid');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const type = undefined;
            const side = this.safeString (trade, 'type');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'order': undefined,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetPairTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'open': 'open',
                'filled': 'closed',
                'cancelled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "order_id": "12345",
            //         "submit_time": "1392228122",
            //         "price": "8000000",
            //         "type": "sell",
            //         "order_ltc": "100000000",
            //         "remain_ltc": "100000000"
            //     }
            //
            // market closed orders - note that the price is very high
            // and does not reflect actual price the order executed at
            //
            //     {
            //       "order_id": "49326856",
            //       "type": "sell",
            //       "price": "1000000000",
            //       "submit_time": "1618314671",
            //       "finish_time": "1618314671",
            //       "status": "filled",
            //       "order_xrp": "30.45000000",
            //       "remain_xrp": "0.00000000"
            //     }
            let side = undefined;
            if ('type' in order) {
                side = order['type'];
            }
            const status = this.parseOrderStatus (this.safeString (order, 'status', 'open'));
            let symbol = undefined;
            let cost = undefined;
            const price = this.safeNumber (order, 'price');
            let amount = undefined;
            let remaining = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
                let quoteId = market['quoteId'];
                let baseId = market['baseId'];
                if ((market['quoteId'] === 'idr') && ('order_rp' in order)) {
                    quoteId = 'rp';
                }
                if ((market['baseId'] === 'idr') && ('remain_rp' in order)) {
                    baseId = 'rp';
                }
                cost = this.safeNumber (order, 'order_' + quoteId);
                if (!cost) {
                    amount = this.safeNumber (order, 'order_' + baseId);
                    remaining = this.safeNumber (order, 'remain_' + baseId);
                }
            }
            const timestamp = this.safeInteger (order, 'submit_time');
            const fee = undefined;
            const id = this.safeString (order, 'order_id');
            return this.safeOrder ({
                'info': order,
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': 'limit',
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': cost,
                'average': undefined,
                'amount': amount,
                'filled': undefined,
                'remaining': remaining,
                'status': status,
                'fee': fee,
                'trades': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrder() requires a symbol');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'order_id': id,
            };
            const response = await this.privatePostGetOrder (this.extend (request, params));
            const orders = response['return'];
            const order = this.parseOrder (this.extend ({ 'id': id }, orders['order']), market);
            return this.extend ({ 'info': response }, order);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            const request = {};
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
            }
            const response = await this.privatePostOpenOrders (this.extend (request, params));
            const rawOrders = response['return']['orders'];
            // { success: 1, return: { orders: null }} if no orders
            if (!rawOrders) {
                return [];
            }
            // { success: 1, return: { orders: [ ... objects ] }} for orders fetched by symbol
            if (symbol !== undefined) {
                return this.parseOrders (rawOrders, market, since, limit);
            }
            // { success: 1, return: { orders: { marketid: [ ... objects ] }}} if all orders are fetched
            const marketIds = Object.keys (rawOrders);
            let exchangeOrders = [];
            for (let i = 0; i < marketIds.length; i++) {
                const marketId = marketIds[i];
                const marketOrders = rawOrders[marketId];
                market = this.markets_by_id[marketId];
                const parsedOrders = this.parseOrders (marketOrders, market, since, limit);
                exchangeOrders = this.arrayConcat (exchangeOrders, parsedOrders);
            }
            return exchangeOrders;
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['pair'] = market['id'];
            }
            const response = await this.privatePostOrderHistory (this.extend (request, params));
            let orders = this.parseOrders (response['return']['orders'], market);
            orders = this.filterBy (orders, 'status', 'closed');
            return this.filterBySymbolSinceLimit (orders, symbol, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            if (type !== 'limit') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'type': side,
                'price': price,
            };
            const currency = market['baseId'];
            if (side === 'buy') {
                request[market['quoteId']] = amount * price;
            } else {
                request[market['baseId']] = amount;
            }
            request[currency] = amount;
            const result = await this.privatePostTrade (this.extend (request, params));
            const data = this.safeValue (result, 'return', {});
            const id = this.safeString (data, 'order_id');
            return {
                'info': result,
                'id': id,
            };
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires a symbol argument');
            }
            const side = this.safeValue (params, 'side');
            if (side === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelOrder() requires an extra "side" param');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'order_id': id,
                'pair': market['id'],
                'type': side,
            };
            return await this.privatePostCancelOrder (this.extend (request, params));
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            // Custom string you need to provide to identify each withdrawal.
            // Will be passed to callback URL (assigned via website to the API key)
            // so your system can identify the request and confirm it.
            // Alphanumeric, max length 255.
            const requestId = this.milliseconds ();
            // Alternatively:
            // let requestId = this.uuid ();
            const request = {
                'currency': currency['id'],
                'withdraw_amount': amount,
                'withdraw_address': address,
                'request_id': requestId.toString (),
            };
            if (tag) {
                request['withdraw_memo'] = tag;
            }
            const response = await this.privatePostWithdrawCoin (this.extend (request, params));
            //
            //     {
            //         "success": 1,
            //         "status": "approved",
            //         "withdraw_currency": "xrp",
            //         "withdraw_address": "rwWr7KUZ3ZFwzgaDGjKBysADByzxvohQ3C",
            //         "withdraw_amount": "10000.00000000",
            //         "fee": "2.00000000",
            //         "amount_after_fee": "9998.00000000",
            //         "submit_time": "1509469200",
            //         "withdraw_id": "xrp-12345",
            //         "txid": "",
            //         "withdraw_memo": "123123"
            //     }
            //
            let id = undefined;
            if (('txid' in response) && (response['txid'].length > 0)) {
                id = response['txid'];
            }
            return {
                'info': response,
                'id': id,
            };
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'][api];
            if (api === 'public') {
                url += '/' + this.implodeParams (path, params);
            } else {
                this.checkRequiredCredentials ();
                body = this.urlencode (this.extend ({
                    'method': path,
                    'timestamp': this.nonce (),
                    'recvWindow': this.options['recvWindow'],
                }, params));
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Key': this.apiKey,
                    'Sign': this.hmac (this.encode (body), this.encode (this.secret), 'sha512'),
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            // { success: 0, error: "invalid order." }
            // or
            // [{ data, ... }, { ... }, ... ]
            if (Array.isArray (response)) {
                return; // public endpoints may return []-arrays
            }
            const error = this.safeValue (response, 'error', '');
            if (!('success' in response) && error === '') {
                return; // no 'success' property on public responses
            }
            if (this.safeInteger (response, 'success', 0) === 1) {
                // { success: 1, return: { orders: [] }}
                if (!('return' in response)) {
                    throw new ExchangeError (this.id + ': malformed response: ' + this.json (response));
                } else {
                    return;
                }
            }
            const feedback = this.id + ' ' + body;
            this.throwExactlyMatchedException (this.exceptions['exact'], error, feedback);
            this.throwBroadlyMatchedException (this.exceptions['broad'], error, feedback);
            throw new ExchangeError (feedback); // unknown message
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],93:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, AuthenticationError, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class itbit extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'itbit',
                'name': 'itBit',
                'countries': [ 'US' ],
                'rateLimit': 2000,
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'CORS': true,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTrades': true,
                    'fetchTransactions': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/27822159-66153620-60ad-11e7-89e7-005f6d7f3de0.jpg',
                    'api': 'https://api.itbit.com',
                    'www': 'https://www.itbit.com',
                    'doc': [
                        'https://api.itbit.com/docs',
                        'https://www.itbit.com/api',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            'markets/{symbol}/ticker',
                            'markets/{symbol}/order_book',
                            'markets/{symbol}/trades',
                        ],
                    },
                    'private': {
                        'get': [
                            'wallets',
                            'wallets/{walletId}',
                            'wallets/{walletId}/balances/{currencyCode}',
                            'wallets/{walletId}/funding_history',
                            'wallets/{walletId}/trades',
                            'wallets/{walletId}/orders',
                            'wallets/{walletId}/orders/{id}',
                        ],
                        'post': [
                            'wallet_transfers',
                            'wallets',
                            'wallets/{walletId}/cryptocurrency_deposits',
                            'wallets/{walletId}/cryptocurrency_withdrawals',
                            'wallets/{walletId}/orders',
                            'wire_withdrawal',
                        ],
                        'delete': [
                            'wallets/{walletId}/orders/{id}',
                        ],
                    },
                },
                'markets': {
                    'BTC/USD': { 'id': 'XBTUSD', 'symbol': 'BTC/USD', 'base': 'BTC', 'quote': 'USD', 'baseId': 'XBT', 'quoteId': 'USD' },
                    'BTC/SGD': { 'id': 'XBTSGD', 'symbol': 'BTC/SGD', 'base': 'BTC', 'quote': 'SGD', 'baseId': 'XBT', 'quoteId': 'SGD' },
                    'BTC/EUR': { 'id': 'XBTEUR', 'symbol': 'BTC/EUR', 'base': 'BTC', 'quote': 'EUR', 'baseId': 'XBT', 'quoteId': 'EUR' },
                    'ETH/USD': { 'id': 'ETHUSD', 'symbol': 'ETH/USD', 'base': 'ETH', 'quote': 'USD', 'baseId': 'ETH', 'quoteId': 'USD' },
                    'ETH/EUR': { 'id': 'ETHEUR', 'symbol': 'ETH/EUR', 'base': 'ETH', 'quote': 'EUR', 'baseId': 'ETH', 'quoteId': 'EUR' },
                    'ETH/SGD': { 'id': 'ETHSGD', 'symbol': 'ETH/SGD', 'base': 'ETH', 'quote': 'SGD', 'baseId': 'ETH', 'quoteId': 'SGD' },
                    'PAXGUSD': { 'id': 'PAXGUSD', 'symbol': 'PAXG/USD', 'base': 'PAXG', 'quote': 'USD', 'baseId': 'PAXG', 'quoteId': 'USD' },
                    'BCHUSD': { 'id': 'BCHUSD', 'symbol': 'BCH/USD', 'base': 'BCH', 'quote': 'USD', 'baseId': 'BCH', 'quoteId': 'USD' },
                    'LTCUSD': { 'id': 'LTCUSD', 'symbol': 'LTC/USD', 'base': 'LTC', 'quote': 'USD', 'baseId': 'LTC', 'quoteId': 'USD' },
                },
                'fees': {
                    'trading': {
                        'maker': -0.03 / 100,
                        'taker': 0.35 / 100,
                    },
                },
                'commonCurrencies': {
                    'XBT': 'BTC',
                },
            });
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            const orderbook = await this.publicGetMarketsSymbolOrderBook (this.extend (request, params));
            return this.parseOrderBook (orderbook, symbol);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': this.marketId (symbol),
            };
            const ticker = await this.publicGetMarketsSymbolTicker (this.extend (request, params));
            const serverTimeUTC = this.safeString (ticker, 'serverTimeUTC');
            if (!serverTimeUTC) {
                throw new ExchangeError (this.id + ' fetchTicker returned a bad response: ' + this.json (ticker));
            }
            const timestamp = this.parse8601 (serverTimeUTC);
            const vwap = this.safeNumber (ticker, 'vwap24h');
            const baseVolume = this.safeNumber (ticker, 'volume24h');
            let quoteVolume = undefined;
            if (baseVolume !== undefined && vwap !== undefined) {
                quoteVolume = baseVolume * vwap;
            }
            const last = this.safeNumber (ticker, 'lastPrice');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high24h'),
                'low': this.safeNumber (ticker, 'low24h'),
                'bid': this.safeNumber (ticker, 'bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'ask'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': this.safeNumber (ticker, 'openToday'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         timestamp: "2015-05-22T17:45:34.7570000Z",
            //         matchNumber: "5CR1JEUBBM8J",
            //         price: "351.45000000",
            //         amount: "0.00010000"
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         "orderId": "248ffda4-83a0-4033-a5bb-8929d523f59f",
            //         "timestamp": "2015-05-11T14:48:01.9870000Z",
            //         "instrument": "XBTUSD",
            //         "direction": "buy",                      // buy or sell
            //         "currency1": "XBT",                      // base currency
            //         "currency1Amount": "0.00010000",         // order amount in base currency
            //         "currency2": "USD",                      // quote currency
            //         "currency2Amount": "0.0250530000000000", // order cost in quote currency
            //         "rate": "250.53000000",
            //         "commissionPaid": "0.00000000",   // net trade fee paid after using any available rebate balance
            //         "commissionCurrency": "USD",
            //         "rebatesApplied": "-0.000125265", // negative values represent amount of rebate balance used for trades removing liquidity from order book; positive values represent amount of rebate balance earned from trades adding liquidity to order book
            //         "rebateCurrency": "USD",
            //         "executionId": "23132"
            //     }
            //
            const id = this.safeString2 (trade, 'executionId', 'matchNumber');
            const timestamp = this.parse8601 (this.safeString (trade, 'timestamp'));
            const side = this.safeString (trade, 'direction');
            const orderId = this.safeString (trade, 'orderId');
            let feeCost = this.safeNumber (trade, 'commissionPaid');
            const feeCurrencyId = this.safeString (trade, 'commissionCurrency');
            const feeCurrency = this.safeCurrencyCode (feeCurrencyId);
            let rebatesApplied = this.safeNumber (trade, 'rebatesApplied');
            if (rebatesApplied !== undefined) {
                rebatesApplied = -rebatesApplied;
            }
            const rebateCurrencyId = this.safeString (trade, 'rebateCurrency');
            const rebateCurrency = this.safeCurrencyCode (rebateCurrencyId);
            const priceString = this.safeString2 (trade, 'price', 'rate');
            const amountString = this.safeString2 (trade, 'currency1Amount', 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            let symbol = undefined;
            const marketId = this.safeString (trade, 'instrument');
            if (marketId !== undefined) {
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const baseId = this.safeString (trade, 'currency1');
                    const quoteId = this.safeString (trade, 'currency2');
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            if (symbol === undefined) {
                if (market !== undefined) {
                    symbol = market['symbol'];
                }
            }
            const result = {
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': orderId,
                'type': undefined,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
            if (feeCost !== undefined) {
                if (rebatesApplied !== undefined) {
                    if (feeCurrency === rebateCurrency) {
                        feeCost = this.sum (feeCost, rebatesApplied);
                        result['fee'] = {
                            'cost': feeCost,
                            'currency': feeCurrency,
                        };
                    } else {
                        result['fees'] = [
                            {
                                'cost': feeCost,
                                'currency': feeCurrency,
                            },
                            {
                                'cost': rebatesApplied,
                                'currency': rebateCurrency,
                            },
                        ];
                    }
                } else {
                    result['fee'] = {
                        'cost': feeCost,
                        'currency': feeCurrency,
                    };
                }
            }
            if (!('fee' in result)) {
                if (!('fees' in result)) {
                    result['fee'] = undefined;
                }
            }
            return result;
        }
    
        async fetchTransactions (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const walletId = this.safeString (params, 'walletId');
            if (walletId === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a walletId parameter');
            }
            const request = {
                'walletId': walletId,
            };
            if (limit !== undefined) {
                request['perPage'] = limit; // default 50, max 50
            }
            const response = await this.privateGetWalletsWalletIdFundingHistory (this.extend (request, params));
            //     { bankName: 'USBC (usd)',
            //         withdrawalId: 94740,
            //         holdingPeriodCompletionDate: '2018-04-16T07:57:05.9606869',
            //         time: '2018-04-16T07:57:05.9600000',
            //         currency: 'USD',
            //         transactionType: 'Withdrawal',
            //         amount: '2186.72000000',
            //         walletName: 'Wallet',
            //         status: 'completed' },
            //
            //     { "time": "2018-01-02T19:52:22.4176503",
            //     "amount": "0.50000000",
            //     "status": "completed",
            //     "txnHash": "1b6fff67ed83cb9e9a38ca4976981fc047322bc088430508fe764a127d3ace95",
            //     "currency": "XBT",
            //     "walletName": "Wallet",
            //     "transactionType": "Deposit",
            //     "destinationAddress": "3AAWTH9et4e8o51YKp9qPpmujrNXKwHWNX"}
            const items = response['fundingHistory'];
            const result = [];
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const time = this.safeString (item, 'time');
                const timestamp = this.parse8601 (time);
                const currency = this.safeString (item, 'currency');
                const destinationAddress = this.safeString (item, 'destinationAddress');
                const txnHash = this.safeString (item, 'txnHash');
                const transactionType = this.safeStringLower (item, 'transactionType');
                const transactionStatus = this.safeString (item, 'status');
                const status = this.parseTransferStatus (transactionStatus);
                result.push ({
                    'id': this.safeString (item, 'withdrawalId'),
                    'timestamp': timestamp,
                    'datetime': this.iso8601 (timestamp),
                    'currency': this.safeCurrencyCode (currency),
                    'address': destinationAddress,
                    'tag': undefined,
                    'txid': txnHash,
                    'type': transactionType,
                    'status': status,
                    'amount': this.safeNumber (item, 'amount'),
                    'fee': undefined,
                    'info': item,
                });
            }
            return result;
        }
    
        parseTransferStatus (status) {
            const options = {
                'cancelled': 'canceled',
                'completed': 'ok',
            };
            return this.safeString (options, status, 'pending');
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const walletId = this.safeString (params, 'walletId');
            if (walletId === undefined) {
                throw new ExchangeError (this.id + ' fetchMyTrades() requires a walletId parameter');
            }
            const request = {
                'walletId': walletId,
            };
            if (since !== undefined) {
                request['rangeStart'] = this.ymdhms (since, 'T');
            }
            if (limit !== undefined) {
                request['perPage'] = limit; // default 50, max 50
            }
            const response = await this.privateGetWalletsWalletIdTrades (this.extend (request, params));
            //
            //     {
            //         "totalNumberOfRecords": "2",
            //         "currentPageNumber": "1",
            //         "latestExecutionId": "332", // most recent execution at time of response
            //         "recordsPerPage": "50",
            //         "tradingHistory": [
            //             {
            //                 "orderId": "248ffda4-83a0-4033-a5bb-8929d523f59f",
            //                 "timestamp": "2015-05-11T14:48:01.9870000Z",
            //                 "instrument": "XBTUSD",
            //                 "direction": "buy",                      // buy or sell
            //                 "currency1": "XBT",                      // base currency
            //                 "currency1Amount": "0.00010000",         // order amount in base currency
            //                 "currency2": "USD",                      // quote currency
            //                 "currency2Amount": "0.0250530000000000", // order cost in quote currency
            //                 "rate": "250.53000000",
            //                 "commissionPaid": "0.00000000",   // net trade fee paid after using any available rebate balance
            //                 "commissionCurrency": "USD",
            //                 "rebatesApplied": "-0.000125265", // negative values represent amount of rebate balance used for trades removing liquidity from order book; positive values represent amount of rebate balance earned from trades adding liquidity to order book
            //                 "rebateCurrency": "USD",
            //                 "executionId": "23132"
            //             },
            //         ],
            //     }
            //
            const trades = this.safeValue (response, 'tradingHistory', []);
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetMarketsSymbolTrades (this.extend (request, params));
            //
            //     {
            //         count: 3,
            //         recentTrades: [
            //             {
            //                 timestamp: "2015-05-22T17:45:34.7570000Z",
            //                 matchNumber: "5CR1JEUBBM8J",
            //                 price: "351.45000000",
            //                 amount: "0.00010000"
            //             },
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'recentTrades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.fetchWallets (params);
            const balances = response[0]['balances'];
            const result = { 'info': response };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'availableBalance');
                account['total'] = this.safeString (balance, 'totalBalance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchWallets (params = {}) {
            await this.loadMarkets ();
            if (!this.uid) {
                throw new AuthenticationError (this.id + ' fetchWallets() requires uid API credential');
            }
            const request = {
                'userId': this.uid,
            };
            return await this.privateGetWallets (this.extend (request, params));
        }
    
        async fetchWallet (walletId, params = {}) {
            await this.loadMarkets ();
            const request = {
                'walletId': walletId,
            };
            return await this.privateGetWalletsWalletId (this.extend (request, params));
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': 'open',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': 'filled',
            };
            return await this.fetchOrders (symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const walletIdInParams = ('walletId' in params);
            if (!walletIdInParams) {
                throw new ExchangeError (this.id + ' fetchOrders() requires a walletId parameter');
            }
            const walletId = params['walletId'];
            const request = {
                'walletId': walletId,
            };
            const response = await this.privateGetWalletsWalletIdOrders (this.extend (request, params));
            return this.parseOrders (response, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'submitted': 'open', // order pending book entry
                'open': 'open',
                'filled': 'closed',
                'cancelled': 'canceled',
                'rejected': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "id": "13d6af57-8b0b-41e5-af30-becf0bcc574d",
            //         "walletId": "7e037345-1288-4c39-12fe-d0f99a475a98",
            //         "side": "buy",
            //         "instrument": "XBTUSD",
            //         "type": "limit",
            //         "currency": "XBT",
            //         "amount": "2.50000000",
            //         "displayAmount": "2.50000000",
            //         "price": "650.00000000",
            //         "volumeWeightedAveragePrice": "0.00000000",
            //         "amountFilled": "0.00000000",
            //         "createdTime": "2014-02-11T17:05:15Z",
            //         "status": "submitted",
            //         "funds": null,
            //         "metadata": {},
            //         "clientOrderIdentifier": null,
            //         "postOnly": "False"
            //     }
            //
            const side = this.safeString (order, 'side');
            const type = this.safeString (order, 'type');
            const symbol = this.markets_by_id[order['instrument']]['symbol'];
            const timestamp = this.parse8601 (order['createdTime']);
            const amount = this.safeNumber (order, 'amount');
            const filled = this.safeNumber (order, 'amountFilled');
            const fee = undefined;
            const price = this.safeNumber (order, 'price');
            const average = this.safeNumber (order, 'volumeWeightedAveragePrice');
            const clientOrderId = this.safeString (order, 'clientOrderIdentifier');
            const id = this.safeString (order, 'id');
            const postOnlyString = this.safeString (order, 'postOnly');
            const postOnly = (postOnlyString === 'True');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': this.parseOrderStatus (this.safeString (order, 'status')),
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': postOnly,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'average': average,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'fee': fee,
                // 'trades': this.parseTrades (order['trades'], market),
                'trades': undefined,
            });
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            if (type === 'market') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            const walletIdInParams = ('walletId' in params);
            if (!walletIdInParams) {
                throw new ExchangeError (this.id + ' createOrder() requires a walletId parameter');
            }
            amount = amount.toString ();
            price = price.toString ();
            const market = this.market (symbol);
            const request = {
                'side': side,
                'type': type,
                'currency': market['id'].replace (market['quote'], ''),
                'amount': amount,
                'display': amount,
                'price': price,
                'instrument': market['id'],
            };
            const response = await this.privatePostWalletsWalletIdOrders (this.extend (request, params));
            return {
                'info': response,
                'id': response['id'],
            };
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const walletIdInParams = ('walletId' in params);
            if (!walletIdInParams) {
                throw new ExchangeError (this.id + ' fetchOrder() requires a walletId parameter');
            }
            const request = {
                'id': id,
            };
            const response = await this.privateGetWalletsWalletIdOrdersId (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            const walletIdInParams = ('walletId' in params);
            if (!walletIdInParams) {
                throw new ExchangeError (this.id + ' cancelOrder() requires a walletId parameter');
            }
            const request = {
                'id': id,
            };
            return await this.privateDeleteWalletsWalletIdOrdersId (this.extend (request, params));
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            if (method === 'GET' && Object.keys (query).length) {
                url += '?' + this.urlencode (query);
            }
            if (method === 'POST' && Object.keys (query).length) {
                body = this.json (query);
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const timestamp = nonce;
                const authBody = (method === 'POST') ? body : '';
                const auth = [ method, url, authBody, nonce, timestamp ];
                const message = nonce + this.json (auth).replace ('\\/', '/');
                const hash = this.hash (this.encode (message), 'sha256', 'binary');
                const binaryUrl = this.stringToBinary (this.encode (url));
                const binhash = this.binaryConcat (binaryUrl, hash);
                const signature = this.hmac (binhash, this.encode (this.secret), 'sha512', 'base64');
                headers = {
                    'Authorization': this.apiKey + ':' + signature,
                    'Content-Type': 'application/json',
                    'X-Auth-Timestamp': timestamp,
                    'X-Auth-Nonce': nonce,
                };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const code = this.safeString (response, 'code');
            if (code !== undefined) {
                throw new ExchangeError (this.id + ' ' + this.json (response));
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],94:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { BadSymbol, BadRequest, ExchangeNotAvailable, ArgumentsRequired, PermissionDenied, AuthenticationError, ExchangeError, OrderNotFound, DDoSProtection, InvalidNonce, InsufficientFunds, CancelPending, InvalidOrder, InvalidAddress, RateLimitExceeded } = require ('./base/errors');
    const { TRUNCATE, DECIMAL_PLACES } = require ('./base/functions/number');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class kraken extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'kraken',
                'name': 'Kraken',
                'countries': [ 'US' ],
                'version': '0',
                'rateLimit': 3000,
                'certified': true,
                'pro': true,
                'has': {
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'CORS': false,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchLedger': true,
                    'fetchLedgerEntry': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrderTrades': 'emulated',
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchTradingFee': true,
                    'fetchTradingFees': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'marketsByAltname': {},
                'timeframes': {
                    '1m': 1,
                    '5m': 5,
                    '15m': 15,
                    '30m': 30,
                    '1h': 60,
                    '4h': 240,
                    '1d': 1440,
                    '1w': 10080,
                    '2w': 21600,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/76173629-fc67fb00-61b1-11ea-84fe-f2de582f58a3.jpg',
                    'api': {
                        'public': 'https://api.kraken.com',
                        'private': 'https://api.kraken.com',
                        'zendesk': 'https://kraken.zendesk.com/api/v2/help_center/en-us/articles', // use the public zendesk api to receive article bodies and bypass new anti-spam protections
                    },
                    'www': 'https://www.kraken.com',
                    'doc': 'https://www.kraken.com/features/api',
                    'fees': 'https://www.kraken.com/en-us/features/fee-schedule',
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': 0.26 / 100,
                        'maker': 0.16 / 100,
                        'tiers': {
                            'taker': [
                                [0, 0.0026],
                                [50000, 0.0024],
                                [100000, 0.0022],
                                [250000, 0.0020],
                                [500000, 0.0018],
                                [1000000, 0.0016],
                                [2500000, 0.0014],
                                [5000000, 0.0012],
                                [10000000, 0.0001],
                            ],
                            'maker': [
                                [0, 0.0016],
                                [50000, 0.0014],
                                [100000, 0.0012],
                                [250000, 0.0010],
                                [500000, 0.0008],
                                [1000000, 0.0006],
                                [2500000, 0.0004],
                                [5000000, 0.0002],
                                [10000000, 0.0],
                            ],
                        },
                    },
                    // this is a bad way of hardcoding fees that change on daily basis
                    // hardcoding is now considered obsolete, we will remove all of it eventually
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                        'withdraw': {
                            'BTC': 0.001,
                            'ETH': 0.005,
                            'XRP': 0.02,
                            'XLM': 0.00002,
                            'LTC': 0.02,
                            'DOGE': 2,
                            'ZEC': 0.00010,
                            'ICN': 0.02,
                            'REP': 0.01,
                            'ETC': 0.005,
                            'MLN': 0.003,
                            'XMR': 0.05,
                            'DASH': 0.005,
                            'GNO': 0.01,
                            'EOS': 0.5,
                            'BCH': 0.001,
                            'XTZ': 0.05,
                            'USD': 5, // if domestic wire
                            'EUR': 5, // if domestic wire
                            'CAD': 10, // CAD EFT Withdrawal
                            'JPY': 300, // if domestic wire
                        },
                        'deposit': {
                            'BTC': 0,
                            'ETH': 0,
                            'XRP': 0,
                            'XLM': 0,
                            'LTC': 0,
                            'DOGE': 0,
                            'ZEC': 0,
                            'ICN': 0,
                            'REP': 0,
                            'ETC': 0,
                            'MLN': 0,
                            'XMR': 0,
                            'DASH': 0,
                            'GNO': 0,
                            'EOS': 0,
                            'BCH': 0,
                            'XTZ': 0.05,
                            'USD': 5, // if domestic wire
                            'EUR': 0, // free deposit if EUR SEPA Deposit
                            'CAD': 5, // if domestic wire
                            'JPY': 0, // Domestic Deposit (Free, ¥5,000 deposit minimum)
                        },
                    },
                },
                'api': {
                    'zendesk': {
                        'get': [
                            // we should really refrain from putting fixed fee numbers and stop hardcoding
                            // we will be using their web APIs to scrape all numbers from these articles
                            '360000292886', // -What-are-the-deposit-fees-
                            '201893608', // -What-are-the-withdrawal-fees-
                        ],
                    },
                    'public': {
                        'get': [
                            'Assets',
                            'AssetPairs',
                            'Depth',
                            'OHLC',
                            'Spread',
                            'Ticker',
                            'Time',
                            'Trades',
                        ],
                    },
                    'private': {
                        'post': [
                            'AddOrder',
                            'AddExport',
                            'Balance',
                            'CancelAll',
                            'CancelOrder',
                            'ClosedOrders',
                            'DepositAddresses',
                            'DepositMethods',
                            'DepositStatus',
                            'ExportStatus',
                            'GetWebSocketsToken',
                            'Ledgers',
                            'OpenOrders',
                            'OpenPositions',
                            'QueryLedgers',
                            'QueryOrders',
                            'QueryTrades',
                            'RetrieveExport',
                            'RemoveExport',
                            'TradeBalance',
                            'TradesHistory',
                            'TradeVolume',
                            'Withdraw',
                            'WithdrawCancel',
                            'WithdrawInfo',
                            'WithdrawStatus',
                        ],
                    },
                },
                'commonCurrencies': {
                    'XBT': 'BTC',
                    'XBT.M': 'BTC.M', // https://support.kraken.com/hc/en-us/articles/360039879471-What-is-Asset-S-and-Asset-M-
                    'XDG': 'DOGE',
                    'REPV2': 'REP',
                    'REP': 'REPV1',
                },
                'options': {
                    'cacheDepositMethodsOnFetchDepositAddress': true, // will issue up to two calls in fetchDepositAddress
                    'depositMethods': {},
                    'delistedMarketsById': {},
                    // cannot withdraw/deposit these
                    'inactiveCurrencies': [ 'CAD', 'USD', 'JPY', 'GBP' ],
                },
                'exceptions': {
                    'EQuery:Invalid asset pair': BadSymbol, // {"error":["EQuery:Invalid asset pair"]}
                    'EAPI:Invalid key': AuthenticationError,
                    'EFunding:Unknown withdraw key': ExchangeError,
                    'EFunding:Invalid amount': InsufficientFunds,
                    'EService:Unavailable': ExchangeNotAvailable,
                    'EDatabase:Internal error': ExchangeNotAvailable,
                    'EService:Busy': ExchangeNotAvailable,
                    'EQuery:Unknown asset': ExchangeError,
                    'EAPI:Rate limit exceeded': DDoSProtection,
                    'EOrder:Rate limit exceeded': DDoSProtection,
                    'EGeneral:Internal error': ExchangeNotAvailable,
                    'EGeneral:Temporary lockout': DDoSProtection,
                    'EGeneral:Permission denied': PermissionDenied,
                    'EOrder:Unknown order': InvalidOrder,
                    'EOrder:Order minimum not met': InvalidOrder,
                    'EGeneral:Invalid arguments': BadRequest,
                    'ESession:Invalid session': AuthenticationError,
                    'EAPI:Invalid nonce': InvalidNonce,
                },
            });
        }
    
        costToPrecision (symbol, cost) {
            return this.decimalToPrecision (cost, TRUNCATE, this.markets[symbol]['precision']['price'], DECIMAL_PLACES);
        }
    
        feeToPrecision (symbol, fee) {
            return this.decimalToPrecision (fee, TRUNCATE, this.markets[symbol]['precision']['amount'], DECIMAL_PLACES);
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetAssetPairs (params);
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "ADAETH":{
            //                 "altname":"ADAETH",
            //                 "wsname":"ADA\/ETH",
            //                 "aclass_base":"currency",
            //                 "base":"ADA",
            //                 "aclass_quote":"currency",
            //                 "quote":"XETH",
            //                 "lot":"unit",
            //                 "pair_decimals":7,
            //                 "lot_decimals":8,
            //                 "lot_multiplier":1,
            //                 "leverage_buy":[],
            //                 "leverage_sell":[],
            //                 "fees":[
            //                     [0,0.26],
            //                     [50000,0.24],
            //                     [100000,0.22],
            //                     [250000,0.2],
            //                     [500000,0.18],
            //                     [1000000,0.16],
            //                     [2500000,0.14],
            //                     [5000000,0.12],
            //                     [10000000,0.1]
            //                 ],
            //                 "fees_maker":[
            //                     [0,0.16],
            //                     [50000,0.14],
            //                     [100000,0.12],
            //                     [250000,0.1],
            //                     [500000,0.08],
            //                     [1000000,0.06],
            //                     [2500000,0.04],
            //                     [5000000,0.02],
            //                     [10000000,0]
            //                 ],
            //                 "fee_volume_currency":"ZUSD",
            //                 "margin_call":80,
            //                 "margin_stop":40,
            //                 "ordermin": "1"
            //             },
            //         }
            //     }
            //
            const markets = this.safeValue (response, 'result', {});
            const keys = Object.keys (markets);
            let result = [];
            for (let i = 0; i < keys.length; i++) {
                const id = keys[i];
                const market = markets[id];
                const baseId = this.safeString (market, 'base');
                const quoteId = this.safeString (market, 'quote');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const darkpool = id.indexOf ('.d') >= 0;
                const altname = this.safeString (market, 'altname');
                const symbol = darkpool ? altname : (base + '/' + quote);
                const makerFees = this.safeValue (market, 'fees_maker', []);
                const firstMakerFee = this.safeValue (makerFees, 0, []);
                const firstMakerFeeRate = this.safeNumber (firstMakerFee, 1);
                let maker = undefined;
                if (firstMakerFeeRate !== undefined) {
                    maker = parseFloat (firstMakerFeeRate) / 100;
                }
                const takerFees = this.safeValue (market, 'fees', []);
                const firstTakerFee = this.safeValue (takerFees, 0, []);
                const firstTakerFeeRate = this.safeNumber (firstTakerFee, 1);
                let taker = undefined;
                if (firstTakerFeeRate !== undefined) {
                    taker = parseFloat (firstTakerFeeRate) / 100;
                }
                const precision = {
                    'amount': this.safeInteger (market, 'lot_decimals'),
                    'price': this.safeInteger (market, 'pair_decimals'),
                };
                const minAmount = this.safeNumber (market, 'ordermin');
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'darkpool': darkpool,
                    'info': market,
                    'altname': market['altname'],
                    'maker': maker,
                    'taker': taker,
                    'active': true,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': minAmount,
                            'max': Math.pow (10, precision['amount']),
                        },
                        'price': {
                            'min': Math.pow (10, -precision['price']),
                            'max': undefined,
                        },
                        'cost': {
                            'min': 0,
                            'max': undefined,
                        },
                    },
                });
            }
            result = this.appendInactiveMarkets (result);
            this.marketsByAltname = this.indexBy (result, 'altname');
            return result;
        }
    
        safeCurrency (currencyId, currency = undefined) {
            if (currencyId.length > 3) {
                if ((currencyId.indexOf ('X') === 0) || (currencyId.indexOf ('Z') === 0)) {
                    if (currencyId.indexOf ('.') > 0) {
                        return super.safeCurrency (currencyId, currency);
                    } else {
                        currencyId = currencyId.slice (1);
                    }
                }
            }
            return super.safeCurrency (currencyId, currency);
        }
    
        appendInactiveMarkets (result) {
            // result should be an array to append to
            const precision = { 'amount': 8, 'price': 8 };
            const costLimits = { 'min': 0, 'max': undefined };
            const priceLimits = { 'min': Math.pow (10, -precision['price']), 'max': undefined };
            const amountLimits = { 'min': Math.pow (10, -precision['amount']), 'max': Math.pow (10, precision['amount']) };
            const limits = { 'amount': amountLimits, 'price': priceLimits, 'cost': costLimits };
            const defaults = {
                'darkpool': false,
                'info': undefined,
                'maker': undefined,
                'taker': undefined,
                'active': false,
                'precision': precision,
                'limits': limits,
            };
            const markets = [
                // { 'id': 'XXLMZEUR', 'symbol': 'XLM/EUR', 'base': 'XLM', 'quote': 'EUR', 'altname': 'XLMEUR' },
            ];
            for (let i = 0; i < markets.length; i++) {
                result.push (this.extend (defaults, markets[i]));
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetAssets (params);
            //
            //     {
            //         "error": [],
            //         "result": {
            //             "ADA": { "aclass": "currency", "altname": "ADA", "decimals": 8, "display_decimals": 6 },
            //             "BCH": { "aclass": "currency", "altname": "BCH", "decimals": 10, "display_decimals": 5 },
            //             ...
            //         },
            //     }
            //
            const currencies = this.safeValue (response, 'result');
            const ids = Object.keys (currencies);
            const result = {};
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const currency = currencies[id];
                // todo: will need to rethink the fees
                // see: https://support.kraken.com/hc/en-us/articles/201893608-What-are-the-withdrawal-fees-
                // to add support for multiple withdrawal/deposit methods and
                // differentiated fees for each particular method
                const code = this.safeCurrencyCode (this.safeString (currency, 'altname'));
                const precision = this.safeInteger (currency, 'decimals');
                // assumes all currencies are active except those listed above
                const active = !this.inArray (code, this.options['inactiveCurrencies']);
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'name': code,
                    'active': active,
                    'fee': undefined,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision),
                            'max': Math.pow (10, precision),
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': Math.pow (10, precision),
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchTradingFees (params = {}) {
            await this.loadMarkets ();
            this.checkRequiredCredentials ();
            const response = await this.privatePostTradeVolume (params);
            const tradedVolume = this.safeNumber (response['result'], 'volume');
            const tiers = this.fees['trading']['tiers'];
            let taker = tiers['taker'][1];
            let maker = tiers['maker'][1];
            for (let i = 0; i < tiers['taker'].length; i++) {
                if (tradedVolume >= tiers['taker'][i][0]) {
                    taker = tiers['taker'][i][1];
                }
            }
            for (let i = 0; i < tiers['maker'].length; i++) {
                if (tradedVolume >= tiers['maker'][i][0]) {
                    maker = tiers['maker'][i][1];
                }
            }
            return {
                'info': response,
                'maker': maker,
                'taker': taker,
            };
        }
    
        parseBidAsk (bidask, priceKey = 0, amountKey = 1) {
            const price = this.safeNumber (bidask, priceKey);
            const amount = this.safeNumber (bidask, amountKey);
            const timestamp = this.safeInteger (bidask, 2);
            return [ price, amount, timestamp ];
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (market['darkpool']) {
                throw new ExchangeError (this.id + ' does not provide an order book for darkpool symbol ' + symbol);
            }
            const request = {
                'pair': market['id'],
            };
            if (limit !== undefined) {
                request['count'] = limit; // 100
            }
            const response = await this.publicGetDepth (this.extend (request, params));
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "XETHXXBT":{
            //                 "asks":[
            //                     ["0.023480","4.000",1586321307],
            //                     ["0.023490","50.095",1586321306],
            //                     ["0.023500","28.535",1586321302],
            //                 ],
            //                 "bids":[
            //                     ["0.023470","59.580",1586321307],
            //                     ["0.023460","20.000",1586321301],
            //                     ["0.023440","67.832",1586321306],
            //                 ]
            //             }
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', {});
            let orderbook = this.safeValue (result, market['id']);
            // sometimes kraken returns wsname instead of market id
            // https://github.com/ccxt/ccxt/issues/8662
            const marketInfo = this.safeValue (market, 'info', {});
            const wsName = this.safeValue (marketInfo, 'wsname');
            if (wsName !== undefined) {
                orderbook = this.safeValue (result, wsName, orderbook);
            }
            return this.parseOrderBook (orderbook, symbol);
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.milliseconds ();
            let symbol = undefined;
            if (market) {
                symbol = market['symbol'];
            }
            const baseVolume = parseFloat (ticker['v'][1]);
            const vwap = parseFloat (ticker['p'][1]);
            let quoteVolume = undefined;
            if (baseVolume !== undefined && vwap !== undefined) {
                quoteVolume = baseVolume * vwap;
            }
            const last = parseFloat (ticker['c'][0]);
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': parseFloat (ticker['h'][1]),
                'low': parseFloat (ticker['l'][1]),
                'bid': parseFloat (ticker['b'][0]),
                'bidVolume': undefined,
                'ask': parseFloat (ticker['a'][0]),
                'askVolume': undefined,
                'vwap': vwap,
                'open': this.safeNumber (ticker, 'o'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            symbols = (symbols === undefined) ? this.symbols : symbols;
            const marketIds = [];
            for (let i = 0; i < symbols.length; i++) {
                const symbol = symbols[i];
                const market = this.markets[symbol];
                if (market['active'] && !market['darkpool']) {
                    marketIds.push (market['id']);
                }
            }
            const request = {
                'pair': marketIds.join (','),
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const tickers = response['result'];
            const ids = Object.keys (tickers);
            const result = {};
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                const market = this.markets_by_id[id];
                const symbol = market['symbol'];
                const ticker = tickers[id];
                result[symbol] = this.parseTicker (ticker, market);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const darkpool = symbol.indexOf ('.d') >= 0;
            if (darkpool) {
                throw new ExchangeError (this.id + ' does not provide a ticker for darkpool symbol ' + symbol);
            }
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const ticker = response['result'][market['id']];
            return this.parseTicker (ticker, market);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1591475640,
            //         "0.02500",
            //         "0.02500",
            //         "0.02500",
            //         "0.02500",
            //         "0.02500",
            //         "9.12201000",
            //         5
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 6),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'interval': this.timeframes[timeframe],
            };
            if (since !== undefined) {
                request['since'] = parseInt ((since - 1) / 1000);
            }
            const response = await this.publicGetOHLC (this.extend (request, params));
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "XETHXXBT":[
            //                 [1591475580,"0.02499","0.02499","0.02499","0.02499","0.00000","0.00000000",0],
            //                 [1591475640,"0.02500","0.02500","0.02500","0.02500","0.02500","9.12201000",5],
            //                 [1591475700,"0.02499","0.02499","0.02499","0.02499","0.02499","1.28681415",2],
            //                 [1591475760,"0.02499","0.02499","0.02499","0.02499","0.02499","0.08800000",1],
            //             ],
            //             "last":1591517580
            //         }
            //     }
            const result = this.safeValue (response, 'result', {});
            const ohlcvs = this.safeValue (result, market['id'], []);
            return this.parseOHLCVs (ohlcvs, market, timeframe, since, limit);
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'trade': 'trade',
                'withdrawal': 'transaction',
                'deposit': 'transaction',
                'transfer': 'transfer',
                'margin': 'margin',
            };
            return this.safeString (types, type, type);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            //     {
            //         'LTFK7F-N2CUX-PNY4SX': {
            //             refid: "TSJTGT-DT7WN-GPPQMJ",
            //             time:  1520102320.555,
            //             type: "trade",
            //             aclass: "currency",
            //             asset: "XETH",
            //             amount: "0.1087194600",
            //             fee: "0.0000000000",
            //             balance: "0.2855851000"
            //         },
            //         ...
            //     }
            //
            const id = this.safeString (item, 'id');
            let direction = undefined;
            const account = undefined;
            const referenceId = this.safeString (item, 'refid');
            const referenceAccount = undefined;
            const type = this.parseLedgerEntryType (this.safeString (item, 'type'));
            const code = this.safeCurrencyCode (this.safeString (item, 'asset'), currency);
            let amount = this.safeNumber (item, 'amount');
            if (amount < 0) {
                direction = 'out';
                amount = Math.abs (amount);
            } else {
                direction = 'in';
            }
            const time = this.safeNumber (item, 'time');
            let timestamp = undefined;
            if (time !== undefined) {
                timestamp = parseInt (time * 1000);
            }
            const fee = {
                'cost': this.safeNumber (item, 'fee'),
                'currency': code,
            };
            const before = undefined;
            const after = this.safeNumber (item, 'balance');
            const status = 'ok';
            return {
                'info': item,
                'id': id,
                'direction': direction,
                'account': account,
                'referenceId': referenceId,
                'referenceAccount': referenceAccount,
                'type': type,
                'currency': code,
                'amount': amount,
                'before': before,
                'after': after,
                'status': status,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': fee,
            };
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            // https://www.kraken.com/features/api#get-ledgers-info
            await this.loadMarkets ();
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['asset'] = currency['id'];
            }
            if (since !== undefined) {
                request['start'] = parseInt (since / 1000);
            }
            const response = await this.privatePostLedgers (this.extend (request, params));
            // {  error: [],
            //   result: { ledger: { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
            //                                                   time:  1520103488.314,
            //                                                   type: "withdrawal",
            //                                                 aclass: "currency",
            //                                                  asset: "XETH",
            //                                                 amount: "-0.2805800000",
            //                                                    fee: "0.0050000000",
            //                                                balance: "0.0000051000"           },
            const result = this.safeValue (response, 'result', {});
            const ledger = this.safeValue (result, 'ledger', {});
            const keys = Object.keys (ledger);
            const items = [];
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const value = ledger[key];
                value['id'] = key;
                items.push (value);
            }
            return this.parseLedger (items, currency, since, limit);
        }
    
        async fetchLedgerEntriesByIds (ids, code = undefined, params = {}) {
            // https://www.kraken.com/features/api#query-ledgers
            await this.loadMarkets ();
            ids = ids.join (',');
            const request = this.extend ({
                'id': ids,
            }, params);
            const response = await this.privatePostQueryLedgers (request);
            // {  error: [],
            //   result: { 'LPUAIB-TS774-UKHP7X': {   refid: "A2B4HBV-L4MDIE-JU4N3N",
            //                                         time:  1520103488.314,
            //                                         type: "withdrawal",
            //                                       aclass: "currency",
            //                                        asset: "XETH",
            //                                       amount: "-0.2805800000",
            //                                          fee: "0.0050000000",
            //                                      balance: "0.0000051000"           } } }
            const result = response['result'];
            const keys = Object.keys (result);
            const items = [];
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                const value = result[key];
                value['id'] = key;
                items.push (value);
            }
            return this.parseLedger (items);
        }
    
        async fetchLedgerEntry (id, code = undefined, params = {}) {
            const items = await this.fetchLedgerEntriesByIds ([ id ], code, params);
            return items[0];
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     [
            //         "0.032310", // price
            //         "4.28169434", // amount
            //         1541390792.763, // timestamp
            //         "s", // sell or buy
            //         "l", // limit or market
            //         ""
            //     ]
            //
            // fetchOrderTrades (private)
            //
            //     {
            //         id: 'TIMIRG-WUNNE-RRJ6GT', // injected from outside
            //         ordertxid: 'OQRPN2-LRHFY-HIFA7D',
            //         postxid: 'TKH2SE-M7IF5-CFI7LT',
            //         pair: 'USDCUSDT',
            //         time: 1586340086.457,
            //         type: 'sell',
            //         ordertype: 'market',
            //         price: '0.99860000',
            //         cost: '22.16892001',
            //         fee: '0.04433784',
            //         vol: '22.20000000',
            //         margin: '0.00000000',
            //         misc: ''
            //     }
            //
            let timestamp = undefined;
            let side = undefined;
            let type = undefined;
            let priceString = undefined;
            let amountString = undefined;
            let id = undefined;
            let orderId = undefined;
            let fee = undefined;
            let symbol = undefined;
            if (Array.isArray (trade)) {
                timestamp = this.safeTimestamp (trade, 2);
                side = (trade[3] === 's') ? 'sell' : 'buy';
                type = (trade[4] === 'l') ? 'limit' : 'market';
                priceString = this.safeString (trade, 0);
                amountString = this.safeString (trade, 1);
                const tradeLength = trade.length;
                if (tradeLength > 6) {
                    id = this.safeString (trade, 6); // artificially added as per #1794
                }
            } else if (typeof trade === 'string') {
                id = trade;
            } else if ('ordertxid' in trade) {
                const marketId = this.safeString (trade, 'pair');
                const foundMarket = this.findMarketByAltnameOrId (marketId);
                if (foundMarket !== undefined) {
                    market = foundMarket;
                } else if (marketId !== undefined) {
                    // delisted market ids go here
                    market = this.getDelistedMarketById (marketId);
                }
                orderId = this.safeString (trade, 'ordertxid');
                id = this.safeString2 (trade, 'id', 'postxid');
                timestamp = this.safeTimestamp (trade, 'time');
                side = this.safeString (trade, 'type');
                type = this.safeString (trade, 'ordertype');
                priceString = this.safeString (trade, 'price');
                amountString = this.safeString (trade, 'vol');
                if ('fee' in trade) {
                    let currency = undefined;
                    if (market !== undefined) {
                        currency = market['quote'];
                    }
                    fee = {
                        'cost': this.safeNumber (trade, 'fee'),
                        'currency': currency,
                    };
                }
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            return {
                'id': id,
                'order': orderId,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const id = market['id'];
            const request = {
                'pair': id,
            };
            // https://support.kraken.com/hc/en-us/articles/218198197-How-to-pull-all-trade-data-using-the-Kraken-REST-API
            // https://github.com/ccxt/ccxt/issues/5677
            if (since !== undefined) {
                // php does not format it properly
                // therefore we use string concatenation here
                request['since'] = since * 1e6;
                request['since'] = since.toString () + '000000'; // expected to be in nanoseconds
            }
            // https://github.com/ccxt/ccxt/issues/5698
            if (limit !== undefined && limit !== 1000) {
                const fetchTradesWarning = this.safeValue (this.options, 'fetchTradesWarning', true);
                if (fetchTradesWarning) {
                    throw new ExchangeError (this.id + ' fetchTrades() cannot serve ' + limit.toString () + " trades without breaking the pagination, see https://github.com/ccxt/ccxt/issues/5698 for more details. Set exchange.options['fetchTradesWarning'] to acknowledge this warning and silence it.");
                }
            }
            const response = await this.publicGetTrades (this.extend (request, params));
            //
            //     {
            //         "error": [],
            //         "result": {
            //             "XETHXXBT": [
            //                 ["0.032310","4.28169434",1541390792.763,"s","l",""]
            //             ],
            //             "last": "1541439421200678657"
            //         }
            //     }
            //
            const result = response['result'];
            const trades = result[id];
            // trades is a sorted array: last (most recent trade) goes last
            const length = trades.length;
            if (length <= 0) {
                return [];
            }
            const lastTrade = trades[length - 1];
            const lastTradeId = this.safeString (result, 'last');
            lastTrade.push (lastTradeId);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostBalance (params);
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "ZUSD":"58.8649",
            //             "KFEE":"4399.43",
            //             "XXBT":"0.0000034506",
            //         }
            //     }
            //
            const balances = this.safeValue (response, 'result', {});
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const currencyIds = Object.keys (balances);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['total'] = this.safeString (balances, currencyId);
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'pair': market['id'],
                'type': side,
                'ordertype': type,
                'volume': this.amountToPrecision (symbol, amount),
            };
            const clientOrderId = this.safeString2 (params, 'userref', 'clientOrderId');
            params = this.omit (params, [ 'userref', 'clientOrderId' ]);
            if (clientOrderId !== undefined) {
                request['userref'] = clientOrderId;
            }
            //
            //     market
            //     limit (price = limit price)
            //     stop-loss (price = stop loss price)
            //     take-profit (price = take profit price)
            //     stop-loss-limit (price = stop loss trigger price, price2 = triggered limit price)
            //     take-profit-limit (price = take profit trigger price, price2 = triggered limit price)
            //     settle-position
            //
            if (type === 'limit') {
                request['price'] = this.priceToPrecision (symbol, price);
            } else if ((type === 'stop-loss') || (type === 'take-profit')) {
                const stopPrice = this.safeNumber2 (params, 'price', 'stopPrice', price);
                if (stopPrice === undefined) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a price argument or a price/stopPrice parameter for a ' + type + ' order');
                } else {
                    request['price'] = this.priceToPrecision (symbol, stopPrice);
                }
            } else if ((type === 'stop-loss-limit') || (type === 'take-profit-limit')) {
                const stopPrice = this.safeNumber2 (params, 'price', 'stopPrice');
                const limitPrice = this.safeNumber (params, 'price2');
                const stopPriceDefined = (stopPrice !== undefined);
                const limitPriceDefined = (limitPrice !== undefined);
                if (stopPriceDefined && limitPriceDefined) {
                    request['price'] = this.priceToPrecision (symbol, stopPrice);
                    request['price2'] = this.priceToPrecision (symbol, limitPrice);
                } else if ((price === undefined) || (!(stopPriceDefined || limitPriceDefined))) {
                    throw new ArgumentsRequired (this.id + ' createOrder() requires a price argument and/or price/stopPrice/price2 parameters for a ' + type + ' order');
                } else {
                    if (stopPriceDefined) {
                        request['price'] = this.priceToPrecision (symbol, stopPrice);
                        request['price2'] = this.priceToPrecision (symbol, price);
                    } else if (limitPriceDefined) {
                        request['price'] = this.priceToPrecision (symbol, price);
                        request['price2'] = this.priceToPrecision (symbol, limitPrice);
                    }
                }
            }
            params = this.omit (params, [ 'price', 'stopPrice', 'price2' ]);
            const response = await this.privatePostAddOrder (this.extend (request, params));
            //
            //     {
            //         error: [],
            //         result: {
            //             descr: { order: 'buy 0.02100000 ETHUSDT @ limit 330.00' },
            //             txid: [ 'OEKVV2-IH52O-TPL6GZ' ]
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result');
            return this.parseOrder (result);
        }
    
        findMarketByAltnameOrId (id) {
            if (id in this.marketsByAltname) {
                return this.marketsByAltname[id];
            } else if (id in this.markets_by_id) {
                return this.markets_by_id[id];
            }
            return undefined;
        }
    
        getDelistedMarketById (id) {
            if (id === undefined) {
                return id;
            }
            let market = this.safeValue (this.options['delistedMarketsById'], id);
            if (market !== undefined) {
                return market;
            }
            const baseIdStart = 0;
            let baseIdEnd = 3;
            let quoteIdStart = 3;
            let quoteIdEnd = 6;
            if (id.length === 8) {
                baseIdEnd = 4;
                quoteIdStart = 4;
                quoteIdEnd = 8;
            } else if (id.length === 7) {
                baseIdEnd = 4;
                quoteIdStart = 4;
                quoteIdEnd = 7;
            }
            const baseId = id.slice (baseIdStart, baseIdEnd);
            const quoteId = id.slice (quoteIdStart, quoteIdEnd);
            const base = this.safeCurrencyCode (baseId);
            const quote = this.safeCurrencyCode (quoteId);
            const symbol = base + '/' + quote;
            market = {
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'baseId': baseId,
                'quoteId': quoteId,
            };
            this.options['delistedMarketsById'][id] = market;
            return market;
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'pending': 'open', // order pending book entry
                'open': 'open',
                'closed': 'closed',
                'canceled': 'canceled',
                'expired': 'expired',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         descr: { order: 'buy 0.02100000 ETHUSDT @ limit 330.00' },
            //         txid: [ 'OEKVV2-IH52O-TPL6GZ' ]
            //     }
            //
            const description = this.safeValue (order, 'descr', {});
            const orderDescription = this.safeString (description, 'order');
            let side = undefined;
            let type = undefined;
            let marketId = undefined;
            let price = undefined;
            let amount = undefined;
            if (orderDescription !== undefined) {
                const parts = orderDescription.split (' ');
                side = this.safeString (parts, 0);
                amount = this.safeNumber (parts, 1);
                marketId = this.safeString (parts, 2);
                type = this.safeString (parts, 4);
                price = this.safeNumber (parts, 5);
            }
            side = this.safeString (description, 'type', side);
            type = this.safeString (description, 'ordertype', type);
            marketId = this.safeString (description, 'pair', marketId);
            const foundMarket = this.findMarketByAltnameOrId (marketId);
            let symbol = undefined;
            if (foundMarket !== undefined) {
                market = foundMarket;
            } else if (marketId !== undefined) {
                // delisted market ids go here
                market = this.getDelistedMarketById (marketId);
            }
            const timestamp = this.safeTimestamp (order, 'opentm');
            amount = this.safeNumber (order, 'vol', amount);
            const filled = this.safeNumber (order, 'vol_exec');
            let fee = undefined;
            const cost = this.safeNumber (order, 'cost');
            price = this.safeNumber (description, 'price', price);
            if ((price === undefined) || (price === 0.0)) {
                price = this.safeNumber (description, 'price2');
            }
            if ((price === undefined) || (price === 0.0)) {
                price = this.safeNumber (order, 'price', price);
            }
            const average = this.safeNumber (order, 'price');
            if (market !== undefined) {
                symbol = market['symbol'];
                if ('fee' in order) {
                    const flags = order['oflags'];
                    const feeCost = this.safeNumber (order, 'fee');
                    fee = {
                        'cost': feeCost,
                        'rate': undefined,
                    };
                    if (flags.indexOf ('fciq') >= 0) {
                        fee['currency'] = market['quote'];
                    } else if (flags.indexOf ('fcib') >= 0) {
                        fee['currency'] = market['base'];
                    }
                }
            }
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            let id = this.safeString (order, 'id');
            if (id === undefined) {
                const txid = this.safeValue (order, 'txid');
                id = this.safeString (txid, 0);
            }
            const clientOrderId = this.safeString (order, 'userref');
            const rawTrades = this.safeValue (order, 'trades');
            let trades = undefined;
            if (rawTrades !== undefined) {
                trades = this.parseTrades (rawTrades, market, undefined, undefined, { 'order': id });
            }
            const stopPrice = this.safeNumber (order, 'stopprice');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': stopPrice,
                'cost': cost,
                'amount': amount,
                'filled': filled,
                'average': average,
                'remaining': undefined,
                'fee': fee,
                'trades': trades,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const clientOrderId = this.safeValue2 (params, 'userref', 'clientOrderId');
            const request = {
                'trades': true, // whether or not to include trades in output (optional, default false)
                // 'txid': id, // do not comma separate a list of ids - use fetchOrdersByIds instead
                // 'userref': 'optional', // restrict results to given user reference id (optional)
            };
            let query = params;
            if (clientOrderId !== undefined) {
                request['userref'] = clientOrderId;
                query = this.omit (params, [ 'userref', 'clientOrderId' ]);
            } else {
                request['txid'] = id;
            }
            const response = await this.privatePostQueryOrders (this.extend (request, query));
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "OTLAS3-RRHUF-NDWH5A":{
            //                 "refid":null,
            //                 "userref":null,
            //                 "status":"closed",
            //                 "reason":null,
            //                 "opentm":1586822919.3342,
            //                 "closetm":1586822919.365,
            //                 "starttm":0,
            //                 "expiretm":0,
            //                 "descr":{
            //                     "pair":"XBTUSDT",
            //                     "type":"sell",
            //                     "ordertype":"market",
            //                     "price":"0",
            //                     "price2":"0",
            //                     "leverage":"none",
            //                     "order":"sell 0.21804000 XBTUSDT @ market",
            //                     "close":""
            //                 },
            //                 "vol":"0.21804000",
            //                 "vol_exec":"0.21804000",
            //                 "cost":"1493.9",
            //                 "fee":"3.8",
            //                 "price":"6851.5",
            //                 "stopprice":"0.00000",
            //                 "limitprice":"0.00000",
            //                 "misc":"",
            //                 "oflags":"fciq",
            //                 "trades":["TT5UC3-GOIRW-6AZZ6R"]
            //             }
            //         }
            //     }
            //
            const result = this.safeValue (response, 'result', []);
            if (!(id in result)) {
                throw new OrderNotFound (this.id + ' fetchOrder() could not find order id ' + id);
            }
            const order = this.parseOrder (this.extend ({ 'id': id }, result[id]));
            return this.extend ({ 'info': response }, order);
        }
    
        async fetchOrderTrades (id, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const orderTrades = this.safeValue (params, 'trades');
            const tradeIds = [];
            if (orderTrades === undefined) {
                throw new ArgumentsRequired (this.id + " fetchOrderTrades() requires a unified order structure in the params argument or a 'trades' param (an array of trade id strings)");
            } else {
                for (let i = 0; i < orderTrades.length; i++) {
                    const orderTrade = orderTrades[i];
                    if (typeof orderTrade === 'string') {
                        tradeIds.push (orderTrade);
                    } else {
                        tradeIds.push (orderTrade['id']);
                    }
                }
            }
            await this.loadMarkets ();
            const options = this.safeValue (this.options, 'fetchOrderTrades', {});
            const batchSize = this.safeInteger (options, 'batchSize', 20);
            const numTradeIds = tradeIds.length;
            let numBatches = parseInt (numTradeIds / batchSize);
            numBatches = this.sum (numBatches, 1);
            let result = [];
            for (let j = 0; j < numBatches; j++) {
                const requestIds = [];
                for (let k = 0; k < batchSize; k++) {
                    const index = this.sum (j * batchSize, k);
                    if (index < numTradeIds) {
                        requestIds.push (tradeIds[index]);
                    }
                }
                const request = {
                    'txid': requestIds.join (','),
                };
                const response = await this.privatePostQueryTrades (request);
                //
                //     {
                //         error: [],
                //         result: {
                //             'TIMIRG-WUNNE-RRJ6GT': {
                //                 ordertxid: 'OQRPN2-LRHFY-HIFA7D',
                //                 postxid: 'TKH2SE-M7IF5-CFI7LT',
                //                 pair: 'USDCUSDT',
                //                 time: 1586340086.457,
                //                 type: 'sell',
                //                 ordertype: 'market',
                //                 price: '0.99860000',
                //                 cost: '22.16892001',
                //                 fee: '0.04433784',
                //                 vol: '22.20000000',
                //                 margin: '0.00000000',
                //                 misc: ''
                //             }
                //         }
                //     }
                //
                const rawTrades = this.safeValue (response, 'result');
                const ids = Object.keys (rawTrades);
                for (let i = 0; i < ids.length; i++) {
                    rawTrades[ids[i]]['id'] = ids[i];
                }
                const trades = this.parseTrades (rawTrades, undefined, since, limit);
                const tradesFilteredBySymbol = this.filterBySymbol (trades, symbol);
                result = this.arrayConcat (result, tradesFilteredBySymbol);
            }
            return result;
        }
    
        async fetchOrdersByIds (ids, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostQueryOrders (this.extend ({
                'trades': true, // whether or not to include trades in output (optional, default false)
                'txid': ids.join (','), // comma delimited list of transaction ids to query info about (20 maximum)
            }, params));
            const result = this.safeValue (response, 'result', {});
            const orders = [];
            const orderIds = Object.keys (result);
            for (let i = 0; i < orderIds.length; i++) {
                const id = orderIds[i];
                const item = result[id];
                const order = this.parseOrder (this.extend ({ 'id': id }, item));
                orders.push (order);
            }
            return orders;
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'type': 'all', // any position, closed position, closing position, no position
                // 'trades': false, // whether or not to include trades related to position in output
                // 'start': 1234567890, // starting unix timestamp or trade tx id of results (exclusive)
                // 'end': 1234567890, // ending unix timestamp or trade tx id of results (inclusive)
                // 'ofs' = result offset
            };
            if (since !== undefined) {
                request['start'] = parseInt (since / 1000);
            }
            const response = await this.privatePostTradesHistory (this.extend (request, params));
            //
            //     {
            //         "error": [],
            //         "result": {
            //             "trades": {
            //                 "GJ3NYQ-XJRTF-THZABF": {
            //                     "ordertxid": "TKH2SE-ZIF5E-CFI7LT",
            //                     "postxid": "OEN3VX-M7IF5-JNBJAM",
            //                     "pair": "XICNXETH",
            //                     "time": 1527213229.4491,
            //                     "type": "sell",
            //                     "ordertype": "limit",
            //                     "price": "0.001612",
            //                     "cost": "0.025792",
            //                     "fee": "0.000026",
            //                     "vol": "16.00000000",
            //                     "margin": "0.000000",
            //                     "misc": ""
            //                 },
            //                 ...
            //             },
            //             "count": 9760,
            //         },
            //     }
            //
            const trades = response['result']['trades'];
            const ids = Object.keys (trades);
            for (let i = 0; i < ids.length; i++) {
                trades[ids[i]]['id'] = ids[i];
            }
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            return this.parseTrades (trades, market, since, limit);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            let response = undefined;
            try {
                response = await this.privatePostCancelOrder (this.extend ({
                    'txid': id,
                }, params));
            } catch (e) {
                if (this.last_http_response) {
                    if (this.last_http_response.indexOf ('EOrder:Unknown order') >= 0) {
                        throw new OrderNotFound (this.id + ' cancelOrder() error ' + this.last_http_response);
                    }
                }
                throw e;
            }
            return response;
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            return await this.privatePostCancelAll (params);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (since !== undefined) {
                request['start'] = parseInt (since / 1000);
            }
            const response = await this.privatePostOpenOrders (this.extend (request, params));
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const result = this.safeValue (response, 'result', {});
            const orders = this.safeValue (result, 'open', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            if (since !== undefined) {
                request['start'] = parseInt (since / 1000);
            }
            const response = await this.privatePostClosedOrders (this.extend (request, params));
            //
            //     {
            //         "error":[],
            //         "result":{
            //             "closed":{
            //                 "OETZYO-UL524-QJMXCT":{
            //                     "refid":null,
            //                     "userref":null,
            //                     "status":"canceled",
            //                     "reason":"User requested",
            //                     "opentm":1601489313.3898,
            //                     "closetm":1601489346.5507,
            //                     "starttm":0,
            //                     "expiretm":0,
            //                     "descr":{
            //                         "pair":"ETHUSDT",
            //                         "type":"buy",
            //                         "ordertype":"limit",
            //                         "price":"330.00",
            //                         "price2":"0",
            //                         "leverage":"none",
            //                         "order":"buy 0.02100000 ETHUSDT @ limit 330.00",
            //                         "close":""
            //                     },
            //                     "vol":"0.02100000",
            //                     "vol_exec":"0.00000000",
            //                     "cost":"0.00000",
            //                     "fee":"0.00000",
            //                     "price":"0.00000",
            //                     "stopprice":"0.00000",
            //                     "limitprice":"0.00000",
            //                     "misc":"",
            //                     "oflags":"fciq"
            //                 },
            //             },
            //             "count":16
            //         }
            //     }
            //
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const result = this.safeValue (response, 'result', {});
            const orders = this.safeValue (result, 'closed', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchDepositMethods (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset': currency['id'],
            };
            const response = await this.privatePostDepositMethods (this.extend (request, params));
            return this.safeValue (response, 'result');
        }
    
        parseTransactionStatus (status) {
            // IFEX transaction states
            const statuses = {
                'Initial': 'pending',
                'Pending': 'pending',
                'Success': 'ok',
                'Settled': 'pending',
                'Failure': 'failed',
                'Partial': 'ok',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     { method: "Ether (Hex)",
            //       aclass: "currency",
            //        asset: "XETH",
            //        refid: "Q2CANKL-LBFVEE-U4Y2WQ",
            //         txid: "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23…",
            //         info: "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
            //       amount: "7.9999257900",
            //          fee: "0.0000000000",
            //         time:  1529223212,
            //       status: "Success"                                                       }
            //
            // fetchWithdrawals
            //
            //     { method: "Ether",
            //       aclass: "currency",
            //        asset: "XETH",
            //        refid: "A2BF34S-O7LBNQ-UE4Y4O",
            //         txid: "0x288b83c6b0904d8400ef44e1c9e2187b5c8f7ea3d838222d53f701a15b5c274d",
            //         info: "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
            //       amount: "9.9950000000",
            //          fee: "0.0050000000",
            //         time:  1530481750,
            //       status: "Success"                                                             }
            //
            const id = this.safeString (transaction, 'refid');
            const txid = this.safeString (transaction, 'txid');
            const timestamp = this.safeTimestamp (transaction, 'time');
            const currencyId = this.safeString (transaction, 'asset');
            const code = this.safeCurrencyCode (currencyId, currency);
            const address = this.safeString (transaction, 'info');
            const amount = this.safeNumber (transaction, 'amount');
            const status = this.parseTransactionStatus (this.safeString (transaction, 'status'));
            const type = this.safeString (transaction, 'type'); // injected from the outside
            let feeCost = this.safeNumber (transaction, 'fee');
            if (feeCost === undefined) {
                if (type === 'deposit') {
                    feeCost = 0;
                }
            }
            return {
                'info': transaction,
                'id': id,
                'currency': code,
                'amount': amount,
                'address': address,
                'tag': undefined,
                'status': status,
                'type': type,
                'updated': undefined,
                'txid': txid,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'fee': {
                    'currency': code,
                    'cost': feeCost,
                },
            };
        }
    
        parseTransactionsByType (type, transactions, code = undefined, since = undefined, limit = undefined) {
            const result = [];
            for (let i = 0; i < transactions.length; i++) {
                const transaction = this.parseTransaction (this.extend ({
                    'type': type,
                }, transactions[i]));
                result.push (transaction);
            }
            return this.filterByCurrencySinceLimit (result, code, since, limit);
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            // https://www.kraken.com/en-us/help/api#deposit-status
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchDeposits() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset': currency['id'],
            };
            const response = await this.privatePostDepositStatus (this.extend (request, params));
            //
            //     {  error: [],
            //       result: [ { method: "Ether (Hex)",
            //                   aclass: "currency",
            //                    asset: "XETH",
            //                    refid: "Q2CANKL-LBFVEE-U4Y2WQ",
            //                     txid: "0x57fd704dab1a73c20e24c8696099b695d596924b401b261513cfdab23…",
            //                     info: "0x615f9ba7a9575b0ab4d571b2b36b1b324bd83290",
            //                   amount: "7.9999257900",
            //                      fee: "0.0000000000",
            //                     time:  1529223212,
            //                   status: "Success"                                                       } ] }
            //
            return this.parseTransactionsByType ('deposit', response['result'], code, since, limit);
        }
    
        async fetchTime (params = {}) {
            // https://www.kraken.com/en-us/features/api#get-server-time
            const response = await this.publicGetTime (params);
            //
            //    {
            //        "error": [],
            //        "result": {
            //            "unixtime": 1591502873,
            //            "rfc1123": "Sun,  7 Jun 20 04:07:53 +0000"
            //        }
            //    }
            //
            const result = this.safeValue (response, 'result', {});
            return this.safeTimestamp (result, 'unixtime');
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            // https://www.kraken.com/en-us/help/api#withdraw-status
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchWithdrawals() requires a currency code argument');
            }
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'asset': currency['id'],
            };
            const response = await this.privatePostWithdrawStatus (this.extend (request, params));
            //
            //     {  error: [],
            //       result: [ { method: "Ether",
            //                   aclass: "currency",
            //                    asset: "XETH",
            //                    refid: "A2BF34S-O7LBNQ-UE4Y4O",
            //                     txid: "0x298c83c7b0904d8400ef43e1c9e2287b518f7ea3d838822d53f704a1565c274d",
            //                     info: "0x7cb275a5e07ba943fee972e165d80daa67cb2dd0",
            //                   amount: "9.9950000000",
            //                      fee: "0.0050000000",
            //                     time:  1530481750,
            //                   status: "Success"                                                             } ] }
            //
            return this.parseTransactionsByType ('withdrawal', response['result'], code, since, limit);
        }
    
        async createDepositAddress (code, params = {}) {
            const request = {
                'new': 'true',
            };
            const response = await this.fetchDepositAddress (code, this.extend (request, params));
            const address = this.safeString (response, 'address');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'info': response,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            // eslint-disable-next-line quotes
            let method = this.safeString (params, 'method');
            if (method === undefined) {
                if (this.options['cacheDepositMethodsOnFetchDepositAddress']) {
                    // cache depositMethods
                    if (!(code in this.options['depositMethods'])) {
                        this.options['depositMethods'][code] = await this.fetchDepositMethods (code);
                    }
                    method = this.options['depositMethods'][code][0]['method'];
                } else {
                    throw new ArgumentsRequired (this.id + ' fetchDepositAddress() requires an extra `method` parameter. Use fetchDepositMethods ("' + code + '") to get a list of available deposit methods or enable the exchange property .options["cacheDepositMethodsOnFetchDepositAddress"] = true');
                }
            }
            const request = {
                'asset': currency['id'],
                'method': method,
            };
            const response = await this.privatePostDepositAddresses (this.extend (request, params)); // overwrite methods
            const result = response['result'];
            const numResults = result.length;
            if (numResults < 1) {
                throw new InvalidAddress (this.id + ' privatePostDepositAddresses() returned no addresses');
            }
            const address = this.safeString (result[0], 'address');
            const tag = this.safeString2 (result[0], 'tag', 'memo');
            this.checkAddress (address);
            return {
                'currency': code,
                'address': address,
                'tag': tag,
                'info': response,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            this.checkAddress (address);
            if ('key' in params) {
                await this.loadMarkets ();
                const currency = this.currency (code);
                const request = {
                    'asset': currency['id'],
                    'amount': amount,
                    // 'address': address, // they don't allow withdrawals to direct addresses
                };
                const response = await this.privatePostWithdraw (this.extend (request, params));
                const result = this.safeValue (response, 'result', {});
                const id = this.safeString (result, 'refid');
                return {
                    'info': result,
                    'id': id,
                };
            }
            throw new ExchangeError (this.id + " withdraw() requires a 'key' parameter (withdrawal key name, as set up on your account)");
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'txid': 'comma delimited list of transaction ids to restrict output to',
                // 'docalcs': false, // whether or not to include profit/loss calculations
                // 'consolidation': 'market', // what to consolidate the positions data around, market will consolidate positions based on market pair
            };
            const response = await this.privatePostOpenPositions (this.extend (request, params));
            //
            // no consolidation
            //
            //     {
            //         error: [],
            //         result: {
            //             'TGUFMY-FLESJ-VYIX3J': {
            //                 ordertxid: "O3LRNU-ZKDG5-XNCDFR",
            //                 posstatus: "open",
            //                 pair: "ETHUSDT",
            //                 time:  1611557231.4584,
            //                 type: "buy",
            //                 ordertype: "market",
            //                 cost: "28.49800",
            //                 fee: "0.07979",
            //                 vol: "0.02000000",
            //                 vol_closed: "0.00000000",
            //                 margin: "14.24900",
            //                 terms: "0.0200% per 4 hours",
            //                 rollovertm: "1611571631",
            //                 misc: "",
            //                 oflags: ""
            //             }
            //         }
            //     }
            //
            // consolidation by market
            //
            //     {
            //         error: [],
            //         result: [
            //             {
            //                 pair: "ETHUSDT",
            //                 positions: "1",
            //                 type: "buy",
            //                 leverage: "2.00000",
            //                 cost: "28.49800",
            //                 fee: "0.07979",
            //                 vol: "0.02000000",
            //                 vol_closed: "0.00000000",
            //                 margin: "14.24900"
            //             }
            //         ]
            //     }
            //
            const result = this.safeValue (response, 'result');
            // todo unify parsePosition/parsePositions
            return result;
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let url = '/' + this.version + '/' + api + '/' + path;
            if (api === 'public') {
                if (Object.keys (params).length) {
                    url += '?' + this.urlencode (params);
                }
            } else if (api === 'private') {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                body = this.urlencode (this.extend ({ 'nonce': nonce }, params));
                const auth = this.encode (nonce + body);
                const hash = this.hash (auth, 'sha256', 'binary');
                const binary = this.stringToBinary (this.encode (url));
                const binhash = this.binaryConcat (binary, hash);
                const secret = this.base64ToBinary (this.secret);
                const signature = this.hmac (binhash, secret, 'sha512', 'base64');
                headers = {
                    'API-Key': this.apiKey,
                    'API-Sign': signature,
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            } else {
                url = '/' + path;
            }
            url = this.urls['api'][api] + url;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (code === 520) {
                throw new ExchangeNotAvailable (this.id + ' ' + code.toString () + ' ' + reason);
            }
            // todo: rewrite this for "broad" exceptions matching
            if (body.indexOf ('Invalid order') >= 0) {
                throw new InvalidOrder (this.id + ' ' + body);
            }
            if (body.indexOf ('Invalid nonce') >= 0) {
                throw new InvalidNonce (this.id + ' ' + body);
            }
            if (body.indexOf ('Insufficient funds') >= 0) {
                throw new InsufficientFunds (this.id + ' ' + body);
            }
            if (body.indexOf ('Cancel pending') >= 0) {
                throw new CancelPending (this.id + ' ' + body);
            }
            if (body.indexOf ('Invalid arguments:volume') >= 0) {
                throw new InvalidOrder (this.id + ' ' + body);
            }
            if (body.indexOf ('Rate limit exceeded') >= 0) {
                throw new RateLimitExceeded (this.id + ' ' + body);
            }
            if (response === undefined) {
                return;
            }
            if (body[0] === '{') {
                if (typeof response !== 'string') {
                    if ('error' in response) {
                        const numErrors = response['error'].length;
                        if (numErrors) {
                            const message = this.id + ' ' + body;
                            for (let i = 0; i < response['error'].length; i++) {
                                const error = response['error'][i];
                                this.throwExactlyMatchedException (this.exceptions, error, message);
                            }
                            throw new ExchangeError (message);
                        }
                    }
                }
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9,"./base/functions/number":15}],95:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, ExchangeNotAvailable, InsufficientFunds, OrderNotFound, InvalidOrder, AccountSuspended, InvalidNonce, NotSupported, BadRequest, AuthenticationError, BadSymbol, RateLimitExceeded, PermissionDenied } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class kucoin extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'kucoin',
                'name': 'KuCoin',
                'countries': [ 'SC' ],
                'rateLimit': 334,
                'version': 'v2',
                'certified': false,
                'pro': true,
                'comment': 'Platform 2.0',
                'quoteJsonNumbers': false,
                'has': {
                    'CORS': false,
                    'cancelAllOrders': true,
                    'cancelOrder': true,
                    'createDepositAddress': true,
                    'createOrder': true,
                    'fetchAccounts': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchDepositAddress': true,
                    'fetchDeposits': true,
                    'fetchFundingFee': true,
                    'fetchLedger': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchStatus': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                    'transfer': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/51840849/87295558-132aaf80-c50e-11ea-9801-a2fb0c57c799.jpg',
                    'referral': 'https://www.kucoin.com/?rcode=E5wkqe',
                    'api': {
                        'public': 'https://openapi-v2.kucoin.com',
                        'private': 'https://openapi-v2.kucoin.com',
                        'futuresPrivate': 'https://api-futures.kucoin.com',
                        'futuresPublic': 'https://api-futures.kucoin.com',
                    },
                    'test': {
                        'public': 'https://openapi-sandbox.kucoin.com',
                        'private': 'https://openapi-sandbox.kucoin.com',
                        'futuresPrivate': 'https://api-sandbox-futures.kucoin.com',
                        'futuresPublic': 'https://api-sandbox-futures.kucoin.com',
                    },
                    'www': 'https://www.kucoin.com',
                    'doc': [
                        'https://docs.kucoin.com',
                    ],
                },
                'requiredCredentials': {
                    'apiKey': true,
                    'secret': true,
                    'password': true,
                },
                'api': {
                    'public': {
                        'get': [
                            'timestamp',
                            'status',
                            'symbols',
                            'markets',
                            'market/allTickers',
                            'market/orderbook/level{level}_{limit}',
                            'market/orderbook/level2_20',
                            'market/orderbook/level2_100',
                            'market/histories',
                            'market/candles',
                            'market/stats',
                            'currencies',
                            'currencies/{currency}',
                            'prices',
                            'mark-price/{symbol}/current',
                            'margin/config',
                        ],
                        'post': [
                            'bullet-public',
                        ],
                    },
                    'private': {
                        'get': [
                            'market/orderbook/level{level}',
                            'market/orderbook/level2',
                            'market/orderbook/level3',
                            'accounts',
                            'accounts/{accountId}',
                            'accounts/{accountId}/ledgers',
                            'accounts/{accountId}/holds',
                            'accounts/transferable',
                            'sub/user',
                            'sub-accounts',
                            'sub-accounts/{subUserId}',
                            'deposit-addresses',
                            'deposits',
                            'hist-deposits',
                            'hist-orders',
                            'hist-withdrawals',
                            'withdrawals',
                            'withdrawals/quotas',
                            'orders',
                            'order/client-order/{clientOid}',
                            'orders/{orderId}',
                            'limit/orders',
                            'fills',
                            'limit/fills',
                            'margin/account',
                            'margin/borrow',
                            'margin/borrow/outstanding',
                            'margin/borrow/borrow/repaid',
                            'margin/lend/active',
                            'margin/lend/done',
                            'margin/lend/trade/unsettled',
                            'margin/lend/trade/settled',
                            'margin/lend/assets',
                            'margin/market',
                            'margin/trade/last',
                            'stop-order/{orderId}',
                            'stop-order',
                            'stop-order/queryOrderByClientOid',
                        ],
                        'post': [
                            'accounts',
                            'accounts/inner-transfer',
                            'accounts/sub-transfer',
                            'deposit-addresses',
                            'withdrawals',
                            'orders',
                            'orders/multi',
                            'margin/borrow',
                            'margin/order',
                            'margin/repay/all',
                            'margin/repay/single',
                            'margin/lend',
                            'margin/toggle-auto-lend',
                            'bullet-private',
                            'stop-order',
                        ],
                        'delete': [
                            'withdrawals/{withdrawalId}',
                            'orders',
                            'orders/client-order/{clientOid}',
                            'orders/{orderId}',
                            'margin/lend/{orderId}',
                            'stop-order/cancelOrderByClientOid',
                            'stop-order/{orderId}',
                            'stop-order/cancel',
                        ],
                    },
                    'futuresPublic': {
                        'get': [
                            'contracts/active',
                            'contracts/{symbol}',
                            'ticker',
                            'level2/snapshot',
                            'level2/depth20',
                            'level2/depth100',
                            'level2/message/query',
                            'level3/message/query', // deprecated，level3/snapshot is suggested
                            'level3/snapshot', // v2
                            'trade/history',
                            'interest/query',
                            'index/query',
                            'mark-price/{symbol}/current',
                            'premium/query',
                            'funding-rate/{symbol}/current',
                            'timestamp',
                            'status',
                            'kline/query',
                        ],
                        'post': [
                            'bullet-public',
                        ],
                    },
                    'futuresPrivate': {
                        'get': [
                            'account-overview',
                            'transaction-history',
                            'deposit-address',
                            'deposit-list',
                            'withdrawals/quotas',
                            'withdrawal-list',
                            'transfer-list',
                            'orders',
                            'stopOrders',
                            'recentDoneOrders',
                            'orders/{order-id}', // ?clientOid={client-order-id} // get order by orderId
                            'orders/byClientOid', // ?clientOid=eresc138b21023a909e5ad59 // get order by clientOid
                            'fills',
                            'recentFills',
                            'openOrderStatistics',
                            'position',
                            'positions',
                            'funding-history',
                        ],
                        'post': [
                            'withdrawals',
                            'transfer-out', // v2
                            'orders',
                            'position/margin/auto-deposit-status',
                            'position/margin/deposit-margin',
                            'bullet-private',
                        ],
                        'delete': [
                            'withdrawals/{withdrawalId}',
                            'cancel/transfer-out',
                            'orders/{order-id}',
                            'orders',
                            'stopOrders',
                        ],
                    },
                },
                'timeframes': {
                    '1m': '1min',
                    '3m': '3min',
                    '5m': '5min',
                    '15m': '15min',
                    '30m': '30min',
                    '1h': '1hour',
                    '2h': '2hour',
                    '4h': '4hour',
                    '6h': '6hour',
                    '8h': '8hour',
                    '12h': '12hour',
                    '1d': '1day',
                    '1w': '1week',
                },
                'exceptions': {
                    'exact': {
                        'order not exist': OrderNotFound,
                        'order not exist.': OrderNotFound, // duplicated error temporarily
                        'order_not_exist': OrderNotFound, // {"code":"order_not_exist","msg":"order_not_exist"} ¯\_(ツ)_/¯
                        'order_not_exist_or_not_allow_to_cancel': InvalidOrder, // {"code":"400100","msg":"order_not_exist_or_not_allow_to_cancel"}
                        'Order size below the minimum requirement.': InvalidOrder, // {"code":"400100","msg":"Order size below the minimum requirement."}
                        'The withdrawal amount is below the minimum requirement.': ExchangeError, // {"code":"400100","msg":"The withdrawal amount is below the minimum requirement."}
                        'Unsuccessful! Exceeded the max. funds out-transfer limit': InsufficientFunds, // {"code":"200000","msg":"Unsuccessful! Exceeded the max. funds out-transfer limit"}
                        '400': BadRequest,
                        '401': AuthenticationError,
                        '403': NotSupported,
                        '404': NotSupported,
                        '405': NotSupported,
                        '429': RateLimitExceeded,
                        '500': ExchangeNotAvailable, // Internal Server Error -- We had a problem with our server. Try again later.
                        '503': ExchangeNotAvailable,
                        '101030': PermissionDenied, // {"code":"101030","msg":"You haven't yet enabled the margin trading"}
                        '200004': InsufficientFunds,
                        '230003': InsufficientFunds, // {"code":"230003","msg":"Balance insufficient!"}
                        '260100': InsufficientFunds, // {"code":"260100","msg":"account.noBalance"}
                        '300000': InvalidOrder,
                        '400000': BadSymbol,
                        '400001': AuthenticationError,
                        '400002': InvalidNonce,
                        '400003': AuthenticationError,
                        '400004': AuthenticationError,
                        '400005': AuthenticationError,
                        '400006': AuthenticationError,
                        '400007': AuthenticationError,
                        '400008': NotSupported,
                        '400100': BadRequest,
                        '411100': AccountSuspended,
                        '415000': BadRequest, // {"code":"415000","msg":"Unsupported Media Type"}
                        '500000': ExchangeError,
                    },
                    'broad': {
                        'Exceeded the access frequency': RateLimitExceeded,
                        'require more permission': PermissionDenied,
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'taker': 0.001,
                        'maker': 0.001,
                    },
                    'funding': {
                        'tierBased': false,
                        'percentage': false,
                        'withdraw': {},
                        'deposit': {},
                    },
                },
                'commonCurrencies': {
                    'HOT': 'HOTNOW',
                    'EDGE': 'DADI', // https://github.com/ccxt/ccxt/issues/5756
                    'WAX': 'WAXP',
                    'TRY': 'Trias',
                    'VAI': 'VAIOT',
                },
                'options': {
                    'version': 'v1',
                    'symbolSeparator': '-',
                    'fetchMyTradesMethod': 'private_get_fills',
                    'fetchBalance': 'trade',
                    // endpoint versions
                    'versions': {
                        'public': {
                            'GET': {
                                'status': 'v1',
                                'market/orderbook/level2_20': 'v1',
                                'market/orderbook/level2_100': 'v1',
                                'market/orderbook/level{level}_{limit}': 'v1',
                            },
                        },
                        'private': {
                            'GET': {
                                'market/orderbook/level2': 'v3',
                                'market/orderbook/level3': 'v3',
                                'market/orderbook/level{level}': 'v3',
                            },
                            'POST': {
                                'accounts/inner-transfer': 'v2',
                                'accounts/sub-transfer': 'v2',
                            },
                        },
                        'futuresPrivate': {
                            'GET': {
                                'account-overview': 'v1',
                                'positions': 'v1',
                            },
                            'POST': {
                                'transfer-out': 'v2',
                            },
                        },
                        'futuresPublic': {
                            'GET': {
                                'level3/snapshot': 'v2',
                            },
                        },
                    },
                    'accountsByType': {
                        'trade': 'trade',
                        'trading': 'trade',
                        'spot': 'trade',
                        'margin': 'margin',
                        'main': 'main',
                        'funding': 'main',
                        'futures': 'contract',
                        'contract': 'contract',
                        'pool': 'pool',
                        'pool-x': 'pool',
                    },
                },
            });
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        async loadTimeDifference (params = {}) {
            const response = await this.publicGetTimestamp (params);
            const after = this.milliseconds ();
            const kucoinTime = this.safeInteger (response, 'data');
            this.options['timeDifference'] = parseInt (after - kucoinTime);
            return this.options['timeDifference'];
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTimestamp (params);
            //
            //     {
            //         "code":"200000",
            //         "msg":"success",
            //         "data":1546837113087
            //     }
            //
            return this.safeInteger (response, 'data');
        }
    
        async fetchStatus (params = {}) {
            const response = await this.publicGetStatus (params);
            //
            //     {
            //         "code":"200000",
            //         "data":{
            //             "msg":"",
            //             "status":"open"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            let status = this.safeValue (data, 'status');
            if (status !== undefined) {
                status = (status === 'open') ? 'ok' : 'maintenance';
                this.status = this.extend (this.status, {
                    'status': status,
                    'updated': this.milliseconds (),
                });
            }
            return this.status;
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetSymbols (params);
            //
            //     {
            //         quoteCurrency: 'BTC',
            //         symbol: 'KCS-BTC',
            //         quoteMaxSize: '9999999',
            //         quoteIncrement: '0.000001',
            //         baseMinSize: '0.01',
            //         quoteMinSize: '0.00001',
            //         enableTrading: true,
            //         priceIncrement: '0.00000001',
            //         name: 'KCS-BTC',
            //         baseIncrement: '0.01',
            //         baseMaxSize: '9999999',
            //         baseCurrency: 'KCS'
            //     }
            //
            const data = response['data'];
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const market = data[i];
                const id = this.safeString (market, 'symbol');
                const [ baseId, quoteId ] = id.split ('-');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const active = this.safeValue (market, 'enableTrading');
                const baseMaxSize = this.safeNumber (market, 'baseMaxSize');
                const baseMinSizeString = this.safeString (market, 'baseMinSize');
                const quoteMaxSizeString = this.safeString (market, 'quoteMaxSize');
                const baseMinSize = this.parseNumber (baseMinSizeString);
                const quoteMaxSize = this.parseNumber (quoteMaxSizeString);
                const quoteMinSize = this.safeNumber (market, 'quoteMinSize');
                // const quoteIncrement = this.safeNumber (market, 'quoteIncrement');
                const precision = {
                    'amount': this.precisionFromString (this.safeString (market, 'baseIncrement')),
                    'price': this.precisionFromString (this.safeString (market, 'priceIncrement')),
                };
                const limits = {
                    'amount': {
                        'min': baseMinSize,
                        'max': baseMaxSize,
                    },
                    'price': {
                        'min': this.safeNumber (market, 'priceIncrement'),
                        'max': this.parseNumber (Precise.stringDiv (quoteMaxSizeString, baseMinSizeString)),
                    },
                    'cost': {
                        'min': quoteMinSize,
                        'max': quoteMaxSize,
                    },
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'base': base,
                    'quote': quote,
                    'active': active,
                    'precision': precision,
                    'limits': limits,
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     {
            //         "currency": "OMG",
            //         "name": "OMG",
            //         "fullName": "OmiseGO",
            //         "precision": 8,
            //         "confirms": 12,
            //         "withdrawalMinSize": "4",
            //         "withdrawalMinFee": "1.25",
            //         "isWithdrawEnabled": false,
            //         "isDepositEnabled": false,
            //         "isMarginEnabled": false,
            //         "isDebitEnabled": false
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            const result = {};
            for (let i = 0; i < data.length; i++) {
                const entry = data[i];
                const id = this.safeString (entry, 'currency');
                const name = this.safeString (entry, 'fullName');
                const code = this.safeCurrencyCode (id);
                const precision = this.safeInteger (entry, 'precision');
                const isWithdrawEnabled = this.safeValue (entry, 'isWithdrawEnabled', false);
                const isDepositEnabled = this.safeValue (entry, 'isDepositEnabled', false);
                const fee = this.safeNumber (entry, 'withdrawalMinFee');
                const active = (isWithdrawEnabled && isDepositEnabled);
                result[code] = {
                    'id': id,
                    'name': name,
                    'code': code,
                    'precision': precision,
                    'info': entry,
                    'active': active,
                    'fee': fee,
                    'limits': this.limits,
                };
            }
            return result;
        }
    
        async fetchAccounts (params = {}) {
            const response = await this.privateGetAccounts (params);
            //
            //     {
            //         code: "200000",
            //         data: [
            //             {
            //                 balance: "0.00009788",
            //                 available: "0.00009788",
            //                 holds: "0",
            //                 currency: "BTC",
            //                 id: "5c6a4fd399a1d81c4f9cc4d0",
            //                 type: "trade"
            //             },
            //             {
            //                 balance: "0.00000001",
            //                 available: "0.00000001",
            //                 holds: "0",
            //                 currency: "ETH",
            //                 id: "5c6a49ec99a1d819392e8e9f",
            //                 type: "trade"
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data');
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const account = data[i];
                const accountId = this.safeString (account, 'id');
                const currencyId = this.safeString (account, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const type = this.safeString (account, 'type');  // main or trade
                result.push ({
                    'id': accountId,
                    'type': type,
                    'currency': code,
                    'info': account,
                });
            }
            return result;
        }
    
        async fetchFundingFee (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
            };
            const response = await this.privateGetWithdrawalsQuotas (this.extend (request, params));
            const data = response['data'];
            const withdrawFees = {};
            withdrawFees[code] = this.safeNumber (data, 'withdrawMinFee');
            return {
                'info': response,
                'withdraw': withdrawFees,
                'deposit': {},
            };
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         symbol: "ETH-BTC",
            //         high: "0.019518",
            //         vol: "7997.82836194",
            //         last: "0.019329",
            //         low: "0.019",
            //         buy: "0.019329",
            //         sell: "0.01933",
            //         changePrice: "-0.000139",
            //         time:  1580553706304,
            //         averagePrice: "0.01926386",
            //         changeRate: "-0.0071",
            //         volValue: "154.40791568183474"
            //     }
            //
            //     {
            //         "trading": true,
            //         "symbol": "KCS-BTC",
            //         "buy": 0.00011,
            //         "sell": 0.00012,
            //         "sort": 100,
            //         "volValue": 3.13851792584,   //total
            //         "baseCurrency": "KCS",
            //         "market": "BTC",
            //         "quoteCurrency": "BTC",
            //         "symbolCode": "KCS-BTC",
            //         "datetime": 1548388122031,
            //         "high": 0.00013,
            //         "vol": 27514.34842,
            //         "low": 0.0001,
            //         "changePrice": -1.0e-5,
            //         "changeRate": -0.0769,
            //         "lastTradedPrice": 0.00012,
            //         "board": 0,
            //         "mark": 0
            //     }
            //
            let percentage = this.safeNumber (ticker, 'changeRate');
            if (percentage !== undefined) {
                percentage = percentage * 100;
            }
            const last = this.safeNumber2 (ticker, 'last', 'lastTradedPrice');
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '-');
            const baseVolume = this.safeNumber (ticker, 'vol');
            const quoteVolume = this.safeNumber (ticker, 'volValue');
            const vwap = this.vwap (baseVolume, quoteVolume);
            const timestamp = this.safeInteger2 (ticker, 'time', 'datetime');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': vwap,
                'open': this.safeNumber (ticker, 'open'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': this.safeNumber (ticker, 'changePrice'),
                'percentage': percentage,
                'average': this.safeNumber (ticker, 'averagePrice'),
                'baseVolume': baseVolume,
                'quoteVolume': quoteVolume,
                'info': ticker,
            };
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetMarketAllTickers (params);
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             "date": 1550661940645,
            //             "ticker": [
            //                 'buy': '0.00001168',
            //                 'changePrice': '-0.00000018',
            //                 'changeRate': '-0.0151',
            //                 'datetime': 1550661146316,
            //                 'high': '0.0000123',
            //                 'last': '0.00001169',
            //                 'low': '0.00001159',
            //                 'sell': '0.00001182',
            //                 'symbol': 'LOOM-BTC',
            //                 'vol': '44399.5669'
            //             },
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const tickers = this.safeValue (data, 'ticker', []);
            const result = {};
            for (let i = 0; i < tickers.length; i++) {
                const ticker = this.parseTicker (tickers[i]);
                const symbol = this.safeString (ticker, 'symbol');
                if (symbol !== undefined) {
                    result[symbol] = ticker;
                }
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetMarketStats (this.extend (request, params));
            //
            //     {
            //         "code": "200000",
            //         "data": {
            //             'buy': '0.00001168',
            //             'changePrice': '-0.00000018',
            //             'changeRate': '-0.0151',
            //             'datetime': 1550661146316,
            //             'high': '0.0000123',
            //             'last': '0.00001169',
            //             'low': '0.00001159',
            //             'sell': '0.00001182',
            //             'symbol': 'LOOM-BTC',
            //             'vol': '44399.5669'
            //         },
            //     }
            //
            return this.parseTicker (response['data'], market);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         "1545904980",             // Start time of the candle cycle
            //         "0.058",                  // opening price
            //         "0.049",                  // closing price
            //         "0.058",                  // highest price
            //         "0.049",                  // lowest price
            //         "0.018",                  // base volume
            //         "0.000945",               // quote volume
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '15m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const marketId = market['id'];
            const request = {
                'symbol': marketId,
                'type': this.timeframes[timeframe],
            };
            const duration = this.parseTimeframe (timeframe) * 1000;
            let endAt = this.milliseconds (); // required param
            if (since !== undefined) {
                request['startAt'] = parseInt (Math.floor (since / 1000));
                if (limit === undefined) {
                    // https://docs.kucoin.com/#get-klines
                    // https://docs.kucoin.com/#details
                    // For each query, the system would return at most 1500 pieces of data.
                    // To obtain more data, please page the data by time.
                    limit = this.safeInteger (this.options, 'fetchOHLCVLimit', 1500);
                }
                endAt = this.sum (since, limit * duration);
            } else if (limit !== undefined) {
                since = endAt - limit * duration;
                request['startAt'] = parseInt (Math.floor (since / 1000));
            }
            request['endAt'] = parseInt (Math.floor (endAt / 1000));
            const response = await this.publicGetMarketCandles (this.extend (request, params));
            //
            //     {
            //         "code":"200000",
            //         "data":[
            //             ["1591517700","0.025078","0.025069","0.025084","0.025064","18.9883256","0.4761861079404"],
            //             ["1591516800","0.025089","0.025079","0.025089","0.02506","99.4716622","2.494143499081"],
            //             ["1591515900","0.025079","0.02509","0.025091","0.025068","59.83701271","1.50060885172798"],
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', []);
            return this.parseOHLCVs (data, market, timeframe, since, limit);
        }
    
        async createDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = { 'currency': currency['id'] };
            const response = await this.privatePostDepositAddresses (this.extend (request, params));
            // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
            // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
            const data = this.safeValue (response, 'data', {});
            let address = this.safeString (data, 'address');
            // BCH/BSV is returned with a "bitcoincash:" prefix, which we cut off here and only keep the address
            if (address !== undefined) {
                address = address.replace ('bitcoincash:', '');
            }
            const tag = this.safeString (data, 'memo');
            if (code !== 'NIM') {
                // contains spaces
                this.checkAddress (address);
            }
            return {
                'info': response,
                'currency': code,
                'address': address,
                'tag': tag,
            };
        }
    
        async fetchDepositAddress (code, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                // for USDT - OMNI, ERC20, TRC20, default is ERC20
                // for BTC - Native, Segwit, TRC20, the parameters are bech32, btc, trx, default is Native
                // 'chain': 'ERC20', // optional
            };
            const response = await this.privateGetDepositAddresses (this.extend (request, params));
            // BCH {"code":"200000","data":{"address":"bitcoincash:qza3m4nj9rx7l9r0cdadfqxts6f92shvhvr5ls4q7z","memo":""}}
            // BTC {"code":"200000","data":{"address":"36SjucKqQpQSvsak9A7h6qzFjrVXpRNZhE","memo":""}}
            const data = this.safeValue (response, 'data', {});
            const address = this.safeString (data, 'address');
            const tag = this.safeString (data, 'memo');
            if (code !== 'NIM') {
                // contains spaces
                this.checkAddress (address);
            }
            return {
                'info': response,
                'currency': code,
                'address': address,
                'tag': tag,
            };
        }
    
        async fetchL3OrderBook (symbol, limit = undefined, params = {}) {
            return await this.fetchOrderBook (symbol, limit, { 'level': 3 });
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const marketId = this.marketId (symbol);
            const level = this.safeInteger (params, 'level', 2);
            const request = { 'symbol': marketId, 'level': level };
            let method = 'privateGetMarketOrderbookLevelLevel';
            if (level === 2) {
                if (limit !== undefined) {
                    if ((limit === 20) || (limit === 100)) {
                        request['limit'] = limit;
                        method = 'publicGetMarketOrderbookLevelLevelLimit';
                    } else {
                        throw new ExchangeError (this.id + ' fetchOrderBook limit argument must be undefined, 20 or 100');
                    }
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            // 'market/orderbook/level2'
            // 'market/orderbook/level2_20'
            // 'market/orderbook/level2_100'
            //
            //     {
            //         "code":"200000",
            //         "data":{
            //             "sequence":"1583235112106",
            //             "asks":[
            //                 // ...
            //                 ["0.023197","12.5067468"],
            //                 ["0.023194","1.8"],
            //                 ["0.023191","8.1069672"]
            //             ],
            //             "bids":[
            //                 ["0.02319","1.6000002"],
            //                 ["0.023189","2.2842325"],
            //             ],
            //             "time":1586584067274
            //         }
            //     }
            //
            // 'market/orderbook/level3'
            //
            //     {
            //         "code":"200000",
            //         "data":{
            //             "sequence":"1583731857120",
            //             "asks":[
            //                 // id, price, size, timestamp in nanoseconds
            //                 ["5e915f8acd26670009675300","6925.7","0.2","1586585482194286069"],
            //                 ["5e915f8ace35a200090bba48","6925.7","0.001","1586585482229569826"],
            //                 ["5e915f8a8857740009ca7d33","6926","0.00001819","1586585482149148621"],
            //             ],
            //             "bids":[
            //                 ["5e915f8acca406000ac88194","6925.6","0.05","1586585482384384842"],
            //                 ["5e915f93cd26670009676075","6925.6","0.08","1586585491334914600"],
            //                 ["5e915f906aa6e200099b49f6","6925.4","0.2","1586585488941126340"],
            //             ],
            //             "time":1586585492487
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            const timestamp = this.safeInteger (data, 'time');
            const orderbook = this.parseOrderBook (data, symbol, timestamp, 'bids', 'asks', level - 2, level - 1);
            orderbook['nonce'] = this.safeInteger (data, 'sequence');
            return orderbook;
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const marketId = this.marketId (symbol);
            // required param, cannot be used twice
            const clientOrderId = this.safeString2 (params, 'clientOid', 'clientOrderId', this.uuid ());
            params = this.omit (params, [ 'clientOid', 'clientOrderId' ]);
            const request = {
                'clientOid': clientOrderId,
                'side': side,
                'symbol': marketId,
                'type': type, // limit or market
                // 'remark': '', // optional remark for the order, length cannot exceed 100 utf8 characters
                // 'stp': '', // self trade prevention, CN, CO, CB or DC
                // To improve the system performance and to accelerate order placing and processing, KuCoin has added a new interface for margin orders
                // The current one will no longer accept margin orders by May 1st, 2021 (UTC)
                // At the time, KuCoin will notify users via the announcement, please pay attention to it
                // 'tradeType': 'TRADE', // TRADE, MARGIN_TRADE // not used with margin orders
                // limit orders ---------------------------------------------------
                // 'timeInForce': 'GTC', // GTC, GTT, IOC, or FOK (default is GTC), limit orders only
                // 'cancelAfter': long, // cancel after n seconds, requires timeInForce to be GTT
                // 'postOnly': false, // Post only flag, invalid when timeInForce is IOC or FOK
                // 'hidden': false, // Order will not be displayed in the order book
                // 'iceberg': false, // Only a portion of the order is displayed in the order book
                // 'visibleSize': this.amountToPrecision (symbol, visibleSize), // The maximum visible size of an iceberg order
                // market orders --------------------------------------------------
                // 'size': this.amountToPrecision (symbol, amount), // Amount in base currency
                // 'funds': this.costToPrecision (symbol, cost), // Amount of quote currency to use
                // stop orders ----------------------------------------------------
                // 'stop': 'loss', // loss or entry, the default is loss, requires stopPrice
                // 'stopPrice': this.priceToPrecision (symbol, amount), // need to be defined if stop is specified
                // margin orders --------------------------------------------------
                // 'marginMode': 'cross', // cross (cross mode) and isolated (isolated mode), set to cross by default, the isolated mode will be released soon, stay tuned
                // 'autoBorrow': false, // The system will first borrow you funds at the optimal interest rate and then place an order for you
            };
            const quoteAmount = this.safeNumber2 (params, 'cost', 'funds');
            let amountString = undefined;
            let costString = undefined;
            if (type === 'market') {
                if (quoteAmount !== undefined) {
                    params = this.omit (params, [ 'cost', 'funds' ]);
                    // kucoin uses base precision even for quote values
                    costString = this.amountToPrecision (symbol, quoteAmount);
                    request['funds'] = costString;
                } else {
                    amountString = this.amountToPrecision (symbol, amount);
                    request['size'] = this.amountToPrecision (symbol, amount);
                }
            } else {
                amountString = this.amountToPrecision (symbol, amount);
                request['size'] = amountString;
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            //
            //     {
            //         code: '200000',
            //         data: {
            //             "orderId": "5bd6e9286d99522a52e458de"
            //         }
            //    }
            //
            const data = this.safeValue (response, 'data', {});
            const timestamp = this.milliseconds ();
            const id = this.safeString (data, 'orderId');
            const order = {
                'id': id,
                'clientOrderId': clientOrderId,
                'info': data,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'symbol': symbol,
                'type': type,
                'side': side,
                'price': price,
                'amount': this.parseNumber (amountString),
                'cost': this.parseNumber (costString),
                'average': undefined,
                'filled': undefined,
                'remaining': undefined,
                'status': undefined,
                'fee': undefined,
                'trades': undefined,
            };
            return order;
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const clientOrderId = this.safeString2 (params, 'clientOid', 'clientOrderId');
            let method = 'privateDeleteOrdersOrderId';
            if (clientOrderId !== undefined) {
                request['clientOid'] = clientOrderId;
                method = 'privateDeleteOrdersClientOrderClientOid';
            } else {
                request['orderId'] = id;
            }
            params = this.omit (params, [ 'clientOid', 'clientOrderId' ]);
            return await this[method] (this.extend (request, params));
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                // 'symbol': market['id'],
                // 'tradeType': 'TRADE', // default is to cancel the spot trading order
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            return await this.privateDeleteOrders (this.extend (request, params));
        }
    
        async fetchOrdersByStatus (status, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'status': status,
            };
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (since !== undefined) {
                request['startAt'] = since;
            }
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            const response = await this.privateGetOrders (this.extend (request, params));
            //
            //     {
            //         code: '200000',
            //         data: {
            //             "currentPage": 1,
            //             "pageSize": 1,
            //             "totalNum": 153408,
            //             "totalPage": 153408,
            //             "items": [
            //                 {
            //                     "id": "5c35c02703aa673ceec2a168",   //orderid
            //                     "symbol": "BTC-USDT",   //symbol
            //                     "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
            //                     "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
            //                     "side": "buy",         // transaction direction,include buy and sell
            //                     "price": "10",         // order price
            //                     "size": "2",           // order quantity
            //                     "funds": "0",          // order funds
            //                     "dealFunds": "0.166",  // deal funds
            //                     "dealSize": "2",       // deal quantity
            //                     "fee": "0",            // fee
            //                     "feeCurrency": "USDT", // charge fee currency
            //                     "stp": "",             // self trade prevention,include CN,CO,DC,CB
            //                     "stop": "",            // stop type
            //                     "stopTriggered": false,  // stop order is triggered
            //                     "stopPrice": "0",      // stop price
            //                     "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
            //                     "postOnly": false,     // postOnly
            //                     "hidden": false,       // hidden order
            //                     "iceberg": false,      // iceberg order
            //                     "visibleSize": "0",    // display quantity for iceberg order
            //                     "cancelAfter": 0,      // cancel orders time，requires timeInForce to be GTT
            //                     "channel": "IOS",      // order source
            //                     "clientOid": "",       // user-entered order unique mark
            //                     "remark": "",          // remark
            //                     "tags": "",            // tag order source
            //                     "isActive": false,     // status before unfilled or uncancelled
            //                     "cancelExist": false,   // order cancellation transaction record
            //                     "createdAt": 1547026471000  // time
            //                 },
            //             ]
            //         }
            //    }
            const responseData = this.safeValue (response, 'data', {});
            const orders = this.safeValue (responseData, 'items', []);
            return this.parseOrders (orders, market, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStatus ('done', symbol, since, limit, params);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return await this.fetchOrdersByStatus ('active', symbol, since, limit, params);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            const clientOrderId = this.safeString2 (params, 'clientOid', 'clientOrderId');
            let method = 'privateGetOrdersOrderId';
            if (clientOrderId !== undefined) {
                request['clientOid'] = clientOrderId;
                method = 'privateGetOrdersClientOrderClientOid';
            } else {
                // a special case for undefined ids
                // otherwise a wrong endpoint for all orders will be triggered
                // https://github.com/ccxt/ccxt/issues/7234
                if (id === undefined) {
                    throw new InvalidOrder (this.id + ' fetchOrder() requires an order id');
                }
                request['orderId'] = id;
            }
            params = this.omit (params, [ 'clientOid', 'clientOrderId' ]);
            const response = await this[method] (this.extend (request, params));
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
            }
            const responseData = this.safeValue (response, 'data');
            return this.parseOrder (responseData, market);
        }
    
        parseOrder (order, market = undefined) {
            //
            // fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "id": "5c35c02703aa673ceec2a168",   //orderid
            //         "symbol": "BTC-USDT",   //symbol
            //         "opType": "DEAL",      // operation type,deal is pending order,cancel is cancel order
            //         "type": "limit",       // order type,e.g. limit,markrt,stop_limit.
            //         "side": "buy",         // transaction direction,include buy and sell
            //         "price": "10",         // order price
            //         "size": "2",           // order quantity
            //         "funds": "0",          // order funds
            //         "dealFunds": "0.166",  // deal funds
            //         "dealSize": "2",       // deal quantity
            //         "fee": "0",            // fee
            //         "feeCurrency": "USDT", // charge fee currency
            //         "stp": "",             // self trade prevention,include CN,CO,DC,CB
            //         "stop": "",            // stop type
            //         "stopTriggered": false,  // stop order is triggered
            //         "stopPrice": "0",      // stop price
            //         "timeInForce": "GTC",  // time InForce,include GTC,GTT,IOC,FOK
            //         "postOnly": false,     // postOnly
            //         "hidden": false,       // hidden order
            //         "iceberg": false,      // iceberg order
            //         "visibleSize": "0",    // display quantity for iceberg order
            //         "cancelAfter": 0,      // cancel orders time，requires timeInForce to be GTT
            //         "channel": "IOS",      // order source
            //         "clientOid": "",       // user-entered order unique mark
            //         "remark": "",          // remark
            //         "tags": "",            // tag order source
            //         "isActive": false,     // status before unfilled or uncancelled
            //         "cancelExist": false,   // order cancellation transaction record
            //         "createdAt": 1547026471000  // time
            //     }
            //
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '-');
            const orderId = this.safeString (order, 'id');
            const type = this.safeString (order, 'type');
            const timestamp = this.safeInteger (order, 'createdAt');
            const datetime = this.iso8601 (timestamp);
            let price = this.safeNumber (order, 'price');
            if (price === 0.0) {
                // market orders
                price = undefined;
            }
            const side = this.safeString (order, 'side');
            const feeCurrencyId = this.safeString (order, 'feeCurrency');
            const feeCurrency = this.safeCurrencyCode (feeCurrencyId);
            const feeCost = this.safeNumber (order, 'fee');
            const amount = this.safeNumber (order, 'size');
            const filled = this.safeNumber (order, 'dealSize');
            const cost = this.safeNumber (order, 'dealFunds');
            // bool
            const isActive = this.safeValue (order, 'isActive', false);
            const cancelExist = this.safeValue (order, 'cancelExist', false);
            let status = isActive ? 'open' : 'closed';
            status = cancelExist ? 'canceled' : status;
            const fee = {
                'currency': feeCurrency,
                'cost': feeCost,
            };
            const clientOrderId = this.safeString (order, 'clientOid');
            const timeInForce = this.safeString (order, 'timeInForce');
            const stopPrice = this.safeNumber (order, 'stopPrice');
            const postOnly = this.safeValue (order, 'postOnly');
            return this.safeOrder ({
                'id': orderId,
                'clientOrderId': clientOrderId,
                'symbol': symbol,
                'type': type,
                'timeInForce': timeInForce,
                'postOnly': postOnly,
                'side': side,
                'amount': amount,
                'price': price,
                'stopPrice': stopPrice,
                'cost': cost,
                'filled': filled,
                'remaining': undefined,
                'timestamp': timestamp,
                'datetime': datetime,
                'fee': fee,
                'status': status,
                'info': order,
                'lastTradeTimestamp': undefined,
                'average': undefined,
                'trades': undefined,
            });
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let market = undefined;
            if (symbol !== undefined) {
                market = this.market (symbol);
                request['symbol'] = market['id'];
            }
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            const method = this.options['fetchMyTradesMethod'];
            let parseResponseData = false;
            if (method === 'private_get_fills') {
                // does not return trades earlier than 2019-02-18T00:00:00Z
                if (since !== undefined) {
                    // only returns trades up to one week after the since param
                    request['startAt'] = since;
                }
            } else if (method === 'private_get_limit_fills') {
                // does not return trades earlier than 2019-02-18T00:00:00Z
                // takes no params
                // only returns first 1000 trades (not only "in the last 24 hours" as stated in the docs)
                parseResponseData = true;
            } else if (method === 'private_get_hist_orders') {
                // despite that this endpoint is called `HistOrders`
                // it returns historical trades instead of orders
                // returns trades earlier than 2019-02-18T00:00:00Z only
                if (since !== undefined) {
                    request['startAt'] = parseInt (since / 1000);
                }
            } else {
                throw new ExchangeError (this.id + ' invalid fetchClosedOrder method');
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "currentPage": 1,
            //         "pageSize": 50,
            //         "totalNum": 1,
            //         "totalPage": 1,
            //         "items": [
            //             {
            //                 "symbol":"BTC-USDT",       // symbol
            //                 "tradeId":"5c35c02709e4f67d5266954e",        // trade id
            //                 "orderId":"5c35c02703aa673ceec2a168",        // order id
            //                 "counterOrderId":"5c1ab46003aa676e487fa8e3", // counter order id
            //                 "side":"buy",              // transaction direction,include buy and sell
            //                 "liquidity":"taker",       // include taker and maker
            //                 "forceTaker":true,         // forced to become taker
            //                 "price":"0.083",           // order price
            //                 "size":"0.8424304",        // order quantity
            //                 "funds":"0.0699217232",    // order funds
            //                 "fee":"0",                 // fee
            //                 "feeRate":"0",             // fee rate
            //                 "feeCurrency":"USDT",      // charge fee currency
            //                 "stop":"",                 // stop type
            //                 "type":"limit",            // order type, e.g. limit, market, stop_limit.
            //                 "createdAt":1547026472000  // time
            //             },
            //             //------------------------------------------------------
            //             // v1 (historical) trade response structure
            //             {
            //                 "symbol": "SNOV-ETH",
            //                 "dealPrice": "0.0000246",
            //                 "dealValue": "0.018942",
            //                 "amount": "770",
            //                 "fee": "0.00001137",
            //                 "side": "sell",
            //                 "createdAt": 1540080199
            //                 "id":"5c4d389e4c8c60413f78e2e5",
            //             }
            //         ]
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            let trades = undefined;
            if (parseResponseData) {
                trades = data;
            } else {
                trades = this.safeValue (data, 'items', []);
            }
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (since !== undefined) {
                request['startAt'] = Math.floor (since / 1000);
            }
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            const response = await this.publicGetMarketHistories (this.extend (request, params));
            //
            //     {
            //         "code": "200000",
            //         "data": [
            //             {
            //                 "sequence": "1548764654235",
            //                 "side": "sell",
            //                 "size":"0.6841354",
            //                 "price":"0.03202",
            //                 "time":1548848575203567174
            //             }
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'data', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         "sequence": "1548764654235",
            //         "side": "sell",
            //         "size":"0.6841354",
            //         "price":"0.03202",
            //         "time":1548848575203567174
            //     }
            //
            //     {
            //         sequence: '1568787654360',
            //         symbol: 'BTC-USDT',
            //         side: 'buy',
            //         size: '0.00536577',
            //         price: '9345',
            //         takerOrderId: '5e356c4a9f1a790008f8d921',
            //         time: '1580559434436443257',
            //         type: 'match',
            //         makerOrderId: '5e356bffedf0010008fa5d7f',
            //         tradeId: '5e356c4aeefabd62c62a1ece'
            //     }
            //
            // fetchMyTrades (private) v2
            //
            //     {
            //         "symbol":"BTC-USDT",
            //         "tradeId":"5c35c02709e4f67d5266954e",
            //         "orderId":"5c35c02703aa673ceec2a168",
            //         "counterOrderId":"5c1ab46003aa676e487fa8e3",
            //         "side":"buy",
            //         "liquidity":"taker",
            //         "forceTaker":true,
            //         "price":"0.083",
            //         "size":"0.8424304",
            //         "funds":"0.0699217232",
            //         "fee":"0",
            //         "feeRate":"0",
            //         "feeCurrency":"USDT",
            //         "stop":"",
            //         "type":"limit",
            //         "createdAt":1547026472000
            //     }
            //
            // fetchMyTrades v2 alternative format since 2019-05-21 https://github.com/ccxt/ccxt/pull/5162
            //
            //     {
            //         symbol: "OPEN-BTC",
            //         forceTaker:  false,
            //         orderId: "5ce36420054b4663b1fff2c9",
            //         fee: "0",
            //         feeCurrency: "",
            //         type: "",
            //         feeRate: "0",
            //         createdAt: 1558417615000,
            //         size: "12.8206",
            //         stop: "",
            //         price: "0",
            //         funds: "0",
            //         tradeId: "5ce390cf6e0db23b861c6e80"
            //     }
            //
            // fetchMyTrades (private) v1 (historical)
            //
            //     {
            //         "symbol": "SNOV-ETH",
            //         "dealPrice": "0.0000246",
            //         "dealValue": "0.018942",
            //         "amount": "770",
            //         "fee": "0.00001137",
            //         "side": "sell",
            //         "createdAt": 1540080199
            //         "id":"5c4d389e4c8c60413f78e2e5",
            //     }
            //
            const marketId = this.safeString (trade, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '-');
            const id = this.safeString2 (trade, 'tradeId', 'id');
            const orderId = this.safeString (trade, 'orderId');
            const takerOrMaker = this.safeString (trade, 'liquidity');
            let timestamp = this.safeInteger (trade, 'time');
            if (timestamp !== undefined) {
                timestamp = parseInt (timestamp / 1000000);
            } else {
                timestamp = this.safeInteger (trade, 'createdAt');
                // if it's a historical v1 trade, the exchange returns timestamp in seconds
                if (('dealValue' in trade) && (timestamp !== undefined)) {
                    timestamp = timestamp * 1000;
                }
            }
            const priceString = this.safeString2 (trade, 'price', 'dealPrice');
            const amountString = this.safeString2 (trade, 'size', 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const side = this.safeString (trade, 'side');
            let fee = undefined;
            const feeCost = this.safeNumber (trade, 'fee');
            if (feeCost !== undefined) {
                const feeCurrencyId = this.safeString (trade, 'feeCurrency');
                let feeCurrency = this.safeCurrencyCode (feeCurrencyId);
                if (feeCurrency === undefined) {
                    if (market !== undefined) {
                        feeCurrency = (side === 'sell') ? market['quote'] : market['base'];
                    }
                }
                fee = {
                    'cost': feeCost,
                    'currency': feeCurrency,
                    'rate': this.safeNumber (trade, 'feeRate'),
                };
            }
            let type = this.safeString (trade, 'type');
            if (type === 'match') {
                type = undefined;
            }
            let cost = this.safeNumber2 (trade, 'funds', 'dealValue');
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            return {
                'info': trade,
                'id': id,
                'order': orderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': type,
                'takerOrMaker': takerOrMaker,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            await this.loadMarkets ();
            this.checkAddress (address);
            const currency = this.currency (code);
            const request = {
                'currency': currency['id'],
                'address': address,
                'amount': amount,
                // 'memo': tag,
                // 'isInner': false, // internal transfer or external withdrawal
                // 'remark': 'optional',
                // 'chain': 'OMNI', // 'ERC20', 'TRC20', default is ERC20
            };
            if (tag !== undefined) {
                request['memo'] = tag;
            }
            const response = await this.privatePostWithdrawals (this.extend (request, params));
            //
            // https://github.com/ccxt/ccxt/issues/5558
            //
            //     {
            //         "code":  200000,
            //         "data": {
            //             "withdrawalId":  "abcdefghijklmnopqrstuvwxyz"
            //         }
            //     }
            //
            const data = this.safeValue (response, 'data', {});
            return {
                'id': this.safeString (data, 'withdrawalId'),
                'info': response,
            };
        }
    
        parseTransactionStatus (status) {
            const statuses = {
                'SUCCESS': 'ok',
                'PROCESSING': 'ok',
                'FAILURE': 'failed',
            };
            return this.safeString (statuses, status);
        }
    
        parseTransaction (transaction, currency = undefined) {
            //
            // fetchDeposits
            //
            //     {
            //         "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
            //         "memo": "5c247c8a03aa677cea2a251d",
            //         "amount": 1,
            //         "fee": 0.0001,
            //         "currency": "KCS",
            //         "isInner": false,
            //         "walletTxId": "5bbb57386d99522d9f954c5a@test004",
            //         "status": "SUCCESS",
            //         "createdAt": 1544178843000,
            //         "updatedAt": 1544178891000
            //         "remark":"foobar"
            //     }
            //
            // fetchWithdrawals
            //
            //     {
            //         "id": "5c2dc64e03aa675aa263f1ac",
            //         "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
            //         "memo": "",
            //         "currency": "ETH",
            //         "amount": 1.0000000,
            //         "fee": 0.0100000,
            //         "walletTxId": "3e2414d82acce78d38be7fe9",
            //         "isInner": false,
            //         "status": "FAILURE",
            //         "createdAt": 1546503758000,
            //         "updatedAt": 1546504603000
            //         "remark":"foobar"
            //     }
            //
            const currencyId = this.safeString (transaction, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            let address = this.safeString (transaction, 'address');
            const amount = this.safeNumber (transaction, 'amount');
            let txid = this.safeString (transaction, 'walletTxId');
            if (txid !== undefined) {
                const txidParts = txid.split ('@');
                const numTxidParts = txidParts.length;
                if (numTxidParts > 1) {
                    if (address === undefined) {
                        if (txidParts[1].length > 1) {
                            address = txidParts[1];
                        }
                    }
                }
                txid = txidParts[0];
            }
            let type = (txid === undefined) ? 'withdrawal' : 'deposit';
            const rawStatus = this.safeString (transaction, 'status');
            const status = this.parseTransactionStatus (rawStatus);
            let fee = undefined;
            const feeCost = this.safeNumber (transaction, 'fee');
            if (feeCost !== undefined) {
                let rate = undefined;
                if (amount !== undefined) {
                    rate = feeCost / amount;
                }
                fee = {
                    'cost': feeCost,
                    'rate': rate,
                    'currency': code,
                };
            }
            const tag = this.safeString (transaction, 'memo');
            let timestamp = this.safeInteger2 (transaction, 'createdAt', 'createAt');
            const id = this.safeString (transaction, 'id');
            let updated = this.safeInteger (transaction, 'updatedAt');
            const isV1 = !('createdAt' in transaction);
            // if it's a v1 structure
            if (isV1) {
                type = ('address' in transaction) ? 'withdrawal' : 'deposit';
                if (timestamp !== undefined) {
                    timestamp = timestamp * 1000;
                }
                if (updated !== undefined) {
                    updated = updated * 1000;
                }
            }
            const comment = this.safeString (transaction, 'remark');
            return {
                'id': id,
                'info': transaction,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'address': address,
                'addressTo': address,
                'addressFrom': undefined,
                'tag': tag,
                'tagTo': tag,
                'tagFrom': undefined,
                'currency': code,
                'amount': amount,
                'txid': txid,
                'type': type,
                'status': status,
                'comment': comment,
                'fee': fee,
                'updated': updated,
            };
        }
    
        async fetchDeposits (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            let method = 'privateGetDeposits';
            if (since !== undefined) {
                // if since is earlier than 2019-02-18T00:00:00Z
                if (since < 1550448000000) {
                    request['startAt'] = parseInt (since / 1000);
                    method = 'privateGetHistDeposits';
                } else {
                    request['startAt'] = since;
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         code: '200000',
            //         data: {
            //             "currentPage": 1,
            //             "pageSize": 5,
            //             "totalNum": 2,
            //             "totalPage": 1,
            //             "items": [
            //                 //--------------------------------------------------
            //                 // version 2 deposit response structure
            //                 {
            //                     "address": "0x5f047b29041bcfdbf0e4478cdfa753a336ba6989",
            //                     "memo": "5c247c8a03aa677cea2a251d",
            //                     "amount": 1,
            //                     "fee": 0.0001,
            //                     "currency": "KCS",
            //                     "isInner": false,
            //                     "walletTxId": "5bbb57386d99522d9f954c5a@test004",
            //                     "status": "SUCCESS",
            //                     "createdAt": 1544178843000,
            //                     "updatedAt": 1544178891000
            //                     "remark":"foobar"
            //                 },
            //                 //--------------------------------------------------
            //                 // version 1 (historical) deposit response structure
            //                 {
            //                     "currency": "BTC",
            //                     "createAt": 1528536998,
            //                     "amount": "0.03266638",
            //                     "walletTxId": "55c643bc2c68d6f17266383ac1be9e454038864b929ae7cee0bc408cc5c869e8@12ffGWmMMD1zA1WbFm7Ho3JZ1w6NYXjpFk@234",
            //                     "isInner": false,
            //                     "status": "SUCCESS",
            //                 }
            //             ]
            //         }
            //     }
            //
            const responseData = response['data']['items'];
            return this.parseTransactions (responseData, currency, since, limit, { 'type': 'deposit' });
        }
    
        async fetchWithdrawals (code = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {};
            let currency = undefined;
            if (code !== undefined) {
                currency = this.currency (code);
                request['currency'] = currency['id'];
            }
            if (limit !== undefined) {
                request['pageSize'] = limit;
            }
            let method = 'privateGetWithdrawals';
            if (since !== undefined) {
                // if since is earlier than 2019-02-18T00:00:00Z
                if (since < 1550448000000) {
                    request['startAt'] = parseInt (since / 1000);
                    method = 'privateGetHistWithdrawals';
                } else {
                    request['startAt'] = since;
                }
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         code: '200000',
            //         data: {
            //             "currentPage": 1,
            //             "pageSize": 5,
            //             "totalNum": 2,
            //             "totalPage": 1,
            //             "items": [
            //                 //--------------------------------------------------
            //                 // version 2 withdrawal response structure
            //                 {
            //                     "id": "5c2dc64e03aa675aa263f1ac",
            //                     "address": "0x5bedb060b8eb8d823e2414d82acce78d38be7fe9",
            //                     "memo": "",
            //                     "currency": "ETH",
            //                     "amount": 1.0000000,
            //                     "fee": 0.0100000,
            //                     "walletTxId": "3e2414d82acce78d38be7fe9",
            //                     "isInner": false,
            //                     "status": "FAILURE",
            //                     "createdAt": 1546503758000,
            //                     "updatedAt": 1546504603000
            //                 },
            //                 //--------------------------------------------------
            //                 // version 1 (historical) withdrawal response structure
            //                 {
            //                     "currency": "BTC",
            //                     "createAt": 1526723468,
            //                     "amount": "0.534",
            //                     "address": "33xW37ZSW4tQvg443Pc7NLCAs167Yc2XUV",
            //                     "walletTxId": "aeacea864c020acf58e51606169240e96774838dcd4f7ce48acf38e3651323f4",
            //                     "isInner": false,
            //                     "status": "SUCCESS"
            //                 }
            //             ]
            //         }
            //     }
            //
            const responseData = response['data']['items'];
            return this.parseTransactions (responseData, currency, since, limit, { 'type': 'withdrawal' });
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const defaultType = this.safeString2 (this.options, 'fetchBalance', 'defaultType', 'trade');
            const requestedType = this.safeString (params, 'type', defaultType);
            const accountsByType = this.safeValue (this.options, 'accountsByType');
            const type = this.safeString (accountsByType, requestedType);
            if (type === undefined) {
                const keys = Object.keys (accountsByType);
                throw new ExchangeError (this.id + ' type must be one of ' + keys.join (', '));
            }
            params = this.omit (params, 'type');
            if ((type === 'contract') || (type === 'futures')) {
                // futures api requires a futures apiKey
                // only fetches one balance at a time
                // by default it will only fetch the BTC balance of the futures account
                // you can send 'currency' in params to fetch other currencies
                // fetchBalance ({ 'type': 'futures', 'currency': 'USDT' })
                const response = await this.futuresPrivateGetAccountOverview (params);
                //
                //     {
                //         code: '200000',
                //         data: {
                //             accountEquity: 0.00005,
                //             unrealisedPNL: 0,
                //             marginBalance: 0.00005,
                //             positionMargin: 0,
                //             orderMargin: 0,
                //             frozenFunds: 0,
                //             availableBalance: 0.00005,
                //             currency: 'XBT'
                //         }
                //     }
                //
                const result = {
                    'info': response,
                    'timestamp': undefined,
                    'datetime': undefined,
                };
                const data = this.safeValue (response, 'data');
                const currencyId = this.safeString (data, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (data, 'availableBalance');
                account['total'] = this.safeString (data, 'accountEquity');
                result[code] = account;
                return this.parseBalance (result);
            } else {
                const request = {
                    'type': type,
                };
                const response = await this.privateGetAccounts (this.extend (request, params));
                //
                //     {
                //         "code":"200000",
                //         "data":[
                //             {"balance":"0.00009788","available":"0.00009788","holds":"0","currency":"BTC","id":"5c6a4fd399a1d81c4f9cc4d0","type":"trade"},
                //             {"balance":"3.41060034","available":"3.41060034","holds":"0","currency":"SOUL","id":"5c6a4d5d99a1d8182d37046d","type":"trade"},
                //             {"balance":"0.01562641","available":"0.01562641","holds":"0","currency":"NEO","id":"5c6a4f1199a1d8165a99edb1","type":"trade"},
                //         ]
                //     }
                //
                const data = this.safeValue (response, 'data', []);
                const result = {
                    'info': response,
                    'timestamp': undefined,
                    'datetime': undefined,
                };
                for (let i = 0; i < data.length; i++) {
                    const balance = data[i];
                    const balanceType = this.safeString (balance, 'type');
                    if (balanceType === type) {
                        const currencyId = this.safeString (balance, 'currency');
                        const code = this.safeCurrencyCode (currencyId);
                        const account = this.account ();
                        account['total'] = this.safeString (balance, 'balance');
                        account['free'] = this.safeString (balance, 'available');
                        account['used'] = this.safeString (balance, 'holds');
                        result[code] = account;
                    }
                }
                return this.parseBalance (result);
            }
        }
    
        async transfer (code, amount, fromAccount, toAccount, params = {}) {
            await this.loadMarkets ();
            const currency = this.currency (code);
            const requestedAmount = this.currencyToPrecision (code, amount);
            const accountsById = this.safeValue (this.options, 'accountsByType', {});
            const fromId = this.safeString (accountsById, fromAccount);
            if (fromId === undefined) {
                const keys = Object.keys (accountsById);
                throw new ExchangeError (this.id + ' fromAccount must be one of ' + keys.join (', '));
            }
            const toId = this.safeString (accountsById, toAccount);
            if (toId === undefined) {
                const keys = Object.keys (accountsById);
                throw new ExchangeError (this.id + ' toAccount must be one of ' + keys.join (', '));
            }
            if (fromId === 'contract') {
                if (toId !== 'main') {
                    throw new ExchangeError (this.id + ' only supports transferring from futures account to main account');
                }
                const request = {
                    'currency': currency['id'],
                    'amount': requestedAmount,
                };
                if (!('bizNo' in params)) {
                    // it doesn't like more than 24 characters
                    request['bizNo'] = this.uuid22 ();
                }
                const response = await this.futuresPrivatePostTransferOut (this.extend (request, params));
                //
                //     {
                //         code: '200000',
                //         data: {
                //             applyId: '605a87217dff1500063d485d',
                //             bizNo: 'bcd6e5e1291f4905af84dc',
                //             payAccountType: 'CONTRACT',
                //             payTag: 'DEFAULT',
                //             remark: '',
                //             recAccountType: 'MAIN',
                //             recTag: 'DEFAULT',
                //             recRemark: '',
                //             recSystem: 'KUCOIN',
                //             status: 'PROCESSING',
                //             currency: 'XBT',
                //             amount: '0.00001',
                //             fee: '0',
                //             sn: '573688685663948',
                //             reason: '',
                //             createdAt: 1616545569000,
                //             updatedAt: 1616545569000
                //         }
                //     }
                //
                const data = this.safeValue (response, 'data');
                const timestamp = this.safeInteger (data, 'createdAt');
                const id = this.safeString (data, 'applyId');
                const currencyId = this.safeString (data, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const amount = this.safeNumber (data, 'amount');
                const rawStatus = this.safeString (data, 'status');
                let status = undefined;
                if (rawStatus === 'PROCESSING') {
                    status = 'pending';
                }
                return {
                    'info': response,
                    'currency': code,
                    'timestamp': timestamp,
                    'datetime': this.iso8601 (timestamp),
                    'amount': amount,
                    'fromAccount': fromId,
                    'toAccount': toId,
                    'id': id,
                    'status': status,
                };
            } else {
                const request = {
                    'currency': currency['id'],
                    'from': fromId,
                    'to': toId,
                    'amount': requestedAmount,
                };
                if (!('clientOid' in params)) {
                    request['clientOid'] = this.uuid ();
                }
                const response = await this.privatePostAccountsInnerTransfer (this.extend (request, params));
                // { code: '200000', data: { orderId: '605a6211e657f00006ad0ad6' } }
                const data = this.safeValue (response, 'data');
                const id = this.safeString (data, 'orderId');
                return {
                    'info': response,
                    'id': id,
                    'timestamp': undefined,
                    'datetime': undefined,
                    'currency': code,
                    'amount': requestedAmount,
                    'fromAccount': fromId,
                    'toAccount': toId,
                    'status': undefined,
                };
            }
        }
    
        async fetchLedger (code = undefined, since = undefined, limit = undefined, params = {}) {
            if (code === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchLedger() requires a code param');
            }
            await this.loadMarkets ();
            await this.loadAccounts ();
            const currency = this.currency (code);
            let accountId = this.safeString (params, 'accountId');
            if (accountId === undefined) {
                for (let i = 0; i < this.accounts.length; i++) {
                    const account = this.accounts[i];
                    if (account['currency'] === code && account['type'] === 'main') {
                        accountId = account['id'];
                        break;
                    }
                }
            }
            if (accountId === undefined) {
                throw new ExchangeError (this.id + ' ' + code + 'main account is not loaded in loadAccounts');
            }
            const request = {
                'accountId': accountId,
            };
            if (since !== undefined) {
                request['startAt'] = Math.floor (since / 1000);
            }
            const response = await this.privateGetAccountsAccountIdLedgers (this.extend (request, params));
            //
            //     {
            //         code: '200000',
            //         data: {
            //             totalNum: 1,
            //             totalPage: 1,
            //             pageSize: 50,
            //             currentPage: 1,
            //             items: [
            //                 {
            //                     createdAt: 1561897880000,
            //                     amount: '0.0111123',
            //                     bizType: 'Exchange',
            //                     balance: '0.13224427',
            //                     fee: '0.0000111',
            //                     context: '{"symbol":"KCS-ETH","orderId":"5d18ab98c788c6426188296f","tradeId":"5d18ab9818996813f539a806"}',
            //                     currency: 'ETH',
            //                     direction: 'out'
            //                 }
            //             ]
            //         }
            //     }
            //
            const items = response['data']['items'];
            return this.parseLedger (items, currency, since, limit);
        }
    
        parseLedgerEntry (item, currency = undefined) {
            //
            // trade
            //
            //     {
            //         createdAt: 1561897880000,
            //         amount: '0.0111123',
            //         bizType: 'Exchange',
            //         balance: '0.13224427',
            //         fee: '0.0000111',
            //         context: '{"symbol":"KCS-ETH","orderId":"5d18ab98c788c6426188296f","tradeId":"5d18ab9818996813f539a806"}',
            //         currency: 'ETH',
            //         direction: 'out'
            //     }
            //
            // withdrawal
            //
            //     {
            //         createdAt: 1561900264000,
            //         amount: '0.14333217',
            //         bizType: 'Withdrawal',
            //         balance: '0',
            //         fee: '0.01',
            //         context: '{"orderId":"5d18b4e687111437cf1c48b9","txId":"0x1d136ee065c5c4c5caa293faa90d43e213c953d7cdd575c89ed0b54eb87228b8"}',
            //         currency: 'ETH',
            //         direction: 'out'
            //     }
            //
            const currencyId = this.safeString (item, 'currency');
            const code = this.safeCurrencyCode (currencyId, currency);
            const fee = {
                'cost': this.safeNumber (item, 'fee'),
                'code': code,
            };
            const amount = this.safeNumber (item, 'amount');
            const after = this.safeNumber (item, 'balance');
            const direction = this.safeString (item, 'direction');
            let before = undefined;
            if (after !== undefined && amount !== undefined) {
                const difference = (direction === 'out') ? amount : -amount;
                before = this.sum (after, difference);
            }
            const timestamp = this.safeInteger (item, 'createdAt');
            const type = this.parseLedgerEntryType (this.safeString (item, 'bizType'));
            const contextString = this.safeString (item, 'context');
            let id = undefined;
            let referenceId = undefined;
            if (this.isJsonEncodedObject (contextString)) {
                const context = this.parseJson (contextString);
                id = this.safeString (context, 'orderId');
                if (type === 'trade') {
                    referenceId = this.safeString (context, 'tradeId');
                } else if (type === 'transaction') {
                    referenceId = this.safeString (context, 'txId');
                }
            }
            return {
                'id': id,
                'currency': code,
                'account': undefined,
                'referenceAccount': undefined,
                'referenceId': referenceId,
                'status': undefined,
                'amount': amount,
                'before': before,
                'after': after,
                'fee': fee,
                'direction': direction,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'type': type,
                'info': item,
            };
        }
    
        parseLedgerEntryType (type) {
            const types = {
                'Exchange': 'trade',
                'Withdrawal': 'transaction',
                'Deposit': 'transaction',
                'Transfer': 'transfer',
            };
            return this.safeString (types, type, type);
        }
    
        async fetchPositions (symbols = undefined, params = {}) {
            const response = await this.futuresPrivateGetPositions (params);
            //
            //     {
            //         code: '200000',
            //         data: [
            //             {
            //                 id: '605a9772a229ab0006408258',
            //                 symbol: 'XBTUSDTM',
            //                 autoDeposit: false,
            //                 maintMarginReq: 0.005,
            //                 riskLimit: 200,
            //                 realLeverage: 0,
            //                 crossMode: false,
            //                 delevPercentage: 0,
            //                 currentTimestamp: 1616549746099,
            //                 currentQty: 0,
            //                 currentCost: 0,
            //                 currentComm: 0,
            //                 unrealisedCost: 0,
            //                 realisedGrossCost: 0,
            //                 realisedCost: 0,
            //                 isOpen: false,
            //                 markPrice: 54371.92,
            //                 markValue: 0,
            //                 posCost: 0,
            //                 posCross: 0,
            //                 posInit: 0,
            //                 posComm: 0,
            //                 posLoss: 0,
            //                 posMargin: 0,
            //                 posMaint: 0,
            //                 maintMargin: 0,
            //                 realisedGrossPnl: 0,
            //                 realisedPnl: 0,
            //                 unrealisedPnl: 0,
            //                 unrealisedPnlPcnt: 0,
            //                 unrealisedRoePcnt: 0,
            //                 avgEntryPrice: 0,
            //                 liquidationPrice: 0,
            //                 bankruptPrice: 0,
            //                 settleCurrency: 'USDT',
            //                 isInverse: false
            //             },
            //             {
            //                 id: '605a9772026ac900066550df',
            //                 symbol: 'XBTUSDM',
            //                 autoDeposit: false,
            //                 maintMarginReq: 0.005,
            //                 riskLimit: 200,
            //                 realLeverage: 0,
            //                 crossMode: false,
            //                 delevPercentage: 0,
            //                 currentTimestamp: 1616549746110,
            //                 currentQty: 0,
            //                 currentCost: 0,
            //                 currentComm: 0,
            //                 unrealisedCost: 0,
            //                 realisedGrossCost: 0,
            //                 realisedCost: 0,
            //                 isOpen: false,
            //                 markPrice: 54354.76,
            //                 markValue: 0,
            //                 posCost: 0,
            //                 posCross: 0,
            //                 posInit: 0,
            //                 posComm: 0,
            //                 posLoss: 0,
            //                 posMargin: 0,
            //                 posMaint: 0,
            //                 maintMargin: 0,
            //                 realisedGrossPnl: 0,
            //                 realisedPnl: 0,
            //                 unrealisedPnl: 0,
            //                 unrealisedPnlPcnt: 0,
            //                 unrealisedRoePcnt: 0,
            //                 avgEntryPrice: 0,
            //                 liquidationPrice: 0,
            //                 bankruptPrice: 0,
            //                 settleCurrency: 'XBT',
            //                 isInverse: true
            //             }
            //         ]
            //     }
            //
            return this.safeValue (response, 'data', response);
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            //
            // the v2 URL is https://openapi-v2.kucoin.com/api/v1/endpoint
            //                                †                 ↑
            //
            const versions = this.safeValue (this.options, 'versions', {});
            const apiVersions = this.safeValue (versions, api, {});
            const methodVersions = this.safeValue (apiVersions, method, {});
            const defaultVersion = this.safeString (methodVersions, path, this.options['version']);
            const version = this.safeString (params, 'version', defaultVersion);
            params = this.omit (params, 'version');
            let endpoint = '/api/' + version + '/' + this.implodeParams (path, params);
            const query = this.omit (params, this.extractParams (path));
            let endpart = '';
            headers = (headers !== undefined) ? headers : {};
            if (Object.keys (query).length) {
                if ((method === 'GET') || (method === 'DELETE')) {
                    endpoint += '?' + this.urlencode (query);
                } else {
                    body = this.json (query);
                    endpart = body;
                    headers['Content-Type'] = 'application/json';
                }
            }
            const url = this.urls['api'][api] + endpoint;
            if ((api === 'private') || (api === 'futuresPrivate')) {
                this.checkRequiredCredentials ();
                const timestamp = this.nonce ().toString ();
                headers = this.extend ({
                    'KC-API-KEY-VERSION': '2',
                    'KC-API-KEY': this.apiKey,
                    'KC-API-TIMESTAMP': timestamp,
                }, headers);
                const apiKeyVersion = this.safeString (headers, 'KC-API-KEY-VERSION');
                if (apiKeyVersion === '2') {
                    const passphrase = this.hmac (this.encode (this.password), this.encode (this.secret), 'sha256', 'base64');
                    headers['KC-API-PASSPHRASE'] = passphrase;
                } else {
                    headers['KC-API-PASSPHRASE'] = this.password;
                }
                const payload = timestamp + method + endpoint + endpart;
                const signature = this.hmac (this.encode (payload), this.encode (this.secret), 'sha256', 'base64');
                headers['KC-API-SIGN'] = signature;
                const partner = this.safeValue (this.options, 'partner', {});
                const partnerId = this.safeString (partner, 'id');
                const partnerSecret = this.safeString (partner, 'secret');
                if ((partnerId !== undefined) && (partnerSecret !== undefined)) {
                    const partnerPayload = timestamp + partnerId + this.apiKey;
                    const partnerSignature = this.hmac (this.encode (partnerPayload), this.encode (partnerSecret), 'sha256', 'base64');
                    headers['KC-API-PARTNER-SIGN'] = partnerSignature;
                    headers['KC-API-PARTNER'] = partnerId;
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (!response) {
                this.throwBroadlyMatchedException (this.exceptions['broad'], body, body);
                return;
            }
            //
            // bad
            //     { "code": "400100", "msg": "validation.createOrder.clientOidIsRequired" }
            // good
            //     { code: '200000', data: { ... }}
            //
            const errorCode = this.safeString (response, 'code');
            const message = this.safeString (response, 'msg', '');
            this.throwExactlyMatchedException (this.exceptions['exact'], message, this.id + ' ' + message);
            this.throwExactlyMatchedException (this.exceptions['exact'], errorCode, this.id + ' ' + message);
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],96:[function(require,module,exports){
    'use strict';
    
    // ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ArgumentsRequired, InsufficientFunds, OrderNotFound } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    // ---------------------------------------------------------------------------
    
    module.exports = class kuna extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'kuna',
                'name': 'Kuna',
                'countries': [ 'UA' ],
                'rateLimit': 1000,
                'version': 'v2',
                'has': {
                    'CORS': false,
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOHLCV': 'emulated',
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                    'withdraw': false,
                },
                'timeframes': undefined,
                'urls': {
                    'extension': '.json',
                    'referral': 'https://kuna.io?r=kunaid-gvfihe8az7o4',
                    'logo': 'https://user-images.githubusercontent.com/51840849/87153927-f0578b80-c2c0-11ea-84b6-74612568e9e1.jpg',
                    'api': 'https://kuna.io',
                    'www': 'https://kuna.io',
                    'doc': 'https://kuna.io/documents/api',
                    'fees': 'https://kuna.io/documents/api',
                },
                'api': {
                    'public': {
                        'get': [
                            'depth', // Get depth or specified market Both asks and bids are sorted from highest price to lowest.
                            'k_with_pending_trades', // Get K data with pending trades, which are the trades not included in K data yet, because there's delay between trade generated and processed by K data generator
                            'k', // Get OHLC(k line) of specific market
                            'markets', // Get all available markets
                            'order_book', // Get the order book of specified market
                            'order_book/{market}',
                            'tickers', // Get ticker of all markets
                            'tickers/{market}', // Get ticker of specific market
                            'timestamp', // Get server current time, in seconds since Unix epoch
                            'trades', // Get recent trades on market, each trade is included only once Trades are sorted in reverse creation order.
                            'trades/{market}',
                        ],
                    },
                    'private': {
                        'get': [
                            'members/me', // Get your profile and accounts info
                            'deposits', // Get your deposits history
                            'deposit', // Get details of specific deposit
                            'deposit_address', // Where to deposit The address field could be empty when a new address is generating (e.g. for bitcoin), you should try again later in that case.
                            'orders', // Get your orders, results is paginated
                            'order', // Get information of specified order
                            'trades/my', // Get your executed trades Trades are sorted in reverse creation order.
                            'withdraws', // Get your cryptocurrency withdraws
                            'withdraw', // Get your cryptocurrency withdraw
                        ],
                        'post': [
                            'orders', // Create a Sell/Buy order
                            'orders/multi', // Create multiple sell/buy orders
                            'orders/clear', // Cancel all my orders
                            'order/delete', // Cancel an order
                            'withdraw', // Create a withdraw
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': false,
                        'percentage': true,
                        'taker': 0.25 / 100,
                        'maker': 0.25 / 100,
                    },
                    'funding': {
                        'withdraw': {
                            'UAH': '1%',
                            'BTC': 0.001,
                            'BCH': 0.001,
                            'ETH': 0.01,
                            'WAVES': 0.01,
                            'GOL': 0.0,
                            'GBG': 0.0,
                            // 'RMC': 0.001 BTC
                            // 'ARN': 0.01 ETH
                            // 'R': 0.01 ETH
                            // 'EVR': 0.01 ETH
                        },
                        'deposit': {
                            // 'UAH': (amount) => amount * 0.001 + 5
                        },
                    },
                },
                'commonCurrencies': {
                    'PLA': 'Plair',
                },
                'exceptions': {
                    '2002': InsufficientFunds,
                    '2003': OrderNotFound,
                },
            });
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetTimestamp (params);
            //
            //     1594911427
            //
            return response * 1000;
        }
    
        async fetchMarkets (params = {}) {
            const quotes = [ 'btc', 'rub', 'uah', 'usd', 'usdt', 'usdc' ];
            const markets = [];
            const response = await this.publicGetTickers (params);
            const ids = Object.keys (response);
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                for (let j = 0; j < quotes.length; j++) {
                    const quoteId = quotes[j];
                    // usd gets matched before usdt in usdtusd USDT/USD
                    // https://github.com/ccxt/ccxt/issues/9868
                    const slicedId = id.slice (1);
                    const index = slicedId.indexOf (quoteId);
                    const slice = slicedId.slice (index);
                    if ((index > 0) && (slice === quoteId)) {
                        // usd gets matched before usdt in usdtusd USDT/USD
                        // https://github.com/ccxt/ccxt/issues/9868
                        const baseId = id[0] + slicedId.replace (quoteId, '');
                        const base = this.safeCurrencyCode (baseId);
                        const quote = this.safeCurrencyCode (quoteId);
                        const symbol = base + '/' + quote;
                        markets.push ({
                            'id': id,
                            'symbol': symbol,
                            'base': base,
                            'quote': quote,
                            'baseId': baseId,
                            'quoteId': quoteId,
                            'precision': {
                                'amount': undefined,
                                'price': undefined,
                            },
                            'limits': {
                                'amount': {
                                    'min': undefined,
                                    'max': undefined,
                                },
                                'price': {
                                    'min': undefined,
                                    'max': undefined,
                                },
                                'cost': {
                                    'min': undefined,
                                    'max': undefined,
                                },
                            },
                            'active': undefined,
                            'info': undefined,
                        });
                    }
                }
            }
            return markets;
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default = 300
            }
            const orderbook = await this.publicGetDepth (this.extend (request, params));
            const timestamp = this.safeTimestamp (orderbook, 'timestamp');
            return this.parseOrderBook (orderbook, symbol, timestamp);
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.safeTimestamp (ticker, 'at');
            ticker = ticker['ticker'];
            let symbol = undefined;
            if (market) {
                symbol = market['symbol'];
            }
            const last = this.safeNumber (ticker, 'last');
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': this.safeNumber (ticker, 'buy'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'sell'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': this.safeNumber (ticker, 'open'),
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': undefined,
                'info': ticker,
            };
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetTickers (params);
            const ids = Object.keys (response);
            const result = {};
            for (let i = 0; i < ids.length; i++) {
                const id = ids[i];
                let market = undefined;
                let symbol = id;
                if (id in this.markets_by_id) {
                    market = this.markets_by_id[id];
                    symbol = market['symbol'];
                } else {
                    let base = id.slice (0, 3);
                    let quote = id.slice (3, 6);
                    base = base.toUpperCase ();
                    quote = quote.toUpperCase ();
                    base = this.safeCurrencyCode (base);
                    quote = this.safeCurrencyCode (quote);
                    symbol = base + '/' + quote;
                }
                result[symbol] = this.parseTicker (response[id], market);
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetTickersMarket (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        async fetchL3OrderBook (symbol, limit = undefined, params = {}) {
            return await this.fetchOrderBook (symbol, limit, params);
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.publicGetTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        parseTrade (trade, market = undefined) {
            const timestamp = this.parse8601 (this.safeString (trade, 'created_at'));
            let symbol = undefined;
            if (market) {
                symbol = market['symbol'];
            }
            let side = this.safeString2 (trade, 'side', 'trend');
            if (side !== undefined) {
                const sideMap = {
                    'ask': 'sell',
                    'bid': 'buy',
                };
                side = this.safeString (sideMap, side, side);
            }
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'volume');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            let cost = this.safeNumber (trade, 'funds');
            if (cost === undefined) {
                cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            }
            const orderId = this.safeString (trade, 'order_id');
            const id = this.safeString (trade, 'id');
            return {
                'id': id,
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'order': orderId,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchOHLCV (symbol, timeframe = '1m', since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const trades = await this.fetchTrades (symbol, since, limit, params);
            const ohlcvc = this.buildOHLCVC (trades, timeframe, since, limit);
            const result = [];
            for (let i = 0; i < ohlcvc.length; i++) {
                const ohlcv = ohlcvc[i];
                result.push ([
                    ohlcv[0],
                    ohlcv[1],
                    ohlcv[2],
                    ohlcv[3],
                    ohlcv[4],
                    ohlcv[5],
                ]);
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetMembersMe (params);
            const balances = this.safeValue (response, 'accounts');
            const result = { 'info': balances };
            for (let i = 0; i < balances.length; i++) {
                const balance = balances[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (balance, 'balance');
                account['used'] = this.safeString (balance, 'locked');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'market': this.marketId (symbol),
                'side': side,
                'volume': amount.toString (),
                'ord_type': type,
            };
            if (type === 'limit') {
                request['price'] = price.toString ();
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            const marketId = this.safeValue (response, 'market');
            const market = this.safeValue (this.markets_by_id, marketId);
            return this.parseOrder (response, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privatePostOrderDelete (this.extend (request, params));
            const order = this.parseOrder (response);
            const status = order['status'];
            if (status === 'closed' || status === 'canceled') {
                throw new OrderNotFound (this.id + ' ' + this.json (order));
            }
            return order;
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'done': 'closed',
                'wait': 'open',
                'cancel': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            const marketId = this.safeString (order, 'market');
            const symbol = this.safeSymbol (marketId, market);
            const timestamp = this.parse8601 (this.safeString (order, 'created_at'));
            const status = this.parseOrderStatus (this.safeString (order, 'state'));
            const type = this.safeString (order, 'type');
            const side = this.safeString (order, 'side');
            const id = this.safeString (order, 'id');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': this.safeNumber (order, 'price'),
                'stopPrice': undefined,
                'amount': this.safeNumber (order, 'volume'),
                'filled': this.safeNumber (order, 'executed_volume'),
                'remaining': this.safeNumber (order, 'remaining_volume'),
                'trades': undefined,
                'fee': undefined,
                'info': order,
                'cost': undefined,
                'average': undefined,
            });
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': parseInt (id),
            };
            const response = await this.privateGetOrder (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOpenOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.privateGetOrders (this.extend (request, params));
            // todo emulation of fetchClosedOrders, fetchOrders, fetchOrder
            // with order cache + fetchOpenOrders
            // as in BTC-e, Liqui, Yobit, DSX, Tidex, WEX
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'market': market['id'],
            };
            const response = await this.privateGetTradesMy (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        encodeParams (params) {
            if ('orders' in params) {
                const orders = params['orders'];
                let query = this.urlencode (this.keysort (this.omit (params, 'orders')));
                for (let i = 0; i < orders.length; i++) {
                    const order = orders[i];
                    const keys = Object.keys (order);
                    for (let k = 0; k < keys.length; k++) {
                        const key = keys[k];
                        const value = order[key];
                        query += '&orders%5B%5D%5B' + key + '%5D=' + value.toString ();
                    }
                }
                return query;
            }
            return this.urlencode (this.keysort (params));
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            let request = '/api/' + this.version + '/' + this.implodeParams (path, params);
            if ('extension' in this.urls) {
                request += this.urls['extension'];
            }
            const query = this.omit (params, this.extractParams (path));
            let url = this.urls['api'] + request;
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const nonce = this.nonce ().toString ();
                const query = this.encodeParams (this.extend ({
                    'access_key': this.apiKey,
                    'tonce': nonce,
                }, params));
                const auth = method + '|' + request + '|' + query;
                const signed = this.hmac (this.encode (auth), this.encode (this.secret));
                const suffix = query + '&signature=' + signed;
                if (method === 'GET') {
                    url += '?' + suffix;
                } else {
                    body = suffix;
                    headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
                }
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            if (code === 400) {
                const error = this.safeValue (response, 'error');
                const errorCode = this.safeString (error, 'code');
                const feedback = this.id + ' ' + this.json (response);
                this.throwExactlyMatchedException (this.exceptions, errorCode, feedback);
                // fallback to default error handler
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],97:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, ArgumentsRequired, InvalidNonce, OrderNotFound, InvalidOrder, DDoSProtection, BadRequest, AuthenticationError } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class latoken extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'latoken',
                'name': 'Latoken',
                'countries': [ 'KY' ], // Cayman Islands
                'version': 'v1',
                'rateLimit': 2000,
                'certified': false,
                'userAgent': this.userAgents['chrome'],
                'has': {
                    'CORS': false,
                    'publicAPI': true,
                    'privateAPI': true,
                    'cancelOrder': true,
                    'cancelAllOrders': true,
                    'createMarketOrder': false,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchCanceledOrders': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': false,
                    'fetchOrdersByStatus': true,
                    'fetchOrderBook': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTime': true,
                    'fetchTrades': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/61511972-24c39f00-aa01-11e9-9f7c-471f1d6e5214.jpg',
                    'api': 'https://api.latoken.com',
                    'www': 'https://latoken.com',
                    'doc': [
                        'https://api.latoken.com',
                    ],
                },
                'api': {
                    'public': {
                        'get': [
                            'ExchangeInfo/time',
                            'ExchangeInfo/limits',
                            'ExchangeInfo/pairs',
                            'ExchangeInfo/pairs/{currency}',
                            'ExchangeInfo/pair',
                            'ExchangeInfo/currencies',
                            'ExchangeInfo/currencies/{symbol}',
                            'MarketData/tickers',
                            'MarketData/ticker/{symbol}',
                            'MarketData/orderBook/{symbol}',
                            'MarketData/orderBook/{symbol}/{limit}',
                            'MarketData/trades/{symbol}',
                            'MarketData/trades/{symbol}/{limit}',
                        ],
                    },
                    'private': {
                        'get': [
                            'Account/balances',
                            'Account/balances/{currency}',
                            'Order/status',
                            'Order/active',
                            'Order/get_order',
                            'Order/trades',
                        ],
                        'post': [
                            'Order/new',
                            'Order/test-order',
                            'Order/cancel',
                            'Order/cancel_all',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'feeSide': 'get',
                        'tierBased': false,
                        'percentage': true,
                        'maker': this.parseNumber ('0.001'),
                        'taker': this.parseNumber ('0.001'),
                    },
                },
                'commonCurrencies': {
                    'MT': 'Monarch',
                    'TSL': 'Treasure SL',
                },
                'options': {
                    'createOrderMethod': 'private_post_order_new', // private_post_order_test_order
                },
                'exceptions': {
                    'exact': {
                        'Signature or ApiKey is not valid': AuthenticationError,
                        'Request is out of time': InvalidNonce,
                        'Symbol must be specified': BadRequest,
                    },
                    'broad': {
                        'Request limit reached': DDoSProtection,
                        'Pair': BadRequest,
                        'Price needs to be greater than': InvalidOrder,
                        'Amount needs to be greater than': InvalidOrder,
                        'The Symbol field is required': InvalidOrder,
                        'OrderType is not valid': InvalidOrder,
                        'Side is not valid': InvalidOrder,
                        'Cancelable order whit': OrderNotFound,
                        'Order': OrderNotFound,
                    },
                },
            });
        }
    
        nonce () {
            return this.milliseconds ();
        }
    
        async fetchTime (params = {}) {
            const response = await this.publicGetExchangeInfoTime (params);
            //
            //     {
            //         "time": "2019-04-18T9:00:00.0Z",
            //         "unixTimeSeconds": 1555578000,
            //         "unixTimeMiliseconds": 1555578000000
            //     }
            //
            return this.safeInteger (response, 'unixTimeMiliseconds');
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetExchangeInfoPairs (params);
            //
            //     [
            //         {
            //             "pairId": 502,
            //             "symbol": "LAETH",
            //             "baseCurrency": "LA",
            //             "quotedCurrency": "ETH",
            //             "makerFee": 0.01,
            //             "takerFee": 0.01,
            //             "pricePrecision": 8,
            //             "amountPrecision": 8,
            //             "minQty": 0.1
            //         }
            //     ]
            //
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = this.safeString (market, 'symbol');
                // the exchange shows them inverted
                const baseId = this.safeString (market, 'baseCurrency');
                const quoteId = this.safeString (market, 'quotedCurrency');
                const numericId = this.safeInteger (market, 'pairId');
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const pricePrecisionString = this.safeString (market, 'pricePrecision');
                const priceLimit = this.parsePrecision (pricePrecisionString);
                const precision = {
                    'price': parseInt (pricePrecisionString),
                    'amount': this.safeInteger (market, 'amountPrecision'),
                };
                const limits = {
                    'amount': {
                        'min': this.safeNumber (market, 'minQty'),
                        'max': undefined,
                    },
                    'price': {
                        'min': this.parseNumber (priceLimit),
                        'max': undefined,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                result.push ({
                    'id': id,
                    'numericId': numericId,
                    'info': market,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': undefined, // assuming true
                    'precision': precision,
                    'limits': limits,
                });
            }
            return result;
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetExchangeInfoCurrencies (params);
            //
            //     [
            //         {
            //             "currencyId": 102,
            //             "symbol": "LA",
            //             "name": "Latoken",
            //             "precission": 8,
            //             "type": "ERC20",
            //             "fee": 0.1
            //         }
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'symbol');
                const numericId = this.safeInteger (currency, 'currencyId');
                const code = this.safeCurrencyCode (id);
                const precision = this.safeInteger (currency, 'precission');
                const fee = this.safeNumber (currency, 'fee');
                const active = undefined;
                result[code] = {
                    'id': id,
                    'numericId': numericId,
                    'code': code,
                    'info': currency,
                    'name': code,
                    'active': active,
                    'fee': fee,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': undefined,
                            'max': undefined,
                        },
                        'withdraw': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccountBalances (params);
            //
            //     [
            //         {
            //             "currencyId": 102,
            //             "symbol": "LA",
            //             "name": "Latoken",
            //             "amount": 1054.66,
            //             "available": 900.66,
            //             "frozen": 154,
            //             "pending": 0
            //         }
            //     ]
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            for (let i = 0; i < response.length; i++) {
                const balance = response[i];
                const currencyId = this.safeString (balance, 'symbol');
                const code = this.safeCurrencyCode (currencyId);
                const frozen = this.safeString (balance, 'frozen');
                const pending = this.safeString (balance, 'pending');
                const account = this.account ();
                account['used'] = Precise.stringAdd (frozen, pending);
                account['free'] = this.safeString (balance, 'available');
                account['total'] = this.safeString (balance, 'amount');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'limit': 10,
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 10, max 100
            }
            const response = await this.publicGetMarketDataOrderBookSymbolLimit (this.extend (request, params));
            //
            //     {
            //         "pairId": 502,
            //         "symbol": "LAETH",
            //         "spread": 0.07,
            //         "asks": [
            //             { "price": 136.3, "quantity": 7.024 }
            //         ],
            //         "bids": [
            //             { "price": 136.2, "quantity": 6.554 }
            //         ]
            //     }
            //
            return this.parseOrderBook (response, symbol, undefined, 'bids', 'asks', 'price', 'quantity');
        }
    
        parseTicker (ticker, market = undefined) {
            //
            //     {
            //         "pairId":"63b41092-f3f6-4ea4-9e7c-4525ed250dad",
            //         "symbol":"ETHBTC",
            //         "volume":11317.037494474000000000,
            //         "open":0.020033000000000000,
            //         "low":0.019791000000000000,
            //         "high":0.020375000000000000,
            //         "close":0.019923000000000000,
            //         "priceChange":-0.1500
            //     }
            //
            const marketId = this.safeString (ticker, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const open = this.safeNumber (ticker, 'open');
            const close = this.safeNumber (ticker, 'close');
            let change = undefined;
            if (open !== undefined && close !== undefined) {
                change = close - open;
            }
            const percentage = this.safeNumber (ticker, 'priceChange');
            const timestamp = this.nonce ();
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'low': this.safeNumber (ticker, 'low'),
                'high': this.safeNumber (ticker, 'high'),
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': close,
                'last': close,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': undefined,
                'baseVolume': undefined,
                'quoteVolume': this.safeNumber (ticker, 'volume'),
                'info': ticker,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetMarketDataTickerSymbol (this.extend (request, params));
            //
            //     {
            //         "pairId": 502,
            //         "symbol": "LAETH",
            //         "volume": 1023314.3202,
            //         "open": 134.82,
            //         "low": 133.95,
            //         "high": 136.22,
            //         "close": 135.12,
            //         "priceChange": 0.22
            //     }
            //
            return this.parseTicker (response, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetMarketDataTickers (params);
            //
            //     [
            //         {
            //             "pairId": 502,
            //             "symbol": "LAETH",
            //             "volume": 1023314.3202,
            //             "open": 134.82,
            //             "low": 133.95,
            //             "high": 136.22,
            //             "close": 135.12,
            //             "priceChange": 0.22
            //         }
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const ticker = this.parseTicker (response[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        parseTrade (trade, market = undefined) {
            //
            // fetchTrades (public)
            //
            //     {
            //         side: 'buy',
            //         price: 0.33634,
            //         amount: 0.01,
            //         timestamp: 1564240008000 // milliseconds
            //     }
            //
            // fetchMyTrades (private)
            //
            //     {
            //         id: '1564223032.892829.3.tg15',
            //         orderId: '1564223032.671436.707548@1379:1',
            //         commission: 0,
            //         side: 'buy',
            //         price: 0.32874,
            //         amount: 0.607,
            //         timestamp: 1564223033 // seconds
            //     }
            //
            const type = undefined;
            let timestamp = this.safeInteger2 (trade, 'timestamp', 'time');
            if (timestamp !== undefined) {
                // 03 Jan 2009 - first block
                if (timestamp < 1230940800000) {
                    timestamp *= 1000;
                }
            }
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const side = this.safeString (trade, 'side');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const id = this.safeString (trade, 'id');
            const orderId = this.safeString (trade, 'orderId');
            const feeCost = this.safeNumber (trade, 'commission');
            let fee = undefined;
            if (feeCost !== undefined) {
                fee = {
                    'cost': feeCost,
                    'currency': undefined,
                };
            }
            return {
                'info': trade,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'id': id,
                'order': orderId,
                'type': type,
                'takerOrMaker': undefined,
                'side': side,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': fee,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 50, max 100
            }
            const response = await this.publicGetMarketDataTradesSymbol (this.extend (request, params));
            //
            //     {
            //         "pairId":370,
            //         "symbol":"ETHBTC",
            //         "tradeCount":51,
            //         "trades": [
            //             {
            //                 side: 'buy',
            //                 price: 0.33634,
            //                 amount: 0.01,
            //                 timestamp: 1564240008000 // milliseconds
            //             }
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchMyTrades() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.privateGetOrderTrades (this.extend (request, params));
            //
            //     {
            //         "pairId": 502,
            //         "symbol": "LAETH",
            //         "tradeCount": 1,
            //         "trades": [
            //             {
            //                 id: '1564223032.892829.3.tg15',
            //                 orderId: '1564223032.671436.707548@1379:1',
            //                 commission: 0,
            //                 side: 'buy',
            //                 price: 0.32874,
            //                 amount: 0.607,
            //                 timestamp: 1564223033 // seconds
            //             }
            //         ]
            //     }
            //
            const trades = this.safeValue (response, 'trades', []);
            return this.parseTrades (trades, market, since, limit);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'active': 'open',
                'partiallyFilled': 'open',
                'filled': 'closed',
                'cancelled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "orderId":"1563460093.134037.704945@0370:2",
            //         "cliOrdId":"",
            //         "pairId":370,
            //         "symbol":"ETHBTC",
            //         "side":"sell",
            //         "orderType":"limit",
            //         "price":1.0,
            //         "amount":1.0
            //     }
            //
            // cancelOrder, fetchOrder, fetchOpenOrders, fetchClosedOrders, fetchCanceledOrders
            //
            //     {
            //         "orderId": "1555492358.126073.126767@0502:2",
            //         "cliOrdId": "myNewOrder",
            //         "pairId": 502,
            //         "symbol": "LAETH",
            //         "side": "buy",
            //         "orderType": "limit",
            //         "price": 136.2,
            //         "amount": 0.57,
            //         "orderStatus": "partiallyFilled",
            //         "executedAmount": 0.27,
            //         "reaminingAmount": 0.3,
            //         "timeCreated": 155551580736,
            //         "timeFilled": 0
            //     }
            //
            const id = this.safeString (order, 'orderId');
            const timestamp = this.safeTimestamp (order, 'timeCreated');
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market);
            const side = this.safeString (order, 'side');
            const type = this.safeString (order, 'orderType');
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount');
            const filled = this.safeNumber (order, 'executedAmount');
            const status = this.parseOrderStatus (this.safeString (order, 'orderStatus'));
            const timeFilled = this.safeTimestamp (order, 'timeFilled');
            let lastTradeTimestamp = undefined;
            if ((timeFilled !== undefined) && (timeFilled > 0)) {
                lastTradeTimestamp = timeFilled;
            }
            const clientOrderId = this.safeString (order, 'cliOrdId');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': clientOrderId,
                'info': order,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'lastTradeTimestamp': lastTradeTimestamp,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'amount': amount,
                'filled': filled,
                'average': undefined,
                'remaining': undefined,
                'fee': undefined,
                'trades': undefined,
            });
        }
    
        async fetchOpenOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return this.fetchOrdersWithMethod ('private_get_order_active', symbol, since, limit, params);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return this.fetchOrdersByStatus ('filled', symbol, since, limit, params);
        }
    
        async fetchCanceledOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            return this.fetchOrdersByStatus ('cancelled', symbol, since, limit, params);
        }
    
        async fetchOrdersByStatus (status, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const request = {
                'status': status,
            };
            return this.fetchOrdersWithMethod ('private_get_order_status', symbol, since, limit, this.extend (request, params));
        }
    
        async fetchOrdersWithMethod (method, symbol = undefined, since = undefined, limit = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOrdersWithMethod() requires a symbol argument');
            }
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit; // default 100
            }
            const response = await this[method] (this.extend (request, params));
            //
            //     [
            //         {
            //             "orderId": "1555492358.126073.126767@0502:2",
            //             "cliOrdId": "myNewOrder",
            //             "pairId": 502,
            //             "symbol": "LAETH",
            //             "side": "buy",
            //             "orderType": "limit",
            //             "price": 136.2,
            //             "amount": 0.57,
            //             "orderStatus": "partiallyFilled",
            //             "executedAmount": 0.27,
            //             "reaminingAmount": 0.3,
            //             "timeCreated": 155551580736,
            //             "timeFilled": 0
            //         }
            //     ]
            //
            return this.parseOrders (response, market, since, limit);
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderId': id,
            };
            const response = await this.privateGetOrderGetOrder (this.extend (request, params));
            //
            //     {
            //         "orderId": "1555492358.126073.126767@0502:2",
            //         "cliOrdId": "myNewOrder",
            //         "pairId": 502,
            //         "symbol": "LAETH",
            //         "side": "buy",
            //         "orderType": "limit",
            //         "price": 136.2,
            //         "amount": 0.57,
            //         "orderStatus": "partiallyFilled",
            //         "executedAmount": 0.27,
            //         "reaminingAmount": 0.3,
            //         "timeCreated": 155551580736,
            //         "timeFilled": 0
            //     }
            //
            return this.parseOrder (response);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            if (type !== 'limit') {
                throw new ExchangeError (this.id + ' allows limit orders only');
            }
            const request = {
                'symbol': this.marketId (symbol),
                'side': side,
                'price': this.priceToPrecision (symbol, price),
                'amount': this.amountToPrecision (symbol, amount),
                'orderType': type,
            };
            const method = this.safeString (this.options, 'createOrderMethod', 'private_post_order_new');
            const response = await this[method] (this.extend (request, params));
            //
            //     {
            //         "orderId":"1563460093.134037.704945@0370:2",
            //         "cliOrdId":"",
            //         "pairId":370,
            //         "symbol":"ETHBTC",
            //         "side":"sell",
            //         "orderType":"limit",
            //         "price":1.0,
            //         "amount":1.0
            //     }
            //
            return this.parseOrder (response);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'orderId': id,
            };
            const response = await this.privatePostOrderCancel (this.extend (request, params));
            //
            //     {
            //         "orderId": "1555492358.126073.126767@0502:2",
            //         "cliOrdId": "myNewOrder",
            //         "pairId": 502,
            //         "symbol": "LAETH",
            //         "side": "buy",
            //         "orderType": "limit",
            //         "price": 136.2,
            //         "amount": 0.57,
            //         "orderStatus": "partiallyFilled",
            //         "executedAmount": 0.27,
            //         "reaminingAmount": 0.3,
            //         "timeCreated": 155551580736,
            //         "timeFilled": 0
            //     }
            //
            return this.parseOrder (response);
        }
    
        async cancelAllOrders (symbol = undefined, params = {}) {
            if (symbol === undefined) {
                throw new ArgumentsRequired (this.id + ' cancelAllOrders() requires a symbol argument');
            }
            await this.loadMarkets ();
            const marketId = this.marketId (symbol);
            const request = {
                'symbol': marketId,
            };
            const response = await this.privatePostOrderCancelAll (this.extend (request, params));
            //
            //     {
            //         "pairId": 502,
            //         "symbol": "LAETH",
            //         "cancelledOrders": [
            //             "1555492358.126073.126767@0502:2"
            //         ]
            //     }
            //
            const result = [];
            const canceledOrders = this.safeValue (response, 'cancelledOrders', []);
            for (let i = 0; i < canceledOrders.length; i++) {
                const order = this.parseOrder ({
                    'symbol': marketId,
                    'orderId': canceledOrders[i],
                    'orderStatus': 'canceled',
                });
                result.push (order);
            }
            return result;
        }
    
        sign (path, api = 'public', method = 'GET', params = undefined, headers = undefined, body = undefined) {
            let request = '/api/' + this.version + '/' + this.implodeParams (path, params);
            let query = this.omit (params, this.extractParams (path));
            if (api === 'private') {
                const nonce = this.nonce ();
                query = this.extend ({
                    'timestamp': nonce,
                }, query);
            }
            const urlencodedQuery = this.urlencode (query);
            if (Object.keys (query).length) {
                request += '?' + urlencodedQuery;
            }
            if (api === 'private') {
                this.checkRequiredCredentials ();
                const signature = this.hmac (this.encode (request), this.encode (this.secret));
                headers = {
                    'X-LA-KEY': this.apiKey,
                    'X-LA-SIGNATURE': signature,
                };
                if (method === 'POST') {
                    headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    body = urlencodedQuery;
                }
            }
            const url = this.urls['api'] + request;
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (code, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (!response) {
                return;
            }
            //
            //     { "message": "Request limit reached!", "details": "Request limit reached. Maximum allowed: 1 per 1s. Please try again in 1 second(s)." }
            //     { "error": { "message": "Pair 370 is not found","errorType":"RequestError","statusCode":400 }}
            //     { "error": { "message": "Signature or ApiKey is not valid","errorType":"RequestError","statusCode":400 }}
            //     { "error": { "message": "Request is out of time", "errorType": "RequestError", "statusCode":400 }}
            //     { "error": { "message": "Price needs to be greater than 0","errorType":"ValidationError","statusCode":400 }}
            //     { "error": { "message": "Side is not valid, Price needs to be greater than 0, Amount needs to be greater than 0, The Symbol field is required., OrderType is not valid","errorType":"ValidationError","statusCode":400 }}
            //     { "error": { "message": "Cancelable order whit ID 1563460289.571254.704945@0370:1 not found","errorType":"RequestError","statusCode":400 }}
            //     { "error": { "message": "Symbol must be specified","errorType":"RequestError","statusCode":400 }}
            //     { "error": { "message": "Order 1563460289.571254.704945@0370:1 is not found","errorType":"RequestError","statusCode":400 }}
            //
            const message = this.safeString (response, 'message');
            const feedback = this.id + ' ' + body;
            if (message !== undefined) {
                this.throwExactlyMatchedException (this.exceptions['exact'], message, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], message, feedback);
            }
            const error = this.safeValue (response, 'error', {});
            const errorMessage = this.safeString (error, 'message');
            if (errorMessage !== undefined) {
                this.throwExactlyMatchedException (this.exceptions['exact'], errorMessage, feedback);
                this.throwBroadlyMatchedException (this.exceptions['broad'], errorMessage, feedback);
                throw new ExchangeError (feedback); // unknown message
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],98:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { ExchangeError, DDoSProtection, AuthenticationError, InvalidOrder, ArgumentsRequired } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class lbank extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'lbank',
                'name': 'LBank',
                'countries': [ 'CN' ],
                'version': 'v1',
                'has': {
                    'cancelOrder': true,
                    'createOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchMarkets': true,
                    'fetchOHLCV': true,
                    'fetchOpenOrders': false, // status 0 API doesn't work
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'withdraw': true,
                },
                'timeframes': {
                    '1m': 'minute1',
                    '5m': 'minute5',
                    '15m': 'minute15',
                    '30m': 'minute30',
                    '1h': 'hour1',
                    '2h': 'hour2',
                    '4h': 'hour4',
                    '6h': 'hour6',
                    '8h': 'hour8',
                    '12h': 'hour12',
                    '1d': 'day1',
                    '1w': 'week1',
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/38063602-9605e28a-3302-11e8-81be-64b1e53c4cfb.jpg',
                    'api': 'https://api.lbank.info',
                    'www': 'https://www.lbank.info',
                    'doc': 'https://github.com/LBank-exchange/lbank-official-api-docs',
                    'fees': 'https://lbankinfo.zendesk.com/hc/en-gb/articles/360012072873-Trading-Fees',
                    'referral': 'https://www.lbex.io/invite?icode=7QCY',
                },
                'api': {
                    'public': {
                        'get': [
                            'currencyPairs',
                            'ticker',
                            'depth',
                            'trades',
                            'kline',
                            'accuracy',
                        ],
                    },
                    'private': {
                        'post': [
                            'user_info',
                            'create_order',
                            'cancel_order',
                            'orders_info',
                            'orders_info_history',
                            'withdraw',
                            'withdrawCancel',
                            'withdraws',
                            'withdrawConfigs',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'maker': this.parseNumber ('0.001'),
                        'taker': this.parseNumber ('0.001'),
                    },
                    'funding': {
                        'withdraw': {},
                    },
                },
                'commonCurrencies': {
                    'VET_ERC20': 'VEN',
                    'PNT': 'Penta',
                },
                'options': {
                    'cacheSecretAsPem': true,
                },
            });
        }
    
        async fetchMarkets (params = {}) {
            const response = await this.publicGetAccuracy (params);
            const result = [];
            for (let i = 0; i < response.length; i++) {
                const market = response[i];
                const id = market['symbol'];
                const parts = id.split ('_');
                let baseId = undefined;
                let quoteId = undefined;
                const numParts = parts.length;
                // lbank will return symbols like "vet_erc20_usdt"
                if (numParts > 2) {
                    baseId = parts[0] + '_' + parts[1];
                    quoteId = parts[2];
                } else {
                    baseId = parts[0];
                    quoteId = parts[1];
                }
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                const symbol = base + '/' + quote;
                const precision = {
                    'amount': this.safeInteger (market, 'quantityAccuracy'),
                    'price': this.safeInteger (market, 'priceAccuracy'),
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'active': true,
                    'precision': precision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -precision['amount']),
                            'max': undefined,
                        },
                        'price': {
                            'min': Math.pow (10, -precision['price']),
                            'max': Math.pow (10, precision['price']),
                        },
                        'cost': {
                            'min': undefined,
                            'max': undefined,
                        },
                    },
                    'info': id,
                });
            }
            return result;
        }
    
        parseTicker (ticker, market = undefined) {
            let symbol = undefined;
            if (market === undefined) {
                const marketId = this.safeString (ticker, 'symbol');
                if (marketId in this.markets_by_id) {
                    const market = this.markets_by_id[marketId];
                    symbol = market['symbol'];
                } else {
                    const parts = marketId.split ('_');
                    let baseId = undefined;
                    let quoteId = undefined;
                    const numParts = parts.length;
                    // lbank will return symbols like "vet_erc20_usdt"
                    if (numParts > 2) {
                        baseId = parts[0] + '_' + parts[1];
                        quoteId = parts[2];
                    } else {
                        baseId = parts[0];
                        quoteId = parts[1];
                    }
                    const base = this.safeCurrencyCode (baseId);
                    const quote = this.safeCurrencyCode (quoteId);
                    symbol = base + '/' + quote;
                }
            }
            const timestamp = this.safeInteger (ticker, 'timestamp');
            const info = ticker;
            ticker = info['ticker'];
            const last = this.safeNumber (ticker, 'latest');
            const percentage = this.safeNumber (ticker, 'change');
            let open = undefined;
            if (percentage !== undefined) {
                const relativeChange = this.sum (1, percentage / 100);
                if (relativeChange > 0) {
                    open = last / this.sum (1, relativeChange);
                }
            }
            let change = undefined;
            let average = undefined;
            if (last !== undefined && open !== undefined) {
                change = last - open;
                average = this.sum (last, open) / 2;
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high'),
                'low': this.safeNumber (ticker, 'low'),
                'bid': undefined,
                'bidVolume': undefined,
                'ask': undefined,
                'askVolume': undefined,
                'vwap': undefined,
                'open': undefined,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': change,
                'percentage': percentage,
                'average': average,
                'baseVolume': this.safeNumber (ticker, 'vol'),
                'quoteVolume': this.safeNumber (ticker, 'turnover'),
                'info': info,
            };
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'symbol': 'all',
            };
            const response = await this.publicGetTicker (this.extend (request, params));
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const ticker = this.parseTicker (response[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchOrderBook (symbol, limit = 60, params = {}) {
            await this.loadMarkets ();
            let size = 60;
            if (limit !== undefined) {
                size = Math.min (limit, size);
            }
            const request = {
                'symbol': this.marketId (symbol),
                'size': size,
            };
            const response = await this.publicGetDepth (this.extend (request, params));
            return this.parseOrderBook (response, symbol);
        }
    
        parseTrade (trade, market = undefined) {
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const timestamp = this.safeInteger (trade, 'date_ms');
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'amount');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const id = this.safeString (trade, 'tid');
            const type = undefined;
            let side = this.safeString (trade, 'type');
            side = side.replace ('_market', '');
            return {
                'id': id,
                'info': this.safeValue (trade, 'info', trade),
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'order': undefined,
                'type': type,
                'side': side,
                'takerOrMaker': undefined,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'size': 100,
            };
            if (since !== undefined) {
                request['time'] = parseInt (since);
            }
            if (limit !== undefined) {
                request['size'] = limit;
            }
            const response = await this.publicGetTrades (this.extend (request, params));
            return this.parseTrades (response, market, since, limit);
        }
    
        parseOHLCV (ohlcv, market = undefined) {
            //
            //     [
            //         1590969600,
            //         0.02451657,
            //         0.02452675,
            //         0.02443701,
            //         0.02447814,
            //         238.38210000
            //     ]
            //
            return [
                this.safeTimestamp (ohlcv, 0),
                this.safeNumber (ohlcv, 1),
                this.safeNumber (ohlcv, 2),
                this.safeNumber (ohlcv, 3),
                this.safeNumber (ohlcv, 4),
                this.safeNumber (ohlcv, 5),
            ];
        }
    
        async fetchOHLCV (symbol, timeframe = '5m', since = undefined, limit = 1000, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            if (since === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOHLCV() requires a `since` argument');
            }
            if (limit === undefined) {
                throw new ArgumentsRequired (this.id + ' fetchOHLCV() requires a `limit` argument');
            }
            const request = {
                'symbol': market['id'],
                'type': this.timeframes[timeframe],
                'size': limit,
                'time': parseInt (since / 1000),
            };
            const response = await this.publicGetKline (this.extend (request, params));
            //
            //     [
            //         [1590969600,0.02451657,0.02452675,0.02443701,0.02447814,238.38210000],
            //         [1590969660,0.02447814,0.02449883,0.02443209,0.02445973,212.40270000],
            //         [1590969720,0.02445973,0.02452067,0.02445909,0.02446151,266.16920000],
            //     ]
            //
            return this.parseOHLCVs (response, market, timeframe, since, limit);
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privatePostUserInfo (params);
            //
            //     {
            //         "result":"true",
            //         "info":{
            //             "freeze":{
            //                 "iog":"0.00000000",
            //                 "ssc":"0.00000000",
            //                 "eon":"0.00000000",
            //             },
            //             "asset":{
            //                 "iog":"0.00000000",
            //                 "ssc":"0.00000000",
            //                 "eon":"0.00000000",
            //             },
            //             "free":{
            //                 "iog":"0.00000000",
            //                 "ssc":"0.00000000",
            //                 "eon":"0.00000000",
            //             },
            //         }
            //     }
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const info = this.safeValue (response, 'info', {});
            const free = this.safeValue (info, 'free', {});
            const freeze = this.safeValue (info, 'freeze', {});
            const asset = this.safeValue (info, 'asset', {});
            const currencyIds = Object.keys (free);
            for (let i = 0; i < currencyIds.length; i++) {
                const currencyId = currencyIds[i];
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['free'] = this.safeString (free, currencyId);
                account['used'] = this.safeString (freeze, currencyId);
                account['total'] = this.safeString (asset, currencyId);
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                '-1': 'cancelled', // cancelled
                '0': 'open', // not traded
                '1': 'open', // partial deal
                '2': 'closed', // complete deal
                '4': 'closed', // disposal processing
            };
            return this.safeString (statuses, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            //     {
            //         "symbol"："eth_btc",
            //         "amount"：10.000000,
            //         "create_time"：1484289832081,
            //         "price"：5000.000000,
            //         "avg_price"：5277.301200,
            //         "type"："sell",
            //         "order_id"："ab704110-af0d-48fd-a083-c218f19a4a55",
            //         "deal_amount"：10.000000,
            //         "status"：2
            //     }
            //
            const marketId = this.safeString (order, 'symbol');
            const symbol = this.safeSymbol (marketId, market, '_');
            const timestamp = this.safeInteger (order, 'create_time');
            // Limit Order Request Returns: Order Price
            // Market Order Returns: cny amount of market order
            const price = this.safeNumber (order, 'price');
            const amount = this.safeNumber (order, 'amount', 0.0);
            const filled = this.safeNumber (order, 'deal_amount', 0.0);
            const average = this.safeNumber (order, 'avg_price');
            const status = this.parseOrderStatus (this.safeString (order, 'status'));
            const id = this.safeString (order, 'order_id');
            const type = this.safeString (order, 'order_type');
            const side = this.safeString (order, 'type');
            return this.safeOrder ({
                'id': id,
                'clientOrderId': undefined,
                'datetime': this.iso8601 (timestamp),
                'timestamp': timestamp,
                'lastTradeTimestamp': undefined,
                'status': status,
                'symbol': symbol,
                'type': type,
                'timeInForce': undefined,
                'postOnly': undefined,
                'side': side,
                'price': price,
                'stopPrice': undefined,
                'cost': undefined,
                'amount': amount,
                'filled': filled,
                'remaining': undefined,
                'trades': undefined,
                'fee': undefined,
                'info': this.safeValue (order, 'info', order),
                'average': average,
            });
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            let order = {
                'symbol': market['id'],
                'type': side,
                'amount': amount,
            };
            if (type === 'market') {
                order['type'] += '_market';
            } else {
                order['price'] = price;
            }
            const response = await this.privatePostCreateOrder (this.extend (order, params));
            order = this.omit (order, 'type');
            order['order_id'] = response['order_id'];
            order['type'] = side;
            order['order_type'] = type;
            order['create_time'] = this.milliseconds ();
            order['info'] = response;
            return this.parseOrder (order, market);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'order_id': id,
            };
            const response = await this.privatePostCancelOrder (this.extend (request, params));
            return response;
        }
    
        async fetchOrder (id, symbol = undefined, params = {}) {
            // Id can be a list of ids delimited by a comma
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'order_id': id,
            };
            const response = await this.privatePostOrdersInfo (this.extend (request, params));
            const data = this.safeValue (response, 'orders', []);
            const orders = this.parseOrders (data, market);
            const numOrders = orders.length;
            if (numOrders === 1) {
                return orders[0];
            } else {
                return orders;
            }
        }
    
        async fetchOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            if (limit === undefined) {
                limit = 100;
            }
            const market = this.market (symbol);
            const request = {
                'symbol': market['id'],
                'current_page': 1,
                'page_length': limit,
            };
            const response = await this.privatePostOrdersInfoHistory (this.extend (request, params));
            const data = this.safeValue (response, 'orders', []);
            return this.parseOrders (data, undefined, since, limit);
        }
    
        async fetchClosedOrders (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            const orders = await this.fetchOrders (symbol, since, limit, params);
            const closed = this.filterBy (orders, 'status', 'closed');
            const canceled = this.filterBy (orders, 'status', 'cancelled'); // cancelled orders may be partially filled
            const allOrders = this.arrayConcat (closed, canceled);
            return this.filterBySymbolSinceLimit (allOrders, symbol, since, limit);
        }
    
        async withdraw (code, amount, address, tag = undefined, params = {}) {
            // mark and fee are optional params, mark is a note and must be less than 255 characters
            this.checkAddress (address);
            await this.loadMarkets ();
            const currency = this.currency (code);
            const request = {
                'assetCode': currency['id'],
                'amount': amount,
                'account': address,
            };
            if (tag !== undefined) {
                request['memo'] = tag;
            }
            const response = this.privatePostWithdraw (this.extend (request, params));
            return {
                'id': this.safeString (response, 'id'),
                'info': response,
            };
        }
    
        convertSecretToPem (secret) {
            const lineLength = 64;
            const secretLength = secret.length - 0;
            let numLines = parseInt (secretLength / lineLength);
            numLines = this.sum (numLines, 1);
            let pem = "-----BEGIN PRIVATE KEY-----\n"; // eslint-disable-line
            for (let i = 0; i < numLines; i++) {
                const start = i * lineLength;
                const end = this.sum (start, lineLength);
                pem += this.secret.slice (start, end) + "\n"; // eslint-disable-line
            }
            return pem + '-----END PRIVATE KEY-----';
        }
    
        sign (path, api = 'public', method = 'GET', params = {}, headers = undefined, body = undefined) {
            const query = this.omit (params, this.extractParams (path));
            let url = this.urls['api'] + '/' + this.version + '/' + this.implodeParams (path, params);
            // Every endpoint ends with ".do"
            url += '.do';
            if (api === 'public') {
                if (Object.keys (query).length) {
                    url += '?' + this.urlencode (query);
                }
            } else {
                this.checkRequiredCredentials ();
                const query = this.keysort (this.extend ({
                    'api_key': this.apiKey,
                }, params));
                const queryString = this.rawencode (query);
                const message = this.hash (this.encode (queryString)).toUpperCase ();
                const cacheSecretAsPem = this.safeValue (this.options, 'cacheSecretAsPem', true);
                let pem = undefined;
                if (cacheSecretAsPem) {
                    pem = this.safeValue (this.options, 'pem');
                    if (pem === undefined) {
                        pem = this.convertSecretToPem (this.secret);
                        this.options['pem'] = pem;
                    }
                } else {
                    pem = this.convertSecretToPem (this.secret);
                }
                const sign = this.binaryToBase64 (this.rsa (message, this.encode (pem), 'RS256'));
                query['sign'] = sign;
                body = this.urlencode (query);
                headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
            }
            return { 'url': url, 'method': method, 'body': body, 'headers': headers };
        }
    
        handleErrors (httpCode, reason, url, method, headers, body, response, requestHeaders, requestBody) {
            if (response === undefined) {
                return;
            }
            const success = this.safeString (response, 'result');
            if (success === 'false') {
                const errorCode = this.safeString (response, 'error_code');
                const message = this.safeString ({
                    '10000': 'Internal error',
                    '10001': 'The required parameters can not be empty',
                    '10002': 'verification failed',
                    '10003': 'Illegal parameters',
                    '10004': 'User requests are too frequent',
                    '10005': 'Key does not exist',
                    '10006': 'user does not exist',
                    '10007': 'Invalid signature',
                    '10008': 'This currency pair is not supported',
                    '10009': 'Limit orders can not be missing orders and the number of orders',
                    '10010': 'Order price or order quantity must be greater than 0',
                    '10011': 'Market orders can not be missing the amount of the order',
                    '10012': 'market sell orders can not be missing orders',
                    '10013': 'is less than the minimum trading position 0.001',
                    '10014': 'Account number is not enough',
                    '10015': 'The order type is wrong',
                    '10016': 'Account balance is not enough',
                    '10017': 'Abnormal server',
                    '10018': 'order inquiry can not be more than 50 less than one',
                    '10019': 'withdrawal orders can not be more than 3 less than one',
                    '10020': 'less than the minimum amount of the transaction limit of 0.001',
                    '10022': 'Insufficient key authority',
                }, errorCode, this.json (response));
                const ErrorClass = this.safeValue ({
                    '10002': AuthenticationError,
                    '10004': DDoSProtection,
                    '10005': AuthenticationError,
                    '10006': AuthenticationError,
                    '10007': AuthenticationError,
                    '10009': InvalidOrder,
                    '10010': InvalidOrder,
                    '10011': InvalidOrder,
                    '10012': InvalidOrder,
                    '10013': InvalidOrder,
                    '10014': InvalidOrder,
                    '10015': InvalidOrder,
                    '10016': InvalidOrder,
                    '10022': AuthenticationError,
                }, errorCode, ExchangeError);
                throw new ErrorClass (message);
            }
        }
    };
    
    },{"./base/Exchange":6,"./base/Precise":7,"./base/errors":9}],99:[function(require,module,exports){
    'use strict';
    
    //  ---------------------------------------------------------------------------
    
    const Exchange = require ('./base/Exchange');
    const { TICK_SIZE } = require ('./base/functions/number');
    const { ExchangeError, ArgumentsRequired, InvalidNonce, OrderNotFound, InvalidOrder, InsufficientFunds, AuthenticationError, DDoSProtection, NotSupported, BadSymbol } = require ('./base/errors');
    const Precise = require ('./base/Precise');
    
    //  ---------------------------------------------------------------------------
    
    module.exports = class liquid extends Exchange {
        describe () {
            return this.deepExtend (super.describe (), {
                'id': 'liquid',
                'name': 'Liquid',
                'countries': [ 'JP', 'CN', 'TW' ],
                'version': '2',
                'rateLimit': 1000,
                'has': {
                    'cancelOrder': true,
                    'CORS': false,
                    'createOrder': true,
                    'editOrder': true,
                    'fetchBalance': true,
                    'fetchClosedOrders': true,
                    'fetchCurrencies': true,
                    'fetchMarkets': true,
                    'fetchMyTrades': true,
                    'fetchOpenOrders': true,
                    'fetchOrder': true,
                    'fetchOrderBook': true,
                    'fetchOrders': true,
                    'fetchTicker': true,
                    'fetchTickers': true,
                    'fetchTrades': true,
                    'fetchWithdrawals': true,
                    'withdraw': true,
                },
                'urls': {
                    'logo': 'https://user-images.githubusercontent.com/1294454/45798859-1a872600-bcb4-11e8-8746-69291ce87b04.jpg',
                    'api': 'https://api.liquid.com',
                    'www': 'https://www.liquid.com',
                    'doc': [
                        'https://developers.liquid.com',
                    ],
                    'fees': 'https://help.liquid.com/getting-started-with-liquid/the-platform/fee-structure',
                    'referral': 'https://www.liquid.com/sign-up/?affiliate=SbzC62lt30976',
                },
                'api': {
                    'public': {
                        'get': [
                            'currencies',
                            'products',
                            'products/{id}',
                            'products/{id}/price_levels',
                            'executions',
                            'ir_ladders/{currency}',
                            'fees', // add fetchFees, fetchTradingFees, fetchFundingFees
                        ],
                    },
                    'private': {
                        'get': [
                            'accounts', // undocumented https://github.com/ccxt/ccxt/pull/7493
                            'accounts/balance',
                            'accounts/main_asset',
                            'accounts/{id}',
                            'accounts/{currency}/reserved_balance_details',
                            'crypto_accounts', // add fetchAccounts
                            'crypto_withdrawal',
                            'crypto_withdrawals',
                            'crypto_withdrawals/crypto_networks',
                            'executions/me',
                            'fiat_accounts', // add fetchAccounts
                            'fund_infos', // add fetchDeposits
                            'loan_bids',
                            'loans',
                            'orders',
                            'orders/{id}',
                            'orders/{id}/trades', // add fetchOrderTrades
                            'trades',
                            'trades/{id}/loans',
                            'trading_accounts',
                            'trading_accounts/{id}',
                            'transactions',
                            'withdrawals', // add fetchWithdrawals
                            'user/fee_tier',
                            'user/fees',
                            'trading_accounts/{id}',
                            'bank_accounts',
                            'accounts/{currency}/reserved_balance_details',
                        ],
                        'post': [
                            'crypto_withdrawals',
                            'fund_infos',
                            'fiat_accounts',
                            'loan_bids',
                            'orders',
                            'withdrawals',
                            'fees/estimate',
                        ],
                        'put': [
                            'crypto_withdrawal/{id}/cancel',
                            'loan_bids/{id}/close',
                            'loans/{id}',
                            'orders/{id}', // add editOrder
                            'orders/{id}/cancel',
                            'trades/{id}',
                            'trades/{id}/adjust_margin',
                            'trades/{id}/close',
                            'trades/close_all',
                            'trading_accounts/{id}',
                            'withdrawals/{id}/cancel',
                        ],
                    },
                },
                'fees': {
                    'trading': {
                        'tierBased': true,
                        'percentage': true,
                        'taker': 0.0030,
                        'maker': 0.0000,
                        'tiers': {
                            'perpetual': {
                                'maker': [
                                    [ 0, 0.0000 ],
                                    [ 25000, 0.0000 ],
                                    [ 50000, -0.00025 ],
                                    [ 100000, -0.00025 ],
                                    [ 1000000, -0.00025 ],
                                    [ 10000000, -0.00025 ],
                                    [ 25000000, -0.00025 ],
                                    [ 50000000, -0.00025 ],
                                    [ 75000000, -0.00025 ],
                                    [ 100000000, -0.00025 ],
                                    [ 200000000, -0.00025 ],
                                    [ 300000000, -0.00025 ],
                                ],
                                'taker': [
                                    [ 0, 0.00120 ],
                                    [ 25000, 0.00115 ],
                                    [ 50000, 0.00110 ],
                                    [ 100000, 0.00105 ],
                                    [ 1000000, 0.00100 ],
                                    [ 10000000, 0.00095 ],
                                    [ 25000000, 0.00090 ],
                                    [ 50000000, 0.00085 ],
                                    [ 75000000, 0.00080 ],
                                    [ 100000000, 0.00075 ],
                                    [ 200000000, 0.00070 ],
                                    [ 300000000, 0.00065 ],
                                ],
                            },
                            'spot': {
                                'taker': [
                                    [ 0, 0.003 ],
                                    [ 10000, 0.0029 ],
                                    [ 20000, 0.0028 ],
                                    [ 50000, 0.0026 ],
                                    [ 100000, 0.0020 ],
                                    [ 1000000, 0.0016 ],
                                    [ 5000000, 0.0012 ],
                                    [ 10000000, 0.0010 ],
                                    [ 25000000, 0.0009 ],
                                    [ 50000000, 0.0008 ],
                                    [ 100000000, 0.0007 ],
                                    [ 200000000, 0.0006 ],
                                    [ 500000000, 0.0004 ],
                                    [ 1000000000, 0.0003 ],
                                ],
                                'maker': [
                                    [ 0, 0.0000 ],
                                    [ 10000, 0.0020 ],
                                    [ 20000, 0.0019 ],
                                    [ 50000, 0.0018 ],
                                    [ 100000, 0.0016 ],
                                    [ 1000000, 0.0008 ],
                                    [ 5000000, 0.0007 ],
                                    [ 10000000, 0.0005 ],
                                    [ 25000000, 0.0000 ],
                                    [ 50000000, 0.0000 ],
                                    [ 100000000, 0.0000 ],
                                    [ 200000000, 0.0000 ],
                                    [ 500000000, 0.0000 ],
                                    [ 1000000000, 0.0000 ],
                                ],
                            },
                        },
                    },
                },
                'precisionMode': TICK_SIZE,
                'exceptions': {
                    'API rate limit exceeded. Please retry after 300s': DDoSProtection,
                    'API Authentication failed': AuthenticationError,
                    'Nonce is too small': InvalidNonce,
                    'Order not found': OrderNotFound,
                    'Can not update partially filled order': InvalidOrder,
                    'Can not update non-live order': OrderNotFound,
                    'not_enough_free_balance': InsufficientFunds,
                    'must_be_positive': InvalidOrder,
                    'less_than_order_size': InvalidOrder,
                    'price_too_high': InvalidOrder,
                    'price_too_small': InvalidOrder, // {"errors":{"order":["price_too_small"]}}
                    'product_disabled': BadSymbol, // {"errors":{"order":["product_disabled"]}}
                },
                'commonCurrencies': {
                    'WIN': 'WCOIN',
                    'HOT': 'HOT Token',
                    'MIOTA': 'IOTA', // https://github.com/ccxt/ccxt/issues/7487
                },
                'options': {
                    'cancelOrderException': true,
                },
            });
        }
    
        async fetchCurrencies (params = {}) {
            const response = await this.publicGetCurrencies (params);
            //
            //     [
            //         {
            //             currency_type: 'fiat',
            //             currency: 'USD',
            //             symbol: '$',
            //             assets_precision: 2,
            //             quoting_precision: 5,
            //             minimum_withdrawal: '15.0',
            //             withdrawal_fee: 5,
            //             minimum_fee: null,
            //             minimum_order_quantity: null,
            //             display_precision: 2,
            //             depositable: true,
            //             withdrawable: true,
            //             discount_fee: 0.5,
            //             credit_card_fundable: false,
            //             lendable: false,
            //             position_fundable: true,
            //             has_memo: false,
            //             stable_currency: null,
            //             root_currency: 'USD',
            //             minimum_loan_bid_quantity: '0.0',
            //             maximum_order_taker_quantity: null,
            //             name: 'United States Dollar'
            //         },
            //     ]
            //
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const currency = response[i];
                const id = this.safeString (currency, 'currency');
                const code = this.safeCurrencyCode (id);
                const name = this.safeString (currency, 'name');
                const active = currency['depositable'] && currency['withdrawable'];
                const amountPrecision = this.safeInteger (currency, 'assets_precision');
                result[code] = {
                    'id': id,
                    'code': code,
                    'info': currency,
                    'name': name,
                    'active': active,
                    'fee': this.safeNumber (currency, 'withdrawal_fee'),
                    'precision': amountPrecision,
                    'limits': {
                        'amount': {
                            'min': Math.pow (10, -amountPrecision),
                            'max': Math.pow (10, amountPrecision),
                        },
                        'withdraw': {
                            'min': this.safeNumber (currency, 'minimum_withdrawal'),
                            'max': undefined,
                        },
                    },
                };
            }
            return result;
        }
    
        async fetchMarkets (params = {}) {
            const spot = await this.publicGetProducts (params);
            //
            //     [
            //         {
            //             "id":"637",
            //             "product_type":"CurrencyPair",
            //             "code":"CASH",
            //             "name":null,
            //             "market_ask":"0.00000797",
            //             "market_bid":"0.00000727",
            //             "indicator":null,
            //             "currency":"BTC",
            //             "currency_pair_code":"TFTBTC",
            //             "symbol":null,
            //             "btc_minimum_withdraw":null,
            //             "fiat_minimum_withdraw":null,
            //             "pusher_channel":"product_cash_tftbtc_637",
            //             "taker_fee":"0.0",
            //             "maker_fee":"0.0",
            //             "low_market_bid":"0.00000685",
            //             "high_market_ask":"0.00000885",
            //             "volume_24h":"3696.0755956",
            //             "last_price_24h":"0.00000716",
            //             "last_traded_price":"0.00000766",
            //             "last_traded_quantity":"1748.0377978",
            //             "average_price":null,
            //             "quoted_currency":"BTC",
            //             "base_currency":"TFT",
            //             "tick_size":"0.00000001",
            //             "disabled":false,
            //             "margin_enabled":false,
            //             "cfd_enabled":false,
            //             "perpetual_enabled":false,
            //             "last_event_timestamp":"1596962820.000797146",
            //             "timestamp":"1596962820.000797146",
            //             "multiplier_up":"9.0",
            //             "multiplier_down":"0.1",
            //             "average_time_interval":null
            //         },
            //     ]
            //
            const perpetual = await this.publicGetProducts ({ 'perpetual': '1' });
            //
            //     [
            //         {
            //             "id":"604",
            //             "product_type":"Perpetual",
            //             "code":"CASH",
            //             "name":null,
            //             "market_ask":"11721.5",
            //             "market_bid":"11719.0",
            //             "indicator":null,
            //             "currency":"USD",
            //             "currency_pair_code":"P-BTCUSD",
            //             "symbol":"$",
            //             "btc_minimum_withdraw":null,
            //             "fiat_minimum_withdraw":null,
            //             "pusher_channel":"product_cash_p-btcusd_604",
            //             "taker_fee":"0.0012",
            //             "maker_fee":"0.0",
            //             "low_market_bid":"11624.5",
            //             "high_market_ask":"11859.0",
            //             "volume_24h":"0.271",
            //             "last_price_24h":"11621.5",
            //             "last_traded_price":"11771.5",
            //             "last_traded_quantity":"0.09",
            //             "average_price":"11771.5",
            //             "quoted_currency":"USD",
            //             "base_currency":"P-BTC",
            //             "tick_size":"0.5",
            //             "disabled":false,
            //             "margin_enabled":false,
            //             "cfd_enabled":false,
            //             "perpetual_enabled":true,
            //             "last_event_timestamp":"1596963309.418853092",
            //             "timestamp":"1596963309.418853092",
            //             "multiplier_up":null,
            //             "multiplier_down":"0.1",
            //             "average_time_interval":300,
            //             "index_price":"11682.8124",
            //             "mark_price":"11719.96781",
            //             "funding_rate":"0.00273",
            //             "fair_price":"11720.2745"
            //         },
            //     ]
            //
            const currencies = await this.fetchCurrencies ();
            const currenciesByCode = this.indexBy (currencies, 'code');
            const result = [];
            const markets = this.arrayConcat (spot, perpetual);
            for (let i = 0; i < markets.length; i++) {
                const market = markets[i];
                const id = this.safeString (market, 'id');
                const baseId = this.safeString (market, 'base_currency');
                const quoteId = this.safeString (market, 'quoted_currency');
                const productType = this.safeString (market, 'product_type');
                let type = 'spot';
                let spot = true;
                let swap = false;
                if (productType === 'Perpetual') {
                    spot = false;
                    swap = true;
                    type = 'swap';
                }
                const base = this.safeCurrencyCode (baseId);
                const quote = this.safeCurrencyCode (quoteId);
                let symbol = undefined;
                if (swap) {
                    symbol = this.safeString (market, 'currency_pair_code');
                } else {
                    symbol = base + '/' + quote;
                }
                let maker = this.fees['trading']['maker'];
                let taker = this.fees['trading']['taker'];
                if (type === 'swap') {
                    maker = this.safeNumber (market, 'maker_fee', this.fees['trading']['maker']);
                    taker = this.safeNumber (market, 'taker_fee', this.fees['trading']['taker']);
                }
                const disabled = this.safeValue (market, 'disabled', false);
                const active = !disabled;
                const baseCurrency = this.safeValue (currenciesByCode, base);
                const precision = {
                    'amount': 0.00000001,
                    'price': this.safeNumber (market, 'tick_size'),
                };
                let minAmount = undefined;
                if (baseCurrency !== undefined) {
                    minAmount = this.safeNumber (baseCurrency['info'], 'minimum_order_quantity');
                }
                const lastPrice = this.safeNumber (market, 'last_traded_price');
                let minPrice = undefined;
                let maxPrice = undefined;
                if (lastPrice) {
                    const multiplierDown = this.safeNumber (market, 'multiplier_down');
                    const multiplierUp = this.safeNumber (market, 'multiplier_up');
                    if (multiplierDown !== undefined) {
                        minPrice = lastPrice * multiplierDown;
                    }
                    if (multiplierUp !== undefined) {
                        maxPrice = lastPrice * multiplierUp;
                    }
                }
                const limits = {
                    'amount': {
                        'min': minAmount,
                        'max': undefined,
                    },
                    'price': {
                        'min': minPrice,
                        'max': maxPrice,
                    },
                    'cost': {
                        'min': undefined,
                        'max': undefined,
                    },
                };
                result.push ({
                    'id': id,
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                    'type': type,
                    'spot': spot,
                    'swap': swap,
                    'maker': maker,
                    'taker': taker,
                    'limits': limits,
                    'precision': precision,
                    'active': active,
                    'info': market,
                });
            }
            return result;
        }
    
        async fetchBalance (params = {}) {
            await this.loadMarkets ();
            const response = await this.privateGetAccounts (params);
            //
            //     {
            //         crypto_accounts: [
            //             {
            //                 id: 2221179,
            //                 currency: 'USDT',
            //                 balance: '0.0',
            //                 reserved_balance: '0.0',
            //                 pusher_channel: 'user_xxxxx_account_usdt',
            //                 lowest_offer_interest_rate: null,
            //                 highest_offer_interest_rate: null,
            //                 address: '0',
            //                 currency_symbol: 'USDT',
            //                 minimum_withdraw: null,
            //                 currency_type: 'crypto'
            //             },
            //         ],
            //         fiat_accounts: [
            //             {
            //                 id: 1112734,
            //                 currency: 'USD',
            //                 balance: '0.0',
            //                 reserved_balance: '0.0',
            //                 pusher_channel: 'user_xxxxx_account_usd',
            //                 lowest_offer_interest_rate: null,
            //                 highest_offer_interest_rate: null,
            //                 currency_symbol: '$',
            //                 send_to_btc_address: null,
            //                 exchange_rate: '1.0',
            //                 currency_type: 'fiat'
            //             }
            //         ]
            //     }
            //
            const result = {
                'info': response,
                'timestamp': undefined,
                'datetime': undefined,
            };
            const crypto = this.safeValue (response, 'crypto_accounts', []);
            const fiat = this.safeValue (response, 'fiat_accounts', []);
            for (let i = 0; i < crypto.length; i++) {
                const balance = crypto[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['total'] = this.safeString (balance, 'balance');
                account['used'] = this.safeString (balance, 'reserved_balance');
                result[code] = account;
            }
            for (let i = 0; i < fiat.length; i++) {
                const balance = fiat[i];
                const currencyId = this.safeString (balance, 'currency');
                const code = this.safeCurrencyCode (currencyId);
                const account = this.account ();
                account['total'] = this.safeString (balance, 'balance');
                account['used'] = this.safeString (balance, 'reserved_balance');
                result[code] = account;
            }
            return this.parseBalance (result);
        }
    
        async fetchOrderBook (symbol, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': this.marketId (symbol),
            };
            const response = await this.publicGetProductsIdPriceLevels (this.extend (request, params));
            return this.parseOrderBook (response, symbol, undefined, 'buy_price_levels', 'sell_price_levels');
        }
    
        parseTicker (ticker, market = undefined) {
            const timestamp = this.milliseconds ();
            let last = undefined;
            if ('last_traded_price' in ticker) {
                if (ticker['last_traded_price']) {
                    const length = ticker['last_traded_price'].length;
                    if (length > 0) {
                        last = this.safeNumber (ticker, 'last_traded_price');
                    }
                }
            }
            let symbol = undefined;
            if (market === undefined) {
                const marketId = this.safeString (ticker, 'id');
                if (marketId in this.markets_by_id) {
                    market = this.markets_by_id[marketId];
                } else {
                    const baseId = this.safeString (ticker, 'base_currency');
                    const quoteId = this.safeString (ticker, 'quoted_currency');
                    if (symbol in this.markets) {
                        market = this.markets[symbol];
                    } else {
                        symbol = this.safeCurrencyCode (baseId) + '/' + this.safeCurrencyCode (quoteId);
                    }
                }
            }
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            const open = this.safeNumber (ticker, 'last_price_24h');
            return this.safeTicker ({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'high': this.safeNumber (ticker, 'high_market_ask'),
                'low': this.safeNumber (ticker, 'low_market_bid'),
                'bid': this.safeNumber (ticker, 'market_bid'),
                'bidVolume': undefined,
                'ask': this.safeNumber (ticker, 'market_ask'),
                'askVolume': undefined,
                'vwap': undefined,
                'open': open,
                'close': last,
                'last': last,
                'previousClose': undefined,
                'change': undefined,
                'percentage': undefined,
                'average': undefined,
                'baseVolume': this.safeNumber (ticker, 'volume_24h'),
                'quoteVolume': undefined,
                'info': ticker,
            }, market);
        }
    
        async fetchTickers (symbols = undefined, params = {}) {
            await this.loadMarkets ();
            const response = await this.publicGetProducts (params);
            const result = {};
            for (let i = 0; i < response.length; i++) {
                const ticker = this.parseTicker (response[i]);
                const symbol = ticker['symbol'];
                result[symbol] = ticker;
            }
            return this.filterByArray (result, 'symbol', symbols);
        }
    
        async fetchTicker (symbol, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'id': market['id'],
            };
            const response = await this.publicGetProductsId (this.extend (request, params));
            return this.parseTicker (response, market);
        }
    
        parseTrade (trade, market = undefined) {
            // {             id:  12345,
            //         quantity: "6.789",
            //            price: "98765.4321",
            //       taker_side: "sell",
            //       created_at:  1512345678,
            //          my_side: "buy"           }
            const timestamp = this.safeTimestamp (trade, 'created_at');
            const orderId = this.safeString (trade, 'order_id');
            // 'taker_side' gets filled for both fetchTrades and fetchMyTrades
            const takerSide = this.safeString (trade, 'taker_side');
            // 'my_side' gets filled for fetchMyTrades only and may differ from 'taker_side'
            const mySide = this.safeString (trade, 'my_side');
            const side = (mySide !== undefined) ? mySide : takerSide;
            let takerOrMaker = undefined;
            if (mySide !== undefined) {
                takerOrMaker = (takerSide === mySide) ? 'taker' : 'maker';
            }
            const priceString = this.safeString (trade, 'price');
            const amountString = this.safeString (trade, 'quantity');
            const price = this.parseNumber (priceString);
            const amount = this.parseNumber (amountString);
            const cost = this.parseNumber (Precise.stringMul (priceString, amountString));
            const id = this.safeString (trade, 'id');
            let symbol = undefined;
            if (market !== undefined) {
                symbol = market['symbol'];
            }
            return {
                'info': trade,
                'id': id,
                'order': orderId,
                'timestamp': timestamp,
                'datetime': this.iso8601 (timestamp),
                'symbol': symbol,
                'type': undefined,
                'side': side,
                'takerOrMaker': takerOrMaker,
                'price': price,
                'amount': amount,
                'cost': cost,
                'fee': undefined,
            };
        }
    
        async fetchTrades (symbol, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            const request = {
                'product_id': market['id'],
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            if (since !== undefined) {
                // timestamp should be in seconds, whereas we use milliseconds in since and everywhere
                request['timestamp'] = parseInt (since / 1000);
            }
            const response = await this.publicGetExecutions (this.extend (request, params));
            const result = (since !== undefined) ? response : response['models'];
            return this.parseTrades (result, market, since, limit);
        }
    
        async fetchMyTrades (symbol = undefined, since = undefined, limit = undefined, params = {}) {
            await this.loadMarkets ();
            const market = this.market (symbol);
            // the `with_details` param is undocumented - it adds the order_id to the results
            const request = {
                'product_id': market['id'],
                'with_details': true,
            };
            if (limit !== undefined) {
                request['limit'] = limit;
            }
            const response = await this.privateGetExecutionsMe (this.extend (request, params));
            return this.parseTrades (response['models'], market, since, limit);
        }
    
        async createOrder (symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            const clientOrderId = this.safeString2 (params, 'clientOrderId', 'client_order_id');
            params = this.omit (params, [ 'clientOrderId', 'client_order_id' ]);
            const request = {
                'order_type': type,
                'product_id': this.marketId (symbol),
                'side': side,
                'quantity': this.amountToPrecision (symbol, amount),
            };
            if (clientOrderId !== undefined) {
                request['client_order_id'] = clientOrderId;
            }
            if ((type === 'limit') || (type === 'limit_post_only') || (type === 'market_with_range') || (type === 'stop')) {
                request['price'] = this.priceToPrecision (symbol, price);
            }
            const response = await this.privatePostOrders (this.extend (request, params));
            //
            //     {
            //         "id": 2157474,
            //         "order_type": "limit",
            //         "quantity": "0.01",
            //         "disc_quantity": "0.0",
            //         "iceberg_total_quantity": "0.0",
            //         "side": "sell",
            //         "filled_quantity": "0.0",
            //         "price": "500.0",
            //         "created_at": 1462123639,
            //         "updated_at": 1462123639,
            //         "status": "live",
            //         "leverage_level": 1,
            //         "source_exchange": "QUOINE",
            //         "product_id": 1,
            //         "product_code": "CASH",
            //         "funding_currency": "USD",
            //         "currency_pair_code": "BTCUSD",
            //         "order_fee": "0.0",
            //         "client_order_id": null,
            //     }
            //
            return this.parseOrder (response);
        }
    
        async cancelOrder (id, symbol = undefined, params = {}) {
            await this.loadMarkets ();
            const request = {
                'id': id,
            };
            const response = await this.privatePutOrdersIdCancel (this.extend (request, params));
            const order = this.parseOrder (response);
            if (order['status'] === 'closed') {
                if (this.options['cancelOrderException']) {
                    throw new OrderNotFound (this.id + ' order closed already: ' + this.json (response));
                }
            }
            return order;
        }
    
        async editOrder (id, symbol, type, side, amount, price = undefined, params = {}) {
            await this.loadMarkets ();
            if (price === undefined) {
                throw new ArgumentsRequired (this.id + ' editOrder() requires the price argument');
            }
            const request = {
                'order': {
                    'quantity': this.amountToPrecision (symbol, amount),
                    'price': this.priceToPrecision (symbol, price),
                },
                'id': id,
            };
            const response = await this.privatePutOrdersId (this.extend (request, params));
            return this.parseOrder (response);
        }
    
        parseOrderStatus (status) {
            const statuses = {
                'live': 'open',
                'filled': 'closed',
                'cancelled': 'canceled',
            };
            return this.safeString (statuses, status, status);
        }
    
        parseOrder (order, market = undefined) {
            //
            // createOrder
            //
            //     {
            //         "id": 2157474,
            //         "order_type": "limit",
            //         "quantity": "0.01",
            //         "disc_quantity": "0.0",
            //         "iceberg_total_quantity": "0.0",
            //         "side": "sell",
            //         "filled_quantity": "0.0",
            //         "price": "500.0",
            //         "created_at": 1462123639,
            //         "updated_at": 1462123639,
            //         "status": "live",
            //         "leverage_level": 1,
            //         "source_exchange": "QUOINE",
            //         "product_id": 1,
            //         "product_code": "CASH",
            //         "funding_currency": "USD",
            //         "currency_pair_code": "BTCUSD",
            //         "order_fee": "0.0"
            //         "client_order_id": null,
            //     }
            //
            // fetchOrder, fetchOrders, fetchOpenOrders, fetchClosedOrders
            //
            //     {
            //         "id": 2157479,
            //         "order_type": "limit",
            //         "quantity": "0.01",
            //         "disc_quantity": "0.0",
            //         "iceberg_total_quantity": "0.0",
            //         "side": "sell",
            //         "filled_quantity": "0.01",
            //         "price": "500.0",
            //         "created_at": 146